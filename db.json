{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/1.png","path":"images/1.png","modified":0,"renderable":0},{"_id":"source/images/10.png","path":"images/10.png","modified":0,"renderable":0},{"_id":"source/images/2.png","path":"images/2.png","modified":0,"renderable":0},{"_id":"source/images/3.png","path":"images/3.png","modified":0,"renderable":0},{"_id":"source/images/4.png","path":"images/4.png","modified":0,"renderable":0},{"_id":"source/images/5.png","path":"images/5.png","modified":0,"renderable":0},{"_id":"source/images/6.png","path":"images/6.png","modified":0,"renderable":0},{"_id":"source/images/7.png","path":"images/7.png","modified":0,"renderable":0},{"_id":"source/images/9.png","path":"images/9.png","modified":0,"renderable":0},{"_id":"source/images/8.png","path":"images/8.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"source/images/11.png","path":"images/11.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1563950143782},{"_id":"themes/landscape/README.md","hash":"e7cc82dc79596f36ba05a8139e7d6b2dfc4ae5f9","modified":1563950143784},{"_id":"themes/landscape/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1563950143827},{"_id":"themes/landscape/_config.yml","hash":"218c5fb76666696c42dc86e2de4711e6b80befbf","modified":1563950143785},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1563950143783},{"_id":"themes/landscape/.npmignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1563950143781},{"_id":"source/images/1.png","hash":"bb42453a4634ba5efa39724a9e9534d83e628609","modified":1564123759154},{"_id":"source/images/10.png","hash":"46d39d6622c1b487fdede45e5e5c16daec45389b","modified":1564124369974},{"_id":"source/images/2.png","hash":"226b3d4003e8de1a6986227e5354ff802e2c6957","modified":1564124064568},{"_id":"source/images/3.png","hash":"487194a77790392b97b7d78d670ece0d51311949","modified":1564126159464},{"_id":"source/images/4.png","hash":"ca862f01f040bb3ea3b96f8336a873b84b6c0811","modified":1564126195472},{"_id":"source/images/5.png","hash":"a15c1fe1536f552659a3954f1e036afee53ed534","modified":1564124220927},{"_id":"source/images/6.png","hash":"82f98a98d4e70602f85533687894b5554df26176","modified":1564124257819},{"_id":"source/images/7.png","hash":"9ba5660654e8de4838df16bfdb314e9790bef507","modified":1564124292571},{"_id":"source/images/9.png","hash":"c7e0f6e6f6ff38dc0d45ad7872b66d43e399c2e7","modified":1564124343686},{"_id":"source/_posts/blogInit.md","hash":"261801bfd02300d62e7bd3f3b5749431ba4c3b2e","modified":1564128499131},{"_id":"source/_posts/hexoDeplayBug.md","hash":"11e61a5445326bdf754177f8c902c3c87fff67f5","modified":1564127334512},{"_id":"source/_posts/message-comp.md","hash":"8ccc2b532459b7a2a5e7a23ee2ecc0435d3bb437","modified":1565856400074},{"_id":"source/_posts/nodeBasics.md","hash":"6d649a58160e99f8be363be2d66756a0fcf91309","modified":1565768988249},{"_id":"source/_posts/npmBuild.md","hash":"ec893f6e93e9149a6bf2c2ac3b781d930d35ba54","modified":1565834785710},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1563950143819},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1563950143820},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1563950143821},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1563950143824},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1563950143786},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1563950143825},{"_id":"themes/landscape/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1563950143787},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1563950143826},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1563950143788},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1563950143790},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1563950143794},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1563950143828},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1563950143792},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1563950143791},{"_id":"source/images/8.png","hash":"39378833bdc6009f6f7e9ebd0ad8cc572adf9e28","modified":1564124337074},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"3beb0d164acacb6f21e1ca2038158a74ab4a73e4","modified":1563950143798},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1563950143797},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1563950143800},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1563950143802},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1563950143822},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1563950143799},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"89998e6b2929c4ff5093bbf6b86d611d7420be52","modified":1563950143803},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"a7faab4f3601b28107af5b1095b3966c2f88fec8","modified":1563950143796},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1563950143805},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1563950143815},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1563950143816},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"148bdf714dd1a7bf55e571f13808ceae079200cc","modified":1563950143804},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1563950143814},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1563950143812},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1563950143817},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1563950143818},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1563950143830},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1563950143862},{"_id":"themes/landscape/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1563950143845},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1563950143861},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1563950143859},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1563950143864},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1563950143867},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1563950143878},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1563950143865},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1563950143863},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1563950143879},{"_id":"source/images/11.png","hash":"777d5895b1775c05c110b095c9affc90dace9014","modified":1564126229769},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1563950143876},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1563950143880},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1563950143807},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1563950143809},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1563950143811},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1563950143831},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1563950143808},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1563950143833},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1563950143810},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1563950143834},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1563950143835},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1563950143832},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1563950143838},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1563950143837},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1563950143841},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1563950143843},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1563950143843},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1563950143806},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1563950143839},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1563950143840},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1563950143847},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1563950143868},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1563950143854},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1563950143872},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1563950143870},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1563950143869},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1563950143875},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1563950143853},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1563950143849},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1563950143873},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1563950143851},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1563950143858},{"_id":"public/2019/07/24/hexoDeplayBug/index.html","hash":"ddf7996b2221ccf0d413c14d4d43ce36833d96a2","modified":1565856422869},{"_id":"public/2019/07/24/blogInit/index.html","hash":"23f3111a8cbe3420355429243b1e5125e6ad8063","modified":1565856422869},{"_id":"public/archives/index.html","hash":"a27785ecebcc8069d50c8ae757e4dde6dfd72d0e","modified":1565856422906},{"_id":"public/archives/2019/index.html","hash":"097eaed92e43ef99d507a09e050dd870d8f9569b","modified":1565856422906},{"_id":"public/archives/2019/07/index.html","hash":"a159aecebf0252f011acee75339e92bc743b965d","modified":1565856422907},{"_id":"public/archives/2019/08/index.html","hash":"9f6bea3e3e57cdfeb5e9613092022c615f0b5650","modified":1565856422907},{"_id":"public/2019/08/14/nodeBasics/index.html","hash":"7331928b424a715d379297cf77673b87e9966827","modified":1565856422907},{"_id":"public/2019/07/26/npmBuild/index.html","hash":"7de3f07b8cfdccd5c6a4b3bb9349151505835798","modified":1565856422907},{"_id":"public/index.html","hash":"59445c4153b571c2bb9c9ad4a32713ee984f4206","modified":1565856422907},{"_id":"public/2019/08/15/message-comp/index.html","hash":"317adf6c523fa350db5f10207ed58556fac1edb8","modified":1565856422912},{"_id":"public/images/1.png","hash":"bb42453a4634ba5efa39724a9e9534d83e628609","modified":1565856422928},{"_id":"public/images/10.png","hash":"46d39d6622c1b487fdede45e5e5c16daec45389b","modified":1565856422928},{"_id":"public/images/2.png","hash":"226b3d4003e8de1a6986227e5354ff802e2c6957","modified":1565856422928},{"_id":"public/images/3.png","hash":"487194a77790392b97b7d78d670ece0d51311949","modified":1565856422928},{"_id":"public/images/4.png","hash":"ca862f01f040bb3ea3b96f8336a873b84b6c0811","modified":1565856422928},{"_id":"public/images/5.png","hash":"a15c1fe1536f552659a3954f1e036afee53ed534","modified":1565856422928},{"_id":"public/images/6.png","hash":"82f98a98d4e70602f85533687894b5554df26176","modified":1565856422928},{"_id":"public/images/7.png","hash":"9ba5660654e8de4838df16bfdb314e9790bef507","modified":1565856422928},{"_id":"public/images/9.png","hash":"c7e0f6e6f6ff38dc0d45ad7872b66d43e399c2e7","modified":1565856422928},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1565856422928},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1565856422929},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1565856422929},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1565856422929},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1565856422929},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1565856422929},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1565856422929},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1565856422929},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1565856422929},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1565856422929},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1565856423467},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1565856423475},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1565856423475},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1565856423476},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1565856423476},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1565856423476},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1565856423476},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1565856423476},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1565856423476},{"_id":"public/images/8.png","hash":"39378833bdc6009f6f7e9ebd0ad8cc572adf9e28","modified":1565856423476},{"_id":"public/images/11.png","hash":"777d5895b1775c05c110b095c9affc90dace9014","modified":1565856423480},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1565856423481},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1565856423481},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1565856423491},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1565856423517}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"hexo deplay出错","date":"2019-07-24T07:28:39.000Z","_content":"\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：\n\n# 当部署失败的时候，请按照以下步骤进行：\n报错内容如下：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 通过SSH key来上传代码\n###### 1将SSH key添加到github中\n① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）\n###### 2测试设置是否成功：\n```\n$ ssh -T git@github.com\n```\n如果出现如下情况\n```\nHi username! You've successfully authenticated, but GitHub does not \nprovide shell access.\n```\n将项目中如下位置文件做出更改\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不要使用https，而是改为SSH，如下：\n```\nrepository: https://github.com/username/username.github.io.git\n```\n修改为\n```\nrepo：git@github.com:username/username.github.io.git\n```\n一般这步基本就可以部署了！！！\n如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）\n```\n删除.deploy_git\n$ hexo clean \n$ hexo g\n$ hexo d\n```\n本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！\n\n\n\n","source":"_posts/hexoDeplayBug.md","raw":"---\ntitle: hexo deplay出错\ndate: 2019-07-24 15:28:39\ntags:\n---\n\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：\n\n# 当部署失败的时候，请按照以下步骤进行：\n报错内容如下：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 通过SSH key来上传代码\n###### 1将SSH key添加到github中\n① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）\n###### 2测试设置是否成功：\n```\n$ ssh -T git@github.com\n```\n如果出现如下情况\n```\nHi username! You've successfully authenticated, but GitHub does not \nprovide shell access.\n```\n将项目中如下位置文件做出更改\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不要使用https，而是改为SSH，如下：\n```\nrepository: https://github.com/username/username.github.io.git\n```\n修改为\n```\nrepo：git@github.com:username/username.github.io.git\n```\n一般这步基本就可以部署了！！！\n如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）\n```\n删除.deploy_git\n$ hexo clean \n$ hexo g\n$ hexo d\n```\n本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！\n\n\n\n","slug":"hexoDeplayBug","published":1,"updated":"2019-07-26T07:48:54.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzcehfz50000cskc3znl0pts","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：</p>\n<h1 id=\"当部署失败的时候，请按照以下步骤进行：\"><a href=\"#当部署失败的时候，请按照以下步骤进行：\" class=\"headerlink\" title=\"当部署失败的时候，请按照以下步骤进行：\"></a>当部署失败的时候，请按照以下步骤进行：</h1><p>报错内容如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h1 id=\"通过SSH-key来上传代码\"><a href=\"#通过SSH-key来上传代码\" class=\"headerlink\" title=\"通过SSH key来上传代码\"></a>通过SSH key来上传代码</h1><h6 id=\"1将SSH-key添加到github中\"><a href=\"#1将SSH-key添加到github中\" class=\"headerlink\" title=\"1将SSH key添加到github中\"></a>1将SSH key添加到github中</h6><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）</p>\n<h6 id=\"2测试设置是否成功：\"><a href=\"#2测试设置是否成功：\" class=\"headerlink\" title=\"2测试设置是否成功：\"></a>2测试设置是否成功：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>如果出现如下情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&apos;ve successfully authenticated, but GitHub does not </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure></p>\n<p>将项目中如下位置文件做出更改<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>不要使用https，而是改为SSH，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repository: https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo：git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>一般这步基本就可以部署了！！！<br>如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除.deploy_git</span><br><span class=\"line\">$ hexo clean </span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：</p>\n<h1 id=\"当部署失败的时候，请按照以下步骤进行：\"><a href=\"#当部署失败的时候，请按照以下步骤进行：\" class=\"headerlink\" title=\"当部署失败的时候，请按照以下步骤进行：\"></a>当部署失败的时候，请按照以下步骤进行：</h1><p>报错内容如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h1 id=\"通过SSH-key来上传代码\"><a href=\"#通过SSH-key来上传代码\" class=\"headerlink\" title=\"通过SSH key来上传代码\"></a>通过SSH key来上传代码</h1><h6 id=\"1将SSH-key添加到github中\"><a href=\"#1将SSH-key添加到github中\" class=\"headerlink\" title=\"1将SSH key添加到github中\"></a>1将SSH key添加到github中</h6><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）</p>\n<h6 id=\"2测试设置是否成功：\"><a href=\"#2测试设置是否成功：\" class=\"headerlink\" title=\"2测试设置是否成功：\"></a>2测试设置是否成功：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>如果出现如下情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&apos;ve successfully authenticated, but GitHub does not </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure></p>\n<p>将项目中如下位置文件做出更改<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>不要使用https，而是改为SSH，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repository: https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo：git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>一般这步基本就可以部署了！！！<br>如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除.deploy_git</span><br><span class=\"line\">$ hexo clean </span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！</p>\n"},{"title":"教你快速搭建个人博客","date":"2019-07-24T06:44:05.000Z","_content":"\n# 基于HEXO博客框架和Github搭建个人博客简单教程\nAuthor: Echo\nTime: 2019-07-24 14:44:23\n\n### 准备工作\n配置环境\n\n* 安装Node.js\n* 安装Git\n* 注册GitHub\n\n# Hexo 部分\n### Hexo简介\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n### Hexo安装方法\n参考官网中文文档,只需要一条命令即可自动安装hexo框架。\n```\n$ npm install -g hexo-cli #使用 npm 安装 Hexo\n```\n\n* 初始化\n创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：\n```\nhexo init\n```\n* 生成静态页面\n继续再Blog目录下执行如下命令，生成静态页面\n```\nhexo generate （或者 hexo g）\n```\n\n* 本地启动\n启动本地服务，进行文章预览调试，命令：\n```\nhexo server\n```\n\n* 本地测试\n\n浏览器输入 http://localhost:4000\n\n# Github 部分\n* 注册github\n* 新建仓库\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!\n* 本地_config.yml文配置件，建立关联\n我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)\n```\ndeploy:  \n   type: git   \n   repository: https://github.com/leopardpan/  leopardpan.github.io.git  \n   branch: master\n```\n# 部署\n执行如下命令才能使用git部署\n```\nnpm install hexo-deployer-git --save\n```\n(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)\n执行配置命令：\n```\nhexo deploy\n```\n然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了\n\n发文章\n每次部署的步骤，可按以下三步来进行。\n```\nhexo clean  \nhexo generate  \nhexo deploy\n```\n一些常用命令：\n```\nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成静态页面至public目录  \nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）  \nhexo deploy #将.deploy目录部署到GitHub  \nhexo help  #查看帮助  \nhexo version  #查看Hexo的版本\n```\n参考：\n\nhttp://www.jianshu.com/p/465830080ea9\nhttp://www.chinaz.com/web/2016/0105/491998.shtml","source":"_posts/blogInit.md","raw":"---\ntitle: 教你快速搭建个人博客\ndate: 2019-07-24 14:44:05\ntags:\n---\n\n# 基于HEXO博客框架和Github搭建个人博客简单教程\nAuthor: Echo\nTime: 2019-07-24 14:44:23\n\n### 准备工作\n配置环境\n\n* 安装Node.js\n* 安装Git\n* 注册GitHub\n\n# Hexo 部分\n### Hexo简介\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n### Hexo安装方法\n参考官网中文文档,只需要一条命令即可自动安装hexo框架。\n```\n$ npm install -g hexo-cli #使用 npm 安装 Hexo\n```\n\n* 初始化\n创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：\n```\nhexo init\n```\n* 生成静态页面\n继续再Blog目录下执行如下命令，生成静态页面\n```\nhexo generate （或者 hexo g）\n```\n\n* 本地启动\n启动本地服务，进行文章预览调试，命令：\n```\nhexo server\n```\n\n* 本地测试\n\n浏览器输入 http://localhost:4000\n\n# Github 部分\n* 注册github\n* 新建仓库\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!\n* 本地_config.yml文配置件，建立关联\n我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)\n```\ndeploy:  \n   type: git   \n   repository: https://github.com/leopardpan/  leopardpan.github.io.git  \n   branch: master\n```\n# 部署\n执行如下命令才能使用git部署\n```\nnpm install hexo-deployer-git --save\n```\n(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)\n执行配置命令：\n```\nhexo deploy\n```\n然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了\n\n发文章\n每次部署的步骤，可按以下三步来进行。\n```\nhexo clean  \nhexo generate  \nhexo deploy\n```\n一些常用命令：\n```\nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成静态页面至public目录  \nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）  \nhexo deploy #将.deploy目录部署到GitHub  \nhexo help  #查看帮助  \nhexo version  #查看Hexo的版本\n```\n参考：\n\nhttp://www.jianshu.com/p/465830080ea9\nhttp://www.chinaz.com/web/2016/0105/491998.shtml","slug":"blogInit","published":1,"updated":"2019-07-26T08:08:19.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzcehfzk0001cskcqsil3x3o","content":"<h1 id=\"基于HEXO博客框架和Github搭建个人博客简单教程\"><a href=\"#基于HEXO博客框架和Github搭建个人博客简单教程\" class=\"headerlink\" title=\"基于HEXO博客框架和Github搭建个人博客简单教程\"></a>基于HEXO博客框架和Github搭建个人博客简单教程</h1><p>Author: Echo<br>Time: 2019-07-24 14:44:23</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>配置环境</p>\n<ul>\n<li>安装Node.js</li>\n<li>安装Git</li>\n<li>注册GitHub</li>\n</ul>\n<h1 id=\"Hexo-部分\"><a href=\"#Hexo-部分\" class=\"headerlink\" title=\"Hexo 部分\"></a>Hexo 部分</h1><h3 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h3><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。<br>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<h3 id=\"Hexo安装方法\"><a href=\"#Hexo安装方法\" class=\"headerlink\" title=\"Hexo安装方法\"></a>Hexo安装方法</h3><p>参考官网中文文档,只需要一条命令即可自动安装hexo框架。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli #使用 npm 安装 Hexo</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>初始化<br>创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态页面<br>继续再Blog目录下执行如下命令，生成静态页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate （或者 hexo g）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地启动<br>启动本地服务，进行文章预览调试，命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地测试</p>\n</li>\n</ul>\n<p>浏览器输入 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<h1 id=\"Github-部分\"><a href=\"#Github-部分\" class=\"headerlink\" title=\"Github 部分\"></a>Github 部分</h1><ul>\n<li>注册github</li>\n<li>新建仓库<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!</li>\n<li>本地_config.yml文配置件，建立关联<br>我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">   type: git   </span><br><span class=\"line\">   repository: https://github.com/leopardpan/  leopardpan.github.io.git  </span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>执行如下命令才能使用git部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)<br>执行配置命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>然后再浏览器中输入<a href=\"http://username.github.io/就行了，把\" target=\"_blank\" rel=\"noopener\">http://username.github.io/就行了，把</a> username ,改成你 github 的账户名就行了</p>\n<p>发文章<br>每次部署的步骤，可按以下三步来进行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  </span><br><span class=\"line\">hexo generate  </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>一些常用命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章  </span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </span><br><span class=\"line\">hexo generate #生成静态页面至public目录  </span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）  </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub  </span><br><span class=\"line\">hexo help  #查看帮助  </span><br><span class=\"line\">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure></p>\n<p>参考：</p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/465830080ea9</a><br><a href=\"http://www.chinaz.com/web/2016/0105/491998.shtml\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/web/2016/0105/491998.shtml</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基于HEXO博客框架和Github搭建个人博客简单教程\"><a href=\"#基于HEXO博客框架和Github搭建个人博客简单教程\" class=\"headerlink\" title=\"基于HEXO博客框架和Github搭建个人博客简单教程\"></a>基于HEXO博客框架和Github搭建个人博客简单教程</h1><p>Author: Echo<br>Time: 2019-07-24 14:44:23</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>配置环境</p>\n<ul>\n<li>安装Node.js</li>\n<li>安装Git</li>\n<li>注册GitHub</li>\n</ul>\n<h1 id=\"Hexo-部分\"><a href=\"#Hexo-部分\" class=\"headerlink\" title=\"Hexo 部分\"></a>Hexo 部分</h1><h3 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h3><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。<br>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<h3 id=\"Hexo安装方法\"><a href=\"#Hexo安装方法\" class=\"headerlink\" title=\"Hexo安装方法\"></a>Hexo安装方法</h3><p>参考官网中文文档,只需要一条命令即可自动安装hexo框架。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli #使用 npm 安装 Hexo</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>初始化<br>创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态页面<br>继续再Blog目录下执行如下命令，生成静态页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate （或者 hexo g）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地启动<br>启动本地服务，进行文章预览调试，命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地测试</p>\n</li>\n</ul>\n<p>浏览器输入 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<h1 id=\"Github-部分\"><a href=\"#Github-部分\" class=\"headerlink\" title=\"Github 部分\"></a>Github 部分</h1><ul>\n<li>注册github</li>\n<li>新建仓库<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!</li>\n<li>本地_config.yml文配置件，建立关联<br>我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">   type: git   </span><br><span class=\"line\">   repository: https://github.com/leopardpan/  leopardpan.github.io.git  </span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>执行如下命令才能使用git部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)<br>执行配置命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>然后再浏览器中输入<a href=\"http://username.github.io/就行了，把\" target=\"_blank\" rel=\"noopener\">http://username.github.io/就行了，把</a> username ,改成你 github 的账户名就行了</p>\n<p>发文章<br>每次部署的步骤，可按以下三步来进行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  </span><br><span class=\"line\">hexo generate  </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>一些常用命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章  </span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </span><br><span class=\"line\">hexo generate #生成静态页面至public目录  </span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）  </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub  </span><br><span class=\"line\">hexo help  #查看帮助  </span><br><span class=\"line\">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure></p>\n<p>参考：</p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/465830080ea9</a><br><a href=\"http://www.chinaz.com/web/2016/0105/491998.shtml\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/web/2016/0105/491998.shtml</a></p>\n"},{"title":"message-comp","date":"2019-08-15T08:05:21.000Z","_content":"Author: Echo\nTime: 2019-08-15 16:05:21\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 写一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 写一个 message.js\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行一下代码：\n![image](https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n再见吧！\n\n参考 连接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n","source":"_posts/message-comp.md","raw":"---\ntitle: message-comp\ndate: 2019-08-15 16:05:21\ntags:\n---\nAuthor: Echo\nTime: 2019-08-15 16:05:21\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 写一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 写一个 message.js\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行一下代码：\n![image](https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n再见吧！\n\n参考 连接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n","slug":"message-comp","published":1,"updated":"2019-08-15T08:06:40.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzcehfzm0002cskc5widfpbf","content":"<p>Author: Echo<br>Time: 2019-08-15 16:05:21</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"写一个-message-组件\"><a href=\"#写一个-message-组件\" class=\"headerlink\" title=\"写一个 message 组件\"></a>写一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"写一个-message-js\"><a href=\"#写一个-message-js\" class=\"headerlink\" title=\"写一个 message.js\"></a>写一个 message.js</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>运行一下代码：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"duration-lt-0-message一直存在\"><a href=\"#duration-lt-0-message一直存在\" class=\"headerlink\" title=\"duration &lt;= 0,message一直存在\"></a>duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>再见吧！</p>\n<p>参考 连接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-15 16:05:21</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"写一个-message-组件\"><a href=\"#写一个-message-组件\" class=\"headerlink\" title=\"写一个 message 组件\"></a>写一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"写一个-message-js\"><a href=\"#写一个-message-js\" class=\"headerlink\" title=\"写一个 message.js\"></a>写一个 message.js</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>运行一下代码：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"duration-lt-0-message一直存在\"><a href=\"#duration-lt-0-message一直存在\" class=\"headerlink\" title=\"duration &lt;= 0,message一直存在\"></a>duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>再见吧！</p>\n<p>参考 连接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n"},{"title":"npm 部署自己的组件库","date":"2019-07-26T06:18:53.000Z","_content":"Author: Echo\nTime: 2019-07-24 15:28:39\n# 基于 vue-cli 打造属于自己的 UI 库\n\n## 写在前面\n \n## 知识前置\n我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：\n```\nimport Loading from '../components/loading'\n// 方法一：name 是组件的名字\nVue.component(Loading.name, Loading)\n// 方法二：前提是 Loading 有提供 install 这个方法\nVue.use(Loading);\n```\n# 基于vue-cli3打造组件库\n# 搭建目录\n#### 快速创建项目\n* vue-cli3\n```\nvue create projectName\n```\n### 修改目录结构\n\n*  把 src 目录名字改成 examples，这是用于展示组件示例的\n*  在根目录下新建一个 packages 文件夹，这是用来放组件的\n![1ll.png](/images/1.png)\n    你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：\n当我们水平不够的时候，模仿是一种强大的学习能力👏。\n\n### 添加配置文件\n\n小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：\n\n```\nconst path = require('path')\nmodule.exports = {\n  // 修改 pages 入口\n  pages: {\n    index: {\n      entry: 'examples/main.js', // 入口\n      template: 'public/index.html', // 模板\n      filename: 'index.html' // 输出文件\n    }\n  },\n  // 扩展 webpack 配置\n  chainWebpack: config => {\n    // @ 默认指向 src 目录，这里要改成 examples\n    // 另外也可以新增一个 ~ 指向 packages\n    config.resolve.alias\n      .set('@', path.resolve('examples'))\n      .set('~', path.resolve('packages'))\n\n    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的\n    config.module\n      .rule('js')\n      .include.add(/packages/).end()\n      .include.add(/examples/).end()\n      .use('babel')\n      .loader('babel-loader')\n      .tap(options => {\n        // 修改它的选项...\n        return options\n      })\n  }\n}\n\n```\n\n上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 [Vue Cli](https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE) 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。\n\n## 编写组件\n\n一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：\n\n![1ll.png](/images/2.png)\n\n\n```\n<!--test.vue-->\n<template>\n  <div class=\"echojoy-test\" @click=\"handleClick\">{{ num }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'EchojoyTest',\n  data () {\n    return {\n      num: 0\n    }\n  },\n  methods: {\n    handleClick () {\n      this.num++\n    }\n  }\n}\n</script>\n\n<style >\n.echojoy-test {\n  width: 100px;\n  height: 100px;\n  line-height: 100px;\n  border-radius: 50%;\n  font-size: 30px;\n  text-align: center;\n  background: #24292e;\n  color: white;\n}\n</style>\n\n\n```\n\n应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 `EchojoyTest`，到时候我们写的标签就长这样 `<echojoy-test></echojoy-test>`，就像 Element 一样，name 是 `ElButton`，用的时候就是 `<el-button></el-button>`。\n\n## 暴露组件\n\n让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：\n\n```\n// 对外提供对组件的引用，注意组件必须声明 name\nimport EchojoyTest from './src/test'\n// 为组件提供 install 安装方法，供按需引入\nEchojoyTest.install = Vue => {\n  Vue.component(EchojoyTest.name, EchojoyTest)\n}\nexport default EchojoyTest\n\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 `Vue.use()` 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：\n\n```\nimport EchojoyTest from './test'\n// 存储组件列表\nconst components = [\n  EchojoyTest\n]\n// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册\nconst install = function (Vue) {\n  // 判断是否安装\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册全局组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 判断是否是直接引入文件\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nexport default {\n  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装\n  install,\n  // 以下是具体的组件列表\n  ...components\n}\n\n\n```\n\n这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：\n\n![1ll.png](/images/3.png)\n\n因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。\n当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。\n\n## 组件测试\n\nok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：\n```\nimport EchojoyUI from './../packages'\nVue.use(EchojoyUI);\n```\n然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：\n\n![1ll.png](/images/11.png)\n\n\n好了，最后让我们运行一下项目 `npm run  serve`，看看效果，嗯，还凑合吧。\n\n## 库模式打包\n\n在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：\n\n```\n// target: 默认为构建应用，改为 lib 即可启用构建库模式\n// name: 输出文件名\n// dest: 输出目录，默认为 dist，这里我们改为 lib\n// entry: 入口文件路径\nvue-cli-service build --target lib --name lib [entry]\n\n```\n\n要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：\n\n![1ll.png](/images/5.png)\n\n\n\n接着执行 `npm run lib` 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。\n![1ll.png](/images/6.png)\n\n\n\n补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。\n\n## 发布到npm\n\n万事俱备，只欠发布。\n\n1.  完善一下 README.md 文档，这个随便写两句就好\n2.  修改一下 package.json 文件：\n\n```\n{ \n  \"name\": \"echojoy-ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"description\": \"基于 vue-cli3 的 UI 组件库\",\n  \"main\": \"lib/xr-ui.umd.min.js\",\n  \"keywords\": \"echojoy-ui\",\n  \"private\": false,\n  \"license\": \"MIT\"\n}\n\n```\n\n3.  在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：\n\n```\n# 这是复制 .gitignore 里面的\n.DS_Store\nnode_modules\n/dist\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw*\n\n# 以下是新增的\n# 要忽略目录和指定文件\nexamples/\npackages/\npublic/\nvue.config.js\nbabel.config.js\n*.map\n*.html\n\n```\n\n最后执行 `npm login` 登入 npm 账号，再执行 `npm publish` 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n## 小试牛刀\n\n终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 `vue create echojoy-ui-use` 另起一个新项目，然后 `npm i echojoy-ui -S`，可以在 node_modules 里面看到我们的包大概长这样：\n![1ll.png](/images/7.png)\n\n\n\n然后在 main.js 引入：\n\n```\nimport EchojoyUI from \"echojoy-ui\";\nimport \"echojoy-ui/lib/echojoy-ui.css\";\nVue.use(EchojoyUI);\n```\n\n这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。\n\n```\n<echojoy-test></echojoy-test>\n```\n\n# ! vue-cli3（vue-cli2）\n```\n vue init webpack projectName\n```\n![1ll.png](/images/8.png)\n\n\n####  启动项目\n`\n npm run dev\n`\n![1ll.png](/images/9.png)\n浏览器输入\n```\nhttp://localhost:8080\n```\n#### 编写组件\n\n在src的components新建组件limit：即文件夹`EchoLimit`->文件`index.vue` + 文件`index+css`\n```\n// index.vue\n<template>\n  <div class=\"echo-limit-container\" v-if=\"visible === false\">\n    <div class=\"echo-limit-container-inner\">\n      <span class=\"echo-limit-text\">\n        {{limitTip}}\n      </span>\n    </div>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    limitTip: {\n      type: String,\n      default: '没有权限！！'\n    },\n  },\n  name: \"EchoLimit\" // 这个名字很重要，它就是未来的标签名<echo-limit></echo-limit>\n};\n</script>\n<style>\n  @import \"./index\"\n</style>\n\n\n```\n   \n\n⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。\n\n#### 暴露组件\n\n* 注册单个组件\n\n在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：\n// 为组件提供 install 方法，供组件对外按需引入\n```\nimport EchoLimit from \"./EchoLimit/index.vue\";\nEchoLimit.install = Vue => {\n  Vue.component(EchoLimit.name, EchoLimit);\n};\nexport default EchoLimit;\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。\n\n* 注册全局组件\n让我们在 components 下面新建一个 index.js 文件，具体代码如下：\n```\n// index.js\nimport EchoLimit from './EchoLimit'\n// 所有组件列表\nconst components = [\n  EchoLimit\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n  // 判断是否安装，安装过就不继续往下执行\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册所有组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nconsole.log(components[0].name) // 控制台输出组件的name,方便引用组件\n\nexport default {\n  install,\n  // 所有组件，必须具有 install，才能使用 Vue.use()\n  ...components\n}\n\n```\n\n目录结构方便大家观看：\n![1ll.png](/images/4.png)\n\n#### 组件测试\n\nok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：\n\n```\nimport EchoUI from './components'\nVue.use(EchoUI)\n```\n在 HelloWorld.vue中引入组件EchoLimit.\n```\n<template>\n  <div>\n    <EchoLimit></EchoLimit>\n     <echo-limit></echo-limit>\n  </div>\n</echo-limit>\n```\n运行项目`npm run dev`,会发现成功了！！!\n![1ll.png](/images/10.png)\n\n\n过程同上！！！！！！！！！\n\n\n参考 连接：https://www.jianshu.com/p/41cc796488df\n参考 链接：https://juejin.im/post/5c95c61f6fb9a070c40acf65\n","source":"_posts/npmBuild.md","raw":"---\ntitle: npm 部署自己的组件库\ndate: 2019-07-26 14:18:53\ntags:\n---\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n# 基于 vue-cli 打造属于自己的 UI 库\n\n## 写在前面\n \n## 知识前置\n我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：\n```\nimport Loading from '../components/loading'\n// 方法一：name 是组件的名字\nVue.component(Loading.name, Loading)\n// 方法二：前提是 Loading 有提供 install 这个方法\nVue.use(Loading);\n```\n# 基于vue-cli3打造组件库\n# 搭建目录\n#### 快速创建项目\n* vue-cli3\n```\nvue create projectName\n```\n### 修改目录结构\n\n*  把 src 目录名字改成 examples，这是用于展示组件示例的\n*  在根目录下新建一个 packages 文件夹，这是用来放组件的\n![1ll.png](/images/1.png)\n    你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：\n当我们水平不够的时候，模仿是一种强大的学习能力👏。\n\n### 添加配置文件\n\n小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：\n\n```\nconst path = require('path')\nmodule.exports = {\n  // 修改 pages 入口\n  pages: {\n    index: {\n      entry: 'examples/main.js', // 入口\n      template: 'public/index.html', // 模板\n      filename: 'index.html' // 输出文件\n    }\n  },\n  // 扩展 webpack 配置\n  chainWebpack: config => {\n    // @ 默认指向 src 目录，这里要改成 examples\n    // 另外也可以新增一个 ~ 指向 packages\n    config.resolve.alias\n      .set('@', path.resolve('examples'))\n      .set('~', path.resolve('packages'))\n\n    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的\n    config.module\n      .rule('js')\n      .include.add(/packages/).end()\n      .include.add(/examples/).end()\n      .use('babel')\n      .loader('babel-loader')\n      .tap(options => {\n        // 修改它的选项...\n        return options\n      })\n  }\n}\n\n```\n\n上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 [Vue Cli](https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE) 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。\n\n## 编写组件\n\n一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：\n\n![1ll.png](/images/2.png)\n\n\n```\n<!--test.vue-->\n<template>\n  <div class=\"echojoy-test\" @click=\"handleClick\">{{ num }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'EchojoyTest',\n  data () {\n    return {\n      num: 0\n    }\n  },\n  methods: {\n    handleClick () {\n      this.num++\n    }\n  }\n}\n</script>\n\n<style >\n.echojoy-test {\n  width: 100px;\n  height: 100px;\n  line-height: 100px;\n  border-radius: 50%;\n  font-size: 30px;\n  text-align: center;\n  background: #24292e;\n  color: white;\n}\n</style>\n\n\n```\n\n应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 `EchojoyTest`，到时候我们写的标签就长这样 `<echojoy-test></echojoy-test>`，就像 Element 一样，name 是 `ElButton`，用的时候就是 `<el-button></el-button>`。\n\n## 暴露组件\n\n让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：\n\n```\n// 对外提供对组件的引用，注意组件必须声明 name\nimport EchojoyTest from './src/test'\n// 为组件提供 install 安装方法，供按需引入\nEchojoyTest.install = Vue => {\n  Vue.component(EchojoyTest.name, EchojoyTest)\n}\nexport default EchojoyTest\n\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 `Vue.use()` 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：\n\n```\nimport EchojoyTest from './test'\n// 存储组件列表\nconst components = [\n  EchojoyTest\n]\n// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册\nconst install = function (Vue) {\n  // 判断是否安装\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册全局组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 判断是否是直接引入文件\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nexport default {\n  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装\n  install,\n  // 以下是具体的组件列表\n  ...components\n}\n\n\n```\n\n这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：\n\n![1ll.png](/images/3.png)\n\n因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。\n当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。\n\n## 组件测试\n\nok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：\n```\nimport EchojoyUI from './../packages'\nVue.use(EchojoyUI);\n```\n然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：\n\n![1ll.png](/images/11.png)\n\n\n好了，最后让我们运行一下项目 `npm run  serve`，看看效果，嗯，还凑合吧。\n\n## 库模式打包\n\n在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：\n\n```\n// target: 默认为构建应用，改为 lib 即可启用构建库模式\n// name: 输出文件名\n// dest: 输出目录，默认为 dist，这里我们改为 lib\n// entry: 入口文件路径\nvue-cli-service build --target lib --name lib [entry]\n\n```\n\n要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：\n\n![1ll.png](/images/5.png)\n\n\n\n接着执行 `npm run lib` 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。\n![1ll.png](/images/6.png)\n\n\n\n补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。\n\n## 发布到npm\n\n万事俱备，只欠发布。\n\n1.  完善一下 README.md 文档，这个随便写两句就好\n2.  修改一下 package.json 文件：\n\n```\n{ \n  \"name\": \"echojoy-ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"description\": \"基于 vue-cli3 的 UI 组件库\",\n  \"main\": \"lib/xr-ui.umd.min.js\",\n  \"keywords\": \"echojoy-ui\",\n  \"private\": false,\n  \"license\": \"MIT\"\n}\n\n```\n\n3.  在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：\n\n```\n# 这是复制 .gitignore 里面的\n.DS_Store\nnode_modules\n/dist\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw*\n\n# 以下是新增的\n# 要忽略目录和指定文件\nexamples/\npackages/\npublic/\nvue.config.js\nbabel.config.js\n*.map\n*.html\n\n```\n\n最后执行 `npm login` 登入 npm 账号，再执行 `npm publish` 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n## 小试牛刀\n\n终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 `vue create echojoy-ui-use` 另起一个新项目，然后 `npm i echojoy-ui -S`，可以在 node_modules 里面看到我们的包大概长这样：\n![1ll.png](/images/7.png)\n\n\n\n然后在 main.js 引入：\n\n```\nimport EchojoyUI from \"echojoy-ui\";\nimport \"echojoy-ui/lib/echojoy-ui.css\";\nVue.use(EchojoyUI);\n```\n\n这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。\n\n```\n<echojoy-test></echojoy-test>\n```\n\n# ! vue-cli3（vue-cli2）\n```\n vue init webpack projectName\n```\n![1ll.png](/images/8.png)\n\n\n####  启动项目\n`\n npm run dev\n`\n![1ll.png](/images/9.png)\n浏览器输入\n```\nhttp://localhost:8080\n```\n#### 编写组件\n\n在src的components新建组件limit：即文件夹`EchoLimit`->文件`index.vue` + 文件`index+css`\n```\n// index.vue\n<template>\n  <div class=\"echo-limit-container\" v-if=\"visible === false\">\n    <div class=\"echo-limit-container-inner\">\n      <span class=\"echo-limit-text\">\n        {{limitTip}}\n      </span>\n    </div>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    limitTip: {\n      type: String,\n      default: '没有权限！！'\n    },\n  },\n  name: \"EchoLimit\" // 这个名字很重要，它就是未来的标签名<echo-limit></echo-limit>\n};\n</script>\n<style>\n  @import \"./index\"\n</style>\n\n\n```\n   \n\n⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。\n\n#### 暴露组件\n\n* 注册单个组件\n\n在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：\n// 为组件提供 install 方法，供组件对外按需引入\n```\nimport EchoLimit from \"./EchoLimit/index.vue\";\nEchoLimit.install = Vue => {\n  Vue.component(EchoLimit.name, EchoLimit);\n};\nexport default EchoLimit;\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。\n\n* 注册全局组件\n让我们在 components 下面新建一个 index.js 文件，具体代码如下：\n```\n// index.js\nimport EchoLimit from './EchoLimit'\n// 所有组件列表\nconst components = [\n  EchoLimit\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n  // 判断是否安装，安装过就不继续往下执行\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册所有组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nconsole.log(components[0].name) // 控制台输出组件的name,方便引用组件\n\nexport default {\n  install,\n  // 所有组件，必须具有 install，才能使用 Vue.use()\n  ...components\n}\n\n```\n\n目录结构方便大家观看：\n![1ll.png](/images/4.png)\n\n#### 组件测试\n\nok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：\n\n```\nimport EchoUI from './components'\nVue.use(EchoUI)\n```\n在 HelloWorld.vue中引入组件EchoLimit.\n```\n<template>\n  <div>\n    <EchoLimit></EchoLimit>\n     <echo-limit></echo-limit>\n  </div>\n</echo-limit>\n```\n运行项目`npm run dev`,会发现成功了！！!\n![1ll.png](/images/10.png)\n\n\n过程同上！！！！！！！！！\n\n\n参考 连接：https://www.jianshu.com/p/41cc796488df\n参考 链接：https://juejin.im/post/5c95c61f6fb9a070c40acf65\n","slug":"npmBuild","published":1,"updated":"2019-08-15T02:06:25.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzcehfzn0003cskczvjta6w8","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<h1 id=\"基于-vue-cli-打造属于自己的-UI-库\"><a href=\"#基于-vue-cli-打造属于自己的-UI-库\" class=\"headerlink\" title=\"基于 vue-cli 打造属于自己的 UI 库\"></a>基于 vue-cli 打造属于自己的 UI 库</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><h2 id=\"知识前置\"><a href=\"#知识前置\" class=\"headerlink\" title=\"知识前置\"></a>知识前置</h2><p>我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Loading from &apos;../components/loading&apos;</span><br><span class=\"line\">// 方法一：name 是组件的名字</span><br><span class=\"line\">Vue.component(Loading.name, Loading)</span><br><span class=\"line\">// 方法二：前提是 Loading 有提供 install 这个方法</span><br><span class=\"line\">Vue.use(Loading);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基于vue-cli3打造组件库\"><a href=\"#基于vue-cli3打造组件库\" class=\"headerlink\" title=\"基于vue-cli3打造组件库\"></a>基于vue-cli3打造组件库</h1><h1 id=\"搭建目录\"><a href=\"#搭建目录\" class=\"headerlink\" title=\"搭建目录\"></a>搭建目录</h1><h4 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h4><ul>\n<li>vue-cli3<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create projectName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改目录结构\"><a href=\"#修改目录结构\" class=\"headerlink\" title=\"修改目录结构\"></a>修改目录结构</h3><ul>\n<li>把 src 目录名字改成 examples，这是用于展示组件示例的</li>\n<li>在根目录下新建一个 packages 文件夹，这是用来放组件的<br><img src=\"/images/1.png\" alt=\"1ll.png\"><br> 你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：<br>当我们水平不够的时候，模仿是一种强大的学习能力👏。</li>\n</ul>\n<h3 id=\"添加配置文件\"><a href=\"#添加配置文件\" class=\"headerlink\" title=\"添加配置文件\"></a>添加配置文件</h3><p>小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 修改 pages 入口</span><br><span class=\"line\">  pages: &#123;</span><br><span class=\"line\">    index: &#123;</span><br><span class=\"line\">      entry: &apos;examples/main.js&apos;, // 入口</span><br><span class=\"line\">      template: &apos;public/index.html&apos;, // 模板</span><br><span class=\"line\">      filename: &apos;index.html&apos; // 输出文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 扩展 webpack 配置</span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    // @ 默认指向 src 目录，这里要改成 examples</span><br><span class=\"line\">    // 另外也可以新增一个 ~ 指向 packages</span><br><span class=\"line\">    config.resolve.alias</span><br><span class=\"line\">      .set(&apos;@&apos;, path.resolve(&apos;examples&apos;))</span><br><span class=\"line\">      .set(&apos;~&apos;, path.resolve(&apos;packages&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(&apos;js&apos;)</span><br><span class=\"line\">      .include.add(/packages/).end()</span><br><span class=\"line\">      .include.add(/examples/).end()</span><br><span class=\"line\">      .use(&apos;babel&apos;)</span><br><span class=\"line\">      .loader(&apos;babel-loader&apos;)</span><br><span class=\"line\">      .tap(options =&gt; &#123;</span><br><span class=\"line\">        // 修改它的选项...</span><br><span class=\"line\">        return options</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE\" target=\"_blank\" rel=\"noopener\">Vue Cli</a> 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。</p>\n<h2 id=\"编写组件\"><a href=\"#编写组件\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h2><p>一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：</p>\n<p><img src=\"/images/2.png\" alt=\"1ll.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--test.vue--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-test&quot; @click=&quot;handleClick&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;EchojoyTest&apos;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      num: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick () &#123;</span><br><span class=\"line\">      this.num++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style &gt;</span><br><span class=\"line\">.echojoy-test &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100px;</span><br><span class=\"line\">  line-height: 100px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  font-size: 30px;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  background: #24292e;</span><br><span class=\"line\">  color: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 <code>EchojoyTest</code>，到时候我们写的标签就长这样 <code>&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</code>，就像 Element 一样，name 是 <code>ElButton</code>，用的时候就是 <code>&lt;el-button&gt;&lt;/el-button&gt;</code>。</p>\n<h2 id=\"暴露组件\"><a href=\"#暴露组件\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h2><p>让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对外提供对组件的引用，注意组件必须声明 name</span><br><span class=\"line\">import EchojoyTest from &apos;./src/test&apos;</span><br><span class=\"line\">// 为组件提供 install 安装方法，供按需引入</span><br><span class=\"line\">EchojoyTest.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchojoyTest.name, EchojoyTest)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default EchojoyTest</span><br></pre></td></tr></table></figure>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 <code>Vue.use()</code> 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyTest from &apos;./test&apos;</span><br><span class=\"line\">// 存储组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchojoyTest</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册全局组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是直接引入文件</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 以下是具体的组件列表</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：</p>\n<p><img src=\"/images/3.png\" alt=\"1ll.png\"></p>\n<p>因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。<br>当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。</p>\n<h2 id=\"组件测试\"><a href=\"#组件测试\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h2><p>ok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &apos;./../packages&apos;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure></p>\n<p>然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：</p>\n<p><img src=\"/images/11.png\" alt=\"1ll.png\"></p>\n<p>好了，最后让我们运行一下项目 <code>npm run  serve</code>，看看效果，嗯，还凑合吧。</p>\n<h2 id=\"库模式打包\"><a href=\"#库模式打包\" class=\"headerlink\" title=\"库模式打包\"></a>库模式打包</h2><p>在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// target: 默认为构建应用，改为 lib 即可启用构建库模式</span><br><span class=\"line\">// name: 输出文件名</span><br><span class=\"line\">// dest: 输出目录，默认为 dist，这里我们改为 lib</span><br><span class=\"line\">// entry: 入口文件路径</span><br><span class=\"line\">vue-cli-service build --target lib --name lib [entry]</span><br></pre></td></tr></table></figure>\n<p>要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：</p>\n<p><img src=\"/images/5.png\" alt=\"1ll.png\"></p>\n<p>接着执行 <code>npm run lib</code> 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。<br><img src=\"/images/6.png\" alt=\"1ll.png\"></p>\n<p>补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。</p>\n<h2 id=\"发布到npm\"><a href=\"#发布到npm\" class=\"headerlink\" title=\"发布到npm\"></a>发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ol>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>修改一下 package.json 文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  &quot;name&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;description&quot;: &quot;基于 vue-cli3 的 UI 组件库&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;lib/xr-ui.umd.min.js&quot;,</span><br><span class=\"line\">  &quot;keywords&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;private&quot;: false,</span><br><span class=\"line\">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是复制 .gitignore 里面的</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">/dist</span><br><span class=\"line\"></span><br><span class=\"line\"># local env files</span><br><span class=\"line\">.env.local</span><br><span class=\"line\">.env.*.local</span><br><span class=\"line\"></span><br><span class=\"line\"># Log files</span><br><span class=\"line\">npm-debug.log*</span><br><span class=\"line\">yarn-debug.log*</span><br><span class=\"line\">yarn-error.log*</span><br><span class=\"line\"></span><br><span class=\"line\"># Editor directories and files</span><br><span class=\"line\">.idea</span><br><span class=\"line\">.vscode</span><br><span class=\"line\">*.suo</span><br><span class=\"line\">*.ntvs*</span><br><span class=\"line\">*.njsproj</span><br><span class=\"line\">*.sln</span><br><span class=\"line\">*.sw*</span><br><span class=\"line\"></span><br><span class=\"line\"># 以下是新增的</span><br><span class=\"line\"># 要忽略目录和指定文件</span><br><span class=\"line\">examples/</span><br><span class=\"line\">packages/</span><br><span class=\"line\">public/</span><br><span class=\"line\">vue.config.js</span><br><span class=\"line\">babel.config.js</span><br><span class=\"line\">*.map</span><br><span class=\"line\">*.html</span><br></pre></td></tr></table></figure>\n<p>最后执行 <code>npm login</code> 登入 npm 账号，再执行 <code>npm publish</code> 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</p>\n<h2 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h2><p>终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 <code>vue create echojoy-ui-use</code> 另起一个新项目，然后 <code>npm i echojoy-ui -S</code>，可以在 node_modules 里面看到我们的包大概长这样：<br><img src=\"/images/7.png\" alt=\"1ll.png\"></p>\n<p>然后在 main.js 引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &quot;echojoy-ui&quot;;</span><br><span class=\"line\">import &quot;echojoy-ui/lib/echojoy-ui.css&quot;;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure>\n<p>这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli3（vue-cli2）\"><a href=\"#vue-cli3（vue-cli2）\" class=\"headerlink\" title=\"! vue-cli3（vue-cli2）\"></a>! vue-cli3（vue-cli2）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack projectName</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/8.png\" alt=\"1ll.png\"></p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><code>npm run dev</code><br><img src=\"/images/9.png\" alt=\"1ll.png\"><br>浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写组件-1\"><a href=\"#编写组件-1\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h4><p>在src的components新建组件limit：即文件夹<code>EchoLimit</code>-&gt;文件<code>index.vue</code> + 文件<code>index+css</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echo-limit-container&quot; v-if=&quot;visible === false&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;echo-limit-container-inner&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;echo-limit-text&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;limitTip&#125;&#125;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    visible: &#123;</span><br><span class=\"line\">      type: Boolean,</span><br><span class=\"line\">      default: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    limitTip: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &apos;没有权限！！&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: &quot;EchoLimit&quot; // 这个名字很重要，它就是未来的标签名&lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  @import &quot;./index&quot;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。</p>\n<h4 id=\"暴露组件-1\"><a href=\"#暴露组件-1\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h4><ul>\n<li>注册单个组件</li>\n</ul>\n<p>在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：<br>// 为组件提供 install 方法，供组件对外按需引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoLimit from &quot;./EchoLimit/index.vue&quot;;</span><br><span class=\"line\">EchoLimit.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchoLimit.name, EchoLimit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default EchoLimit;</span><br></pre></td></tr></table></figure></p>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。</p>\n<ul>\n<li>注册全局组件<br>让我们在 components 下面新建一个 index.js 文件，具体代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.js</span><br><span class=\"line\">import EchoLimit from &apos;./EchoLimit&apos;</span><br><span class=\"line\">// 所有组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchoLimit</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装，安装过就不继续往下执行</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册所有组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检测到 Vue 才执行，毕竟我们是基于 Vue 的</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(components[0].name) // 控制台输出组件的name,方便引用组件</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 所有组件，必须具有 install，才能使用 Vue.use()</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>目录结构方便大家观看：<br><img src=\"/images/4.png\" alt=\"1ll.png\"></p>\n<h4 id=\"组件测试-1\"><a href=\"#组件测试-1\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h4><p>ok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoUI from &apos;./components&apos;</span><br><span class=\"line\">Vue.use(EchoUI)</span><br></pre></td></tr></table></figure>\n<p>在 HelloWorld.vue中引入组件EchoLimit.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;EchoLimit&gt;&lt;/EchoLimit&gt;</span><br><span class=\"line\">     &lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/echo-limit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行项目<code>npm run dev</code>,会发现成功了！！!<br><img src=\"/images/10.png\" alt=\"1ll.png\"></p>\n<p>过程同上！！！！！！！！！</p>\n<p>参考 连接：<a href=\"https://www.jianshu.com/p/41cc796488df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/41cc796488df</a><br>参考 链接：<a href=\"https://juejin.im/post/5c95c61f6fb9a070c40acf65\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c95c61f6fb9a070c40acf65</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<h1 id=\"基于-vue-cli-打造属于自己的-UI-库\"><a href=\"#基于-vue-cli-打造属于自己的-UI-库\" class=\"headerlink\" title=\"基于 vue-cli 打造属于自己的 UI 库\"></a>基于 vue-cli 打造属于自己的 UI 库</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><h2 id=\"知识前置\"><a href=\"#知识前置\" class=\"headerlink\" title=\"知识前置\"></a>知识前置</h2><p>我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Loading from &apos;../components/loading&apos;</span><br><span class=\"line\">// 方法一：name 是组件的名字</span><br><span class=\"line\">Vue.component(Loading.name, Loading)</span><br><span class=\"line\">// 方法二：前提是 Loading 有提供 install 这个方法</span><br><span class=\"line\">Vue.use(Loading);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基于vue-cli3打造组件库\"><a href=\"#基于vue-cli3打造组件库\" class=\"headerlink\" title=\"基于vue-cli3打造组件库\"></a>基于vue-cli3打造组件库</h1><h1 id=\"搭建目录\"><a href=\"#搭建目录\" class=\"headerlink\" title=\"搭建目录\"></a>搭建目录</h1><h4 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h4><ul>\n<li>vue-cli3<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create projectName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改目录结构\"><a href=\"#修改目录结构\" class=\"headerlink\" title=\"修改目录结构\"></a>修改目录结构</h3><ul>\n<li>把 src 目录名字改成 examples，这是用于展示组件示例的</li>\n<li>在根目录下新建一个 packages 文件夹，这是用来放组件的<br><img src=\"/images/1.png\" alt=\"1ll.png\"><br> 你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：<br>当我们水平不够的时候，模仿是一种强大的学习能力👏。</li>\n</ul>\n<h3 id=\"添加配置文件\"><a href=\"#添加配置文件\" class=\"headerlink\" title=\"添加配置文件\"></a>添加配置文件</h3><p>小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 修改 pages 入口</span><br><span class=\"line\">  pages: &#123;</span><br><span class=\"line\">    index: &#123;</span><br><span class=\"line\">      entry: &apos;examples/main.js&apos;, // 入口</span><br><span class=\"line\">      template: &apos;public/index.html&apos;, // 模板</span><br><span class=\"line\">      filename: &apos;index.html&apos; // 输出文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 扩展 webpack 配置</span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    // @ 默认指向 src 目录，这里要改成 examples</span><br><span class=\"line\">    // 另外也可以新增一个 ~ 指向 packages</span><br><span class=\"line\">    config.resolve.alias</span><br><span class=\"line\">      .set(&apos;@&apos;, path.resolve(&apos;examples&apos;))</span><br><span class=\"line\">      .set(&apos;~&apos;, path.resolve(&apos;packages&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(&apos;js&apos;)</span><br><span class=\"line\">      .include.add(/packages/).end()</span><br><span class=\"line\">      .include.add(/examples/).end()</span><br><span class=\"line\">      .use(&apos;babel&apos;)</span><br><span class=\"line\">      .loader(&apos;babel-loader&apos;)</span><br><span class=\"line\">      .tap(options =&gt; &#123;</span><br><span class=\"line\">        // 修改它的选项...</span><br><span class=\"line\">        return options</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE\" target=\"_blank\" rel=\"noopener\">Vue Cli</a> 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。</p>\n<h2 id=\"编写组件\"><a href=\"#编写组件\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h2><p>一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：</p>\n<p><img src=\"/images/2.png\" alt=\"1ll.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--test.vue--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-test&quot; @click=&quot;handleClick&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;EchojoyTest&apos;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      num: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick () &#123;</span><br><span class=\"line\">      this.num++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style &gt;</span><br><span class=\"line\">.echojoy-test &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100px;</span><br><span class=\"line\">  line-height: 100px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  font-size: 30px;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  background: #24292e;</span><br><span class=\"line\">  color: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 <code>EchojoyTest</code>，到时候我们写的标签就长这样 <code>&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</code>，就像 Element 一样，name 是 <code>ElButton</code>，用的时候就是 <code>&lt;el-button&gt;&lt;/el-button&gt;</code>。</p>\n<h2 id=\"暴露组件\"><a href=\"#暴露组件\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h2><p>让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对外提供对组件的引用，注意组件必须声明 name</span><br><span class=\"line\">import EchojoyTest from &apos;./src/test&apos;</span><br><span class=\"line\">// 为组件提供 install 安装方法，供按需引入</span><br><span class=\"line\">EchojoyTest.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchojoyTest.name, EchojoyTest)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default EchojoyTest</span><br></pre></td></tr></table></figure>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 <code>Vue.use()</code> 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyTest from &apos;./test&apos;</span><br><span class=\"line\">// 存储组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchojoyTest</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册全局组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是直接引入文件</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 以下是具体的组件列表</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：</p>\n<p><img src=\"/images/3.png\" alt=\"1ll.png\"></p>\n<p>因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。<br>当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。</p>\n<h2 id=\"组件测试\"><a href=\"#组件测试\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h2><p>ok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &apos;./../packages&apos;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure></p>\n<p>然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：</p>\n<p><img src=\"/images/11.png\" alt=\"1ll.png\"></p>\n<p>好了，最后让我们运行一下项目 <code>npm run  serve</code>，看看效果，嗯，还凑合吧。</p>\n<h2 id=\"库模式打包\"><a href=\"#库模式打包\" class=\"headerlink\" title=\"库模式打包\"></a>库模式打包</h2><p>在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// target: 默认为构建应用，改为 lib 即可启用构建库模式</span><br><span class=\"line\">// name: 输出文件名</span><br><span class=\"line\">// dest: 输出目录，默认为 dist，这里我们改为 lib</span><br><span class=\"line\">// entry: 入口文件路径</span><br><span class=\"line\">vue-cli-service build --target lib --name lib [entry]</span><br></pre></td></tr></table></figure>\n<p>要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：</p>\n<p><img src=\"/images/5.png\" alt=\"1ll.png\"></p>\n<p>接着执行 <code>npm run lib</code> 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。<br><img src=\"/images/6.png\" alt=\"1ll.png\"></p>\n<p>补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。</p>\n<h2 id=\"发布到npm\"><a href=\"#发布到npm\" class=\"headerlink\" title=\"发布到npm\"></a>发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ol>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>修改一下 package.json 文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  &quot;name&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;description&quot;: &quot;基于 vue-cli3 的 UI 组件库&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;lib/xr-ui.umd.min.js&quot;,</span><br><span class=\"line\">  &quot;keywords&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;private&quot;: false,</span><br><span class=\"line\">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是复制 .gitignore 里面的</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">/dist</span><br><span class=\"line\"></span><br><span class=\"line\"># local env files</span><br><span class=\"line\">.env.local</span><br><span class=\"line\">.env.*.local</span><br><span class=\"line\"></span><br><span class=\"line\"># Log files</span><br><span class=\"line\">npm-debug.log*</span><br><span class=\"line\">yarn-debug.log*</span><br><span class=\"line\">yarn-error.log*</span><br><span class=\"line\"></span><br><span class=\"line\"># Editor directories and files</span><br><span class=\"line\">.idea</span><br><span class=\"line\">.vscode</span><br><span class=\"line\">*.suo</span><br><span class=\"line\">*.ntvs*</span><br><span class=\"line\">*.njsproj</span><br><span class=\"line\">*.sln</span><br><span class=\"line\">*.sw*</span><br><span class=\"line\"></span><br><span class=\"line\"># 以下是新增的</span><br><span class=\"line\"># 要忽略目录和指定文件</span><br><span class=\"line\">examples/</span><br><span class=\"line\">packages/</span><br><span class=\"line\">public/</span><br><span class=\"line\">vue.config.js</span><br><span class=\"line\">babel.config.js</span><br><span class=\"line\">*.map</span><br><span class=\"line\">*.html</span><br></pre></td></tr></table></figure>\n<p>最后执行 <code>npm login</code> 登入 npm 账号，再执行 <code>npm publish</code> 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</p>\n<h2 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h2><p>终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 <code>vue create echojoy-ui-use</code> 另起一个新项目，然后 <code>npm i echojoy-ui -S</code>，可以在 node_modules 里面看到我们的包大概长这样：<br><img src=\"/images/7.png\" alt=\"1ll.png\"></p>\n<p>然后在 main.js 引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &quot;echojoy-ui&quot;;</span><br><span class=\"line\">import &quot;echojoy-ui/lib/echojoy-ui.css&quot;;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure>\n<p>这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli3（vue-cli2）\"><a href=\"#vue-cli3（vue-cli2）\" class=\"headerlink\" title=\"! vue-cli3（vue-cli2）\"></a>! vue-cli3（vue-cli2）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack projectName</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/8.png\" alt=\"1ll.png\"></p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><code>npm run dev</code><br><img src=\"/images/9.png\" alt=\"1ll.png\"><br>浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写组件-1\"><a href=\"#编写组件-1\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h4><p>在src的components新建组件limit：即文件夹<code>EchoLimit</code>-&gt;文件<code>index.vue</code> + 文件<code>index+css</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echo-limit-container&quot; v-if=&quot;visible === false&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;echo-limit-container-inner&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;echo-limit-text&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;limitTip&#125;&#125;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    visible: &#123;</span><br><span class=\"line\">      type: Boolean,</span><br><span class=\"line\">      default: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    limitTip: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &apos;没有权限！！&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: &quot;EchoLimit&quot; // 这个名字很重要，它就是未来的标签名&lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  @import &quot;./index&quot;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。</p>\n<h4 id=\"暴露组件-1\"><a href=\"#暴露组件-1\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h4><ul>\n<li>注册单个组件</li>\n</ul>\n<p>在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：<br>// 为组件提供 install 方法，供组件对外按需引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoLimit from &quot;./EchoLimit/index.vue&quot;;</span><br><span class=\"line\">EchoLimit.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchoLimit.name, EchoLimit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default EchoLimit;</span><br></pre></td></tr></table></figure></p>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。</p>\n<ul>\n<li>注册全局组件<br>让我们在 components 下面新建一个 index.js 文件，具体代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.js</span><br><span class=\"line\">import EchoLimit from &apos;./EchoLimit&apos;</span><br><span class=\"line\">// 所有组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchoLimit</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装，安装过就不继续往下执行</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册所有组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检测到 Vue 才执行，毕竟我们是基于 Vue 的</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(components[0].name) // 控制台输出组件的name,方便引用组件</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 所有组件，必须具有 install，才能使用 Vue.use()</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>目录结构方便大家观看：<br><img src=\"/images/4.png\" alt=\"1ll.png\"></p>\n<h4 id=\"组件测试-1\"><a href=\"#组件测试-1\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h4><p>ok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoUI from &apos;./components&apos;</span><br><span class=\"line\">Vue.use(EchoUI)</span><br></pre></td></tr></table></figure>\n<p>在 HelloWorld.vue中引入组件EchoLimit.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;EchoLimit&gt;&lt;/EchoLimit&gt;</span><br><span class=\"line\">     &lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/echo-limit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行项目<code>npm run dev</code>,会发现成功了！！!<br><img src=\"/images/10.png\" alt=\"1ll.png\"></p>\n<p>过程同上！！！！！！！！！</p>\n<p>参考 连接：<a href=\"https://www.jianshu.com/p/41cc796488df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/41cc796488df</a><br>参考 链接：<a href=\"https://juejin.im/post/5c95c61f6fb9a070c40acf65\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c95c61f6fb9a070c40acf65</a></p>\n"},{"title":"node 基础知识","date":"2019-08-14T07:37:18.609Z","_content":"Author: Echo\nTime: 2019-08-14 15:37:18\n\n# 有助于理解前端工具的 node 知识\n\n## 缘起\n平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。\n想想我们是不是时常看到过这种东西：`const path = require('path');`。\n假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。\n后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。\n言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。\n ## node 初识\n#### node 是什么\n首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。\n#### node 遵循的规范\n其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：\n```\nrequire('./module')\nmodule.exports = {\n    a: 1,\n}\nexports.a = 1;\n\n```\n这就是 node 的规范，用` require` 导入、用 `module.exports` 导出。那 node 为什么不支持 ESM（就是用 `import` 导入、用 `export` 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 `require()` 字样却没有看见 `import()`就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 `require()`。\n\n这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：\n\n![16ad4be6bc803f68.png](https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## require 寻找依赖\nrequire() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：\n```\nrequire('./module'); // 带相对路径\nrequire('/module'); // 带绝对路径\nrequire('module'); // 不带路径\n```\n这种不带路径的 `require('module') `引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。\n\n另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。\n## node 模块包装\nnode 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：\n```\n(function(exports, require, module, __filename, __dirname) {\n    // module: 表示当前模块\n    // __filename: 当前模块的带有完整绝对路径的文件名\n    // __dirname: 当前模块的完整绝对路径\n    module.exports = exports = this = {};\n    // 我们的代码就在这里...\n    return module.exports;\n})()\n```\n想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。\n## node 的应用场景\n一般来说，node 主要应用于以下几个方面：\n\n* 自动化构建等工具\n* 中间层\n* 小项目\n\n第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。\n## node 的优点\n\n* 适合前端大大们\n* 基于事件驱动和无阻塞的I/O（适合处理并发请求）\n* 性能较好（别人做过性能分析）\n\n## node 内置模块\nok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。\n### http 模块\n这是 node 最最基础的功能了，我们用 `node http.js` 运行一下下面的文件就能开启一个服务器，在浏览器中输入 `http://localhost:8888` 即可访问，http.js 具体内容如下：\n```\n// http.js\nconst http = require('http');\nhttp.createServer((req, res) => { // 开启一个服务\n  console.log('请求来了'); // 如果你打开 http://localhost:8888，控制台就会打印此消息\n  res.write('hello'); // 返回给页面的值，也就是页面会显示 hello\n  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态\n}).listen(8888); // 端口号\n```\n### fs 文件系统\n\n由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 `<input type='file'>`），但是需要用户手动操作才行。\n但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：\n\n```\nconst fs = require('fs');\n\n// 写入文件：fs.writeFile(path, fileData, cb);\nfs.writeFile('./text.txt', 'hello xr!', err => {\n  if (err) {\n    console.log('写入失败', err);\n  } else {\n    console.log('写入成功');\n  }\n});\n\n// 读取文件：fs.readFile(path, cb);\nfs.readFile('./text.txt', (err, fileData) => {\n  if (err) {\n    console.log('读取失败', err);\n  } else {\n    console.log('读取成功', fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下\n  }\n});\n```\n\n需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em...就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 `toString()` 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 `toString()` 转换的话会丢失掉原始信息，所以不能乱转。二进制和 `toString` 的效果就像下面这样：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。\n## path 路径\n这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：\n```\nconst path = require('path');\n\nlet str = '/root/a/b/index.html';\nconsole.log(path.dirname(str)); // 路径\n// /root/a/b\nconsole.log(path.extname(str)); // 后缀名\n// .html\nconsole.log(path.basename(str)); // 文件名\n// index.html\n\n// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径\nlet pathOne = path.resolve('rooot/a/b', '../c', 'd', '..', 'e');\n\n// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录\nlet pathTwo = path.resolve(__dirname, 'build'); // 这个用法很常见，你应该在 webpack 中有见过\n\nconsole.log(pathOne, pathTwo, __dirname);\n// pathOne  =>  /Users/lgq/Desktop/node/rooot/a/c/e\n// pathTwo  =>  /Users/lgq/Desktop/node/build\n// __dirname  =>  /Users/lgq/Desktop/node\n```\n嗯，下次看到 path 这个东西就不会迷茫了。\n### url 模块\n\n很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：\n\n```\nconst url = require('url');\n\nlet site = 'http://www.xr.com/a/b/index.html?a=1&b=2';\nlet { pathname, query } = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象\n\nconsole.log(pathname, query);\n// /a/b/index.html  { a: '1', b: '2' }\n```\n\n### querystring 查询字符串\n\n这个主要是用来把形如这样的字符串 `a=1&b=2&c=3`（&和=可以换成别的）解析成 `{ a: '1', b: '2', c: '3' }` 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：\n\n```\nconst querystring = require('querystring');\n\nlet query = 'a=1&b=2&c=3'; // 形如这样的字符串就能被解析\nlet obj = querystring.parse(query);\nconsole.log(obj, obj.a); // { a: '1', b: '2', c: '3' }   '1'\n\nquery = 'a=1&b=2&c=3&a=3'; // 如果参数重复，其所对应的值会变成数组\nobj = querystring.parse(query);\nconsole.log(obj); // { a: [ '1', '3' ], b: '2', c: '3' }\n\n// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串\nquery = querystring.stringify(obj);\nconsole.log(query); // a=1&a=3&b=2&c=3\n```\n\n### assert 断言\n\n这个我们直接看下面代码就知道它的作用了：\n\n```\n// assert.js\nconst assert = require('assert');\n\n// assert(条件，错误消息)，条件这部分会返回一个布尔值\nassert(2 < 1, '断言失败');\n```\n\n`node assert.js` 运行一下代码就能看到如下结果：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 `false` 则阻止程序运行，并抛出一个错误，如果返回值为 `true` 则继续执行，一般用于函数中间和参数判断。\n另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：\n\n```\n// assert.js\nconst assert = require('assert');\n\nconst obj1 = { a: { b: 1 } };\nconst obj2 = { a: { b: 1 } };\nconst obj3 = { a: { b: '1' } };\n\n// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值\n// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值\n// 同样也是错误的时候抛出信息，正确的时候继续默默执行\nassert.deepEqual(obj1, obj2, '不等哦'); // true\nassert.deepEqual(obj1, obj3, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj2, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj3, '不等哦'); // false，这个会抛出错误信息\n```\n\n### stream 流\n\nstream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 `fs.readFile` 和 `fs.writeFile` 的升级版。\n我们要知道 `readFile` 和 `writeFile` 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。\n\n```\nconst fs = require('fs');\n\n// 读取流：fs.createReadStream();\n// 写入流：fs.createWriteStream();\nlet rs = fs.createReadStream('a.txt'); // 要读取的文件\nlet ws = fs.createWriteStream('a2.txt'); // 输出的文件\n\nrs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n\n```\n\n流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。\n\n### zlib 压缩\n\n这个用法简单，作用也明了，直接看下面的代码就能理解：\n\n```\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nlet rs = fs.createReadStream('tree.jpg');\nlet gz = zlib.createGzip();\nlet ws = fs.createWriteStream('tree.jpg.gz');\n\nrs.pipe(gz).pipe(ws);  // 原始文件 => 压缩 => 写入\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n```\n\n## 小结\n\nok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。\n参考作者：尤水就下\n参考链接：https://juejin.im/post/5ccacfb96fb9a03201243cb9","source":"_posts/nodeBasics.md","raw":"---\ntitle: node 基础知识\ndate: \ntags:\n---\nAuthor: Echo\nTime: 2019-08-14 15:37:18\n\n# 有助于理解前端工具的 node 知识\n\n## 缘起\n平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。\n想想我们是不是时常看到过这种东西：`const path = require('path');`。\n假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。\n后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。\n言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。\n ## node 初识\n#### node 是什么\n首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。\n#### node 遵循的规范\n其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：\n```\nrequire('./module')\nmodule.exports = {\n    a: 1,\n}\nexports.a = 1;\n\n```\n这就是 node 的规范，用` require` 导入、用 `module.exports` 导出。那 node 为什么不支持 ESM（就是用 `import` 导入、用 `export` 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 `require()` 字样却没有看见 `import()`就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 `require()`。\n\n这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：\n\n![16ad4be6bc803f68.png](https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## require 寻找依赖\nrequire() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：\n```\nrequire('./module'); // 带相对路径\nrequire('/module'); // 带绝对路径\nrequire('module'); // 不带路径\n```\n这种不带路径的 `require('module') `引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。\n\n另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。\n## node 模块包装\nnode 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：\n```\n(function(exports, require, module, __filename, __dirname) {\n    // module: 表示当前模块\n    // __filename: 当前模块的带有完整绝对路径的文件名\n    // __dirname: 当前模块的完整绝对路径\n    module.exports = exports = this = {};\n    // 我们的代码就在这里...\n    return module.exports;\n})()\n```\n想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。\n## node 的应用场景\n一般来说，node 主要应用于以下几个方面：\n\n* 自动化构建等工具\n* 中间层\n* 小项目\n\n第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。\n## node 的优点\n\n* 适合前端大大们\n* 基于事件驱动和无阻塞的I/O（适合处理并发请求）\n* 性能较好（别人做过性能分析）\n\n## node 内置模块\nok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。\n### http 模块\n这是 node 最最基础的功能了，我们用 `node http.js` 运行一下下面的文件就能开启一个服务器，在浏览器中输入 `http://localhost:8888` 即可访问，http.js 具体内容如下：\n```\n// http.js\nconst http = require('http');\nhttp.createServer((req, res) => { // 开启一个服务\n  console.log('请求来了'); // 如果你打开 http://localhost:8888，控制台就会打印此消息\n  res.write('hello'); // 返回给页面的值，也就是页面会显示 hello\n  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态\n}).listen(8888); // 端口号\n```\n### fs 文件系统\n\n由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 `<input type='file'>`），但是需要用户手动操作才行。\n但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：\n\n```\nconst fs = require('fs');\n\n// 写入文件：fs.writeFile(path, fileData, cb);\nfs.writeFile('./text.txt', 'hello xr!', err => {\n  if (err) {\n    console.log('写入失败', err);\n  } else {\n    console.log('写入成功');\n  }\n});\n\n// 读取文件：fs.readFile(path, cb);\nfs.readFile('./text.txt', (err, fileData) => {\n  if (err) {\n    console.log('读取失败', err);\n  } else {\n    console.log('读取成功', fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下\n  }\n});\n```\n\n需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em...就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 `toString()` 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 `toString()` 转换的话会丢失掉原始信息，所以不能乱转。二进制和 `toString` 的效果就像下面这样：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。\n## path 路径\n这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：\n```\nconst path = require('path');\n\nlet str = '/root/a/b/index.html';\nconsole.log(path.dirname(str)); // 路径\n// /root/a/b\nconsole.log(path.extname(str)); // 后缀名\n// .html\nconsole.log(path.basename(str)); // 文件名\n// index.html\n\n// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径\nlet pathOne = path.resolve('rooot/a/b', '../c', 'd', '..', 'e');\n\n// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录\nlet pathTwo = path.resolve(__dirname, 'build'); // 这个用法很常见，你应该在 webpack 中有见过\n\nconsole.log(pathOne, pathTwo, __dirname);\n// pathOne  =>  /Users/lgq/Desktop/node/rooot/a/c/e\n// pathTwo  =>  /Users/lgq/Desktop/node/build\n// __dirname  =>  /Users/lgq/Desktop/node\n```\n嗯，下次看到 path 这个东西就不会迷茫了。\n### url 模块\n\n很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：\n\n```\nconst url = require('url');\n\nlet site = 'http://www.xr.com/a/b/index.html?a=1&b=2';\nlet { pathname, query } = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象\n\nconsole.log(pathname, query);\n// /a/b/index.html  { a: '1', b: '2' }\n```\n\n### querystring 查询字符串\n\n这个主要是用来把形如这样的字符串 `a=1&b=2&c=3`（&和=可以换成别的）解析成 `{ a: '1', b: '2', c: '3' }` 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：\n\n```\nconst querystring = require('querystring');\n\nlet query = 'a=1&b=2&c=3'; // 形如这样的字符串就能被解析\nlet obj = querystring.parse(query);\nconsole.log(obj, obj.a); // { a: '1', b: '2', c: '3' }   '1'\n\nquery = 'a=1&b=2&c=3&a=3'; // 如果参数重复，其所对应的值会变成数组\nobj = querystring.parse(query);\nconsole.log(obj); // { a: [ '1', '3' ], b: '2', c: '3' }\n\n// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串\nquery = querystring.stringify(obj);\nconsole.log(query); // a=1&a=3&b=2&c=3\n```\n\n### assert 断言\n\n这个我们直接看下面代码就知道它的作用了：\n\n```\n// assert.js\nconst assert = require('assert');\n\n// assert(条件，错误消息)，条件这部分会返回一个布尔值\nassert(2 < 1, '断言失败');\n```\n\n`node assert.js` 运行一下代码就能看到如下结果：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 `false` 则阻止程序运行，并抛出一个错误，如果返回值为 `true` 则继续执行，一般用于函数中间和参数判断。\n另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：\n\n```\n// assert.js\nconst assert = require('assert');\n\nconst obj1 = { a: { b: 1 } };\nconst obj2 = { a: { b: 1 } };\nconst obj3 = { a: { b: '1' } };\n\n// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值\n// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值\n// 同样也是错误的时候抛出信息，正确的时候继续默默执行\nassert.deepEqual(obj1, obj2, '不等哦'); // true\nassert.deepEqual(obj1, obj3, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj2, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj3, '不等哦'); // false，这个会抛出错误信息\n```\n\n### stream 流\n\nstream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 `fs.readFile` 和 `fs.writeFile` 的升级版。\n我们要知道 `readFile` 和 `writeFile` 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。\n\n```\nconst fs = require('fs');\n\n// 读取流：fs.createReadStream();\n// 写入流：fs.createWriteStream();\nlet rs = fs.createReadStream('a.txt'); // 要读取的文件\nlet ws = fs.createWriteStream('a2.txt'); // 输出的文件\n\nrs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n\n```\n\n流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。\n\n### zlib 压缩\n\n这个用法简单，作用也明了，直接看下面的代码就能理解：\n\n```\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nlet rs = fs.createReadStream('tree.jpg');\nlet gz = zlib.createGzip();\nlet ws = fs.createWriteStream('tree.jpg.gz');\n\nrs.pipe(gz).pipe(ws);  // 原始文件 => 压缩 => 写入\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n```\n\n## 小结\n\nok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。\n参考作者：尤水就下\n参考链接：https://juejin.im/post/5ccacfb96fb9a03201243cb9","slug":"nodeBasics","published":1,"updated":"2019-08-14T07:49:48.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzcehfzo0004cskcp80x29qj","content":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h1 id=\"有助于理解前端工具的-node-知识\"><a href=\"#有助于理解前端工具的-node-知识\" class=\"headerlink\" title=\"有助于理解前端工具的 node 知识\"></a>有助于理解前端工具的 node 知识</h1><h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>\n<h2 id=\"node-初识\"><a href=\"#node-初识\" class=\"headerlink\" title=\"node 初识\"></a>node 初识</h2><h4 id=\"node-是什么\"><a href=\"#node-是什么\" class=\"headerlink\" title=\"node 是什么\"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>\n<h4 id=\"node-遵循的规范\"><a href=\"#node-遵循的规范\" class=\"headerlink\" title=\"node 遵循的规范\"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    a: 1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.a = 1;</span><br></pre></td></tr></table></figure></p>\n<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>\n<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"16ad4be6bc803f68.png\"></p>\n<h2 id=\"require-寻找依赖\"><a href=\"#require-寻找依赖\" class=\"headerlink\" title=\"require 寻找依赖\"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;); // 带相对路径</span><br><span class=\"line\">require(&apos;/module&apos;); // 带绝对路径</span><br><span class=\"line\">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>\n<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>\n<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>\n<h2 id=\"node-模块包装\"><a href=\"#node-模块包装\" class=\"headerlink\" title=\"node 模块包装\"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">    // module: 表示当前模块</span><br><span class=\"line\">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class=\"line\">    // __dirname: 当前模块的完整绝对路径</span><br><span class=\"line\">    module.exports = exports = this = &#123;&#125;;</span><br><span class=\"line\">    // 我们的代码就在这里...</span><br><span class=\"line\">    return module.exports;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>\n<h2 id=\"node-的应用场景\"><a href=\"#node-的应用场景\" class=\"headerlink\" title=\"node 的应用场景\"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>\n<ul>\n<li>自动化构建等工具</li>\n<li>中间层</li>\n<li>小项目</li>\n</ul>\n<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>\n<h2 id=\"node-的优点\"><a href=\"#node-的优点\" class=\"headerlink\" title=\"node 的优点\"></a>node 的优点</h2><ul>\n<li>适合前端大大们</li>\n<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>\n<li>性能较好（别人做过性能分析）</li>\n</ul>\n<h2 id=\"node-内置模块\"><a href=\"#node-内置模块\" class=\"headerlink\" title=\"node 内置模块\"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>\n<h3 id=\"http-模块\"><a href=\"#http-模块\" class=\"headerlink\" title=\"http 模块\"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http.js</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class=\"line\">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class=\"line\">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class=\"line\">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class=\"line\">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"fs-文件系统\"><a href=\"#fs-文件系统\" class=\"headerlink\" title=\"fs 文件系统\"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class=\"line\">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;写入失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;写入成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取文件：fs.readFile(path, cb);</span><br><span class=\"line\">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;读取失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>\n<h2 id=\"path-路径\"><a href=\"#path-路径\" class=\"headerlink\" title=\"path 路径\"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class=\"line\">console.log(path.dirname(str)); // 路径</span><br><span class=\"line\">// /root/a/b</span><br><span class=\"line\">console.log(path.extname(str)); // 后缀名</span><br><span class=\"line\">// .html</span><br><span class=\"line\">console.log(path.basename(str)); // 文件名</span><br><span class=\"line\">// index.html</span><br><span class=\"line\"></span><br><span class=\"line\">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class=\"line\">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class=\"line\">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathOne, pathTwo, __dirname);</span><br><span class=\"line\">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class=\"line\">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class=\"line\">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>\n<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>\n<h3 id=\"url-模块\"><a href=\"#url-模块\" class=\"headerlink\" title=\"url 模块\"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = require(&apos;url&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class=\"line\">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathname, query);</span><br><span class=\"line\">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"querystring-查询字符串\"><a href=\"#querystring-查询字符串\" class=\"headerlink\" title=\"querystring 查询字符串\"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring = require(&apos;querystring&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class=\"line\">let obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class=\"line\">obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class=\"line\">query = querystring.stringify(obj);</span><br><span class=\"line\">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert 断言\"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class=\"line\">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>\n<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class=\"line\">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class=\"line\">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class=\"line\">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"stream-流\"><a href=\"#stream-流\" class=\"headerlink\" title=\"stream 流\"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取流：fs.createReadStream();</span><br><span class=\"line\">// 写入流：fs.createWriteStream();</span><br><span class=\"line\">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>\n<h3 id=\"zlib-压缩\"><a href=\"#zlib-压缩\" class=\"headerlink\" title=\"zlib 压缩\"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const zlib = require(&apos;zlib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class=\"line\">let gz = zlib.createGzip();</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href=\"https://juejin.im/post/5ccacfb96fb9a03201243cb9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h1 id=\"有助于理解前端工具的-node-知识\"><a href=\"#有助于理解前端工具的-node-知识\" class=\"headerlink\" title=\"有助于理解前端工具的 node 知识\"></a>有助于理解前端工具的 node 知识</h1><h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>\n<h2 id=\"node-初识\"><a href=\"#node-初识\" class=\"headerlink\" title=\"node 初识\"></a>node 初识</h2><h4 id=\"node-是什么\"><a href=\"#node-是什么\" class=\"headerlink\" title=\"node 是什么\"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>\n<h4 id=\"node-遵循的规范\"><a href=\"#node-遵循的规范\" class=\"headerlink\" title=\"node 遵循的规范\"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    a: 1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.a = 1;</span><br></pre></td></tr></table></figure></p>\n<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>\n<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"16ad4be6bc803f68.png\"></p>\n<h2 id=\"require-寻找依赖\"><a href=\"#require-寻找依赖\" class=\"headerlink\" title=\"require 寻找依赖\"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;); // 带相对路径</span><br><span class=\"line\">require(&apos;/module&apos;); // 带绝对路径</span><br><span class=\"line\">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>\n<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>\n<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>\n<h2 id=\"node-模块包装\"><a href=\"#node-模块包装\" class=\"headerlink\" title=\"node 模块包装\"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">    // module: 表示当前模块</span><br><span class=\"line\">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class=\"line\">    // __dirname: 当前模块的完整绝对路径</span><br><span class=\"line\">    module.exports = exports = this = &#123;&#125;;</span><br><span class=\"line\">    // 我们的代码就在这里...</span><br><span class=\"line\">    return module.exports;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>\n<h2 id=\"node-的应用场景\"><a href=\"#node-的应用场景\" class=\"headerlink\" title=\"node 的应用场景\"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>\n<ul>\n<li>自动化构建等工具</li>\n<li>中间层</li>\n<li>小项目</li>\n</ul>\n<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>\n<h2 id=\"node-的优点\"><a href=\"#node-的优点\" class=\"headerlink\" title=\"node 的优点\"></a>node 的优点</h2><ul>\n<li>适合前端大大们</li>\n<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>\n<li>性能较好（别人做过性能分析）</li>\n</ul>\n<h2 id=\"node-内置模块\"><a href=\"#node-内置模块\" class=\"headerlink\" title=\"node 内置模块\"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>\n<h3 id=\"http-模块\"><a href=\"#http-模块\" class=\"headerlink\" title=\"http 模块\"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http.js</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class=\"line\">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class=\"line\">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class=\"line\">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class=\"line\">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"fs-文件系统\"><a href=\"#fs-文件系统\" class=\"headerlink\" title=\"fs 文件系统\"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class=\"line\">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;写入失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;写入成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取文件：fs.readFile(path, cb);</span><br><span class=\"line\">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;读取失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>\n<h2 id=\"path-路径\"><a href=\"#path-路径\" class=\"headerlink\" title=\"path 路径\"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class=\"line\">console.log(path.dirname(str)); // 路径</span><br><span class=\"line\">// /root/a/b</span><br><span class=\"line\">console.log(path.extname(str)); // 后缀名</span><br><span class=\"line\">// .html</span><br><span class=\"line\">console.log(path.basename(str)); // 文件名</span><br><span class=\"line\">// index.html</span><br><span class=\"line\"></span><br><span class=\"line\">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class=\"line\">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class=\"line\">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathOne, pathTwo, __dirname);</span><br><span class=\"line\">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class=\"line\">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class=\"line\">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>\n<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>\n<h3 id=\"url-模块\"><a href=\"#url-模块\" class=\"headerlink\" title=\"url 模块\"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = require(&apos;url&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class=\"line\">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathname, query);</span><br><span class=\"line\">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"querystring-查询字符串\"><a href=\"#querystring-查询字符串\" class=\"headerlink\" title=\"querystring 查询字符串\"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring = require(&apos;querystring&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class=\"line\">let obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class=\"line\">obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class=\"line\">query = querystring.stringify(obj);</span><br><span class=\"line\">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert 断言\"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class=\"line\">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>\n<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class=\"line\">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class=\"line\">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class=\"line\">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"stream-流\"><a href=\"#stream-流\" class=\"headerlink\" title=\"stream 流\"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取流：fs.createReadStream();</span><br><span class=\"line\">// 写入流：fs.createWriteStream();</span><br><span class=\"line\">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>\n<h3 id=\"zlib-压缩\"><a href=\"#zlib-压缩\" class=\"headerlink\" title=\"zlib 压缩\"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const zlib = require(&apos;zlib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class=\"line\">let gz = zlib.createGzip();</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href=\"https://juejin.im/post/5ccacfb96fb9a03201243cb9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}