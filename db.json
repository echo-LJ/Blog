{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/1.png","path":"images/1.png","modified":0,"renderable":0},{"_id":"source/images/10.png","path":"images/10.png","modified":0,"renderable":0},{"_id":"source/images/2.png","path":"images/2.png","modified":0,"renderable":0},{"_id":"source/images/3.png","path":"images/3.png","modified":0,"renderable":0},{"_id":"source/images/4.png","path":"images/4.png","modified":0,"renderable":0},{"_id":"source/images/5.png","path":"images/5.png","modified":0,"renderable":0},{"_id":"source/images/6.png","path":"images/6.png","modified":0,"renderable":0},{"_id":"source/images/7.png","path":"images/7.png","modified":0,"renderable":0},{"_id":"source/images/vueDiff.jpg","path":"images/vueDiff.jpg","modified":0,"renderable":0},{"_id":"source/images/9.png","path":"images/9.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"source/images/8.png","path":"images/8.png","modified":0,"renderable":0},{"_id":"source/images/11.png","path":"images/11.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1563950143781},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1563950143783},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1563950143782},{"_id":"themes/landscape/_config.yml","hash":"218c5fb76666696c42dc86e2de4711e6b80befbf","modified":1563950143785},{"_id":"themes/landscape/README.md","hash":"e7cc82dc79596f36ba05a8139e7d6b2dfc4ae5f9","modified":1563950143784},{"_id":"themes/landscape/package.json","hash":"d07f326588fef82f1d23ae3101c9ddfff34c132f","modified":1563950143827},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1563950143786},{"_id":"themes/landscape/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1563950143787},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1563950143788},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1563950143790},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1563950143791},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1563950143792},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1563950143794},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1563950143819},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1563950143820},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1563950143821},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1563950143822},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1563950143824},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1563950143825},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1563950143826},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1563950143828},{"_id":"source/_drafts/express.md","hash":"2ff2cebde31fa3c0c441caf9eb7f139b131880a5","modified":1568949863726},{"_id":"source/_drafts/html.md","hash":"04c9d1165f386fc1d64bb941862ab27849db4ce6","modified":1568945238979},{"_id":"source/_drafts/jsTitle.md","hash":"79f1009bc621fcbe41d0da0d69feff7567778f1f","modified":1568895929368},{"_id":"source/_drafts/question.md","hash":"d027d4f6c778f8bca25897b9fdc61d06cc90f880","modified":1568711620954},{"_id":"source/_drafts/storybook.md","hash":"8cdae0c4d9695543e09817445d940439ca942e37","modified":1568701024103},{"_id":"source/_drafts/title.md","hash":"c4e441802e1f723f89ec50f003714fb315ee07ea","modified":1568971812360},{"_id":"source/_drafts/vueCli3-proxy.md","hash":"3eed8657675ac2cb6fe44b591bf6f9d14f38cad8","modified":1567668382186},{"_id":"source/_drafts/vueSourceCoding.md","hash":"ebbd16305fc382cf559367f4e78dcbba14d81c74","modified":1567475247937},{"_id":"source/_posts/ForwardReverseProxy.md","hash":"86a4b753b63d05088ce376337afecd14e0d6ff91","modified":1568949583510},{"_id":"source/_posts/JS-thread.md","hash":"9163aec37b0497603a0c1dc6d58cc490ef6ff045","modified":1568705624046},{"_id":"source/_posts/axios.md","hash":"3b92292c19fa43d6fabd9f43e397bfe9d85c7e09","modified":1568948766380},{"_id":"source/_posts/blogInit.md","hash":"1a930434c3c3fb33dcbad7047cfcdb71ee9e0a5e","modified":1568892332710},{"_id":"source/_posts/commitMessage.md","hash":"d7da46b654d5e0b4aaa31ec7651307647f083e27","modified":1568966118396},{"_id":"source/_posts/css.md","hash":"0b5330c464ab06c85b439b9708dacfda6fda5ccf","modified":1568944038833},{"_id":"source/_posts/cssTitle.md","hash":"937ec34a2e47fbded6c57d74d06fbf6e7fab2343","modified":1568897017523},{"_id":"source/_posts/express.md","hash":"56562a4122b2b2d55944fb94fc017984fc027498","modified":1568971828409},{"_id":"source/_posts/hexoDeplayBug.md","hash":"6216104cb1d85ff20d410fe265ffe01442f62333","modified":1566373209010},{"_id":"source/_posts/js.md","hash":"c6b9f80c41dd41b0109d3f914d2045e43461765f","modified":1568897375668},{"_id":"source/_posts/message-comp.md","hash":"82645fcacdfabbc0f012165dc94016694efc7347","modified":1568895037009},{"_id":"source/_posts/nodeBasics.md","hash":"cd5542835d0a8dd126e1895bf0b9d5b477a41a9b","modified":1566373180539},{"_id":"source/_posts/npmBuild.md","hash":"adafc4fcc08dc4a7d01e6a4f3e5782bb244dd6f9","modified":1566373200747},{"_id":"source/_posts/promise.md","hash":"c7b833c7949b90bd7cda2dd6ca6e5227cd2d60d0","modified":1567590096452},{"_id":"source/_posts/request.md","hash":"c1c3c88902b7b11639aa438a538974aea7e2ffff","modified":1566528168046},{"_id":"source/_posts/virtualDom.md","hash":"6473ebc252bf31eeb48d899bed8e4d55b3c110eb","modified":1568948745501},{"_id":"source/_posts/vue.md","hash":"63349b8ba07fe44ddb6e141508125f887d50f190","modified":1568897561480},{"_id":"source/_posts/vueSourceCoding.md","hash":"64d9537fbf673d5493afe9ddb691bbe60b1adde1","modified":1568621717238},{"_id":"source/_posts/vueTitle.md","hash":"3f0b66b28732e4ccbfa3789f27c0d74f006f336e","modified":1568895618104},{"_id":"source/_posts/web.md","hash":"a154ece0270035d14c507b5c76f0a14a2b1d03ad","modified":1568897689786},{"_id":"source/images/1.png","hash":"bb42453a4634ba5efa39724a9e9534d83e628609","modified":1564123759154},{"_id":"source/_posts/webTitle.md","hash":"520baf64f436184ea2506d6e4a6d66e8c1a0dac8","modified":1568897701834},{"_id":"source/images/10.png","hash":"46d39d6622c1b487fdede45e5e5c16daec45389b","modified":1564124369974},{"_id":"source/images/2.png","hash":"226b3d4003e8de1a6986227e5354ff802e2c6957","modified":1564124064568},{"_id":"source/images/3.png","hash":"487194a77790392b97b7d78d670ece0d51311949","modified":1564126159464},{"_id":"source/images/4.png","hash":"ca862f01f040bb3ea3b96f8336a873b84b6c0811","modified":1564126195472},{"_id":"source/images/5.png","hash":"a15c1fe1536f552659a3954f1e036afee53ed534","modified":1564124220927},{"_id":"source/images/6.png","hash":"82f98a98d4e70602f85533687894b5554df26176","modified":1564124257819},{"_id":"source/images/7.png","hash":"9ba5660654e8de4838df16bfdb314e9790bef507","modified":1564124292571},{"_id":"source/images/vueDiff.jpg","hash":"d9da1e7acbdace27c64834411ed947d76b07e468","modified":1568618309038},{"_id":"source/images/9.png","hash":"c7e0f6e6f6ff38dc0d45ad7872b66d43e399c2e7","modified":1564124343686},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1563950143797},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"a7faab4f3601b28107af5b1095b3966c2f88fec8","modified":1563950143796},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"3beb0d164acacb6f21e1ca2038158a74ab4a73e4","modified":1563950143798},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1563950143799},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1563950143800},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1563950143802},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"148bdf714dd1a7bf55e571f13808ceae079200cc","modified":1563950143804},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"89998e6b2929c4ff5093bbf6b86d611d7420be52","modified":1563950143803},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1563950143805},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1563950143812},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1563950143814},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1563950143815},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1563950143816},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1563950143817},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1563950143818},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1563950143830},{"_id":"themes/landscape/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1563950143845},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1563950143859},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1563950143861},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1563950143862},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1563950143863},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1563950143864},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1563950143865},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1563950143867},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1563950143876},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1563950143878},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1563950143879},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1567672802828},{"_id":"source/images/8.png","hash":"39378833bdc6009f6f7e9ebd0ad8cc572adf9e28","modified":1564124337074},{"_id":"source/images/11.png","hash":"777d5895b1775c05c110b095c9affc90dace9014","modified":1564126229769},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1563950143806},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1563950143807},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1563950143808},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1563950143809},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1563950143810},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1563950143811},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1563950143831},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1567672802827},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1563950143833},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1563950143834},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1563950143835},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1563950143837},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1563950143838},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1563950143839},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1563950143840},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1563950143841},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1563950143843},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1563950143843},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1563950143847},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1563950143849},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1563950143854},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1563950143869},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1563950143868},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1563950143870},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1563950143872},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1563950143873},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1563950143875},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1563950143853},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1563950143851},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1563950143858},{"_id":"public/2019/09/20/ForwardReverseProxy/index.html","hash":"521acb08601dd9a0a7864ec47957f153f154a3f6","modified":1568971911067},{"_id":"public/2019/09/20/virtualDom/index.html","hash":"03b64d1e0918f9cee72023c9c2c6437b757126e0","modified":1568971911067},{"_id":"public/2019/09/19/web/index.html","hash":"02c5ec1f0655aef941aa8958ea12ea1c78aa2d76","modified":1568971911068},{"_id":"public/2019/09/19/css/index.html","hash":"4757c26663d0c4c9bf4b8538c222d1a611dc7ba2","modified":1568971911068},{"_id":"public/2019/09/19/vue/index.html","hash":"32334844fb7f94b2816db4597e1db45db7c4f88c","modified":1568971911068},{"_id":"public/2019/09/19/js/index.html","hash":"ce3177c3516bf2e34a5f1a521a5667876258983d","modified":1568971911068},{"_id":"public/2019/09/03/vueTitle/index.html","hash":"5f8f5eccef18bc48b00003f25ea7ebf5ae938fb1","modified":1568971911068},{"_id":"public/2019/07/24/hexoDeplayBug/index.html","hash":"40f8fdcb019c26bdf63400ca43e3d966db07a101","modified":1568971911068},{"_id":"public/2019/07/24/blogInit/index.html","hash":"967f13796d081ee6a081d012e634b1f4c03357c5","modified":1568971911069},{"_id":"public/archives/index.html","hash":"d3882304329bd04734dae06dd0d1130035ef78f3","modified":1568971911069},{"_id":"public/archives/page/2/index.html","hash":"2051e671d0bff7d0e9edbb2849ae340a52cd6843","modified":1568971911069},{"_id":"public/archives/page/3/index.html","hash":"a78ec6439d823c40506b4a996609e5aa9e6e0bd2","modified":1568971911069},{"_id":"public/archives/2019/index.html","hash":"31ffe39521d305a6bf584a0a3161057fda053ca4","modified":1568971911069},{"_id":"public/archives/2019/page/2/index.html","hash":"091095c1458c1a2b5ee2d90ee4afb624e7a5c6fe","modified":1568971911069},{"_id":"public/archives/2019/page/3/index.html","hash":"1bd04d219d02571147e0b32785cc344055f82200","modified":1568971911069},{"_id":"public/archives/2019/07/index.html","hash":"e06869440bdf1370359fbc560ea4694975cce712","modified":1568971911069},{"_id":"public/archives/2019/08/index.html","hash":"6f81188cfd828afbc0b3e893f757644237804015","modified":1568971911069},{"_id":"public/archives/2019/09/index.html","hash":"b6823ec10f7bb319387510835a3582c3d0f129e6","modified":1568971911070},{"_id":"public/archives/2019/09/page/2/index.html","hash":"7b7531d735e3b9f2b8e198e5dc37ccbaf766de36","modified":1568971911070},{"_id":"public/page/3/index.html","hash":"33c813a36ab4592926ad59efa674564b90b67bae","modified":1568971911070},{"_id":"public/tags/web/index.html","hash":"4aadeca0bafbb5962ef4be12c14233d0b976517c","modified":1568971911070},{"_id":"public/tags/blog-hexo/index.html","hash":"1c94224555b7eb51150b2f94aacea0bcef71cac9","modified":1568971911070},{"_id":"public/tags/git/index.html","hash":"43ce04e8b22638e37f0ef48c858558a0cf39036c","modified":1568971911070},{"_id":"public/tags/前端面试题/index.html","hash":"77edb9739afca531b694e08f0857b1c04b8d4b45","modified":1568971911070},{"_id":"public/tags/node/index.html","hash":"4582246455118c5a2c2c126a34fe646644dd2165","modified":1568971911070},{"_id":"public/tags/js/index.html","hash":"7adfca15193ad04eff3ca5f0ebf61e1c2c33d986","modified":1568971911070},{"_id":"public/tags/vue/index.html","hash":"68825e8a01ff4d2825e8d3bb7baf35b3b552957a","modified":1568971911070},{"_id":"public/tags/es6-vue/index.html","hash":"ef72d4290d708b625f356d7a983b49f72a3406a0","modified":1568971911070},{"_id":"public/tags/css/index.html","hash":"303bf0420cf8078598b7d8d9aa8c35d1d6e70d11","modified":1568971911070},{"_id":"public/tags/npm/index.html","hash":"555f5b1347fb42c33a09170e3ff02caf931a06c7","modified":1568971911071},{"_id":"public/tags/es6/index.html","hash":"15c5c87209f1fecc8eb1511ef23fa4a4613f5f92","modified":1568971911071},{"_id":"public/2019/09/20/express/index.html","hash":"3e135690079d77746b5bdf5c8424a656b1b72be6","modified":1568971911071},{"_id":"public/2019/09/20/commitMessage/index.html","hash":"aeebc905cf18ba5207acc2a201baa19b72a8e46c","modified":1568971911071},{"_id":"public/2019/09/20/axios/index.html","hash":"4b886d93e141cc1500c3b2ffb0153b8694d1cae2","modified":1568971911071},{"_id":"public/2019/09/19/cssTitle/index.html","hash":"1be0d47d93991456c75dec8dfef7637d9fbbbe4e","modified":1568971911071},{"_id":"public/2019/09/03/vueSourceCoding/index.html","hash":"0987ce6b8ec49fed47e5768164d829db3e43f3cf","modified":1568971911071},{"_id":"public/2019/09/02/webTitle/index.html","hash":"11eb422c9cd0fe2004068c6fae72b0050392a5fa","modified":1568971911071},{"_id":"public/2019/08/26/promise/index.html","hash":"10e813e786df4bd66d9b37e9f141b64a3f356899","modified":1568971911071},{"_id":"public/2019/08/21/JS-thread/index.html","hash":"f1be12ff6a5696efb4d425f8266c911797cc5ebe","modified":1568971911072},{"_id":"public/2019/08/19/request/index.html","hash":"0de2f11257541b23b60eec877f4231628f9a9ecb","modified":1568971911072},{"_id":"public/2019/08/15/message-comp/index.html","hash":"f350a7a1d4a46497451e4f9f9f4b9c9906534703","modified":1568971911072},{"_id":"public/2019/08/14/nodeBasics/index.html","hash":"c87a6c51cb0b3945c742530c685dbf9be365e34f","modified":1568971911072},{"_id":"public/2019/07/26/npmBuild/index.html","hash":"ca1852af70ceb0aee628d0b42d5b3c1cc52a40a9","modified":1568971911072},{"_id":"public/index.html","hash":"89874759404d4204c55d83cd07b643794e363e22","modified":1568971911072},{"_id":"public/page/2/index.html","hash":"92d0def67636b8a67f7db5dba219e35a54ff323e","modified":1568971911072},{"_id":"public/images/2.png","hash":"226b3d4003e8de1a6986227e5354ff802e2c6957","modified":1568971911095},{"_id":"public/images/3.png","hash":"487194a77790392b97b7d78d670ece0d51311949","modified":1568971911095},{"_id":"public/images/5.png","hash":"a15c1fe1536f552659a3954f1e036afee53ed534","modified":1568971911095},{"_id":"public/images/4.png","hash":"ca862f01f040bb3ea3b96f8336a873b84b6c0811","modified":1568971911096},{"_id":"public/images/1.png","hash":"bb42453a4634ba5efa39724a9e9534d83e628609","modified":1568971911096},{"_id":"public/images/vueDiff.jpg","hash":"d9da1e7acbdace27c64834411ed947d76b07e468","modified":1568971911096},{"_id":"public/images/10.png","hash":"46d39d6622c1b487fdede45e5e5c16daec45389b","modified":1568971911096},{"_id":"public/images/6.png","hash":"82f98a98d4e70602f85533687894b5554df26176","modified":1568971911096},{"_id":"public/images/9.png","hash":"c7e0f6e6f6ff38dc0d45ad7872b66d43e399c2e7","modified":1568971911096},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1568971911096},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1568971911096},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1568971911096},{"_id":"public/images/7.png","hash":"9ba5660654e8de4838df16bfdb314e9790bef507","modified":1568971911097},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1568971911097},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1568971911097},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1568971911097},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1568971911097},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1568971911097},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1568971911097},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1568971911097},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1568971911915},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1568971911922},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1568971911922},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1568971911922},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1568971911922},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1568971911922},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1568971911922},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1568971911922},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1568971911922},{"_id":"public/images/8.png","hash":"39378833bdc6009f6f7e9ebd0ad8cc572adf9e28","modified":1568971911922},{"_id":"public/images/11.png","hash":"777d5895b1775c05c110b095c9affc90dace9014","modified":1568971911964},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1568971911964},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1568971911964},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1568971911980},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1568971912078}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"express： 实现本地代码+本地mock+环境接口数据","_content":"\nAuthor: Echo\nTime: 2019-08-14 15:37:18\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```","source":"_drafts/express.md","raw":"---\ntitle: express： 实现本地代码+本地mock+环境接口数据\ntags:\n---\n\nAuthor: Echo\nTime: 2019-08-14 15:37:18\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```","slug":"express","published":0,"date":"2019-09-05T12:45:13.378Z","updated":"2019-09-20T03:24:23.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4s50000ygkc0nuppycv","content":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>"},{"title":"html","_content":"\n\n* htML\n#### 你有用过bdo标签吗？举例说明它的作用是什么？\n```\n// bi-diretion-override\n```\n* 含义：覆盖标签内文本的显示方向\n* 是一个行内元素\n* 有一个属性dir，两个值：\n** rtl: right to left（默认）\n** ltr: left to right\n\n* css\n\n#### 外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\n1. 外边距重叠是什么？\n外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。\n2. 重叠的结果是什么？\n举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。\n3. 怎么防止外边距重叠？\n* 浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）\n* 外层元素padding代替\n* 内层元素透明边框 border:1px solid transparent;\n* 用同一方向的margin，都设置为top或者bottom。\n\n\n* js\n\n#### 举例说明js拖拽用到的事件有哪些？\n使用html的新特性dragable\n* dragstart:拖拽开始时在被拖拽元素上触发此事件. \n  此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件\n* dragover:拖拽时鼠标在目标元素上移动时触发.\n  此时监听器通过阻止浏览器默认行为设置元素为可拖放元素\n* dragleave:拖拽时鼠标移出目标元素时在目标元素上触发\n  此时监听器可以取消掉前面设置的视觉效果.\n* drag:拖拽期间在被拖拽元素上连续触发\n* drop:鼠标在拖放目标上释放时,在拖放目标上触发.\n  此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.\n* dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.\n  将元素从浏览器拖放到操作系统时不会触发此事件.\n\n* web\n#### 项目上线流程是怎样的？\n\n","source":"_drafts/html.md","raw":"---\ntitle: html\ntags:\n---\n\n\n* htML\n#### 你有用过bdo标签吗？举例说明它的作用是什么？\n```\n// bi-diretion-override\n```\n* 含义：覆盖标签内文本的显示方向\n* 是一个行内元素\n* 有一个属性dir，两个值：\n** rtl: right to left（默认）\n** ltr: left to right\n\n* css\n\n#### 外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\n1. 外边距重叠是什么？\n外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。\n2. 重叠的结果是什么？\n举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。\n3. 怎么防止外边距重叠？\n* 浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）\n* 外层元素padding代替\n* 内层元素透明边框 border:1px solid transparent;\n* 用同一方向的margin，都设置为top或者bottom。\n\n\n* js\n\n#### 举例说明js拖拽用到的事件有哪些？\n使用html的新特性dragable\n* dragstart:拖拽开始时在被拖拽元素上触发此事件. \n  此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件\n* dragover:拖拽时鼠标在目标元素上移动时触发.\n  此时监听器通过阻止浏览器默认行为设置元素为可拖放元素\n* dragleave:拖拽时鼠标移出目标元素时在目标元素上触发\n  此时监听器可以取消掉前面设置的视觉效果.\n* drag:拖拽期间在被拖拽元素上连续触发\n* drop:鼠标在拖放目标上释放时,在拖放目标上触发.\n  此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.\n* dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.\n  将元素从浏览器拖放到操作系统时不会触发此事件.\n\n* web\n#### 项目上线流程是怎样的？\n\n","slug":"html","published":0,"date":"2019-09-20T01:33:47.358Z","updated":"2019-09-20T02:07:18.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sd0001ygkc6mrqxldj","content":"<ul>\n<li><p>htML</p>\n<h4 id=\"你有用过bdo标签吗？举例说明它的作用是什么？\"><a href=\"#你有用过bdo标签吗？举例说明它的作用是什么？\" class=\"headerlink\" title=\"你有用过bdo标签吗？举例说明它的作用是什么？\"></a>你有用过bdo标签吗？举例说明它的作用是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bi-diretion-override</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>含义：覆盖标签内文本的显示方向</p>\n</li>\n<li>是一个行内元素</li>\n<li><p>有一个属性dir，两个值：<br><strong> rtl: right to left（默认）\n</strong> ltr: left to right</p>\n</li>\n<li><p>css</p>\n</li>\n</ul>\n<h4 id=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"><a href=\"#外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\" class=\"headerlink\" title=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"></a>外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？</h4><ol>\n<li>外边距重叠是什么？<br>外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。</li>\n<li>重叠的结果是什么？<br>举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。</li>\n<li>怎么防止外边距重叠？</li>\n</ol>\n<ul>\n<li>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）</li>\n<li>外层元素padding代替</li>\n<li>内层元素透明边框 border:1px solid transparent;</li>\n<li>用同一方向的margin，都设置为top或者bottom。</li>\n</ul>\n<ul>\n<li>js</li>\n</ul>\n<h4 id=\"举例说明js拖拽用到的事件有哪些？\"><a href=\"#举例说明js拖拽用到的事件有哪些？\" class=\"headerlink\" title=\"举例说明js拖拽用到的事件有哪些？\"></a>举例说明js拖拽用到的事件有哪些？</h4><p>使用html的新特性dragable</p>\n<ul>\n<li>dragstart:拖拽开始时在被拖拽元素上触发此事件.<br>此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件</li>\n<li>dragover:拖拽时鼠标在目标元素上移动时触发.<br>此时监听器通过阻止浏览器默认行为设置元素为可拖放元素</li>\n<li>dragleave:拖拽时鼠标移出目标元素时在目标元素上触发<br>此时监听器可以取消掉前面设置的视觉效果.</li>\n<li>drag:拖拽期间在被拖拽元素上连续触发</li>\n<li>drop:鼠标在拖放目标上释放时,在拖放目标上触发.<br>此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.</li>\n<li><p>dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.<br>将元素从浏览器拖放到操作系统时不会触发此事件.</p>\n</li>\n<li><p>web</p>\n<h4 id=\"项目上线流程是怎样的？\"><a href=\"#项目上线流程是怎样的？\" class=\"headerlink\" title=\"项目上线流程是怎样的？\"></a>项目上线流程是怎样的？</h4></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>htML</p>\n<h4 id=\"你有用过bdo标签吗？举例说明它的作用是什么？\"><a href=\"#你有用过bdo标签吗？举例说明它的作用是什么？\" class=\"headerlink\" title=\"你有用过bdo标签吗？举例说明它的作用是什么？\"></a>你有用过bdo标签吗？举例说明它的作用是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bi-diretion-override</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>含义：覆盖标签内文本的显示方向</p>\n</li>\n<li>是一个行内元素</li>\n<li><p>有一个属性dir，两个值：<br><strong> rtl: right to left（默认）\n</strong> ltr: left to right</p>\n</li>\n<li><p>css</p>\n</li>\n</ul>\n<h4 id=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"><a href=\"#外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\" class=\"headerlink\" title=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"></a>外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？</h4><ol>\n<li>外边距重叠是什么？<br>外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。</li>\n<li>重叠的结果是什么？<br>举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。</li>\n<li>怎么防止外边距重叠？</li>\n</ol>\n<ul>\n<li>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）</li>\n<li>外层元素padding代替</li>\n<li>内层元素透明边框 border:1px solid transparent;</li>\n<li>用同一方向的margin，都设置为top或者bottom。</li>\n</ul>\n<ul>\n<li>js</li>\n</ul>\n<h4 id=\"举例说明js拖拽用到的事件有哪些？\"><a href=\"#举例说明js拖拽用到的事件有哪些？\" class=\"headerlink\" title=\"举例说明js拖拽用到的事件有哪些？\"></a>举例说明js拖拽用到的事件有哪些？</h4><p>使用html的新特性dragable</p>\n<ul>\n<li>dragstart:拖拽开始时在被拖拽元素上触发此事件.<br>此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件</li>\n<li>dragover:拖拽时鼠标在目标元素上移动时触发.<br>此时监听器通过阻止浏览器默认行为设置元素为可拖放元素</li>\n<li>dragleave:拖拽时鼠标移出目标元素时在目标元素上触发<br>此时监听器可以取消掉前面设置的视觉效果.</li>\n<li>drag:拖拽期间在被拖拽元素上连续触发</li>\n<li>drop:鼠标在拖放目标上释放时,在拖放目标上触发.<br>此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.</li>\n<li><p>dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.<br>将元素从浏览器拖放到操作系统时不会触发此事件.</p>\n</li>\n<li><p>web</p>\n<h4 id=\"项目上线流程是怎样的？\"><a href=\"#项目上线流程是怎样的？\" class=\"headerlink\" title=\"项目上线流程是怎样的？\"></a>项目上线流程是怎样的？</h4></li>\n</ul>\n"},{"title":"jsTitle","_content":"promise.md\n#### promise\n\njsTitle\n#### 宏任务、微任务\n\n\n\n\n\n\n\n\n\n\n\n\n#### 用原生JS封装插件的方式有哪些？-156\n\n问题参考链接： https://github.com/haizlin/fe-interview/issues/1223\n\n#### HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\n\n#### 如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\n\n\n## window.load 和$(document).ready() 区别\n\n* 执行时间\n\nwindow.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n* 执行的次数不同\n\nwindow.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n$(document).ready()可以同时编写多个，并且都可以得到执行 \n\n* 简化写法 \n\nwindow.onload没有简化写法 \n\n$(document).ready(function(){})可以简写成$(function(){});","source":"_drafts/jsTitle.md","raw":"---\ntitle: jsTitle\ntags:\n---\npromise.md\n#### promise\n\njsTitle\n#### 宏任务、微任务\n\n\n\n\n\n\n\n\n\n\n\n\n#### 用原生JS封装插件的方式有哪些？-156\n\n问题参考链接： https://github.com/haizlin/fe-interview/issues/1223\n\n#### HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\n\n#### 如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\n\n\n## window.load 和$(document).ready() 区别\n\n* 执行时间\n\nwindow.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n* 执行的次数不同\n\nwindow.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n$(document).ready()可以同时编写多个，并且都可以得到执行 \n\n* 简化写法 \n\nwindow.onload没有简化写法 \n\n$(document).ready(function(){})可以简写成$(function(){});","slug":"jsTitle","published":0,"date":"2019-09-19T03:25:55.996Z","updated":"2019-09-19T12:25:29.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sg0002ygkchf96x831","content":"<p>promise.md</p>\n<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>jsTitle</p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><h4 id=\"用原生JS封装插件的方式有哪些？-156\"><a href=\"#用原生JS封装插件的方式有哪些？-156\" class=\"headerlink\" title=\"用原生JS封装插件的方式有哪些？-156\"></a>用原生JS封装插件的方式有哪些？-156</h4><p>问题参考链接： <a href=\"https://github.com/haizlin/fe-interview/issues/1223\" target=\"_blank\" rel=\"noopener\">https://github.com/haizlin/fe-interview/issues/1223</a></p>\n<h4 id=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"><a href=\"#HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\" class=\"headerlink\" title=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"></a>HTML5的video在有的移动端设备无法自动播放？怎么解决？-156</h4><h4 id=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"><a href=\"#如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\" class=\"headerlink\" title=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"></a>如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156</h4><h2 id=\"window-load-和-document-ready-区别\"><a href=\"#window-load-和-document-ready-区别\" class=\"headerlink\" title=\"window.load 和$(document).ready() 区别\"></a>window.load 和$(document).ready() 区别</h2><ul>\n<li>执行时间</li>\n</ul>\n<p>window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 </p>\n<p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</p>\n<ul>\n<li>执行的次数不同</li>\n</ul>\n<p>window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。</p>\n<p>$(document).ready()可以同时编写多个，并且都可以得到执行 </p>\n<ul>\n<li>简化写法 </li>\n</ul>\n<p>window.onload没有简化写法 </p>\n<p>$(document).ready(function(){})可以简写成$(function(){});</p>\n","site":{"data":{}},"excerpt":"","more":"<p>promise.md</p>\n<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>jsTitle</p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><h4 id=\"用原生JS封装插件的方式有哪些？-156\"><a href=\"#用原生JS封装插件的方式有哪些？-156\" class=\"headerlink\" title=\"用原生JS封装插件的方式有哪些？-156\"></a>用原生JS封装插件的方式有哪些？-156</h4><p>问题参考链接： <a href=\"https://github.com/haizlin/fe-interview/issues/1223\" target=\"_blank\" rel=\"noopener\">https://github.com/haizlin/fe-interview/issues/1223</a></p>\n<h4 id=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"><a href=\"#HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\" class=\"headerlink\" title=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"></a>HTML5的video在有的移动端设备无法自动播放？怎么解决？-156</h4><h4 id=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"><a href=\"#如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\" class=\"headerlink\" title=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"></a>如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156</h4><h2 id=\"window-load-和-document-ready-区别\"><a href=\"#window-load-和-document-ready-区别\" class=\"headerlink\" title=\"window.load 和$(document).ready() 区别\"></a>window.load 和$(document).ready() 区别</h2><ul>\n<li>执行时间</li>\n</ul>\n<p>window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 </p>\n<p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</p>\n<ul>\n<li>执行的次数不同</li>\n</ul>\n<p>window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。</p>\n<p>$(document).ready()可以同时编写多个，并且都可以得到执行 </p>\n<ul>\n<li>简化写法 </li>\n</ul>\n<p>window.onload没有简化写法 </p>\n<p>$(document).ready(function(){})可以简写成$(function(){});</p>\n"},{"title":"question","_content":"\n* `webTitle`: 浏览器解析过程?\n* `webTitle`: HTTP response报文结构是怎样的\n* `vueSourceCoding`:看一下这个https://www.cnblogs.com/zhuzhenwei918/p/9266407.html 百度搜索一下`vue serverPrefetch`& https://zhuanlan.zhihu.com/p/25936718\n\n####### 在jd的电脑提交代码到github上需要重定向密钥：\n\neval $(ssh-agent -s)\nssh-add ~/.ssh/lujing163\n\nhttps://ssr.vuejs.org/zh/\nhttps://cn.vuejs.org/v2/guide/ssr.html\n* 看一下process.env.NODE_ENV是怎么回事 https://www.jb51.net/article/126838.htm\n\n\n* mac:总结一下github中怎么发布的doc和myzone这两个项目\n* mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&发布组件到npm上\n\n* 看一下前端工程化（媛媛之前分享）\n* 了解骨架屏\n* 了解一下typeScript\n* 了解一下webpack\n* 了解一下node\n* 了解一下deep,样式穿透。\n* 了解一下github中的vue+express&写一下思路。\n\n\n\n\n","source":"_drafts/question.md","raw":"---\ntitle: question\ntags:\n---\n\n* `webTitle`: 浏览器解析过程?\n* `webTitle`: HTTP response报文结构是怎样的\n* `vueSourceCoding`:看一下这个https://www.cnblogs.com/zhuzhenwei918/p/9266407.html 百度搜索一下`vue serverPrefetch`& https://zhuanlan.zhihu.com/p/25936718\n\n####### 在jd的电脑提交代码到github上需要重定向密钥：\n\neval $(ssh-agent -s)\nssh-add ~/.ssh/lujing163\n\nhttps://ssr.vuejs.org/zh/\nhttps://cn.vuejs.org/v2/guide/ssr.html\n* 看一下process.env.NODE_ENV是怎么回事 https://www.jb51.net/article/126838.htm\n\n\n* mac:总结一下github中怎么发布的doc和myzone这两个项目\n* mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&发布组件到npm上\n\n* 看一下前端工程化（媛媛之前分享）\n* 了解骨架屏\n* 了解一下typeScript\n* 了解一下webpack\n* 了解一下node\n* 了解一下deep,样式穿透。\n* 了解一下github中的vue+express&写一下思路。\n\n\n\n\n","slug":"question","published":0,"date":"2019-09-02T03:19:14.668Z","updated":"2019-09-17T09:13:40.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sh0003ygkch665gybk","content":"<ul>\n<li><code>webTitle</code>: 浏览器解析过程?</li>\n<li><code>webTitle</code>: HTTP response报文结构是怎样的</li>\n<li><code>vueSourceCoding</code>:看一下这个<a href=\"https://www.cnblogs.com/zhuzhenwei918/p/9266407.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhuzhenwei918/p/9266407.html</a> 百度搜索一下<code>vue serverPrefetch</code>&amp; <a href=\"https://zhuanlan.zhihu.com/p/25936718\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25936718</a></li>\n</ul>\n<p>####### 在jd的电脑提交代码到github上需要重定向密钥：</p>\n<p>eval $(ssh-agent -s)<br>ssh-add ~/.ssh/lujing163</p>\n<p><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">https://ssr.vuejs.org/zh/</a><br><a href=\"https://cn.vuejs.org/v2/guide/ssr.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/ssr.html</a></p>\n<ul>\n<li>看一下process.env.NODE_ENV是怎么回事 <a href=\"https://www.jb51.net/article/126838.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/126838.htm</a></li>\n</ul>\n<ul>\n<li>mac:总结一下github中怎么发布的doc和myzone这两个项目</li>\n<li><p>mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&amp;发布组件到npm上</p>\n</li>\n<li><p>看一下前端工程化（媛媛之前分享）</p>\n</li>\n<li>了解骨架屏</li>\n<li>了解一下typeScript</li>\n<li>了解一下webpack</li>\n<li>了解一下node</li>\n<li>了解一下deep,样式穿透。</li>\n<li>了解一下github中的vue+express&amp;写一下思路。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><code>webTitle</code>: 浏览器解析过程?</li>\n<li><code>webTitle</code>: HTTP response报文结构是怎样的</li>\n<li><code>vueSourceCoding</code>:看一下这个<a href=\"https://www.cnblogs.com/zhuzhenwei918/p/9266407.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhuzhenwei918/p/9266407.html</a> 百度搜索一下<code>vue serverPrefetch</code>&amp; <a href=\"https://zhuanlan.zhihu.com/p/25936718\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25936718</a></li>\n</ul>\n<p>####### 在jd的电脑提交代码到github上需要重定向密钥：</p>\n<p>eval $(ssh-agent -s)<br>ssh-add ~/.ssh/lujing163</p>\n<p><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">https://ssr.vuejs.org/zh/</a><br><a href=\"https://cn.vuejs.org/v2/guide/ssr.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/ssr.html</a></p>\n<ul>\n<li>看一下process.env.NODE_ENV是怎么回事 <a href=\"https://www.jb51.net/article/126838.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/126838.htm</a></li>\n</ul>\n<ul>\n<li>mac:总结一下github中怎么发布的doc和myzone这两个项目</li>\n<li><p>mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&amp;发布组件到npm上</p>\n</li>\n<li><p>看一下前端工程化（媛媛之前分享）</p>\n</li>\n<li>了解骨架屏</li>\n<li>了解一下typeScript</li>\n<li>了解一下webpack</li>\n<li>了解一下node</li>\n<li>了解一下deep,样式穿透。</li>\n<li>了解一下github中的vue+express&amp;写一下思路。</li>\n</ul>\n"},{"title":"storybook","_content":"\n# 关于storyBook\n\n在现有的vue项目上 自动搭建 storybook\n\n```\n自动搭建\nnpx -p @storybook/cli sb init --type vue\n\n```\n\n### 调试\nnpm run storybook\n\n### 打包\nnpm run build-storybook","source":"_drafts/storybook.md","raw":"---\ntitle: storybook\ntags:\n---\n\n# 关于storyBook\n\n在现有的vue项目上 自动搭建 storybook\n\n```\n自动搭建\nnpx -p @storybook/cli sb init --type vue\n\n```\n\n### 调试\nnpm run storybook\n\n### 打包\nnpm run build-storybook","slug":"storybook","published":0,"date":"2019-09-17T06:16:52.961Z","updated":"2019-09-17T06:17:04.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sj0004ygkccjh21cu1","content":"<h1 id=\"关于storyBook\"><a href=\"#关于storyBook\" class=\"headerlink\" title=\"关于storyBook\"></a>关于storyBook</h1><p>在现有的vue项目上 自动搭建 storybook</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动搭建</span><br><span class=\"line\">npx -p @storybook/cli sb init --type vue</span><br></pre></td></tr></table></figure>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>npm run storybook</p>\n<h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><p>npm run build-storybook</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于storyBook\"><a href=\"#关于storyBook\" class=\"headerlink\" title=\"关于storyBook\"></a>关于storyBook</h1><p>在现有的vue项目上 自动搭建 storybook</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动搭建</span><br><span class=\"line\">npx -p @storybook/cli sb init --type vue</span><br></pre></td></tr></table></figure>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>npm run storybook</p>\n<h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><p>npm run build-storybook</p>\n"},{"title":"title","_content":"\n\n### 记录文章内容和文件名得对应关系。\n\n* blogInit.md -> 基于HEXO博客框架和Github搭建个人博客简单教程\n\n* cssTitle.md -> css相关面试题\n\n* hexoDeplayBug.md -> hexo deplay出错\n\n* JS-thread.md -> 从多线程到Event Loop全面梳理\n\n* message-comp.md -> 模拟element-ui写message组件思路\n\n* node.md -> node 基础知识\n\n* npmBuild.md -> npm 部署自己的组件库\n\n* promise.md -> Promise\n\n* request.md -> 关于前端请求的那些事\n\n* vueSourceCoding.md -> 了解vue源码\n\n* vueTitle.md -> vue相关面试题\n\n* webTitle.md -> 前端面试题整理\n\n* axios.md -> axios 封装\n\n* virtualDom.md -> 虚拟dom\n\n* ForwardReverseProxy.md -> 正向代理&反向代理\n\n* commitMessage.md -> Commit message 代码提交规范\n\n* express.md -> express： 实现本地代码+本地mock+环境接口数据","source":"_drafts/title.md","raw":"---\ntitle: title\ntags:\n---\n\n\n### 记录文章内容和文件名得对应关系。\n\n* blogInit.md -> 基于HEXO博客框架和Github搭建个人博客简单教程\n\n* cssTitle.md -> css相关面试题\n\n* hexoDeplayBug.md -> hexo deplay出错\n\n* JS-thread.md -> 从多线程到Event Loop全面梳理\n\n* message-comp.md -> 模拟element-ui写message组件思路\n\n* node.md -> node 基础知识\n\n* npmBuild.md -> npm 部署自己的组件库\n\n* promise.md -> Promise\n\n* request.md -> 关于前端请求的那些事\n\n* vueSourceCoding.md -> 了解vue源码\n\n* vueTitle.md -> vue相关面试题\n\n* webTitle.md -> 前端面试题整理\n\n* axios.md -> axios 封装\n\n* virtualDom.md -> 虚拟dom\n\n* ForwardReverseProxy.md -> 正向代理&反向代理\n\n* commitMessage.md -> Commit message 代码提交规范\n\n* express.md -> express： 实现本地代码+本地mock+环境接口数据","slug":"title","published":0,"date":"2019-09-19T11:23:13.428Z","updated":"2019-09-20T09:30:12.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sl0005ygkcvpsp0l3w","content":"<h3 id=\"记录文章内容和文件名得对应关系。\"><a href=\"#记录文章内容和文件名得对应关系。\" class=\"headerlink\" title=\"记录文章内容和文件名得对应关系。\"></a>记录文章内容和文件名得对应关系。</h3><ul>\n<li><p>blogInit.md -&gt; 基于HEXO博客框架和Github搭建个人博客简单教程</p>\n</li>\n<li><p>cssTitle.md -&gt; css相关面试题</p>\n</li>\n<li><p>hexoDeplayBug.md -&gt; hexo deplay出错</p>\n</li>\n<li><p>JS-thread.md -&gt; 从多线程到Event Loop全面梳理</p>\n</li>\n<li><p>message-comp.md -&gt; 模拟element-ui写message组件思路</p>\n</li>\n<li><p>node.md -&gt; node 基础知识</p>\n</li>\n<li><p>npmBuild.md -&gt; npm 部署自己的组件库</p>\n</li>\n<li><p>promise.md -&gt; Promise</p>\n</li>\n<li><p>request.md -&gt; 关于前端请求的那些事</p>\n</li>\n<li><p>vueSourceCoding.md -&gt; 了解vue源码</p>\n</li>\n<li><p>vueTitle.md -&gt; vue相关面试题</p>\n</li>\n<li><p>webTitle.md -&gt; 前端面试题整理</p>\n</li>\n<li><p>axios.md -&gt; axios 封装</p>\n</li>\n<li><p>virtualDom.md -&gt; 虚拟dom</p>\n</li>\n<li><p>ForwardReverseProxy.md -&gt; 正向代理&amp;反向代理</p>\n</li>\n<li><p>commitMessage.md -&gt; Commit message 代码提交规范</p>\n</li>\n<li><p>express.md -&gt; express： 实现本地代码+本地mock+环境接口数据</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"记录文章内容和文件名得对应关系。\"><a href=\"#记录文章内容和文件名得对应关系。\" class=\"headerlink\" title=\"记录文章内容和文件名得对应关系。\"></a>记录文章内容和文件名得对应关系。</h3><ul>\n<li><p>blogInit.md -&gt; 基于HEXO博客框架和Github搭建个人博客简单教程</p>\n</li>\n<li><p>cssTitle.md -&gt; css相关面试题</p>\n</li>\n<li><p>hexoDeplayBug.md -&gt; hexo deplay出错</p>\n</li>\n<li><p>JS-thread.md -&gt; 从多线程到Event Loop全面梳理</p>\n</li>\n<li><p>message-comp.md -&gt; 模拟element-ui写message组件思路</p>\n</li>\n<li><p>node.md -&gt; node 基础知识</p>\n</li>\n<li><p>npmBuild.md -&gt; npm 部署自己的组件库</p>\n</li>\n<li><p>promise.md -&gt; Promise</p>\n</li>\n<li><p>request.md -&gt; 关于前端请求的那些事</p>\n</li>\n<li><p>vueSourceCoding.md -&gt; 了解vue源码</p>\n</li>\n<li><p>vueTitle.md -&gt; vue相关面试题</p>\n</li>\n<li><p>webTitle.md -&gt; 前端面试题整理</p>\n</li>\n<li><p>axios.md -&gt; axios 封装</p>\n</li>\n<li><p>virtualDom.md -&gt; 虚拟dom</p>\n</li>\n<li><p>ForwardReverseProxy.md -&gt; 正向代理&amp;反向代理</p>\n</li>\n<li><p>commitMessage.md -&gt; Commit message 代码提交规范</p>\n</li>\n<li><p>express.md -&gt; express： 实现本地代码+本地mock+环境接口数据</p>\n</li>\n</ul>\n"},{"title":"vueCli3-proxy","_content":"\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n\n##本地代理\n在根目录下新建一个vue.config.js文件\n\n\n```\nconst proxy_url = 'http://baidu.com';\nconst renewal_url = 'http://renewal-baidu.com';\n\nmodule.exports = {\n  productionSourceMap: false, //防止源码泄露\n  devServer: {\n    proxy: {\n      '/ccs-api': {\n        target: proxy_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/ccs-api': '' //需要rewrite的,\n        }\n      },\n      '/renewal': {\n        target: renewal_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/renewal': renewal_url //需要rewrite的,\n        }\n      }\n    }\n  }\n  \n}\n```\n\nForward Proxy; Reverse Proxy ","source":"_drafts/vueCli3-proxy.md","raw":"---\ntitle: vueCli3-proxy\ntags: proxy\n---\n\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n\n##本地代理\n在根目录下新建一个vue.config.js文件\n\n\n```\nconst proxy_url = 'http://baidu.com';\nconst renewal_url = 'http://renewal-baidu.com';\n\nmodule.exports = {\n  productionSourceMap: false, //防止源码泄露\n  devServer: {\n    proxy: {\n      '/ccs-api': {\n        target: proxy_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/ccs-api': '' //需要rewrite的,\n        }\n      },\n      '/renewal': {\n        target: renewal_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/renewal': renewal_url //需要rewrite的,\n        }\n      }\n    }\n  }\n  \n}\n```\n\nForward Proxy; Reverse Proxy ","slug":"vueCli3-proxy","published":0,"date":"2019-09-05T07:15:14.255Z","updated":"2019-09-05T07:26:22.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sm0006ygkcey9a8k1l","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>##本地代理<br>在根目录下新建一个vue.config.js文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const proxy_url = &apos;http://baidu.com&apos;;</span><br><span class=\"line\">const renewal_url = &apos;http://renewal-baidu.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  productionSourceMap: false, //防止源码泄露</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &apos;/ccs-api&apos;: &#123;</span><br><span class=\"line\">        target: proxy_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/ccs-api&apos;: &apos;&apos; //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &apos;/renewal&apos;: &#123;</span><br><span class=\"line\">        target: renewal_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/renewal&apos;: renewal_url //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Forward Proxy; Reverse Proxy </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>##本地代理<br>在根目录下新建一个vue.config.js文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const proxy_url = &apos;http://baidu.com&apos;;</span><br><span class=\"line\">const renewal_url = &apos;http://renewal-baidu.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  productionSourceMap: false, //防止源码泄露</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &apos;/ccs-api&apos;: &#123;</span><br><span class=\"line\">        target: proxy_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/ccs-api&apos;: &apos;&apos; //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &apos;/renewal&apos;: &#123;</span><br><span class=\"line\">        target: renewal_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/renewal&apos;: renewal_url //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Forward Proxy; Reverse Proxy </p>\n"},{"title":"vueSourceCoding","_content":"\n「从源码中学习」面试官都不知道的Vue题目答案\n\nhttps://juejin.im/post/5c959f74f265da610c068fa8","source":"_drafts/vueSourceCoding.md","raw":"---\ntitle: vueSourceCoding\ntags:\n---\n\n「从源码中学习」面试官都不知道的Vue题目答案\n\nhttps://juejin.im/post/5c959f74f265da610c068fa8","slug":"vueSourceCoding","published":0,"date":"2019-09-02T12:40:36.689Z","updated":"2019-09-03T01:47:27.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sp0007ygkcclywbk0c","content":"<p>「从源码中学习」面试官都不知道的Vue题目答案</p>\n<p><a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>「从源码中学习」面试官都不知道的Vue题目答案</p>\n<p><a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a></p>\n"},{"title":"正向代理&反向代理","date":"2019-09-20T03:12:13.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 11:12:13\n\n## ForwardProxy\n\n正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。\n\n\n```\n这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。\n\n有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。\n\n```\n\n![ForwardProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 正向代理，其实是\"代理服务器\"代理了\"客户端\"，去和\"目标服务器\"进行交互。\n#### 用途：\n* 突破访问限制 \n  通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。\n* 提高访问速度\n  通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。\n* 隐藏客户端真实IP\n  上网者也可以通过这种方法隐藏自己的IP，免受攻击。\n\n## ReverseProxy\n\n反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\n```\n对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。\n\n```\n\n![ReverseProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 反向代理，其实是\"代理服务器\"代理了\"目标服务器\"，去和\"客户端\"进行交互。\n#### 用途：\n* 负载均衡 \n  反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。\n* 提高访问速度\n  反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。\n* 隐藏客户端真实IP\n  使用反向代理，可以对客户端隐藏服务器的IP地址。\n* 提供安全保障\n  反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等\n","source":"_posts/ForwardReverseProxy.md","raw":"---\ntitle: 正向代理&反向代理\ndate: 2019-09-20 11:12:13\ntags: web\n---\n\nAuthor: Echo\nTime: 2019-09-20 11:12:13\n\n## ForwardProxy\n\n正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。\n\n\n```\n这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。\n\n有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。\n\n```\n\n![ForwardProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 正向代理，其实是\"代理服务器\"代理了\"客户端\"，去和\"目标服务器\"进行交互。\n#### 用途：\n* 突破访问限制 \n  通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。\n* 提高访问速度\n  通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。\n* 隐藏客户端真实IP\n  上网者也可以通过这种方法隐藏自己的IP，免受攻击。\n\n## ReverseProxy\n\n反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\n```\n对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。\n\n```\n\n![ReverseProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 反向代理，其实是\"代理服务器\"代理了\"目标服务器\"，去和\"客户端\"进行交互。\n#### 用途：\n* 负载均衡 \n  反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。\n* 提高访问速度\n  反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。\n* 隐藏客户端真实IP\n  使用反向代理，可以对客户端隐藏服务器的IP地址。\n* 提供安全保障\n  反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等\n","slug":"ForwardReverseProxy","published":1,"updated":"2019-09-20T03:19:43.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4ss0009ygkc7npcpglu","content":"<p>Author: Echo<br>Time: 2019-09-20 11:12:13</p>\n<h2 id=\"ForwardProxy\"><a href=\"#ForwardProxy\" class=\"headerlink\" title=\"ForwardProxy\"></a>ForwardProxy</h2><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。</span><br><span class=\"line\"></span><br><span class=\"line\">有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ForwardProxy\"></p>\n<h6 id=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"><a href=\"#正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\" class=\"headerlink\" title=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"></a>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。</h6><h4 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>突破访问限制<br>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</li>\n<li>提高访问速度<br>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>\n<li>隐藏客户端真实IP<br>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li>\n</ul>\n<h2 id=\"ReverseProxy\"><a href=\"#ReverseProxy\" class=\"headerlink\" title=\"ReverseProxy\"></a>ReverseProxy</h2><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ReverseProxy\"></p>\n<h6 id=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"><a href=\"#反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\" class=\"headerlink\" title=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"></a>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。</h6><h4 id=\"用途：-1\"><a href=\"#用途：-1\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>负载均衡<br>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</li>\n<li>提高访问速度<br>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li>\n<li>隐藏客户端真实IP<br>使用反向代理，可以对客户端隐藏服务器的IP地址。</li>\n<li>提供安全保障<br>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 11:12:13</p>\n<h2 id=\"ForwardProxy\"><a href=\"#ForwardProxy\" class=\"headerlink\" title=\"ForwardProxy\"></a>ForwardProxy</h2><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。</span><br><span class=\"line\"></span><br><span class=\"line\">有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ForwardProxy\"></p>\n<h6 id=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"><a href=\"#正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\" class=\"headerlink\" title=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"></a>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。</h6><h4 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>突破访问限制<br>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</li>\n<li>提高访问速度<br>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>\n<li>隐藏客户端真实IP<br>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li>\n</ul>\n<h2 id=\"ReverseProxy\"><a href=\"#ReverseProxy\" class=\"headerlink\" title=\"ReverseProxy\"></a>ReverseProxy</h2><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ReverseProxy\"></p>\n<h6 id=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"><a href=\"#反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\" class=\"headerlink\" title=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"></a>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。</h6><h4 id=\"用途：-1\"><a href=\"#用途：-1\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>负载均衡<br>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</li>\n<li>提高访问速度<br>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li>\n<li>隐藏客户端真实IP<br>使用反向代理，可以对客户端隐藏服务器的IP地址。</li>\n<li>提供安全保障<br>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</li>\n</ul>\n"},{"title":"基于HEXO博客框架和Github搭建个人博客简单教程","date":"2019-07-24T06:44:05.000Z","_content":"\nAuthor: Echo\nTime: 2019-07-24 14:44:23\n\n### 准备工作\n配置环境\n\n* 安装Node.js\n* 安装Git\n* 注册GitHub\n\n# Hexo 部分\n### Hexo简介\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n### Hexo安装方法\n参考官网中文文档,只需要一条命令即可自动安装hexo框架。\n```\n$ npm install -g hexo-cli #使用 npm 安装 Hexo\n```\n\n* 初始化\n创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：\n```\nhexo init\n```\n* 生成静态页面\n继续再Blog目录下执行如下命令，生成静态页面\n```\nhexo generate （或者 hexo g）\n```\n\n* 本地启动\n启动本地服务，进行文章预览调试，命令：\n```\nhexo server\n```\n\n* 本地测试\n\n浏览器输入 http://localhost:4000\n\n# Github 部分\n* 注册github\n* 新建仓库\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!\n* 本地_config.yml文配置件，建立关联\n我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)\n```\ndeploy:  \n   type: git   \n   repository: https://github.com/leopardpan/  leopardpan.github.io.git  \n   branch: master\n```\n# 部署\n执行如下命令才能使用git部署\n```\nnpm install hexo-deployer-git --save\n```\n(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)\n执行配置命令：\n```\nhexo deploy\n```\n然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了\n\n发文章\n每次部署的步骤，可按以下三步来进行。\n```\nhexo clean  \nhexo generate  \nhexo deploy\n```\n一些常用命令：\n```\nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成静态页面至public目录  \nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）  \nhexo deploy #将.deploy目录部署到GitHub  \nhexo help  #查看帮助  \nhexo version  #查看Hexo的版本\n```\n参考：\n\nhttp://www.jianshu.com/p/465830080ea9\nhttp://www.chinaz.com/web/2016/0105/491998.shtml","source":"_posts/blogInit.md","raw":"---\ntitle: 基于HEXO博客框架和Github搭建个人博客简单教程\ndate: 2019-07-24 14:44:05\ntags: blog-hexo\n---\n\nAuthor: Echo\nTime: 2019-07-24 14:44:23\n\n### 准备工作\n配置环境\n\n* 安装Node.js\n* 安装Git\n* 注册GitHub\n\n# Hexo 部分\n### Hexo简介\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n### Hexo安装方法\n参考官网中文文档,只需要一条命令即可自动安装hexo框架。\n```\n$ npm install -g hexo-cli #使用 npm 安装 Hexo\n```\n\n* 初始化\n创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：\n```\nhexo init\n```\n* 生成静态页面\n继续再Blog目录下执行如下命令，生成静态页面\n```\nhexo generate （或者 hexo g）\n```\n\n* 本地启动\n启动本地服务，进行文章预览调试，命令：\n```\nhexo server\n```\n\n* 本地测试\n\n浏览器输入 http://localhost:4000\n\n# Github 部分\n* 注册github\n* 新建仓库\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!\n* 本地_config.yml文配置件，建立关联\n我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)\n```\ndeploy:  \n   type: git   \n   repository: https://github.com/leopardpan/  leopardpan.github.io.git  \n   branch: master\n```\n# 部署\n执行如下命令才能使用git部署\n```\nnpm install hexo-deployer-git --save\n```\n(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)\n执行配置命令：\n```\nhexo deploy\n```\n然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了\n\n发文章\n每次部署的步骤，可按以下三步来进行。\n```\nhexo clean  \nhexo generate  \nhexo deploy\n```\n一些常用命令：\n```\nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成静态页面至public目录  \nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）  \nhexo deploy #将.deploy目录部署到GitHub  \nhexo help  #查看帮助  \nhexo version  #查看Hexo的版本\n```\n参考：\n\nhttp://www.jianshu.com/p/465830080ea9\nhttp://www.chinaz.com/web/2016/0105/491998.shtml","slug":"blogInit","published":1,"updated":"2019-09-19T11:25:32.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4su000aygkcqv0y3wr6","content":"<p>Author: Echo<br>Time: 2019-07-24 14:44:23</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>配置环境</p>\n<ul>\n<li>安装Node.js</li>\n<li>安装Git</li>\n<li>注册GitHub</li>\n</ul>\n<h1 id=\"Hexo-部分\"><a href=\"#Hexo-部分\" class=\"headerlink\" title=\"Hexo 部分\"></a>Hexo 部分</h1><h3 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h3><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。<br>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<h3 id=\"Hexo安装方法\"><a href=\"#Hexo安装方法\" class=\"headerlink\" title=\"Hexo安装方法\"></a>Hexo安装方法</h3><p>参考官网中文文档,只需要一条命令即可自动安装hexo框架。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli #使用 npm 安装 Hexo</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>初始化<br>创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态页面<br>继续再Blog目录下执行如下命令，生成静态页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate （或者 hexo g）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地启动<br>启动本地服务，进行文章预览调试，命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地测试</p>\n</li>\n</ul>\n<p>浏览器输入 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<h1 id=\"Github-部分\"><a href=\"#Github-部分\" class=\"headerlink\" title=\"Github 部分\"></a>Github 部分</h1><ul>\n<li>注册github</li>\n<li>新建仓库<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!</li>\n<li>本地_config.yml文配置件，建立关联<br>我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">   type: git   </span><br><span class=\"line\">   repository: https://github.com/leopardpan/  leopardpan.github.io.git  </span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>执行如下命令才能使用git部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)<br>执行配置命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>然后再浏览器中输入<a href=\"http://username.github.io/就行了，把\" target=\"_blank\" rel=\"noopener\">http://username.github.io/就行了，把</a> username ,改成你 github 的账户名就行了</p>\n<p>发文章<br>每次部署的步骤，可按以下三步来进行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  </span><br><span class=\"line\">hexo generate  </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>一些常用命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章  </span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </span><br><span class=\"line\">hexo generate #生成静态页面至public目录  </span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）  </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub  </span><br><span class=\"line\">hexo help  #查看帮助  </span><br><span class=\"line\">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure></p>\n<p>参考：</p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/465830080ea9</a><br><a href=\"http://www.chinaz.com/web/2016/0105/491998.shtml\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/web/2016/0105/491998.shtml</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 14:44:23</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>配置环境</p>\n<ul>\n<li>安装Node.js</li>\n<li>安装Git</li>\n<li>注册GitHub</li>\n</ul>\n<h1 id=\"Hexo-部分\"><a href=\"#Hexo-部分\" class=\"headerlink\" title=\"Hexo 部分\"></a>Hexo 部分</h1><h3 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h3><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。<br>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<h3 id=\"Hexo安装方法\"><a href=\"#Hexo安装方法\" class=\"headerlink\" title=\"Hexo安装方法\"></a>Hexo安装方法</h3><p>参考官网中文文档,只需要一条命令即可自动安装hexo框架。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli #使用 npm 安装 Hexo</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>初始化<br>创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态页面<br>继续再Blog目录下执行如下命令，生成静态页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate （或者 hexo g）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地启动<br>启动本地服务，进行文章预览调试，命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地测试</p>\n</li>\n</ul>\n<p>浏览器输入 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<h1 id=\"Github-部分\"><a href=\"#Github-部分\" class=\"headerlink\" title=\"Github 部分\"></a>Github 部分</h1><ul>\n<li>注册github</li>\n<li>新建仓库<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!</li>\n<li>本地_config.yml文配置件，建立关联<br>我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">   type: git   </span><br><span class=\"line\">   repository: https://github.com/leopardpan/  leopardpan.github.io.git  </span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>执行如下命令才能使用git部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)<br>执行配置命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>然后再浏览器中输入<a href=\"http://username.github.io/就行了，把\" target=\"_blank\" rel=\"noopener\">http://username.github.io/就行了，把</a> username ,改成你 github 的账户名就行了</p>\n<p>发文章<br>每次部署的步骤，可按以下三步来进行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  </span><br><span class=\"line\">hexo generate  </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>一些常用命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章  </span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </span><br><span class=\"line\">hexo generate #生成静态页面至public目录  </span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）  </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub  </span><br><span class=\"line\">hexo help  #查看帮助  </span><br><span class=\"line\">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure></p>\n<p>参考：</p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/465830080ea9</a><br><a href=\"http://www.chinaz.com/web/2016/0105/491998.shtml\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/web/2016/0105/491998.shtml</a></p>\n"},{"title":"Commit message 代码提交规范","date":"2019-09-20T07:52:39.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 15:52:39\n\n#### 前言\n\n在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。\n\n##### Commit message 的作用\n* 提供更多的历史信息，方便快速浏览\n* 过滤某些commit（比如文档改动），便于快速查找信息\n* 直接从commit生成Change log\n* 可读性好，清晰，不必深入看代码即可了解当前commit的作用。\n* 为 Code Reviewing（代码审查）做准备\n* 方便跟踪工程历史\n* 提高项目的整体质量，提高个人工程素质\n\n##### Commit message 的格式\n\nCommit message 包括三个部分：Header，Body 和 Footer\n\n###### 一、Header\n`\nHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）\n`\n\n* type\n\n type用于说明 commit 的类别，只允许使用下面的标识\n\n    feat：新增功能（feature）\n    fix：修补bug\n    docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等\n    style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑\n    refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    test：增加测试，包括单元测试、集成测试等\n    chore：构建过程或辅助工具的变动\n    type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。\n    perf: 优化相关，比如提升性能、体验\n    revert: 回滚到上一个版本\n    ci：自动化流程配置修改\n注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中\n\n* scope\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。\n\n* subject\n\n①subject是 commit 目的的简短描述，不超过50个字符。\n②以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n③第一个字母小写\n④结尾不加句号（.）\n\n###### 一、Body\n\n`\nBody 部分是对本次 commit 的详细描述，可以分成多行\n`\n\n###### 三、Footer\nFooter 部分只用于两种情况：\n* 不兼容变动\n如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法\n* 关闭 Issue\n\n```\n如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue\n\nCloses #234\n\n也可以一次关闭多个 issue\n\nCloses #123, #245, #992\n```\n\n#### 全局安装\n```\n$ npm install -g commitizen\n```\n#### 项目中安装\n\n```\n$ commitizen init cz-conventional-changelog --save --save-exact\n```\n注意：如果是第二次配置，需要用–force：\n```\n$ commitizen init cz-conventional-changelog --save --force\n```\n\n#### 将未暂存文件所有变化提交到暂存区\n\n```\n$ git add .\n```\n\n① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。\n\n②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add --update的缩写）。add -u 不会提交新文件。\n\n③git add -a ：是上面两个功能的合集（git add --all的缩写）\n\n#### 命令行输入提交命令\n```\n$ git cz\n```\n输入命令后依次提示：\n```\n1. 上、下键选择要提交的更改类型\n\n2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)\n\n3. 写一个简短的祈使句来描述这个变化\n\n4. 提供更详细的更改说明:(按回车键跳过)\n\n5. 有什么重大变化吗?\n\n6. 这一变化是否会影响\n任何未解决的问题?\n```\n#### 再推送到本地git仓库\n\n```\n$ git push\n```\n\n#### 打印日志命令\n```\n$ git log\n```\n#### 输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\n\n* 安装生成 Change log 的工具\n\n```\n$ npm install -g conventional-changelog-cli\n```\n* 通过提交记录生成 CHANGELOG.md\n\n```\n$ conventional-changelog -p -i CHANGELOG.md -s\n```\n#### 打印出 git log 的日志记录（详细日志记录）\n\n```\n$ git log > 文件名\n```\n\n参考链接： https://segmentfault.com/a/1190000019579621","source":"_posts/commitMessage.md","raw":"---\ntitle: Commit message 代码提交规范\ndate: 2019-09-20 15:52:39\ntags: git\n---\n\nAuthor: Echo\nTime: 2019-09-20 15:52:39\n\n#### 前言\n\n在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。\n\n##### Commit message 的作用\n* 提供更多的历史信息，方便快速浏览\n* 过滤某些commit（比如文档改动），便于快速查找信息\n* 直接从commit生成Change log\n* 可读性好，清晰，不必深入看代码即可了解当前commit的作用。\n* 为 Code Reviewing（代码审查）做准备\n* 方便跟踪工程历史\n* 提高项目的整体质量，提高个人工程素质\n\n##### Commit message 的格式\n\nCommit message 包括三个部分：Header，Body 和 Footer\n\n###### 一、Header\n`\nHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）\n`\n\n* type\n\n type用于说明 commit 的类别，只允许使用下面的标识\n\n    feat：新增功能（feature）\n    fix：修补bug\n    docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等\n    style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑\n    refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    test：增加测试，包括单元测试、集成测试等\n    chore：构建过程或辅助工具的变动\n    type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。\n    perf: 优化相关，比如提升性能、体验\n    revert: 回滚到上一个版本\n    ci：自动化流程配置修改\n注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中\n\n* scope\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。\n\n* subject\n\n①subject是 commit 目的的简短描述，不超过50个字符。\n②以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n③第一个字母小写\n④结尾不加句号（.）\n\n###### 一、Body\n\n`\nBody 部分是对本次 commit 的详细描述，可以分成多行\n`\n\n###### 三、Footer\nFooter 部分只用于两种情况：\n* 不兼容变动\n如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法\n* 关闭 Issue\n\n```\n如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue\n\nCloses #234\n\n也可以一次关闭多个 issue\n\nCloses #123, #245, #992\n```\n\n#### 全局安装\n```\n$ npm install -g commitizen\n```\n#### 项目中安装\n\n```\n$ commitizen init cz-conventional-changelog --save --save-exact\n```\n注意：如果是第二次配置，需要用–force：\n```\n$ commitizen init cz-conventional-changelog --save --force\n```\n\n#### 将未暂存文件所有变化提交到暂存区\n\n```\n$ git add .\n```\n\n① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。\n\n②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add --update的缩写）。add -u 不会提交新文件。\n\n③git add -a ：是上面两个功能的合集（git add --all的缩写）\n\n#### 命令行输入提交命令\n```\n$ git cz\n```\n输入命令后依次提示：\n```\n1. 上、下键选择要提交的更改类型\n\n2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)\n\n3. 写一个简短的祈使句来描述这个变化\n\n4. 提供更详细的更改说明:(按回车键跳过)\n\n5. 有什么重大变化吗?\n\n6. 这一变化是否会影响\n任何未解决的问题?\n```\n#### 再推送到本地git仓库\n\n```\n$ git push\n```\n\n#### 打印日志命令\n```\n$ git log\n```\n#### 输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\n\n* 安装生成 Change log 的工具\n\n```\n$ npm install -g conventional-changelog-cli\n```\n* 通过提交记录生成 CHANGELOG.md\n\n```\n$ conventional-changelog -p -i CHANGELOG.md -s\n```\n#### 打印出 git log 的日志记录（详细日志记录）\n\n```\n$ git log > 文件名\n```\n\n参考链接： https://segmentfault.com/a/1190000019579621","slug":"commitMessage","published":1,"updated":"2019-09-20T07:55:18.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sv000bygkcw8b8l1xd","content":"<p>Author: Echo<br>Time: 2019-09-20 15:52:39</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。</p>\n<h5 id=\"Commit-message-的作用\"><a href=\"#Commit-message-的作用\" class=\"headerlink\" title=\"Commit message 的作用\"></a>Commit message 的作用</h5><ul>\n<li>提供更多的历史信息，方便快速浏览</li>\n<li>过滤某些commit（比如文档改动），便于快速查找信息</li>\n<li>直接从commit生成Change log</li>\n<li>可读性好，清晰，不必深入看代码即可了解当前commit的作用。</li>\n<li>为 Code Reviewing（代码审查）做准备</li>\n<li>方便跟踪工程历史</li>\n<li>提高项目的整体质量，提高个人工程素质</li>\n</ul>\n<h5 id=\"Commit-message-的格式\"><a href=\"#Commit-message-的格式\" class=\"headerlink\" title=\"Commit message 的格式\"></a>Commit message 的格式</h5><p>Commit message 包括三个部分：Header，Body 和 Footer</p>\n<h6 id=\"一、Header\"><a href=\"#一、Header\" class=\"headerlink\" title=\"一、Header\"></a>一、Header</h6><p><code>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）</code></p>\n<ul>\n<li><p>type</p>\n<p>type用于说明 commit 的类别，只允许使用下面的标识</p>\n<p>  feat：新增功能（feature）<br>  fix：修补bug<br>  docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等<br>  style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑<br>  refactor：重构（即不是新增功能，也不是修改bug的代码变动）<br>  test：增加测试，包括单元测试、集成测试等<br>  chore：构建过程或辅助工具的变动<br>  type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。<br>  perf: 优化相关，比如提升性能、体验<br>  revert: 回滚到上一个版本<br>  ci：自动化流程配置修改<br>注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中</p>\n</li>\n<li><p>scope</p>\n</li>\n</ul>\n<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。</p>\n<ul>\n<li>subject</li>\n</ul>\n<p>①subject是 commit 目的的简短描述，不超过50个字符。<br>②以动词开头，使用第一人称现在时，比如change，而不是changed或changes<br>③第一个字母小写<br>④结尾不加句号（.）</p>\n<h6 id=\"一、Body\"><a href=\"#一、Body\" class=\"headerlink\" title=\"一、Body\"></a>一、Body</h6><p><code>Body 部分是对本次 commit 的详细描述，可以分成多行</code></p>\n<h6 id=\"三、Footer\"><a href=\"#三、Footer\" class=\"headerlink\" title=\"三、Footer\"></a>三、Footer</h6><p>Footer 部分只用于两种情况：</p>\n<ul>\n<li>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法</li>\n<li>关闭 Issue</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #234</span><br><span class=\"line\"></span><br><span class=\"line\">也可以一次关闭多个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #123, #245, #992</span><br></pre></td></tr></table></figure>\n<h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g commitizen</span><br></pre></td></tr></table></figure>\n<h4 id=\"项目中安装\"><a href=\"#项目中安装\" class=\"headerlink\" title=\"项目中安装\"></a>项目中安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>\n<p>注意：如果是第二次配置，需要用–force：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --force</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"将未暂存文件所有变化提交到暂存区\"><a href=\"#将未暂存文件所有变化提交到暂存区\" class=\"headerlink\" title=\"将未暂存文件所有变化提交到暂存区\"></a>将未暂存文件所有变化提交到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<p>① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p>\n<p>②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add –update的缩写）。add -u 不会提交新文件。</p>\n<p>③git add -a ：是上面两个功能的合集（git add –all的缩写）</p>\n<h4 id=\"命令行输入提交命令\"><a href=\"#命令行输入提交命令\" class=\"headerlink\" title=\"命令行输入提交命令\"></a>命令行输入提交命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git cz</span><br></pre></td></tr></table></figure>\n<p>输入命令后依次提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 上、下键选择要提交的更改类型</span><br><span class=\"line\"></span><br><span class=\"line\">2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">3. 写一个简短的祈使句来描述这个变化</span><br><span class=\"line\"></span><br><span class=\"line\">4. 提供更详细的更改说明:(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">5. 有什么重大变化吗?</span><br><span class=\"line\"></span><br><span class=\"line\">6. 这一变化是否会影响</span><br><span class=\"line\">任何未解决的问题?</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"再推送到本地git仓库\"><a href=\"#再推送到本地git仓库\" class=\"headerlink\" title=\"再推送到本地git仓库\"></a>再推送到本地git仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印日志命令\"><a href=\"#打印日志命令\" class=\"headerlink\" title=\"打印日志命令\"></a>打印日志命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\"><a href=\"#输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\" class=\"headerlink\" title=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\"></a>输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件</h4><ul>\n<li>安装生成 Change log 的工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过提交记录生成 CHANGELOG.md</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ conventional-changelog -p -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印出-git-log-的日志记录（详细日志记录）\"><a href=\"#打印出-git-log-的日志记录（详细日志记录）\" class=\"headerlink\" title=\"打印出 git log 的日志记录（详细日志记录）\"></a>打印出 git log 的日志记录（详细日志记录）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log &gt; 文件名</span><br></pre></td></tr></table></figure>\n<p>参考链接： <a href=\"https://segmentfault.com/a/1190000019579621\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000019579621</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 15:52:39</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。</p>\n<h5 id=\"Commit-message-的作用\"><a href=\"#Commit-message-的作用\" class=\"headerlink\" title=\"Commit message 的作用\"></a>Commit message 的作用</h5><ul>\n<li>提供更多的历史信息，方便快速浏览</li>\n<li>过滤某些commit（比如文档改动），便于快速查找信息</li>\n<li>直接从commit生成Change log</li>\n<li>可读性好，清晰，不必深入看代码即可了解当前commit的作用。</li>\n<li>为 Code Reviewing（代码审查）做准备</li>\n<li>方便跟踪工程历史</li>\n<li>提高项目的整体质量，提高个人工程素质</li>\n</ul>\n<h5 id=\"Commit-message-的格式\"><a href=\"#Commit-message-的格式\" class=\"headerlink\" title=\"Commit message 的格式\"></a>Commit message 的格式</h5><p>Commit message 包括三个部分：Header，Body 和 Footer</p>\n<h6 id=\"一、Header\"><a href=\"#一、Header\" class=\"headerlink\" title=\"一、Header\"></a>一、Header</h6><p><code>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）</code></p>\n<ul>\n<li><p>type</p>\n<p>type用于说明 commit 的类别，只允许使用下面的标识</p>\n<p>  feat：新增功能（feature）<br>  fix：修补bug<br>  docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等<br>  style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑<br>  refactor：重构（即不是新增功能，也不是修改bug的代码变动）<br>  test：增加测试，包括单元测试、集成测试等<br>  chore：构建过程或辅助工具的变动<br>  type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。<br>  perf: 优化相关，比如提升性能、体验<br>  revert: 回滚到上一个版本<br>  ci：自动化流程配置修改<br>注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中</p>\n</li>\n<li><p>scope</p>\n</li>\n</ul>\n<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。</p>\n<ul>\n<li>subject</li>\n</ul>\n<p>①subject是 commit 目的的简短描述，不超过50个字符。<br>②以动词开头，使用第一人称现在时，比如change，而不是changed或changes<br>③第一个字母小写<br>④结尾不加句号（.）</p>\n<h6 id=\"一、Body\"><a href=\"#一、Body\" class=\"headerlink\" title=\"一、Body\"></a>一、Body</h6><p><code>Body 部分是对本次 commit 的详细描述，可以分成多行</code></p>\n<h6 id=\"三、Footer\"><a href=\"#三、Footer\" class=\"headerlink\" title=\"三、Footer\"></a>三、Footer</h6><p>Footer 部分只用于两种情况：</p>\n<ul>\n<li>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法</li>\n<li>关闭 Issue</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #234</span><br><span class=\"line\"></span><br><span class=\"line\">也可以一次关闭多个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #123, #245, #992</span><br></pre></td></tr></table></figure>\n<h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g commitizen</span><br></pre></td></tr></table></figure>\n<h4 id=\"项目中安装\"><a href=\"#项目中安装\" class=\"headerlink\" title=\"项目中安装\"></a>项目中安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>\n<p>注意：如果是第二次配置，需要用–force：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --force</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"将未暂存文件所有变化提交到暂存区\"><a href=\"#将未暂存文件所有变化提交到暂存区\" class=\"headerlink\" title=\"将未暂存文件所有变化提交到暂存区\"></a>将未暂存文件所有变化提交到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<p>① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p>\n<p>②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add –update的缩写）。add -u 不会提交新文件。</p>\n<p>③git add -a ：是上面两个功能的合集（git add –all的缩写）</p>\n<h4 id=\"命令行输入提交命令\"><a href=\"#命令行输入提交命令\" class=\"headerlink\" title=\"命令行输入提交命令\"></a>命令行输入提交命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git cz</span><br></pre></td></tr></table></figure>\n<p>输入命令后依次提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 上、下键选择要提交的更改类型</span><br><span class=\"line\"></span><br><span class=\"line\">2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">3. 写一个简短的祈使句来描述这个变化</span><br><span class=\"line\"></span><br><span class=\"line\">4. 提供更详细的更改说明:(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">5. 有什么重大变化吗?</span><br><span class=\"line\"></span><br><span class=\"line\">6. 这一变化是否会影响</span><br><span class=\"line\">任何未解决的问题?</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"再推送到本地git仓库\"><a href=\"#再推送到本地git仓库\" class=\"headerlink\" title=\"再推送到本地git仓库\"></a>再推送到本地git仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印日志命令\"><a href=\"#打印日志命令\" class=\"headerlink\" title=\"打印日志命令\"></a>打印日志命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\"><a href=\"#输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\" class=\"headerlink\" title=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\"></a>输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件</h4><ul>\n<li>安装生成 Change log 的工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过提交记录生成 CHANGELOG.md</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ conventional-changelog -p -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印出-git-log-的日志记录（详细日志记录）\"><a href=\"#打印出-git-log-的日志记录（详细日志记录）\" class=\"headerlink\" title=\"打印出 git log 的日志记录（详细日志记录）\"></a>打印出 git log 的日志记录（详细日志记录）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log &gt; 文件名</span><br></pre></td></tr></table></figure>\n<p>参考链接： <a href=\"https://segmentfault.com/a/1190000019579621\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000019579621</a></p>\n"},{"title":"前端css相关面试题汇总","date":"2019-09-19T12:53:19.000Z","_content":"\n##### 什么是 BFC机制\n##### CSS3中新增的选择器以及属性\n##### 居中布局\n##### 清除浮动有哪些方法, 各有什么优缺点\n##### 用纯CSS创建一个三角形的原理是什么\n##### 实现三栏布局有哪些方法, 分别描述一下\n##### css3实现0.5px的细线\n##### link 与 @import 的区别\n##### 开发中为什么要初始化css样式\n\n答案参考链接：https://lujinggirl.github.io/2019/09/19/cssTitle/\n\n\n\n","source":"_posts/css.md","raw":"---\ntitle: 前端css相关面试题汇总\ndate: 2019-09-19 20:53:19\ntags: 前端面试题\n---\n\n##### 什么是 BFC机制\n##### CSS3中新增的选择器以及属性\n##### 居中布局\n##### 清除浮动有哪些方法, 各有什么优缺点\n##### 用纯CSS创建一个三角形的原理是什么\n##### 实现三栏布局有哪些方法, 分别描述一下\n##### css3实现0.5px的细线\n##### link 与 @import 的区别\n##### 开发中为什么要初始化css样式\n\n答案参考链接：https://lujinggirl.github.io/2019/09/19/cssTitle/\n\n\n\n","slug":"css","published":1,"updated":"2019-09-20T01:47:18.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4sy000eygkcu7wswmdc","content":"<h5 id=\"什么是-BFC机制\"><a href=\"#什么是-BFC机制\" class=\"headerlink\" title=\"什么是 BFC机制\"></a>什么是 BFC机制</h5><h5 id=\"CSS3中新增的选择器以及属性\"><a href=\"#CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"CSS3中新增的选择器以及属性\"></a>CSS3中新增的选择器以及属性</h5><h5 id=\"居中布局\"><a href=\"#居中布局\" class=\"headerlink\" title=\"居中布局\"></a>居中布局</h5><h5 id=\"清除浮动有哪些方法-各有什么优缺点\"><a href=\"#清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"清除浮动有哪些方法, 各有什么优缺点\"></a>清除浮动有哪些方法, 各有什么优缺点</h5><h5 id=\"用纯CSS创建一个三角形的原理是什么\"><a href=\"#用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"用纯CSS创建一个三角形的原理是什么\"></a>用纯CSS创建一个三角形的原理是什么</h5><h5 id=\"实现三栏布局有哪些方法-分别描述一下\"><a href=\"#实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"实现三栏布局有哪些方法, 分别描述一下\"></a>实现三栏布局有哪些方法, 分别描述一下</h5><h5 id=\"css3实现0-5px的细线\"><a href=\"#css3实现0-5px的细线\" class=\"headerlink\" title=\"css3实现0.5px的细线\"></a>css3实现0.5px的细线</h5><h5 id=\"link-与-import-的区别\"><a href=\"#link-与-import-的区别\" class=\"headerlink\" title=\"link 与 @import 的区别\"></a>link 与 @import 的区别</h5><h5 id=\"开发中为什么要初始化css样式\"><a href=\"#开发中为什么要初始化css样式\" class=\"headerlink\" title=\"开发中为什么要初始化css样式\"></a>开发中为什么要初始化css样式</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/19/cssTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/19/cssTitle/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"什么是-BFC机制\"><a href=\"#什么是-BFC机制\" class=\"headerlink\" title=\"什么是 BFC机制\"></a>什么是 BFC机制</h5><h5 id=\"CSS3中新增的选择器以及属性\"><a href=\"#CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"CSS3中新增的选择器以及属性\"></a>CSS3中新增的选择器以及属性</h5><h5 id=\"居中布局\"><a href=\"#居中布局\" class=\"headerlink\" title=\"居中布局\"></a>居中布局</h5><h5 id=\"清除浮动有哪些方法-各有什么优缺点\"><a href=\"#清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"清除浮动有哪些方法, 各有什么优缺点\"></a>清除浮动有哪些方法, 各有什么优缺点</h5><h5 id=\"用纯CSS创建一个三角形的原理是什么\"><a href=\"#用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"用纯CSS创建一个三角形的原理是什么\"></a>用纯CSS创建一个三角形的原理是什么</h5><h5 id=\"实现三栏布局有哪些方法-分别描述一下\"><a href=\"#实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"实现三栏布局有哪些方法, 分别描述一下\"></a>实现三栏布局有哪些方法, 分别描述一下</h5><h5 id=\"css3实现0-5px的细线\"><a href=\"#css3实现0-5px的细线\" class=\"headerlink\" title=\"css3实现0.5px的细线\"></a>css3实现0.5px的细线</h5><h5 id=\"link-与-import-的区别\"><a href=\"#link-与-import-的区别\" class=\"headerlink\" title=\"link 与 @import 的区别\"></a>link 与 @import 的区别</h5><h5 id=\"开发中为什么要初始化css样式\"><a href=\"#开发中为什么要初始化css样式\" class=\"headerlink\" title=\"开发中为什么要初始化css样式\"></a>开发中为什么要初始化css样式</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/19/cssTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/19/cssTitle/</a></p>\n"},{"title":"express： 实现本地代码+本地mock+环境接口数据","date":"2019-09-20T09:29:05.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 17:29:05\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```","source":"_posts/express.md","raw":"---\ntitle: express： 实现本地代码+本地mock+环境接口数据\ndate: 2019-09-20 17:29:05\ntags: node\n---\n\nAuthor: Echo\nTime: 2019-09-20 17:29:05\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```","slug":"express","published":1,"updated":"2019-09-20T09:30:28.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4t0000fygkcdv92a854","content":"<p>Author: Echo<br>Time: 2019-09-20 17:29:05</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 17:29:05</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>"},{"title":"hexo deplay出错","date":"2019-07-24T07:28:39.000Z","_content":"\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：\n\n# 当部署失败的时候，请按照以下步骤进行：\n报错内容如下：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 通过SSH key来上传代码\n###### 1将SSH key添加到github中\n① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）\n###### 2测试设置是否成功：\n```\n$ ssh -T git@github.com\n```\n如果出现如下情况\n```\nHi username! You've successfully authenticated, but GitHub does not \nprovide shell access.\n```\n将项目中如下位置文件做出更改\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不要使用https，而是改为SSH，如下：\n```\nrepository: https://github.com/username/username.github.io.git\n```\n修改为\n```\nrepo：git@github.com:username/username.github.io.git\n```\n一般这步基本就可以部署了！！！\n如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）\n```\n删除.deploy_git\n$ hexo clean \n$ hexo g\n$ hexo d\n```\n本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！\n\n\n\n","source":"_posts/hexoDeplayBug.md","raw":"---\ntitle: hexo deplay出错\ndate: 2019-07-24 15:28:39\ntags: blog-hexo\n---\n\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：\n\n# 当部署失败的时候，请按照以下步骤进行：\n报错内容如下：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 通过SSH key来上传代码\n###### 1将SSH key添加到github中\n① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）\n###### 2测试设置是否成功：\n```\n$ ssh -T git@github.com\n```\n如果出现如下情况\n```\nHi username! You've successfully authenticated, but GitHub does not \nprovide shell access.\n```\n将项目中如下位置文件做出更改\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不要使用https，而是改为SSH，如下：\n```\nrepository: https://github.com/username/username.github.io.git\n```\n修改为\n```\nrepo：git@github.com:username/username.github.io.git\n```\n一般这步基本就可以部署了！！！\n如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）\n```\n删除.deploy_git\n$ hexo clean \n$ hexo g\n$ hexo d\n```\n本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！\n\n\n\n","slug":"hexoDeplayBug","published":1,"updated":"2019-08-21T07:40:09.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4t3000hygkctjlyz4mh","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：</p>\n<h1 id=\"当部署失败的时候，请按照以下步骤进行：\"><a href=\"#当部署失败的时候，请按照以下步骤进行：\" class=\"headerlink\" title=\"当部署失败的时候，请按照以下步骤进行：\"></a>当部署失败的时候，请按照以下步骤进行：</h1><p>报错内容如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h1 id=\"通过SSH-key来上传代码\"><a href=\"#通过SSH-key来上传代码\" class=\"headerlink\" title=\"通过SSH key来上传代码\"></a>通过SSH key来上传代码</h1><h6 id=\"1将SSH-key添加到github中\"><a href=\"#1将SSH-key添加到github中\" class=\"headerlink\" title=\"1将SSH key添加到github中\"></a>1将SSH key添加到github中</h6><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）</p>\n<h6 id=\"2测试设置是否成功：\"><a href=\"#2测试设置是否成功：\" class=\"headerlink\" title=\"2测试设置是否成功：\"></a>2测试设置是否成功：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>如果出现如下情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&apos;ve successfully authenticated, but GitHub does not </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure></p>\n<p>将项目中如下位置文件做出更改<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>不要使用https，而是改为SSH，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repository: https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo：git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>一般这步基本就可以部署了！！！<br>如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除.deploy_git</span><br><span class=\"line\">$ hexo clean </span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：</p>\n<h1 id=\"当部署失败的时候，请按照以下步骤进行：\"><a href=\"#当部署失败的时候，请按照以下步骤进行：\" class=\"headerlink\" title=\"当部署失败的时候，请按照以下步骤进行：\"></a>当部署失败的时候，请按照以下步骤进行：</h1><p>报错内容如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h1 id=\"通过SSH-key来上传代码\"><a href=\"#通过SSH-key来上传代码\" class=\"headerlink\" title=\"通过SSH key来上传代码\"></a>通过SSH key来上传代码</h1><h6 id=\"1将SSH-key添加到github中\"><a href=\"#1将SSH-key添加到github中\" class=\"headerlink\" title=\"1将SSH key添加到github中\"></a>1将SSH key添加到github中</h6><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）</p>\n<h6 id=\"2测试设置是否成功：\"><a href=\"#2测试设置是否成功：\" class=\"headerlink\" title=\"2测试设置是否成功：\"></a>2测试设置是否成功：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>如果出现如下情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&apos;ve successfully authenticated, but GitHub does not </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure></p>\n<p>将项目中如下位置文件做出更改<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>不要使用https，而是改为SSH，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repository: https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo：git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>一般这步基本就可以部署了！！！<br>如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除.deploy_git</span><br><span class=\"line\">$ hexo clean </span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！</p>\n"},{"title":"前端js相关面试题汇总","date":"2019-09-19T12:45:32.000Z","_content":"\n#### promise \n答案参考链接：https://lujinggirl.github.io/2019/08/26/promise/\n#### 宏任务、微任务\n答案参考链接：https://lujinggirl.github.io/2019/08/21/JS-thread/","source":"_posts/js.md","raw":"---\ntitle: 前端js相关面试题汇总\ndate: 2019-09-19 20:45:32\ntags: 前端面试题\n---\n\n#### promise \n答案参考链接：https://lujinggirl.github.io/2019/08/26/promise/\n#### 宏任务、微任务\n答案参考链接：https://lujinggirl.github.io/2019/08/21/JS-thread/","slug":"js","published":1,"updated":"2019-09-19T12:49:35.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4t4000jygkcnqvs8yph","content":"<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/26/promise/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/26/promise/</a></p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/21/JS-thread/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/21/JS-thread/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/26/promise/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/26/promise/</a></p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/21/JS-thread/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/21/JS-thread/</a></p>\n"},{"title":"关于前端请求的那些事","date":"2019-08-19T06:05:42.000Z","_content":"\nAuthor: Echo\nTime: 2019-08-19 14:05:42\n\n## 引言\n\n前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。\n\n## XMLHttpRequest\n\nXMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象\n```\nvar xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象\n```\n由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');  //IE5,6\n    } catch (e) {}\n  }\n}\n```\n使用XMLHttpRequest发起一个get请求\n```\n// get请求\nxhr.open(\"GET\",\"test1.txt\",true);\nxhr.send();\n```\n完整的post请求代码如下：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');\n    } catch (e) {}\n  }\n}\n\nif (xhr) {\n  xhr.onreadystatechange = onReadyStateChange;\n  xhr.open('POST', '/api', true);\n  // 设置 Content-Type 为 application/x-www-form-urlencoded\n  // 以表单的形式传递数据\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('username=admin&password=root');\n}\n\n// onreadystatechange 方法\nfunction onReadyStateChange() {\n  // 该函数会被调用四次\n  if (xhr.readyState === 4 &&xhr.status === 200) {\n    console.log('执行成功');\n  } else {\n    console.log('执行出错');\n  }\n}\n```\n## Jquery Ajax\n说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。\n```\n$.ajax({   //标准写法\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}\n});\n$.get(url,function(){}); //get请求\n$.post(url,body,function(){}); //post请求\n$.getJSON(url,function(){});  //get请求从服务器加载Json编码\n```\n#### 优点：\n* 对原生XHR的封装\n* 针对MVC的编程\n* 完美的兼容性\n* 支持jsonp\n#### 缺点：\n* 不符合MVVM\n* 异步模型不够现代，不支持链式，代码可读性差\n* 整个Jquery太大，引入成本过高\n\n## Fetch\nfetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。\n使用fetch的代码会相比xhr来说更具有条理性。\n\n```\nfetch(url).then(function(response) {\n  return response.json();\n}).then(function(data) {\n  console.log(data);\n}).catch(function(e) {\n  console.log(\"Oops, error\");\n});\n```\n在使用ES6的箭头函数后\n```\nfetch(url).then(response => response.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Oops, error\", e))\n```\n优点：\n\n* 更加底层，提供的API丰富（request, response）\n* 语法简单，脱离了XHR，基于ES新的Promise设计\n\n缺点：\n* 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：`es6-promise`,`babel-polyfill`,`fetch-ie8`等\n* 不支持jsonp，可以引入`fetch-jsonp `\n\n```\n安装 npm install fetch-jsonp --save-dev\n```\n```\n// 使用 \nfetchJsonp(url, {\n timeout: 3000, jsonpCallback: 'callback' \n}).then(function(response) { \n  console.log(response.json()); \n}).catch(function(e) { \n  console.log(e) \n});\n```\n\n- 没有拦截器，需要额外再封装一层或者`fetch-interceptor`\n- 默认不带cookie，需要添加配置\n\n```\nfetch(url,{\n  credentials: 'include'  \n  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域\n});\n```\n* 没有abort，不支持timeout超时处理\n可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。\n* 无法获取progress状态\nFetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.\n## Axios\naxios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。\n* 支持node，创建http请求\n* 支持Promise API\n* 客户端防止CSRF：每个请求带一个cookie拿到的key\n* 拦截请求和响应\n* 可取消请求\n兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。\n#### 安装:\n\n```\n//npm\nnpm install axios\n\n//cdn\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n```\n#### 基本使用如下：\n```\naxios({\n    method: 'GET',\n    url: url,\n})\n.then(res => {console.log(res)})\n.catch(err => {console.log(err)})\n\n// get请求\naxios.get(url)\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// post请求\naxios.post（‘/user’, {\n    name: 'Jerry',\n    lastName: 'Liang'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n## 如何选择（个人理解，仅供参考）[](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-)\n\n1.  首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。\n2.  如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。\n3.  如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。\n\n参考：[https://qianduan.group/posts/5bebe26f9fd64d5a7458a932](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932)\n\n","source":"_posts/request.md","raw":"---\ntitle: 关于前端请求的那些事\ndate: 2019-08-19 14:05:42\ntags: js\n---\n\nAuthor: Echo\nTime: 2019-08-19 14:05:42\n\n## 引言\n\n前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。\n\n## XMLHttpRequest\n\nXMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象\n```\nvar xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象\n```\n由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');  //IE5,6\n    } catch (e) {}\n  }\n}\n```\n使用XMLHttpRequest发起一个get请求\n```\n// get请求\nxhr.open(\"GET\",\"test1.txt\",true);\nxhr.send();\n```\n完整的post请求代码如下：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');\n    } catch (e) {}\n  }\n}\n\nif (xhr) {\n  xhr.onreadystatechange = onReadyStateChange;\n  xhr.open('POST', '/api', true);\n  // 设置 Content-Type 为 application/x-www-form-urlencoded\n  // 以表单的形式传递数据\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('username=admin&password=root');\n}\n\n// onreadystatechange 方法\nfunction onReadyStateChange() {\n  // 该函数会被调用四次\n  if (xhr.readyState === 4 &&xhr.status === 200) {\n    console.log('执行成功');\n  } else {\n    console.log('执行出错');\n  }\n}\n```\n## Jquery Ajax\n说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。\n```\n$.ajax({   //标准写法\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}\n});\n$.get(url,function(){}); //get请求\n$.post(url,body,function(){}); //post请求\n$.getJSON(url,function(){});  //get请求从服务器加载Json编码\n```\n#### 优点：\n* 对原生XHR的封装\n* 针对MVC的编程\n* 完美的兼容性\n* 支持jsonp\n#### 缺点：\n* 不符合MVVM\n* 异步模型不够现代，不支持链式，代码可读性差\n* 整个Jquery太大，引入成本过高\n\n## Fetch\nfetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。\n使用fetch的代码会相比xhr来说更具有条理性。\n\n```\nfetch(url).then(function(response) {\n  return response.json();\n}).then(function(data) {\n  console.log(data);\n}).catch(function(e) {\n  console.log(\"Oops, error\");\n});\n```\n在使用ES6的箭头函数后\n```\nfetch(url).then(response => response.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Oops, error\", e))\n```\n优点：\n\n* 更加底层，提供的API丰富（request, response）\n* 语法简单，脱离了XHR，基于ES新的Promise设计\n\n缺点：\n* 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：`es6-promise`,`babel-polyfill`,`fetch-ie8`等\n* 不支持jsonp，可以引入`fetch-jsonp `\n\n```\n安装 npm install fetch-jsonp --save-dev\n```\n```\n// 使用 \nfetchJsonp(url, {\n timeout: 3000, jsonpCallback: 'callback' \n}).then(function(response) { \n  console.log(response.json()); \n}).catch(function(e) { \n  console.log(e) \n});\n```\n\n- 没有拦截器，需要额外再封装一层或者`fetch-interceptor`\n- 默认不带cookie，需要添加配置\n\n```\nfetch(url,{\n  credentials: 'include'  \n  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域\n});\n```\n* 没有abort，不支持timeout超时处理\n可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。\n* 无法获取progress状态\nFetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.\n## Axios\naxios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。\n* 支持node，创建http请求\n* 支持Promise API\n* 客户端防止CSRF：每个请求带一个cookie拿到的key\n* 拦截请求和响应\n* 可取消请求\n兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。\n#### 安装:\n\n```\n//npm\nnpm install axios\n\n//cdn\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n```\n#### 基本使用如下：\n```\naxios({\n    method: 'GET',\n    url: url,\n})\n.then(res => {console.log(res)})\n.catch(err => {console.log(err)})\n\n// get请求\naxios.get(url)\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// post请求\naxios.post（‘/user’, {\n    name: 'Jerry',\n    lastName: 'Liang'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n## 如何选择（个人理解，仅供参考）[](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-)\n\n1.  首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。\n2.  如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。\n3.  如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。\n\n参考：[https://qianduan.group/posts/5bebe26f9fd64d5a7458a932](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932)\n\n","slug":"request","published":1,"updated":"2019-08-23T02:42:48.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4t6000mygkcq5fyc8bp","content":"<p>Author: Echo<br>Time: 2019-08-19 14:05:42</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。</p>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h2><p>XMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象</span><br></pre></td></tr></table></figure></p>\n<p>由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  //IE5,6</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用XMLHttpRequest发起一个get请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// get请求</span><br><span class=\"line\">xhr.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure></p>\n<p>完整的post请求代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (xhr) &#123;</span><br><span class=\"line\">  xhr.onreadystatechange = onReadyStateChange;</span><br><span class=\"line\">  xhr.open(&apos;POST&apos;, &apos;/api&apos;, true);</span><br><span class=\"line\">  // 设置 Content-Type 为 application/x-www-form-urlencoded</span><br><span class=\"line\">  // 以表单的形式传递数据</span><br><span class=\"line\">  xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class=\"line\">  xhr.send(&apos;username=admin&amp;password=root&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// onreadystatechange 方法</span><br><span class=\"line\">function onReadyStateChange() &#123;</span><br><span class=\"line\">  // 该函数会被调用四次</span><br><span class=\"line\">  if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123;</span><br><span class=\"line\">    console.log(&apos;执行成功&apos;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;执行出错&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Jquery-Ajax\"><a href=\"#Jquery-Ajax\" class=\"headerlink\" title=\"Jquery Ajax\"></a>Jquery Ajax</h2><p>说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;   //标准写法</span><br><span class=\"line\">   type: &apos;POST&apos;,</span><br><span class=\"line\">   url: url,</span><br><span class=\"line\">   data: data,</span><br><span class=\"line\">   dataType: dataType,</span><br><span class=\"line\">   success: function () &#123;&#125;,</span><br><span class=\"line\">   error: function () &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$.get(url,function()&#123;&#125;); //get请求</span><br><span class=\"line\">$.post(url,body,function()&#123;&#125;); //post请求</span><br><span class=\"line\">$.getJSON(url,function()&#123;&#125;);  //get请求从服务器加载Json编码</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>对原生XHR的封装</li>\n<li>针对MVC的编程</li>\n<li>完美的兼容性</li>\n<li>支持jsonp<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4></li>\n<li>不符合MVVM</li>\n<li>异步模型不够现代，不支持链式，代码可读性差</li>\n<li>整个Jquery太大，引入成本过高</li>\n</ul>\n<h2 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h2><p>fetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。<br>使用fetch的代码会相比xhr来说更具有条理性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(function(response) &#123;</span><br><span class=\"line\">  return response.json();</span><br><span class=\"line\">&#125;).then(function(data) &#123;</span><br><span class=\"line\">  console.log(data);</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Oops, error&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在使用ES6的箭头函数后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(response =&gt; response.json())</span><br><span class=\"line\">  .then(data =&gt; console.log(data))</span><br><span class=\"line\">  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>更加底层，提供的API丰富（request, response）</li>\n<li>语法简单，脱离了XHR，基于ES新的Promise设计</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：<code>es6-promise</code>,<code>babel-polyfill</code>,<code>fetch-ie8</code>等</li>\n<li>不支持jsonp，可以引入<code>fetch-jsonp</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装 npm install fetch-jsonp --save-dev</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 </span><br><span class=\"line\">fetchJsonp(url, &#123;</span><br><span class=\"line\"> timeout: 3000, jsonpCallback: &apos;callback&apos; </span><br><span class=\"line\">&#125;).then(function(response) &#123; </span><br><span class=\"line\">  console.log(response.json()); </span><br><span class=\"line\">&#125;).catch(function(e) &#123; </span><br><span class=\"line\">  console.log(e) </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有拦截器，需要额外再封装一层或者<code>fetch-interceptor</code></li>\n<li>默认不带cookie，需要添加配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url,&#123;</span><br><span class=\"line\">  credentials: &apos;include&apos;  </span><br><span class=\"line\">  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有abort，不支持timeout超时处理<br>可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。</li>\n<li>无法获取progress状态<br>Fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.<h2 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h2>axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。</li>\n<li>支持node，创建http请求</li>\n<li>支持Promise API</li>\n<li>客户端防止CSRF：每个请求带一个cookie拿到的key</li>\n<li>拦截请求和响应</li>\n<li>可取消请求<br>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装:\"></a>安装:</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//npm</span><br><span class=\"line\">npm install axios</span><br><span class=\"line\"></span><br><span class=\"line\">//cdn</span><br><span class=\"line\">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本使用如下：\"><a href=\"#基本使用如下：\" class=\"headerlink\" title=\"基本使用如下：\"></a>基本使用如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class=\"line\">.catch(err =&gt; &#123;console.log(err)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// get请求</span><br><span class=\"line\">axios.get(url)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// post请求</span><br><span class=\"line\">axios.post（‘/user’, &#123;</span><br><span class=\"line\">    name: &apos;Jerry&apos;,</span><br><span class=\"line\">    lastName: &apos;Liang&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何选择（个人理解，仅供参考）\"><a href=\"#如何选择（个人理解，仅供参考）\" class=\"headerlink\" title=\"如何选择（个人理解，仅供参考）\"></a>如何选择（个人理解，仅供参考）<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-\" target=\"_blank\" rel=\"noopener\"></a></h2><ol>\n<li>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。</li>\n<li>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。</li>\n<li>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。</li>\n</ol>\n<p>参考：<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932\" target=\"_blank\" rel=\"noopener\">https://qianduan.group/posts/5bebe26f9fd64d5a7458a932</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-19 14:05:42</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。</p>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h2><p>XMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象</span><br></pre></td></tr></table></figure></p>\n<p>由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  //IE5,6</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用XMLHttpRequest发起一个get请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// get请求</span><br><span class=\"line\">xhr.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure></p>\n<p>完整的post请求代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (xhr) &#123;</span><br><span class=\"line\">  xhr.onreadystatechange = onReadyStateChange;</span><br><span class=\"line\">  xhr.open(&apos;POST&apos;, &apos;/api&apos;, true);</span><br><span class=\"line\">  // 设置 Content-Type 为 application/x-www-form-urlencoded</span><br><span class=\"line\">  // 以表单的形式传递数据</span><br><span class=\"line\">  xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class=\"line\">  xhr.send(&apos;username=admin&amp;password=root&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// onreadystatechange 方法</span><br><span class=\"line\">function onReadyStateChange() &#123;</span><br><span class=\"line\">  // 该函数会被调用四次</span><br><span class=\"line\">  if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123;</span><br><span class=\"line\">    console.log(&apos;执行成功&apos;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;执行出错&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Jquery-Ajax\"><a href=\"#Jquery-Ajax\" class=\"headerlink\" title=\"Jquery Ajax\"></a>Jquery Ajax</h2><p>说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;   //标准写法</span><br><span class=\"line\">   type: &apos;POST&apos;,</span><br><span class=\"line\">   url: url,</span><br><span class=\"line\">   data: data,</span><br><span class=\"line\">   dataType: dataType,</span><br><span class=\"line\">   success: function () &#123;&#125;,</span><br><span class=\"line\">   error: function () &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$.get(url,function()&#123;&#125;); //get请求</span><br><span class=\"line\">$.post(url,body,function()&#123;&#125;); //post请求</span><br><span class=\"line\">$.getJSON(url,function()&#123;&#125;);  //get请求从服务器加载Json编码</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>对原生XHR的封装</li>\n<li>针对MVC的编程</li>\n<li>完美的兼容性</li>\n<li>支持jsonp<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4></li>\n<li>不符合MVVM</li>\n<li>异步模型不够现代，不支持链式，代码可读性差</li>\n<li>整个Jquery太大，引入成本过高</li>\n</ul>\n<h2 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h2><p>fetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。<br>使用fetch的代码会相比xhr来说更具有条理性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(function(response) &#123;</span><br><span class=\"line\">  return response.json();</span><br><span class=\"line\">&#125;).then(function(data) &#123;</span><br><span class=\"line\">  console.log(data);</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Oops, error&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在使用ES6的箭头函数后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(response =&gt; response.json())</span><br><span class=\"line\">  .then(data =&gt; console.log(data))</span><br><span class=\"line\">  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>更加底层，提供的API丰富（request, response）</li>\n<li>语法简单，脱离了XHR，基于ES新的Promise设计</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：<code>es6-promise</code>,<code>babel-polyfill</code>,<code>fetch-ie8</code>等</li>\n<li>不支持jsonp，可以引入<code>fetch-jsonp</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装 npm install fetch-jsonp --save-dev</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 </span><br><span class=\"line\">fetchJsonp(url, &#123;</span><br><span class=\"line\"> timeout: 3000, jsonpCallback: &apos;callback&apos; </span><br><span class=\"line\">&#125;).then(function(response) &#123; </span><br><span class=\"line\">  console.log(response.json()); </span><br><span class=\"line\">&#125;).catch(function(e) &#123; </span><br><span class=\"line\">  console.log(e) </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有拦截器，需要额外再封装一层或者<code>fetch-interceptor</code></li>\n<li>默认不带cookie，需要添加配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url,&#123;</span><br><span class=\"line\">  credentials: &apos;include&apos;  </span><br><span class=\"line\">  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有abort，不支持timeout超时处理<br>可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。</li>\n<li>无法获取progress状态<br>Fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.<h2 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h2>axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。</li>\n<li>支持node，创建http请求</li>\n<li>支持Promise API</li>\n<li>客户端防止CSRF：每个请求带一个cookie拿到的key</li>\n<li>拦截请求和响应</li>\n<li>可取消请求<br>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装:\"></a>安装:</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//npm</span><br><span class=\"line\">npm install axios</span><br><span class=\"line\"></span><br><span class=\"line\">//cdn</span><br><span class=\"line\">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本使用如下：\"><a href=\"#基本使用如下：\" class=\"headerlink\" title=\"基本使用如下：\"></a>基本使用如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class=\"line\">.catch(err =&gt; &#123;console.log(err)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// get请求</span><br><span class=\"line\">axios.get(url)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// post请求</span><br><span class=\"line\">axios.post（‘/user’, &#123;</span><br><span class=\"line\">    name: &apos;Jerry&apos;,</span><br><span class=\"line\">    lastName: &apos;Liang&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何选择（个人理解，仅供参考）\"><a href=\"#如何选择（个人理解，仅供参考）\" class=\"headerlink\" title=\"如何选择（个人理解，仅供参考）\"></a>如何选择（个人理解，仅供参考）<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-\" target=\"_blank\" rel=\"noopener\"></a></h2><ol>\n<li>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。</li>\n<li>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。</li>\n<li>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。</li>\n</ol>\n<p>参考：<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932\" target=\"_blank\" rel=\"noopener\">https://qianduan.group/posts/5bebe26f9fd64d5a7458a932</a></p>\n"},{"title":"虚拟dom","date":"2019-09-20T03:05:02.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 11:05:02\n\n##### 什么是虚拟DOM树？（Virtual DOM）\nvirtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。\n虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的\n* 当页面渲染的时候Vue会创建一颗虚拟DOM树\n* 当页面发生改变Vue会再创建一颗新的虚拟DOM树\n* 前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方\n* 将有差异的地方更新到真实的DOM树中\n##### 虚拟DOM树有什么用？　\nvue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 -------虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。\n\n可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。\n##### Vue  v-for 中 :key 到底有什么用？\nvue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。\nkey的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元\n\n参考链接： https://www.cnblogs.com/javascript9527/p/11327924.html\n\n实现一个Virtual DOM算法参考链接： https://www.cnblogs.com/ssw-men/p/10818585.html","source":"_posts/virtualDom.md","raw":"---\ntitle: 虚拟dom\ndate: 2019-09-20 11:05:02\ntags: vue\n---\n\nAuthor: Echo\nTime: 2019-09-20 11:05:02\n\n##### 什么是虚拟DOM树？（Virtual DOM）\nvirtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。\n虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的\n* 当页面渲染的时候Vue会创建一颗虚拟DOM树\n* 当页面发生改变Vue会再创建一颗新的虚拟DOM树\n* 前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方\n* 将有差异的地方更新到真实的DOM树中\n##### 虚拟DOM树有什么用？　\nvue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 -------虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。\n\n可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。\n##### Vue  v-for 中 :key 到底有什么用？\nvue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。\nkey的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元\n\n参考链接： https://www.cnblogs.com/javascript9527/p/11327924.html\n\n实现一个Virtual DOM算法参考链接： https://www.cnblogs.com/ssw-men/p/10818585.html","slug":"virtualDom","published":1,"updated":"2019-09-20T03:05:45.501Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4t8000oygkcla55vjow","content":"<p>Author: Echo<br>Time: 2019-09-20 11:05:02</p>\n<h5 id=\"什么是虚拟DOM树？（Virtual-DOM）\"><a href=\"#什么是虚拟DOM树？（Virtual-DOM）\" class=\"headerlink\" title=\"什么是虚拟DOM树？（Virtual DOM）\"></a>什么是虚拟DOM树？（Virtual DOM）</h5><p>virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的</p>\n<ul>\n<li>当页面渲染的时候Vue会创建一颗虚拟DOM树</li>\n<li>当页面发生改变Vue会再创建一颗新的虚拟DOM树</li>\n<li>前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方</li>\n<li>将有差异的地方更新到真实的DOM树中<h5 id=\"虚拟DOM树有什么用？\"><a href=\"#虚拟DOM树有什么用？\" class=\"headerlink\" title=\"虚拟DOM树有什么用？　\"></a>虚拟DOM树有什么用？　</h5>vue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 ——-虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。</li>\n</ul>\n<p>可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。</p>\n<h5 id=\"Vue-v-for-中-key-到底有什么用？\"><a href=\"#Vue-v-for-中-key-到底有什么用？\" class=\"headerlink\" title=\"Vue  v-for 中 :key 到底有什么用？\"></a>Vue  v-for 中 :key 到底有什么用？</h5><p>vue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。<br>key的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元</p>\n<p>参考链接： <a href=\"https://www.cnblogs.com/javascript9527/p/11327924.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/javascript9527/p/11327924.html</a></p>\n<p>实现一个Virtual DOM算法参考链接： <a href=\"https://www.cnblogs.com/ssw-men/p/10818585.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ssw-men/p/10818585.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 11:05:02</p>\n<h5 id=\"什么是虚拟DOM树？（Virtual-DOM）\"><a href=\"#什么是虚拟DOM树？（Virtual-DOM）\" class=\"headerlink\" title=\"什么是虚拟DOM树？（Virtual DOM）\"></a>什么是虚拟DOM树？（Virtual DOM）</h5><p>virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的</p>\n<ul>\n<li>当页面渲染的时候Vue会创建一颗虚拟DOM树</li>\n<li>当页面发生改变Vue会再创建一颗新的虚拟DOM树</li>\n<li>前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方</li>\n<li>将有差异的地方更新到真实的DOM树中<h5 id=\"虚拟DOM树有什么用？\"><a href=\"#虚拟DOM树有什么用？\" class=\"headerlink\" title=\"虚拟DOM树有什么用？　\"></a>虚拟DOM树有什么用？　</h5>vue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 ——-虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。</li>\n</ul>\n<p>可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。</p>\n<h5 id=\"Vue-v-for-中-key-到底有什么用？\"><a href=\"#Vue-v-for-中-key-到底有什么用？\" class=\"headerlink\" title=\"Vue  v-for 中 :key 到底有什么用？\"></a>Vue  v-for 中 :key 到底有什么用？</h5><p>vue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。<br>key的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元</p>\n<p>参考链接： <a href=\"https://www.cnblogs.com/javascript9527/p/11327924.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/javascript9527/p/11327924.html</a></p>\n<p>实现一个Virtual DOM算法参考链接： <a href=\"https://www.cnblogs.com/ssw-men/p/10818585.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ssw-men/p/10818585.html</a></p>\n"},{"title":"vue相关面试题汇总","date":"2019-09-19T12:50:06.000Z","_content":"\n##### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n##### 子组件访问父组件数据（除了props） \n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueTitle/\n\n##### new Vue()做了什么？\n##### 什么阶段才能访问DOM？\n##### 谈谈你对Vue的生命周期的理解？\n##### 生命周期钩子的合并策略\n##### 新生命周期钩子：serverPrefetch是什么？\n##### Vue-router 路由模式有几种？\n##### 谈谈你对keep-alive的了解\n##### vue源码中内置的组件？\n##### 了解Vue2.6+新全局API：Vue.observable()吗？\n##### 了解Vue数据绑定原理？\n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueSourceCoding/","source":"_posts/vue.md","raw":"---\ntitle: vue相关面试题汇总\ndate: 2019-09-19 20:50:06\ntags: 前端面试题\n---\n\n##### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n##### 子组件访问父组件数据（除了props） \n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueTitle/\n\n##### new Vue()做了什么？\n##### 什么阶段才能访问DOM？\n##### 谈谈你对Vue的生命周期的理解？\n##### 生命周期钩子的合并策略\n##### 新生命周期钩子：serverPrefetch是什么？\n##### Vue-router 路由模式有几种？\n##### 谈谈你对keep-alive的了解\n##### vue源码中内置的组件？\n##### 了解Vue2.6+新全局API：Vue.observable()吗？\n##### 了解Vue数据绑定原理？\n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueSourceCoding/","slug":"vue","published":1,"updated":"2019-09-19T12:52:41.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4t9000qygkcahzesj5f","content":"<h5 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h5><h5 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueTitle/</a></p>\n<h5 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h5><h5 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h5><h5 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h5><h5 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h5><h5 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h5><h5 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h5><h5 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h5><h5 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h5><h5 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h5><h5 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueSourceCoding/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueSourceCoding/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h5><h5 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueTitle/</a></p>\n<h5 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h5><h5 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h5><h5 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h5><h5 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h5><h5 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h5><h5 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h5><h5 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h5><h5 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h5><h5 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h5><h5 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueSourceCoding/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueSourceCoding/</a></p>\n"},{"title":"vue相关面试题","date":"2019-09-03T02:10:37.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-03 10:10:37\n\n### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n* Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递\n###### 缺点:\n使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护\n#####1.  父组件使用provide，子组件使用inject\n* 通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等\n```\n1.provide就相当于加强版父组件prop\n2.inject就相当于加强版子组件的props \n```\n// 示例代码\n```\n// 父组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'father',\n  // 传入对象写法\n  provide: {\n    name: 'bar'\n  }\n  // 函数写法\n\tprovide () {\n    return {\n      name: 'foo'\n    }\n  }\n}\n</script>\n\n// 孙子组件或者深层次组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'Grandson',\n\tinject: [name]\n}\n</script>\n```\n\n###### 缺点\n在任意层级都能访问，导致数据变化追踪比较困难。\n\n##### 2.通过$attrs传递属性\nvue api解释说明：\n```\nvm.$attrs和inheritAttrs\n2.4.0 新增\n类型：{ [key: string]: string }\n只读\n详细：\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\n```\n细节使用示例参考链接：https://www.jianshu.com/p/ce8ca875c337\n\n##### 3.通过$listeners传递事件\n```\nvm.$listeners\n2.4.0 新增\n类型：{ [key: string]: Function | Array<Function> }\n只读\n详细：\n包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。\n```\n##### 4.Vue2.6+新全局API：Vue.observable()\n\n### 子组件访问父组件数据（除了props）\n* 使用$parent属性\n* 通过$attrs传递属性\n* Vue2.6+新全局API：Vue.observable()\n","source":"_posts/vueTitle.md","raw":"---\ntitle: vue相关面试题\ndate: 2019-09-03 10:10:37\ntags: vue\n---\n\nAuthor: Echo\nTime: 2019-09-03 10:10:37\n\n### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n* Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递\n###### 缺点:\n使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护\n#####1.  父组件使用provide，子组件使用inject\n* 通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等\n```\n1.provide就相当于加强版父组件prop\n2.inject就相当于加强版子组件的props \n```\n// 示例代码\n```\n// 父组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'father',\n  // 传入对象写法\n  provide: {\n    name: 'bar'\n  }\n  // 函数写法\n\tprovide () {\n    return {\n      name: 'foo'\n    }\n  }\n}\n</script>\n\n// 孙子组件或者深层次组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'Grandson',\n\tinject: [name]\n}\n</script>\n```\n\n###### 缺点\n在任意层级都能访问，导致数据变化追踪比较困难。\n\n##### 2.通过$attrs传递属性\nvue api解释说明：\n```\nvm.$attrs和inheritAttrs\n2.4.0 新增\n类型：{ [key: string]: string }\n只读\n详细：\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\n```\n细节使用示例参考链接：https://www.jianshu.com/p/ce8ca875c337\n\n##### 3.通过$listeners传递事件\n```\nvm.$listeners\n2.4.0 新增\n类型：{ [key: string]: Function | Array<Function> }\n只读\n详细：\n包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。\n```\n##### 4.Vue2.6+新全局API：Vue.observable()\n\n### 子组件访问父组件数据（除了props）\n* 使用$parent属性\n* 通过$attrs传递属性\n* Vue2.6+新全局API：Vue.observable()\n","slug":"vueTitle","published":1,"updated":"2019-09-19T12:20:18.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4ta000sygkc81rfw2q3","content":"<p>Author: Echo<br>Time: 2019-09-03 10:10:37</p>\n<h3 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h3><ul>\n<li>Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h6>使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护<br>#####1.  父组件使用provide，子组件使用inject</li>\n<li>通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.provide就相当于加强版父组件prop</span><br><span class=\"line\">2.inject就相当于加强版子组件的props</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>// 示例代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;father&apos;,</span><br><span class=\"line\">  // 传入对象写法</span><br><span class=\"line\">  provide: &#123;</span><br><span class=\"line\">    name: &apos;bar&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 函数写法</span><br><span class=\"line\">\tprovide () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name: &apos;foo&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 孙子组件或者深层次组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;Grandson&apos;,</span><br><span class=\"line\">\tinject: [name]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>在任意层级都能访问，导致数据变化追踪比较困难。</p>\n<h5 id=\"2-通过-attrs传递属性\"><a href=\"#2-通过-attrs传递属性\" class=\"headerlink\" title=\"2.通过$attrs传递属性\"></a>2.通过$attrs传递属性</h5><p>vue api解释说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$attrs和inheritAttrs</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: string &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</span><br></pre></td></tr></table></figure></p>\n<p>细节使用示例参考链接：<a href=\"https://www.jianshu.com/p/ce8ca875c337\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ce8ca875c337</a></p>\n<h5 id=\"3-通过-listeners传递事件\"><a href=\"#3-通过-listeners传递事件\" class=\"headerlink\" title=\"3.通过$listeners传递事件\"></a>3.通过$listeners传递事件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$listeners</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: Function | Array&lt;Function&gt; &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-Vue2-6-新全局API：Vue-observable\"><a href=\"#4-Vue2-6-新全局API：Vue-observable\" class=\"headerlink\" title=\"4.Vue2.6+新全局API：Vue.observable()\"></a>4.Vue2.6+新全局API：Vue.observable()</h5><h3 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h3><ul>\n<li>使用$parent属性</li>\n<li>通过$attrs传递属性</li>\n<li>Vue2.6+新全局API：Vue.observable()</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-03 10:10:37</p>\n<h3 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h3><ul>\n<li>Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h6>使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护<br>#####1.  父组件使用provide，子组件使用inject</li>\n<li>通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.provide就相当于加强版父组件prop</span><br><span class=\"line\">2.inject就相当于加强版子组件的props</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>// 示例代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;father&apos;,</span><br><span class=\"line\">  // 传入对象写法</span><br><span class=\"line\">  provide: &#123;</span><br><span class=\"line\">    name: &apos;bar&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 函数写法</span><br><span class=\"line\">\tprovide () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name: &apos;foo&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 孙子组件或者深层次组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;Grandson&apos;,</span><br><span class=\"line\">\tinject: [name]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>在任意层级都能访问，导致数据变化追踪比较困难。</p>\n<h5 id=\"2-通过-attrs传递属性\"><a href=\"#2-通过-attrs传递属性\" class=\"headerlink\" title=\"2.通过$attrs传递属性\"></a>2.通过$attrs传递属性</h5><p>vue api解释说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$attrs和inheritAttrs</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: string &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</span><br></pre></td></tr></table></figure></p>\n<p>细节使用示例参考链接：<a href=\"https://www.jianshu.com/p/ce8ca875c337\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ce8ca875c337</a></p>\n<h5 id=\"3-通过-listeners传递事件\"><a href=\"#3-通过-listeners传递事件\" class=\"headerlink\" title=\"3.通过$listeners传递事件\"></a>3.通过$listeners传递事件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$listeners</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: Function | Array&lt;Function&gt; &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-Vue2-6-新全局API：Vue-observable\"><a href=\"#4-Vue2-6-新全局API：Vue-observable\" class=\"headerlink\" title=\"4.Vue2.6+新全局API：Vue.observable()\"></a>4.Vue2.6+新全局API：Vue.observable()</h5><h3 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h3><ul>\n<li>使用$parent属性</li>\n<li>通过$attrs传递属性</li>\n<li>Vue2.6+新全局API：Vue.observable()</li>\n</ul>\n"},{"title":"前端面试题汇总","date":"2019-09-19T12:53:29.000Z","_content":"\n##### 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n##### 浏览器工作原理\n##### 浏览器内核\n##### 常见的浏览器内核有哪些？\n##### cookies，sessionStorage 和 localStorage 的区别？\n##### 页面访问cookie的限制条件\n##### 实现浏览器内多个标签页之间的通信\n##### 页面可见性（Page Visibility API） 可以有哪些用途\n##### 网页验证码是做什么的，是为了解决什么安全问题\n##### 为什么利用多个域名来存储网站资源\n##### 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n##### 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n##### 前端性能优化\n##### webSocket如何兼容低浏览器\n##### web开发中会话跟踪的方法\n##### HTTP method\n##### HTTP状态码及其含义\n##### 什么是同源：协议相同 域名相同 端口相同\n\n答案参考链接：https://lujinggirl.github.io/2019/09/02/webTitle/","source":"_posts/web.md","raw":"---\ntitle: 前端面试题汇总\ndate: 2019-09-19 20:53:29\ntags: 前端面试题\n---\n\n##### 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n##### 浏览器工作原理\n##### 浏览器内核\n##### 常见的浏览器内核有哪些？\n##### cookies，sessionStorage 和 localStorage 的区别？\n##### 页面访问cookie的限制条件\n##### 实现浏览器内多个标签页之间的通信\n##### 页面可见性（Page Visibility API） 可以有哪些用途\n##### 网页验证码是做什么的，是为了解决什么安全问题\n##### 为什么利用多个域名来存储网站资源\n##### 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n##### 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n##### 前端性能优化\n##### webSocket如何兼容低浏览器\n##### web开发中会话跟踪的方法\n##### HTTP method\n##### HTTP状态码及其含义\n##### 什么是同源：协议相同 域名相同 端口相同\n\n答案参考链接：https://lujinggirl.github.io/2019/09/02/webTitle/","slug":"web","published":1,"updated":"2019-09-19T12:54:49.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4to0016ygkc91j54i1s","content":"<h5 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h5><h5 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h5><h5 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h5><h5 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h5><h5 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h5><h5 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h5><h5 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h5><h5 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h5><h5 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h5><h5 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h5><h5 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h5><h5 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h5><h5 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h5><h5 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h5><h5 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h5><h5 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h5><h5 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h5><h5 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/02/webTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/02/webTitle/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h5><h5 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h5><h5 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h5><h5 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h5><h5 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h5><h5 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h5><h5 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h5><h5 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h5><h5 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h5><h5 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h5><h5 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h5><h5 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h5><h5 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h5><h5 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h5><h5 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h5><h5 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h5><h5 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h5><h5 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/02/webTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/02/webTitle/</a></p>\n"},{"title":"从多线程到Event Loop全面梳理","date":"2019-08-21T07:36:08.000Z","_content":"\nAuthor: Echo\nTime: 2019-08-21 15:36:08\n\n\n\n## 引言\n几乎在每一本JS相关的书籍中，都会说JS是`单线程`的，JS是通过`事件队列(Event Loop)`的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 `异步`的能力，所以，我试图从`进程`、`线程`的角度来解释这个问题。\n## CPU\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n计算机的核心是`CPU`，它承担了所有的计算任务。\n它就像一座工厂，时刻在运行。\n## 进程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n`进程`就好比工厂的车间，它代表CPU所能处理的单个任务。 `进程`之间相互独立，任一时刻，CPU总是运行一个`进程`，其他`进程`处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个`进程`。\n## 线程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。\n`线程`就好比车间里的工人，一个`进程`可以包括多个`线程`，多个`线程`共享`进程`资源。\n## CPU、进程、线程之间的关系\n从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。\n* `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n* `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n* 不同`进程`之间也可以通信，不过代价较大\n* `单线程`与`多线程`，都是指在一个`进程`内的单和多\n## 浏览器是多进程的\n\n我们已经知道了`CPU`、`进程`、`线程`之间的关系，对于计算机来说，每一个应用程序都是一个`进程`，\n而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过`子进程`来实现的。\n对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。\n而对于浏览器来说，浏览器就是`多进程`的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n如上图，我们可以看到一个Chrome浏览器启动了好多个进程。\n\n总结一下：\n\n* 浏览器是多进程的\n* 每一个Tab页，就是一个独立的进程\n## 浏览器包含了哪些进程\n* 主进程\n>*  协调控制其他子进程（创建、销毁）\n>*  浏览器界面显示，用户交互，前进、后退、收藏\n>*  将渲染进程得到的内存中的Bitmap，绘制到用户界面上\n>*   处理不可见操作，网络请求，文件访问等\n* 第三方插件进程\n>*  每种类型的插件对应一个进程，仅当使用该插件时才创建\n* GPU进程\n>*  用于3D绘制等\n* `渲染进程`，就是我们说的`浏览器内核`\n>*  负责页面渲染，脚本执行，事件处理等\n>*  每个tab页一个渲染进程\n\n那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？\n\n答案是`渲染进程`，也就是我们常说的`浏览器内核`\n## 浏览器内核（渲染进程）\n从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。\n而对于`渲染进程`来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。\n* GUI渲染线程\n>*  负责渲染页面，布局和绘制\n>*  页面需要重绘和回流时，该线程就会执行\n>*  与js引擎线程互斥，防止渲染结果不可预期\n* JS引擎线程\n>*  负责处理解析和执行javascript脚本程序\n>*  只有一个JS引擎线程（单线程）\n>*  与GUI渲染线程互斥，防止渲染结果不可预期\n* 事件触发线程\n>*  用来控制事件循环（鼠标点击、setTimeout、ajax等）\n>*  当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中\n* 定时触发器线程\n>*  setInterval与setTimeout所在的线程\n>*  定时任务并不是由JS引擎计时的，是由定时触发线程来计时的\n>*  计时完毕后，通知事件触发线程\n* 异步http请求线程\n>*  浏览器有一个单独的线程用于处理AJAX请求\n>*  当请求完成时，若有回调函数，通知事件触发线程\n\n当我们了解了渲染进程包含的这些线程后，我们思考两个问题：\n\n1. 为什么 javascript 是单线程的\n2. 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n## 为什么 javascript 是单线程的\n首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。\n\n其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。\n## 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n\n这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，\n那么渲染线程前后获得的元素就可能不一致了。\n因此，为了防止渲染出现不可预期的结果，浏览器设定 `GUI渲染线程`和`JS引擎线程`为互斥关系，\n当JS引擎线程执行时`GUI渲染线程`会被挂起，GUI更新则会被保存在一个队列中等待`JS引擎线程`空闲时立即被执行。\n## 从 Event Loop 看 JS 的运行机制\n到了这里，终于要进入我们的主题，什么是 Event Loop\n先理解一些概念\n* JS 分为同步任务和异步任务\n* 同步任务都在JS引擎线程上执行，形成一个`执行栈`\n* 事件触发线程管理一个`任务队列`，异步任务触发条件达成，将回调事件放到`任务队列`中\n* `执行栈`中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取`任务队列`，将可运行的异步任务回调事件添加到`执行栈`中，开始执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n在前端开发中我们会通过`setTimeout/setInterval`来指定定时任务，会通过`XHR/fetch`发送网络请求， 接下来简述一下`setTimeout/setInterval`和`XHR/fetch`到底做了什么事\n\n我们知道，不管是`setTimeout/setInterval`和`XHR/fetch`代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。\n\n当代码执行到`setTimeout/setInterval`时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而`定时触发器线程`在接收到这个消息后，会在等待的时间后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当代码执行到`XHR/fetch`时，实际上是`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成后的回调事件， 而`异步http请求线程`在接收到这个消息后，会在请求成功后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在`事件队列`中是否有待执行的回调函数，如果有就会加入到执行栈中交给`JS引擎线程`执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n再用代码来解释一下：\n```\nlet timerCallback = function() {\n  console.log('wait one second');\n};\nlet httpCallback = function() {\n  console.log('get server data success');\n}\n\n// 同步任务\nconsole.log('hello');\n// 同步任务\n// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理\n// 1s 后事件触发线程将 timerCallback 加入到事件队列中\nsetTimeout(timerCallback,1000);\n// 同步任务\n// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理\n// 请求成功后事件触发线程将 httpCallback 加入到事件队列中\n$.get('www.xxxx.com',httpCallback);\n// 同步任务\nconsole.log('world');\n//...\n// 所有同步任务执行完后\n// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数\n// 如果没有，一直询问，直到有为止\n// 如果有，将回调事件加入执行栈中，开始执行回调代码\n\n```\n总结一下：\n\n* JS引擎线程只执行执行栈中的事件\n* 执行栈中的代码执行完毕，就会读取事件队列中的事件\n* 事件队列中的回调事件，是由各自线程插入到事件队列中的\n* 如此循环\n\n## 宏任务、微任务\n当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中`宏任务`、`微任务`\n#### 什么是宏任务\n我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），\n每一个宏任务会从头到尾执行完毕，不会执行其他。\n\n我们前文提到过`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染。\n>宏任务-->渲染-->宏任务-->渲染-->渲染．．．\n\n###### 主代码块，setTimeout，setInterval等，都属于宏任务\n第一个例子：\n```\ndocument.body.style = 'background:black';\ndocument.body.style = 'background:red';\ndocument.body.style = 'background:blue';\ndocument.body.style = 'background:grey';\n```\n我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip)\n我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次`宏任务`，所以全部执行完才触发`页面渲染`，渲染时`GUI线程`会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。\n\n第二个例子:\n```\ndocument.body.style = 'background:blue';\nsetTimeout(function(){\n    document.body.style = 'background:black'\n},0)\n```\n执行一下，再看效果\n![image](https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip)\n我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次`宏任务`，第一次`宏任务`执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色\n\n## 什么是微任务\n\n我们已经知道`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`， 而`微任务`可以理解成在当前`宏任务`执行后立即执行的任务。\n也就是说，当`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完。\n\n###### Promise，process.nextTick等，属于微任务。\n第一个例子：\n```\ndocument.body.style = 'background:blue'\nconsole.log(1);\nPromise.resolve().then(()=>{\n    console.log(2);\n    document.body.style = 'background:black'\n});\nconsole.log(3);\n```\n执行一下，再看效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip)\n\n控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。\n页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染\n第二个例子：\n```\nsetTimeout(() => {\n    console.log(1)\n    Promise.resolve(3).then(data => console.log(data))\n}, 0)\n\nsetTimeout(() => {\n    console.log(2)\n}, 0)\n\n// print : 1 3 2\n```\n\n上面代码共包含两个 `setTimeout` ，也就是说除主代码块外，共有两个`宏任务`，\n其中第一个`宏任务`执行中，输出 1 ，并且创建了`微任务队列`，所以在下一个`宏任务队列`执行前，\n先执行`微任务`，在`微任务`执行中，输出 3 ，`微任务`执行后，执行下一次`宏任务`，执行中输出 2\n## 总结\n* 执行一个`宏任务`（栈中没有就从`事件队列`中获取）\n* 执行过程中如果遇到`微任务`，就将它添加到`微任务`的任务队列中\n* `宏任务`执行完毕后，立即执行当前微`任务队列`中的所有`微任务`（依次执行）\n* 当前`宏任务`执行完毕，开始检查渲染，然后`GUI线程`接管渲染\n* 渲染完毕后，`JS线程`继续接管，开始下一个`宏任务`（从事件队列中获取）\n\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n参考链接：https://juejin.im/post/5d5b4c2df265da03dd3d73e5\n\n","source":"_posts/JS-thread.md","raw":"---\ntitle: 从多线程到Event Loop全面梳理\ndate: 2019-08-21 15:36:08\ntags: js\n---\n\nAuthor: Echo\nTime: 2019-08-21 15:36:08\n\n\n\n## 引言\n几乎在每一本JS相关的书籍中，都会说JS是`单线程`的，JS是通过`事件队列(Event Loop)`的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 `异步`的能力，所以，我试图从`进程`、`线程`的角度来解释这个问题。\n## CPU\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n计算机的核心是`CPU`，它承担了所有的计算任务。\n它就像一座工厂，时刻在运行。\n## 进程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n`进程`就好比工厂的车间，它代表CPU所能处理的单个任务。 `进程`之间相互独立，任一时刻，CPU总是运行一个`进程`，其他`进程`处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个`进程`。\n## 线程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。\n`线程`就好比车间里的工人，一个`进程`可以包括多个`线程`，多个`线程`共享`进程`资源。\n## CPU、进程、线程之间的关系\n从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。\n* `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n* `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n* 不同`进程`之间也可以通信，不过代价较大\n* `单线程`与`多线程`，都是指在一个`进程`内的单和多\n## 浏览器是多进程的\n\n我们已经知道了`CPU`、`进程`、`线程`之间的关系，对于计算机来说，每一个应用程序都是一个`进程`，\n而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过`子进程`来实现的。\n对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。\n而对于浏览器来说，浏览器就是`多进程`的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n如上图，我们可以看到一个Chrome浏览器启动了好多个进程。\n\n总结一下：\n\n* 浏览器是多进程的\n* 每一个Tab页，就是一个独立的进程\n## 浏览器包含了哪些进程\n* 主进程\n>*  协调控制其他子进程（创建、销毁）\n>*  浏览器界面显示，用户交互，前进、后退、收藏\n>*  将渲染进程得到的内存中的Bitmap，绘制到用户界面上\n>*   处理不可见操作，网络请求，文件访问等\n* 第三方插件进程\n>*  每种类型的插件对应一个进程，仅当使用该插件时才创建\n* GPU进程\n>*  用于3D绘制等\n* `渲染进程`，就是我们说的`浏览器内核`\n>*  负责页面渲染，脚本执行，事件处理等\n>*  每个tab页一个渲染进程\n\n那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？\n\n答案是`渲染进程`，也就是我们常说的`浏览器内核`\n## 浏览器内核（渲染进程）\n从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。\n而对于`渲染进程`来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。\n* GUI渲染线程\n>*  负责渲染页面，布局和绘制\n>*  页面需要重绘和回流时，该线程就会执行\n>*  与js引擎线程互斥，防止渲染结果不可预期\n* JS引擎线程\n>*  负责处理解析和执行javascript脚本程序\n>*  只有一个JS引擎线程（单线程）\n>*  与GUI渲染线程互斥，防止渲染结果不可预期\n* 事件触发线程\n>*  用来控制事件循环（鼠标点击、setTimeout、ajax等）\n>*  当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中\n* 定时触发器线程\n>*  setInterval与setTimeout所在的线程\n>*  定时任务并不是由JS引擎计时的，是由定时触发线程来计时的\n>*  计时完毕后，通知事件触发线程\n* 异步http请求线程\n>*  浏览器有一个单独的线程用于处理AJAX请求\n>*  当请求完成时，若有回调函数，通知事件触发线程\n\n当我们了解了渲染进程包含的这些线程后，我们思考两个问题：\n\n1. 为什么 javascript 是单线程的\n2. 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n## 为什么 javascript 是单线程的\n首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。\n\n其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。\n## 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n\n这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，\n那么渲染线程前后获得的元素就可能不一致了。\n因此，为了防止渲染出现不可预期的结果，浏览器设定 `GUI渲染线程`和`JS引擎线程`为互斥关系，\n当JS引擎线程执行时`GUI渲染线程`会被挂起，GUI更新则会被保存在一个队列中等待`JS引擎线程`空闲时立即被执行。\n## 从 Event Loop 看 JS 的运行机制\n到了这里，终于要进入我们的主题，什么是 Event Loop\n先理解一些概念\n* JS 分为同步任务和异步任务\n* 同步任务都在JS引擎线程上执行，形成一个`执行栈`\n* 事件触发线程管理一个`任务队列`，异步任务触发条件达成，将回调事件放到`任务队列`中\n* `执行栈`中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取`任务队列`，将可运行的异步任务回调事件添加到`执行栈`中，开始执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n在前端开发中我们会通过`setTimeout/setInterval`来指定定时任务，会通过`XHR/fetch`发送网络请求， 接下来简述一下`setTimeout/setInterval`和`XHR/fetch`到底做了什么事\n\n我们知道，不管是`setTimeout/setInterval`和`XHR/fetch`代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。\n\n当代码执行到`setTimeout/setInterval`时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而`定时触发器线程`在接收到这个消息后，会在等待的时间后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当代码执行到`XHR/fetch`时，实际上是`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成后的回调事件， 而`异步http请求线程`在接收到这个消息后，会在请求成功后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在`事件队列`中是否有待执行的回调函数，如果有就会加入到执行栈中交给`JS引擎线程`执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n再用代码来解释一下：\n```\nlet timerCallback = function() {\n  console.log('wait one second');\n};\nlet httpCallback = function() {\n  console.log('get server data success');\n}\n\n// 同步任务\nconsole.log('hello');\n// 同步任务\n// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理\n// 1s 后事件触发线程将 timerCallback 加入到事件队列中\nsetTimeout(timerCallback,1000);\n// 同步任务\n// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理\n// 请求成功后事件触发线程将 httpCallback 加入到事件队列中\n$.get('www.xxxx.com',httpCallback);\n// 同步任务\nconsole.log('world');\n//...\n// 所有同步任务执行完后\n// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数\n// 如果没有，一直询问，直到有为止\n// 如果有，将回调事件加入执行栈中，开始执行回调代码\n\n```\n总结一下：\n\n* JS引擎线程只执行执行栈中的事件\n* 执行栈中的代码执行完毕，就会读取事件队列中的事件\n* 事件队列中的回调事件，是由各自线程插入到事件队列中的\n* 如此循环\n\n## 宏任务、微任务\n当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中`宏任务`、`微任务`\n#### 什么是宏任务\n我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），\n每一个宏任务会从头到尾执行完毕，不会执行其他。\n\n我们前文提到过`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染。\n>宏任务-->渲染-->宏任务-->渲染-->渲染．．．\n\n###### 主代码块，setTimeout，setInterval等，都属于宏任务\n第一个例子：\n```\ndocument.body.style = 'background:black';\ndocument.body.style = 'background:red';\ndocument.body.style = 'background:blue';\ndocument.body.style = 'background:grey';\n```\n我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip)\n我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次`宏任务`，所以全部执行完才触发`页面渲染`，渲染时`GUI线程`会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。\n\n第二个例子:\n```\ndocument.body.style = 'background:blue';\nsetTimeout(function(){\n    document.body.style = 'background:black'\n},0)\n```\n执行一下，再看效果\n![image](https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip)\n我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次`宏任务`，第一次`宏任务`执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色\n\n## 什么是微任务\n\n我们已经知道`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`， 而`微任务`可以理解成在当前`宏任务`执行后立即执行的任务。\n也就是说，当`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完。\n\n###### Promise，process.nextTick等，属于微任务。\n第一个例子：\n```\ndocument.body.style = 'background:blue'\nconsole.log(1);\nPromise.resolve().then(()=>{\n    console.log(2);\n    document.body.style = 'background:black'\n});\nconsole.log(3);\n```\n执行一下，再看效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip)\n\n控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。\n页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染\n第二个例子：\n```\nsetTimeout(() => {\n    console.log(1)\n    Promise.resolve(3).then(data => console.log(data))\n}, 0)\n\nsetTimeout(() => {\n    console.log(2)\n}, 0)\n\n// print : 1 3 2\n```\n\n上面代码共包含两个 `setTimeout` ，也就是说除主代码块外，共有两个`宏任务`，\n其中第一个`宏任务`执行中，输出 1 ，并且创建了`微任务队列`，所以在下一个`宏任务队列`执行前，\n先执行`微任务`，在`微任务`执行中，输出 3 ，`微任务`执行后，执行下一次`宏任务`，执行中输出 2\n## 总结\n* 执行一个`宏任务`（栈中没有就从`事件队列`中获取）\n* 执行过程中如果遇到`微任务`，就将它添加到`微任务`的任务队列中\n* `宏任务`执行完毕后，立即执行当前微`任务队列`中的所有`微任务`（依次执行）\n* 当前`宏任务`执行完毕，开始检查渲染，然后`GUI线程`接管渲染\n* 渲染完毕后，`JS线程`继续接管，开始下一个`宏任务`（从事件队列中获取）\n\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n参考链接：https://juejin.im/post/5d5b4c2df265da03dd3d73e5\n\n","slug":"JS-thread","published":1,"updated":"2019-09-17T07:33:44.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4tq0017ygkct4mzlrpp","content":"<p>Author: Echo<br>Time: 2019-08-21 15:36:08</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>几乎在每一本JS相关的书籍中，都会说JS是<code>单线程</code>的，JS是通过<code>事件队列(Event Loop)</code>的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 <code>异步</code>的能力，所以，我试图从<code>进程</code>、<code>线程</code>的角度来解释这个问题。</p>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>计算机的核心是<code>CPU</code>，它承担了所有的计算任务。<br>它就像一座工厂，时刻在运行。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br><code>进程</code>就好比工厂的车间，它代表CPU所能处理的单个任务。 <code>进程</code>之间相互独立，任一时刻，CPU总是运行一个<code>进程</code>，其他<code>进程</code>处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个<code>进程</code>。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。<br><code>线程</code>就好比车间里的工人，一个<code>进程</code>可以包括多个<code>线程</code>，多个<code>线程</code>共享<code>进程</code>资源。</p>\n<h2 id=\"CPU、进程、线程之间的关系\"><a href=\"#CPU、进程、线程之间的关系\" class=\"headerlink\" title=\"CPU、进程、线程之间的关系\"></a>CPU、进程、线程之间的关系</h2><p>从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。</p>\n<ul>\n<li><code>进程</code>是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>\n<li><code>线程</code>是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>\n<li>不同<code>进程</code>之间也可以通信，不过代价较大</li>\n<li><code>单线程</code>与<code>多线程</code>，都是指在一个<code>进程</code>内的单和多<h2 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h2></li>\n</ul>\n<p>我们已经知道了<code>CPU</code>、<code>进程</code>、<code>线程</code>之间的关系，对于计算机来说，每一个应用程序都是一个<code>进程</code>，<br>而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过<code>子进程</code>来实现的。<br>对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。<br>而对于浏览器来说，浏览器就是<code>多进程</code>的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>如上图，我们可以看到一个Chrome浏览器启动了好多个进程。</p>\n<p>总结一下：</p>\n<ul>\n<li>浏览器是多进程的</li>\n<li>每一个Tab页，就是一个独立的进程<h2 id=\"浏览器包含了哪些进程\"><a href=\"#浏览器包含了哪些进程\" class=\"headerlink\" title=\"浏览器包含了哪些进程\"></a>浏览器包含了哪些进程</h2></li>\n<li>主进程<blockquote>\n<ul>\n<li>协调控制其他子进程（创建、销毁）</li>\n<li>浏览器界面显示，用户交互，前进、后退、收藏</li>\n<li>将渲染进程得到的内存中的Bitmap，绘制到用户界面上</li>\n<li>处理不可见操作，网络请求，文件访问等</li>\n</ul>\n</blockquote>\n</li>\n<li>第三方插件进程<blockquote>\n<ul>\n<li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li>\n</ul>\n</blockquote>\n</li>\n<li>GPU进程<blockquote>\n<ul>\n<li>用于3D绘制等</li>\n</ul>\n</blockquote>\n</li>\n<li><code>渲染进程</code>，就是我们说的<code>浏览器内核</code><blockquote>\n<ul>\n<li>负责页面渲染，脚本执行，事件处理等</li>\n<li>每个tab页一个渲染进程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？</p>\n<p>答案是<code>渲染进程</code>，也就是我们常说的<code>浏览器内核</code></p>\n<h2 id=\"浏览器内核（渲染进程）\"><a href=\"#浏览器内核（渲染进程）\" class=\"headerlink\" title=\"浏览器内核（渲染进程）\"></a>浏览器内核（渲染进程）</h2><p>从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。<br>而对于<code>渲染进程</code>来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。</p>\n<ul>\n<li>GUI渲染线程<blockquote>\n<ul>\n<li>负责渲染页面，布局和绘制</li>\n<li>页面需要重绘和回流时，该线程就会执行</li>\n<li>与js引擎线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>JS引擎线程<blockquote>\n<ul>\n<li>负责处理解析和执行javascript脚本程序</li>\n<li>只有一个JS引擎线程（单线程）</li>\n<li>与GUI渲染线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>事件触发线程<blockquote>\n<ul>\n<li>用来控制事件循环（鼠标点击、setTimeout、ajax等）</li>\n<li>当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</li>\n</ul>\n</blockquote>\n</li>\n<li>定时触发器线程<blockquote>\n<ul>\n<li>setInterval与setTimeout所在的线程</li>\n<li>定时任务并不是由JS引擎计时的，是由定时触发线程来计时的</li>\n<li>计时完毕后，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n<li>异步http请求线程<blockquote>\n<ul>\n<li>浏览器有一个单独的线程用于处理AJAX请求</li>\n<li>当请求完成时，若有回调函数，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>当我们了解了渲染进程包含的这些线程后，我们思考两个问题：</p>\n<ol>\n<li>为什么 javascript 是单线程的</li>\n<li>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥<h2 id=\"为什么-javascript-是单线程的\"><a href=\"#为什么-javascript-是单线程的\" class=\"headerlink\" title=\"为什么 javascript 是单线程的\"></a>为什么 javascript 是单线程的</h2>首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。</li>\n</ol>\n<p>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</p>\n<h2 id=\"为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\"><a href=\"#为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\" class=\"headerlink\" title=\"为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\"></a>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥</h2><p>这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，<br>那么渲染线程前后获得的元素就可能不一致了。<br>因此，为了防止渲染出现不可预期的结果，浏览器设定 <code>GUI渲染线程</code>和<code>JS引擎线程</code>为互斥关系，<br>当JS引擎线程执行时<code>GUI渲染线程</code>会被挂起，GUI更新则会被保存在一个队列中等待<code>JS引擎线程</code>空闲时立即被执行。</p>\n<h2 id=\"从-Event-Loop-看-JS-的运行机制\"><a href=\"#从-Event-Loop-看-JS-的运行机制\" class=\"headerlink\" title=\"从 Event Loop 看 JS 的运行机制\"></a>从 Event Loop 看 JS 的运行机制</h2><p>到了这里，终于要进入我们的主题，什么是 Event Loop<br>先理解一些概念</p>\n<ul>\n<li>JS 分为同步任务和异步任务</li>\n<li>同步任务都在JS引擎线程上执行，形成一个<code>执行栈</code></li>\n<li>事件触发线程管理一个<code>任务队列</code>，异步任务触发条件达成，将回调事件放到<code>任务队列</code>中</li>\n<li><code>执行栈</code>中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取<code>任务队列</code>，将可运行的异步任务回调事件添加到<code>执行栈</code>中，开始执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>在前端开发中我们会通过<code>setTimeout/setInterval</code>来指定定时任务，会通过<code>XHR/fetch</code>发送网络请求， 接下来简述一下<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>到底做了什么事</p>\n<p>我们知道，不管是<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。</p>\n<p>当代码执行到<code>setTimeout/setInterval</code>时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而<code>定时触发器线程</code>在接收到这个消息后，会在等待的时间后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当代码执行到<code>XHR/fetch</code>时，实际上是<code>JS引擎线程</code>通知<code>异步http请求线程</code>，发送一个网络请求，并制定请求完成后的回调事件， 而<code>异步http请求线程</code>在接收到这个消息后，会在请求成功后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当我们的同步任务执行完，<code>JS引擎线程</code>会询问<code>事件触发线程</code>，在<code>事件队列</code>中是否有待执行的回调函数，如果有就会加入到执行栈中交给<code>JS引擎线程</code>执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>再用代码来解释一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let timerCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;wait one second&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let httpCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;get server data success&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;hello&apos;);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><br><span class=\"line\">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><br><span class=\"line\">setTimeout(timerCallback,1000);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><br><span class=\"line\">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span><br><span class=\"line\">$.get(&apos;www.xxxx.com&apos;,httpCallback);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;world&apos;);</span><br><span class=\"line\">//...</span><br><span class=\"line\">// 所有同步任务执行完后</span><br><span class=\"line\">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><br><span class=\"line\">// 如果没有，一直询问，直到有为止</span><br><span class=\"line\">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span><br></pre></td></tr></table></figure></p>\n<p>总结一下：</p>\n<ul>\n<li>JS引擎线程只执行执行栈中的事件</li>\n<li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li>\n<li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li>\n<li>如此循环</li>\n</ul>\n<h2 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h2><p>当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中<code>宏任务</code>、<code>微任务</code></p>\n<h4 id=\"什么是宏任务\"><a href=\"#什么是宏任务\" class=\"headerlink\" title=\"什么是宏任务\"></a>什么是宏任务</h4><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），<br>每一个宏任务会从头到尾执行完毕，不会执行其他。</p>\n<p>我们前文提到过<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染。</p>\n<blockquote>\n<p>宏任务–&gt;渲染–&gt;宏任务–&gt;渲染–&gt;渲染．．．</p>\n</blockquote>\n<h6 id=\"主代码块，setTimeout，setInterval等，都属于宏任务\"><a href=\"#主代码块，setTimeout，setInterval等，都属于宏任务\" class=\"headerlink\" title=\"主代码块，setTimeout，setInterval等，都属于宏任务\"></a>主代码块，setTimeout，setInterval等，都属于宏任务</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:black&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:red&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:grey&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次<code>宏任务</code>，所以全部执行完才触发<code>页面渲染</code>，渲染时<code>GUI线程</code>会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。</p>\n<p>第二个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;,0)</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p>\n<h2 id=\"什么是微任务\"><a href=\"#什么是微任务\" class=\"headerlink\" title=\"什么是微任务\"></a>什么是微任务</h2><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而<code>微任务</code>可以理解成在当前<code>宏任务</code>执行后立即执行的任务。<br>也就是说，当<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完。</p>\n<h6 id=\"Promise，process-nextTick等，属于微任务。\"><a href=\"#Promise，process-nextTick等，属于微任务。\" class=\"headerlink\" title=\"Promise，process.nextTick等，属于微任务。\"></a>Promise，process.nextTick等，属于微任务。</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;</span><br><span class=\"line\">console.log(1);</span><br><span class=\"line\">Promise.resolve().then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(3);</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。<br>页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染<br>第二个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">    Promise.resolve(3).then(data =&gt; console.log(data))</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">// print : 1 3 2</span><br></pre></td></tr></table></figure></p>\n<p>上面代码共包含两个 <code>setTimeout</code> ，也就是说除主代码块外，共有两个<code>宏任务</code>，<br>其中第一个<code>宏任务</code>执行中，输出 1 ，并且创建了<code>微任务队列</code>，所以在下一个<code>宏任务队列</code>执行前，<br>先执行<code>微任务</code>，在<code>微任务</code>执行中，输出 3 ，<code>微任务</code>执行后，执行下一次<code>宏任务</code>，执行中输出 2</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>执行一个<code>宏任务</code>（栈中没有就从<code>事件队列</code>中获取）</li>\n<li>执行过程中如果遇到<code>微任务</code>，就将它添加到<code>微任务</code>的任务队列中</li>\n<li><code>宏任务</code>执行完毕后，立即执行当前微<code>任务队列</code>中的所有<code>微任务</code>（依次执行）</li>\n<li>当前<code>宏任务</code>执行完毕，开始检查渲染，然后<code>GUI线程</code>接管渲染</li>\n<li>渲染完毕后，<code>JS线程</code>继续接管，开始下一个<code>宏任务</code>（从事件队列中获取）</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>参考链接：<a href=\"https://juejin.im/post/5d5b4c2df265da03dd3d73e5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d5b4c2df265da03dd3d73e5</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-21 15:36:08</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>几乎在每一本JS相关的书籍中，都会说JS是<code>单线程</code>的，JS是通过<code>事件队列(Event Loop)</code>的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 <code>异步</code>的能力，所以，我试图从<code>进程</code>、<code>线程</code>的角度来解释这个问题。</p>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>计算机的核心是<code>CPU</code>，它承担了所有的计算任务。<br>它就像一座工厂，时刻在运行。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br><code>进程</code>就好比工厂的车间，它代表CPU所能处理的单个任务。 <code>进程</code>之间相互独立，任一时刻，CPU总是运行一个<code>进程</code>，其他<code>进程</code>处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个<code>进程</code>。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。<br><code>线程</code>就好比车间里的工人，一个<code>进程</code>可以包括多个<code>线程</code>，多个<code>线程</code>共享<code>进程</code>资源。</p>\n<h2 id=\"CPU、进程、线程之间的关系\"><a href=\"#CPU、进程、线程之间的关系\" class=\"headerlink\" title=\"CPU、进程、线程之间的关系\"></a>CPU、进程、线程之间的关系</h2><p>从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。</p>\n<ul>\n<li><code>进程</code>是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>\n<li><code>线程</code>是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>\n<li>不同<code>进程</code>之间也可以通信，不过代价较大</li>\n<li><code>单线程</code>与<code>多线程</code>，都是指在一个<code>进程</code>内的单和多<h2 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h2></li>\n</ul>\n<p>我们已经知道了<code>CPU</code>、<code>进程</code>、<code>线程</code>之间的关系，对于计算机来说，每一个应用程序都是一个<code>进程</code>，<br>而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过<code>子进程</code>来实现的。<br>对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。<br>而对于浏览器来说，浏览器就是<code>多进程</code>的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>如上图，我们可以看到一个Chrome浏览器启动了好多个进程。</p>\n<p>总结一下：</p>\n<ul>\n<li>浏览器是多进程的</li>\n<li>每一个Tab页，就是一个独立的进程<h2 id=\"浏览器包含了哪些进程\"><a href=\"#浏览器包含了哪些进程\" class=\"headerlink\" title=\"浏览器包含了哪些进程\"></a>浏览器包含了哪些进程</h2></li>\n<li>主进程<blockquote>\n<ul>\n<li>协调控制其他子进程（创建、销毁）</li>\n<li>浏览器界面显示，用户交互，前进、后退、收藏</li>\n<li>将渲染进程得到的内存中的Bitmap，绘制到用户界面上</li>\n<li>处理不可见操作，网络请求，文件访问等</li>\n</ul>\n</blockquote>\n</li>\n<li>第三方插件进程<blockquote>\n<ul>\n<li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li>\n</ul>\n</blockquote>\n</li>\n<li>GPU进程<blockquote>\n<ul>\n<li>用于3D绘制等</li>\n</ul>\n</blockquote>\n</li>\n<li><code>渲染进程</code>，就是我们说的<code>浏览器内核</code><blockquote>\n<ul>\n<li>负责页面渲染，脚本执行，事件处理等</li>\n<li>每个tab页一个渲染进程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？</p>\n<p>答案是<code>渲染进程</code>，也就是我们常说的<code>浏览器内核</code></p>\n<h2 id=\"浏览器内核（渲染进程）\"><a href=\"#浏览器内核（渲染进程）\" class=\"headerlink\" title=\"浏览器内核（渲染进程）\"></a>浏览器内核（渲染进程）</h2><p>从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。<br>而对于<code>渲染进程</code>来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。</p>\n<ul>\n<li>GUI渲染线程<blockquote>\n<ul>\n<li>负责渲染页面，布局和绘制</li>\n<li>页面需要重绘和回流时，该线程就会执行</li>\n<li>与js引擎线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>JS引擎线程<blockquote>\n<ul>\n<li>负责处理解析和执行javascript脚本程序</li>\n<li>只有一个JS引擎线程（单线程）</li>\n<li>与GUI渲染线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>事件触发线程<blockquote>\n<ul>\n<li>用来控制事件循环（鼠标点击、setTimeout、ajax等）</li>\n<li>当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</li>\n</ul>\n</blockquote>\n</li>\n<li>定时触发器线程<blockquote>\n<ul>\n<li>setInterval与setTimeout所在的线程</li>\n<li>定时任务并不是由JS引擎计时的，是由定时触发线程来计时的</li>\n<li>计时完毕后，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n<li>异步http请求线程<blockquote>\n<ul>\n<li>浏览器有一个单独的线程用于处理AJAX请求</li>\n<li>当请求完成时，若有回调函数，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>当我们了解了渲染进程包含的这些线程后，我们思考两个问题：</p>\n<ol>\n<li>为什么 javascript 是单线程的</li>\n<li>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥<h2 id=\"为什么-javascript-是单线程的\"><a href=\"#为什么-javascript-是单线程的\" class=\"headerlink\" title=\"为什么 javascript 是单线程的\"></a>为什么 javascript 是单线程的</h2>首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。</li>\n</ol>\n<p>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</p>\n<h2 id=\"为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\"><a href=\"#为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\" class=\"headerlink\" title=\"为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\"></a>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥</h2><p>这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，<br>那么渲染线程前后获得的元素就可能不一致了。<br>因此，为了防止渲染出现不可预期的结果，浏览器设定 <code>GUI渲染线程</code>和<code>JS引擎线程</code>为互斥关系，<br>当JS引擎线程执行时<code>GUI渲染线程</code>会被挂起，GUI更新则会被保存在一个队列中等待<code>JS引擎线程</code>空闲时立即被执行。</p>\n<h2 id=\"从-Event-Loop-看-JS-的运行机制\"><a href=\"#从-Event-Loop-看-JS-的运行机制\" class=\"headerlink\" title=\"从 Event Loop 看 JS 的运行机制\"></a>从 Event Loop 看 JS 的运行机制</h2><p>到了这里，终于要进入我们的主题，什么是 Event Loop<br>先理解一些概念</p>\n<ul>\n<li>JS 分为同步任务和异步任务</li>\n<li>同步任务都在JS引擎线程上执行，形成一个<code>执行栈</code></li>\n<li>事件触发线程管理一个<code>任务队列</code>，异步任务触发条件达成，将回调事件放到<code>任务队列</code>中</li>\n<li><code>执行栈</code>中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取<code>任务队列</code>，将可运行的异步任务回调事件添加到<code>执行栈</code>中，开始执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>在前端开发中我们会通过<code>setTimeout/setInterval</code>来指定定时任务，会通过<code>XHR/fetch</code>发送网络请求， 接下来简述一下<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>到底做了什么事</p>\n<p>我们知道，不管是<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。</p>\n<p>当代码执行到<code>setTimeout/setInterval</code>时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而<code>定时触发器线程</code>在接收到这个消息后，会在等待的时间后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当代码执行到<code>XHR/fetch</code>时，实际上是<code>JS引擎线程</code>通知<code>异步http请求线程</code>，发送一个网络请求，并制定请求完成后的回调事件， 而<code>异步http请求线程</code>在接收到这个消息后，会在请求成功后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当我们的同步任务执行完，<code>JS引擎线程</code>会询问<code>事件触发线程</code>，在<code>事件队列</code>中是否有待执行的回调函数，如果有就会加入到执行栈中交给<code>JS引擎线程</code>执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>再用代码来解释一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let timerCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;wait one second&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let httpCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;get server data success&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;hello&apos;);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><br><span class=\"line\">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><br><span class=\"line\">setTimeout(timerCallback,1000);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><br><span class=\"line\">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span><br><span class=\"line\">$.get(&apos;www.xxxx.com&apos;,httpCallback);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;world&apos;);</span><br><span class=\"line\">//...</span><br><span class=\"line\">// 所有同步任务执行完后</span><br><span class=\"line\">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><br><span class=\"line\">// 如果没有，一直询问，直到有为止</span><br><span class=\"line\">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span><br></pre></td></tr></table></figure></p>\n<p>总结一下：</p>\n<ul>\n<li>JS引擎线程只执行执行栈中的事件</li>\n<li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li>\n<li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li>\n<li>如此循环</li>\n</ul>\n<h2 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h2><p>当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中<code>宏任务</code>、<code>微任务</code></p>\n<h4 id=\"什么是宏任务\"><a href=\"#什么是宏任务\" class=\"headerlink\" title=\"什么是宏任务\"></a>什么是宏任务</h4><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），<br>每一个宏任务会从头到尾执行完毕，不会执行其他。</p>\n<p>我们前文提到过<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染。</p>\n<blockquote>\n<p>宏任务–&gt;渲染–&gt;宏任务–&gt;渲染–&gt;渲染．．．</p>\n</blockquote>\n<h6 id=\"主代码块，setTimeout，setInterval等，都属于宏任务\"><a href=\"#主代码块，setTimeout，setInterval等，都属于宏任务\" class=\"headerlink\" title=\"主代码块，setTimeout，setInterval等，都属于宏任务\"></a>主代码块，setTimeout，setInterval等，都属于宏任务</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:black&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:red&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:grey&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次<code>宏任务</code>，所以全部执行完才触发<code>页面渲染</code>，渲染时<code>GUI线程</code>会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。</p>\n<p>第二个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;,0)</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p>\n<h2 id=\"什么是微任务\"><a href=\"#什么是微任务\" class=\"headerlink\" title=\"什么是微任务\"></a>什么是微任务</h2><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而<code>微任务</code>可以理解成在当前<code>宏任务</code>执行后立即执行的任务。<br>也就是说，当<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完。</p>\n<h6 id=\"Promise，process-nextTick等，属于微任务。\"><a href=\"#Promise，process-nextTick等，属于微任务。\" class=\"headerlink\" title=\"Promise，process.nextTick等，属于微任务。\"></a>Promise，process.nextTick等，属于微任务。</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;</span><br><span class=\"line\">console.log(1);</span><br><span class=\"line\">Promise.resolve().then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(3);</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。<br>页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染<br>第二个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">    Promise.resolve(3).then(data =&gt; console.log(data))</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">// print : 1 3 2</span><br></pre></td></tr></table></figure></p>\n<p>上面代码共包含两个 <code>setTimeout</code> ，也就是说除主代码块外，共有两个<code>宏任务</code>，<br>其中第一个<code>宏任务</code>执行中，输出 1 ，并且创建了<code>微任务队列</code>，所以在下一个<code>宏任务队列</code>执行前，<br>先执行<code>微任务</code>，在<code>微任务</code>执行中，输出 3 ，<code>微任务</code>执行后，执行下一次<code>宏任务</code>，执行中输出 2</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>执行一个<code>宏任务</code>（栈中没有就从<code>事件队列</code>中获取）</li>\n<li>执行过程中如果遇到<code>微任务</code>，就将它添加到<code>微任务</code>的任务队列中</li>\n<li><code>宏任务</code>执行完毕后，立即执行当前微<code>任务队列</code>中的所有<code>微任务</code>（依次执行）</li>\n<li>当前<code>宏任务</code>执行完毕，开始检查渲染，然后<code>GUI线程</code>接管渲染</li>\n<li>渲染完毕后，<code>JS线程</code>继续接管，开始下一个<code>宏任务</code>（从事件队列中获取）</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>参考链接：<a href=\"https://juejin.im/post/5d5b4c2df265da03dd3d73e5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d5b4c2df265da03dd3d73e5</a></p>\n"},{"title":"axios封装","date":"2019-09-20T02:50:39.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\n[axios文档地址](https://www.npmjs.com/package/axios)\n\n在vue项目中，和后台交互获取数据这块，我们通常使用的是`axios`库，它是基于`promise`的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如`拦截请求和响应、取消请求、转换json、客户端防御cSRF`等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.\n\n`\n本次封装以vue项目为例做实践。\n`\n##### 安装\n\n```\n$ npm install axios\n```\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n// 或者直接设置成基本变量：\nconst TIMEOUT = 30000;\n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\napi.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api//export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","source":"_posts/axios.md","raw":"---\ntitle: axios封装\ndate: 2019-09-20 10:50:39\ntags: es6, vue\n---\n\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\n[axios文档地址](https://www.npmjs.com/package/axios)\n\n在vue项目中，和后台交互获取数据这块，我们通常使用的是`axios`库，它是基于`promise`的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如`拦截请求和响应、取消请求、转换json、客户端防御cSRF`等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.\n\n`\n本次封装以vue项目为例做实践。\n`\n##### 安装\n\n```\n$ npm install axios\n```\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n// 或者直接设置成基本变量：\nconst TIMEOUT = 30000;\n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\napi.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api//export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","slug":"axios","published":1,"updated":"2019-09-20T03:06:06.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4ts0019ygkc9tu9df92","content":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p><a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios文档地址</a></p>\n<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是<code>axios</code>库，它是基于<code>promise</code>的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如<code>拦截请求和响应、取消请求、转换json、客户端防御cSRF</code>等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.</p>\n<p><code>本次封装以vue项目为例做实践。</code></p>\n<h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install axios</span><br></pre></td></tr></table></figure>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class=\"line\">// 或者直接设置成基本变量：</span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<p>api.js使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api//export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p><a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios文档地址</a></p>\n<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是<code>axios</code>库，它是基于<code>promise</code>的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如<code>拦截请求和响应、取消请求、转换json、客户端防御cSRF</code>等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.</p>\n<p><code>本次封装以vue项目为例做实践。</code></p>\n<h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install axios</span><br></pre></td></tr></table></figure>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class=\"line\">// 或者直接设置成基本变量：</span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<p>api.js使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api//export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n"},{"title":"css相关面试题","date":"2019-09-19T03:27:51.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-19 15:46:24\n\n## 1.什么是 BFC机制\n\nBFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\n* 触发条件 (以下任意一条)\n1. float的值不为none\n2. overflow的值不为visible\n3. display的值为table-cell、tabble-caption和inline-block之一\n4. position的值不为static或则releative中的任何一个\n`\n在IE下, Layout,可通过zoom:1 触发\n`\n* BFC布局与普通文档流布局区别:\n\n###### BFC布局规则:\n1. 浮动的元素会被父级计算高度(父级元素触发了BFC)\n2. 非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)\n3. margin不会传递给父级(父级触发BFC)\n4. 属于同一个BFC的两个相邻元素上下margin会重叠\n1. 普通文档流布局: 浮动的元素是不会被父级计算高度\n2. 非浮动元素会覆盖浮动元素的位置\n3. margin会传递给父级元素\n4. 两个相邻元素上下的margin会重叠\n* 开发中的应用\n1. 阻止margin重叠\n2. 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)\n3. 自适应两栏布局\n4. 可以阻止元素被浮动元素覆盖\n\n## 2. CSS3中新增的选择器以及属性\n\n* 属性选择器\n\n| 属性选择器        | 含义描述    |\n| --------   | -----:  |\n| E[att^=\"val\"]        | 属性att的值以\"val\"开头的元素      |\n| E[att$=\"val\"]        | 属性att的值以\"val\"结尾的元素      |\n| E[att*=\"val\"]        | 属性att的值包含\"val\"字符串的元素     |\n\n* 结构伪类选择器\n\t\n| 选择器        | 含义描述    |\n| --------   | -----:  |\n| E:root       | 匹配文档的根元素，对于HTML文档，就是HTML元素      |\n| E:nth-child(n)       | 匹配其父元素的第n个子元素，第一个编号为1      |\n| E:nth-last-child(n)       | 匹配其父元素的倒数第n个子元素，第一个编号为1     |\n| E:nth-of-type(n)       | 与:nth-child()作用类似，但是仅匹配使用同种标签的元素    |\n| E:nth-last-of-type(n)       | 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素    |\n| E:last-child       | 匹配父元素的最后一个子元素，等同于:nth-last-child(1)    |\n| E:first-of-type       | 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)    |\n| E:last-of-type      | 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)    |\n| E:only-child       | 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)    |\n| E:only-of-type      | 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)   |\n| E:empty     | 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素   |\n\t\ncss3新增属性\n\n| 属性        | 含义描述    | 兼容    |\n| --------   | -----:  | -----:  |\n| transition       | 设置过渡效果      |        |\n| transform       | 变换效果(移动、缩放、转动、拉长或拉伸)      |        |\n| animation       | 动画效果      |        |\n| box-shadow       | 阴影效果      |     FF3.5, Safari 4, Chrome 3   |\n| text-shadow       | 文本阴影      |    FF 3.5, Opera 10, Safari 4, Chrome 3    |\n| border-colors       | 为边框设置多种颜色      |    FF3+    |\n| boder-image       | 图片边框      |    FF 3.5, Safari 4, Chrome 3    |\n| text-overflow       | 文本截断      |    IE6+, Safari4, Chrome3, Opera10    |\n| word-wrap       | 自动换行      |    IE6+, FF 3.5, Safari 4, Chrome 3    |\n| border-radius       | 圆角边框      |    FF 3+, Safari 4 , Chrome 3    |\n| opacity       | 不透明度      |    all    |\n| box-sizing       | 控制盒模型的组成模式      |    FF3+, Opera 10, Safari 4, Chrome 3    |\n| outline       | 外边框      |    FF3+, safari 4, chrome 3, opera 10    |\n| background-size       | 不指定背景图片的尺寸      |    safari 4, chrome 3, opera 10    |\n| background-origin      | 指定背景图片从哪里开始显示      |    safari 4, chrome 3, FF 3+    |\n| background-clip       | 指定背景图片从什么位置开始裁切      |    safari 4, chrome 3    |\n| rgba       | 基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度      |    safari 4, chrome 3, FF3, opera 10    |\n\t\t\n## 3. 居中布局\n\n* 水平居中\n1. 行内元素: text-align:center\n2. 块级元素: margin:0 auto\n3. 绝对定位和移动: absolute + transform\n4. 绝对定位和负边距: absolute + margin\n5. flex布局: flex + justify-content:center\n* 垂直居中\n1. 子元素为单行文本: line-height:height;\n                    absolute + transform;\n                    flex + align-items:center;\n                    table: display:table-cell; vertical-align: middle;\n2. 利用position和top和负margin\n* 水平垂直居中\n\n1. 已知元素宽高:绝对定位+margin:auto:\n  ```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n2. 已知元素宽高:  绝对定位+负margin\n```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n3. absolute+transform\n```\n   div{\n     width: 200px;\n     height: 200px;\n     background: green;\n\n     position:absolute;\n     left:50%;    /* 定位父级的50% */\n     top:50%;\n     transform: translate(-50%,-50%); /*自己的50% */\n   }\n\n```\n4.flex + justify-content + align-items\n```\n.box{\n   height:600px;\n\n   display:flex;\n   justify-content:center;  //子元素水平居中\n   align-items:center;      //子元素垂直居中\n     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/\n    }\n  .box>div{\n    background: green;\n    width: 200px;\n    height: 200px;\n  }\n```\n## 4. 清除浮动有哪些方法, 各有什么优缺点\n\n* 使用clear属性的空元素 \n  在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\" />或<hr class=\"clear\" />来进行清理。\n\n优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大\n\n* 使用css的overflow属性 \n给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden\n\n* 使用CSS的:after伪元素 结合 :after 伪元素\n（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个\tclearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格\"020\"或点\".\"，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。\n\n优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持\n给父级元素设置高度\n简单, 代码少,好掌握 缺点: 只适用于高度固定的布局\n## 5. 用纯CSS创建一个三角形的原理是什么\n\n之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就......回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:\n1. 写一个我们最熟悉的 border应用\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 3px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n效果如下:\n2. 接下来,我们将border值增大\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n很容易发现, border渲染并不是正方形, 而是梯形的.\n\n3. 在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;\n\n4. 设置透明, 隐藏其中三个三角形\n```\n .box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:transparent transparent transparent #ef4848;\n}\n```\n三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid transparent;\n\tborder-left:50px solid #ef4848;\n}\n```\n\n这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用\n\n\n## 6. 实现三栏布局有哪些方法, 分别描述一下\n\n三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:\n\n* Flex 布局\n```\n<style>\n.container{\n  display:flex;\n  justify-content: center;\n  height: 200px;\n  background: #eee;\n}\n.left {\n   width: 200px;\n   background-color: red;\n   height: 100%;\n }\n.main {\n    background-color: yellow;\n    flex: 1;\n}\n.right {\n    width: 200px;\n    background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```\n简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。\n\n* 绝对定位布局\n```\n<style>\n.container {\n  position: relative;\n  background:#eee;\n  height:200px;\n\t}\n.main {\n  height: 200px;\n  margin: 0 120px;\n  background-color: yellow;\n\t}\n.left {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  left: 0;\n  top: 0;\n  background-color: red;\n\t}\n.right {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  background-color: green;\n  right: 0;\n  top: 0;\n}\n</style>\n\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```* \n这种方案也简单实用, 并且可以将 <div class=\"main\"></div>元素放到第一位,使得主要内容优先加载!\n\n双飞翼布局\n```\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}\t\n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n* 圣杯布局\n```\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n```\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。\n\n\n## 7. css3实现0.5px的细线\n```\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<div class=\"line\"></div>\n```\n\n## 8. link 与 @import 的区别\n\n* 从属关系区别\n@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等\n* 加载顺序区别\n加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。\n* 兼容性区别\n@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。\nDOM可控性区别\n可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。\ncss部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他\n## 9. 开发中为什么要初始化css样式\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n10. CSS优化、提高性能的方法有哪些\n\n尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：\n* 内容和样式分离，易于管理和维护\n* 减少页面体积\n* css文件可以被缓存、重用，维护成本降低\n* 不使用@import\n* 避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：\n精简页面的样式文件，去掉不用的样式\n* 利用CSS继承减少代码量\n* 避免！important，可以选择其他选择器\n\n参考链接：http://www.pinlue.com/article/2019/05/2002/158990051021.html","source":"_posts/cssTitle.md","raw":"---\ntitle: css相关面试题\ndate: 2019-09-19 11:27:51\ntags: css\n---\n\nAuthor: Echo\nTime: 2019-09-19 15:46:24\n\n## 1.什么是 BFC机制\n\nBFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\n* 触发条件 (以下任意一条)\n1. float的值不为none\n2. overflow的值不为visible\n3. display的值为table-cell、tabble-caption和inline-block之一\n4. position的值不为static或则releative中的任何一个\n`\n在IE下, Layout,可通过zoom:1 触发\n`\n* BFC布局与普通文档流布局区别:\n\n###### BFC布局规则:\n1. 浮动的元素会被父级计算高度(父级元素触发了BFC)\n2. 非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)\n3. margin不会传递给父级(父级触发BFC)\n4. 属于同一个BFC的两个相邻元素上下margin会重叠\n1. 普通文档流布局: 浮动的元素是不会被父级计算高度\n2. 非浮动元素会覆盖浮动元素的位置\n3. margin会传递给父级元素\n4. 两个相邻元素上下的margin会重叠\n* 开发中的应用\n1. 阻止margin重叠\n2. 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)\n3. 自适应两栏布局\n4. 可以阻止元素被浮动元素覆盖\n\n## 2. CSS3中新增的选择器以及属性\n\n* 属性选择器\n\n| 属性选择器        | 含义描述    |\n| --------   | -----:  |\n| E[att^=\"val\"]        | 属性att的值以\"val\"开头的元素      |\n| E[att$=\"val\"]        | 属性att的值以\"val\"结尾的元素      |\n| E[att*=\"val\"]        | 属性att的值包含\"val\"字符串的元素     |\n\n* 结构伪类选择器\n\t\n| 选择器        | 含义描述    |\n| --------   | -----:  |\n| E:root       | 匹配文档的根元素，对于HTML文档，就是HTML元素      |\n| E:nth-child(n)       | 匹配其父元素的第n个子元素，第一个编号为1      |\n| E:nth-last-child(n)       | 匹配其父元素的倒数第n个子元素，第一个编号为1     |\n| E:nth-of-type(n)       | 与:nth-child()作用类似，但是仅匹配使用同种标签的元素    |\n| E:nth-last-of-type(n)       | 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素    |\n| E:last-child       | 匹配父元素的最后一个子元素，等同于:nth-last-child(1)    |\n| E:first-of-type       | 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)    |\n| E:last-of-type      | 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)    |\n| E:only-child       | 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)    |\n| E:only-of-type      | 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)   |\n| E:empty     | 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素   |\n\t\ncss3新增属性\n\n| 属性        | 含义描述    | 兼容    |\n| --------   | -----:  | -----:  |\n| transition       | 设置过渡效果      |        |\n| transform       | 变换效果(移动、缩放、转动、拉长或拉伸)      |        |\n| animation       | 动画效果      |        |\n| box-shadow       | 阴影效果      |     FF3.5, Safari 4, Chrome 3   |\n| text-shadow       | 文本阴影      |    FF 3.5, Opera 10, Safari 4, Chrome 3    |\n| border-colors       | 为边框设置多种颜色      |    FF3+    |\n| boder-image       | 图片边框      |    FF 3.5, Safari 4, Chrome 3    |\n| text-overflow       | 文本截断      |    IE6+, Safari4, Chrome3, Opera10    |\n| word-wrap       | 自动换行      |    IE6+, FF 3.5, Safari 4, Chrome 3    |\n| border-radius       | 圆角边框      |    FF 3+, Safari 4 , Chrome 3    |\n| opacity       | 不透明度      |    all    |\n| box-sizing       | 控制盒模型的组成模式      |    FF3+, Opera 10, Safari 4, Chrome 3    |\n| outline       | 外边框      |    FF3+, safari 4, chrome 3, opera 10    |\n| background-size       | 不指定背景图片的尺寸      |    safari 4, chrome 3, opera 10    |\n| background-origin      | 指定背景图片从哪里开始显示      |    safari 4, chrome 3, FF 3+    |\n| background-clip       | 指定背景图片从什么位置开始裁切      |    safari 4, chrome 3    |\n| rgba       | 基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度      |    safari 4, chrome 3, FF3, opera 10    |\n\t\t\n## 3. 居中布局\n\n* 水平居中\n1. 行内元素: text-align:center\n2. 块级元素: margin:0 auto\n3. 绝对定位和移动: absolute + transform\n4. 绝对定位和负边距: absolute + margin\n5. flex布局: flex + justify-content:center\n* 垂直居中\n1. 子元素为单行文本: line-height:height;\n                    absolute + transform;\n                    flex + align-items:center;\n                    table: display:table-cell; vertical-align: middle;\n2. 利用position和top和负margin\n* 水平垂直居中\n\n1. 已知元素宽高:绝对定位+margin:auto:\n  ```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n2. 已知元素宽高:  绝对定位+负margin\n```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n3. absolute+transform\n```\n   div{\n     width: 200px;\n     height: 200px;\n     background: green;\n\n     position:absolute;\n     left:50%;    /* 定位父级的50% */\n     top:50%;\n     transform: translate(-50%,-50%); /*自己的50% */\n   }\n\n```\n4.flex + justify-content + align-items\n```\n.box{\n   height:600px;\n\n   display:flex;\n   justify-content:center;  //子元素水平居中\n   align-items:center;      //子元素垂直居中\n     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/\n    }\n  .box>div{\n    background: green;\n    width: 200px;\n    height: 200px;\n  }\n```\n## 4. 清除浮动有哪些方法, 各有什么优缺点\n\n* 使用clear属性的空元素 \n  在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\" />或<hr class=\"clear\" />来进行清理。\n\n优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大\n\n* 使用css的overflow属性 \n给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden\n\n* 使用CSS的:after伪元素 结合 :after 伪元素\n（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个\tclearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格\"020\"或点\".\"，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。\n\n优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持\n给父级元素设置高度\n简单, 代码少,好掌握 缺点: 只适用于高度固定的布局\n## 5. 用纯CSS创建一个三角形的原理是什么\n\n之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就......回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:\n1. 写一个我们最熟悉的 border应用\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 3px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n效果如下:\n2. 接下来,我们将border值增大\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n很容易发现, border渲染并不是正方形, 而是梯形的.\n\n3. 在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;\n\n4. 设置透明, 隐藏其中三个三角形\n```\n .box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:transparent transparent transparent #ef4848;\n}\n```\n三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid transparent;\n\tborder-left:50px solid #ef4848;\n}\n```\n\n这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用\n\n\n## 6. 实现三栏布局有哪些方法, 分别描述一下\n\n三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:\n\n* Flex 布局\n```\n<style>\n.container{\n  display:flex;\n  justify-content: center;\n  height: 200px;\n  background: #eee;\n}\n.left {\n   width: 200px;\n   background-color: red;\n   height: 100%;\n }\n.main {\n    background-color: yellow;\n    flex: 1;\n}\n.right {\n    width: 200px;\n    background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```\n简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。\n\n* 绝对定位布局\n```\n<style>\n.container {\n  position: relative;\n  background:#eee;\n  height:200px;\n\t}\n.main {\n  height: 200px;\n  margin: 0 120px;\n  background-color: yellow;\n\t}\n.left {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  left: 0;\n  top: 0;\n  background-color: red;\n\t}\n.right {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  background-color: green;\n  right: 0;\n  top: 0;\n}\n</style>\n\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```* \n这种方案也简单实用, 并且可以将 <div class=\"main\"></div>元素放到第一位,使得主要内容优先加载!\n\n双飞翼布局\n```\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}\t\n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n* 圣杯布局\n```\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n```\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。\n\n\n## 7. css3实现0.5px的细线\n```\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<div class=\"line\"></div>\n```\n\n## 8. link 与 @import 的区别\n\n* 从属关系区别\n@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等\n* 加载顺序区别\n加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。\n* 兼容性区别\n@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。\nDOM可控性区别\n可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。\ncss部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他\n## 9. 开发中为什么要初始化css样式\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n10. CSS优化、提高性能的方法有哪些\n\n尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：\n* 内容和样式分离，易于管理和维护\n* 减少页面体积\n* css文件可以被缓存、重用，维护成本降低\n* 不使用@import\n* 避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：\n精简页面的样式文件，去掉不用的样式\n* 利用CSS继承减少代码量\n* 避免！important，可以选择其他选择器\n\n参考链接：http://www.pinlue.com/article/2019/05/2002/158990051021.html","slug":"cssTitle","published":1,"updated":"2019-09-19T12:43:37.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4tt001bygkc0clgm77i","content":"<p>Author: Echo<br>Time: 2019-09-19 15:46:24</p>\n<h2 id=\"1-什么是-BFC机制\"><a href=\"#1-什么是-BFC机制\" class=\"headerlink\" title=\"1.什么是 BFC机制\"></a>1.什么是 BFC机制</h2><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>\n<ul>\n<li>触发条件 (以下任意一条)</li>\n</ul>\n<ol>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为table-cell、tabble-caption和inline-block之一</li>\n<li>position的值不为static或则releative中的任何一个<br><code>在IE下, Layout,可通过zoom:1 触发</code></li>\n</ol>\n<ul>\n<li>BFC布局与普通文档流布局区别:</li>\n</ul>\n<h6 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则:\"></a>BFC布局规则:</h6><ol>\n<li>浮动的元素会被父级计算高度(父级元素触发了BFC)</li>\n<li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)</li>\n<li>margin不会传递给父级(父级触发BFC)</li>\n<li>属于同一个BFC的两个相邻元素上下margin会重叠</li>\n<li>普通文档流布局: 浮动的元素是不会被父级计算高度</li>\n<li>非浮动元素会覆盖浮动元素的位置</li>\n<li>margin会传递给父级元素</li>\n<li>两个相邻元素上下的margin会重叠</li>\n</ol>\n<ul>\n<li>开发中的应用</li>\n</ul>\n<ol>\n<li>阻止margin重叠</li>\n<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)</li>\n<li>自适应两栏布局</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n</ol>\n<h2 id=\"2-CSS3中新增的选择器以及属性\"><a href=\"#2-CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"2. CSS3中新增的选择器以及属性\"></a>2. CSS3中新增的选择器以及属性</h2><ul>\n<li>属性选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E[att^=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”开头的元素</td>\n</tr>\n<tr>\n<td>E[att$=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”结尾的元素</td>\n</tr>\n<tr>\n<td>E[att*=”val”]</td>\n<td style=\"text-align:right\">属性att的值包含”val”字符串的元素</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>结构伪类选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E:root</td>\n<td style=\"text-align:right\">匹配文档的根元素，对于HTML文档，就是HTML元素</td>\n</tr>\n<tr>\n<td>E:nth-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-last-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的倒数第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:nth-last-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:last-child</td>\n<td style=\"text-align:right\">匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:first-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>\n</tr>\n<tr>\n<td>E:last-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:only-child</td>\n<td style=\"text-align:right\">匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:only-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:empty</td>\n<td style=\"text-align:right\">匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>\n</tr>\n</tbody>\n</table>\n<p>css3新增属性</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:right\">含义描述</th>\n<th style=\"text-align:right\">兼容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>transition</td>\n<td style=\"text-align:right\">设置过渡效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>transform</td>\n<td style=\"text-align:right\">变换效果(移动、缩放、转动、拉长或拉伸)</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>animation</td>\n<td style=\"text-align:right\">动画效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>box-shadow</td>\n<td style=\"text-align:right\">阴影效果</td>\n<td style=\"text-align:right\">FF3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-shadow</td>\n<td style=\"text-align:right\">文本阴影</td>\n<td style=\"text-align:right\">FF 3.5, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-colors</td>\n<td style=\"text-align:right\">为边框设置多种颜色</td>\n<td style=\"text-align:right\">FF3+</td>\n</tr>\n<tr>\n<td>boder-image</td>\n<td style=\"text-align:right\">图片边框</td>\n<td style=\"text-align:right\">FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-overflow</td>\n<td style=\"text-align:right\">文本截断</td>\n<td style=\"text-align:right\">IE6+, Safari4, Chrome3, Opera10</td>\n</tr>\n<tr>\n<td>word-wrap</td>\n<td style=\"text-align:right\">自动换行</td>\n<td style=\"text-align:right\">IE6+, FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-radius</td>\n<td style=\"text-align:right\">圆角边框</td>\n<td style=\"text-align:right\">FF 3+, Safari 4 , Chrome 3</td>\n</tr>\n<tr>\n<td>opacity</td>\n<td style=\"text-align:right\">不透明度</td>\n<td style=\"text-align:right\">all</td>\n</tr>\n<tr>\n<td>box-sizing</td>\n<td style=\"text-align:right\">控制盒模型的组成模式</td>\n<td style=\"text-align:right\">FF3+, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>outline</td>\n<td style=\"text-align:right\">外边框</td>\n<td style=\"text-align:right\">FF3+, safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-size</td>\n<td style=\"text-align:right\">不指定背景图片的尺寸</td>\n<td style=\"text-align:right\">safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-origin</td>\n<td style=\"text-align:right\">指定背景图片从哪里开始显示</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF 3+</td>\n</tr>\n<tr>\n<td>background-clip</td>\n<td style=\"text-align:right\">指定背景图片从什么位置开始裁切</td>\n<td style=\"text-align:right\">safari 4, chrome 3</td>\n</tr>\n<tr>\n<td>rgba</td>\n<td style=\"text-align:right\">基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF3, opera 10</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-居中布局\"><a href=\"#3-居中布局\" class=\"headerlink\" title=\"3. 居中布局\"></a>3. 居中布局</h2><ul>\n<li>水平居中</li>\n</ul>\n<ol>\n<li>行内元素: text-align:center</li>\n<li>块级元素: margin:0 auto</li>\n<li>绝对定位和移动: absolute + transform</li>\n<li>绝对定位和负边距: absolute + margin</li>\n<li>flex布局: flex + justify-content:center</li>\n</ol>\n<ul>\n<li>垂直居中</li>\n</ul>\n<ol>\n<li>子元素为单行文本: line-height:height;<pre><code>absolute + transform;\nflex + align-items:center;\ntable: display:table-cell; vertical-align: middle;\n</code></pre></li>\n<li>利用position和top和负margin</li>\n</ol>\n<ul>\n<li>水平垂直居中</li>\n</ul>\n<ol>\n<li><p>已知元素宽高:绝对定位+margin:auto:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知元素宽高:  绝对定位+负margin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>absolute+transform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">  position:absolute;</span><br><span class=\"line\">  left:50%;    /* 定位父级的50% */</span><br><span class=\"line\">  top:50%;</span><br><span class=\"line\">  transform: translate(-50%,-50%); /*自己的50% */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.flex + justify-content + align-items<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">   height:600px;</span><br><span class=\"line\"></span><br><span class=\"line\">   display:flex;</span><br><span class=\"line\">   justify-content:center;  //子元素水平居中</span><br><span class=\"line\">   align-items:center;      //子元素垂直居中</span><br><span class=\"line\">     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  .box&gt;div&#123;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-清除浮动有哪些方法-各有什么优缺点\"><a href=\"#4-清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"4. 清除浮动有哪些方法, 各有什么优缺点\"></a>4. 清除浮动有哪些方法, 各有什么优缺点</h2><ul>\n<li>使用clear属性的空元素<br>在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\">或<hr class=\"clear\">来进行清理。</li>\n</ul>\n<p>优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大</p>\n<ul>\n<li>使用css的overflow属性<br>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</li>\n</ul>\n<p>优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden</p>\n<ul>\n<li>使用CSS的:after伪元素 结合 :after 伪元素<br>（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个    clearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</li>\n</ul>\n<p>优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持<br>给父级元素设置高度<br>简单, 代码少,好掌握 缺点: 只适用于高度固定的布局</p>\n<h2 id=\"5-用纯CSS创建一个三角形的原理是什么\"><a href=\"#5-用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"5. 用纯CSS创建一个三角形的原理是什么\"></a>5. 用纯CSS创建一个三角形的原理是什么</h2><p>之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就……回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:</p>\n<ol>\n<li>写一个我们最熟悉的 border应用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 3px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>效果如下:</p>\n<ol start=\"2\">\n<li>接下来,我们将border值增大<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>很容易发现, border渲染并不是正方形, 而是梯形的.</p>\n<ol start=\"3\">\n<li>在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;</p>\n<ol start=\"4\">\n<li>设置透明, 隐藏其中三个三角形<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> .box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:transparent transparent transparent #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid transparent;</span><br><span class=\"line\">\tborder-left:50px solid #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用</p>\n<h2 id=\"6-实现三栏布局有哪些方法-分别描述一下\"><a href=\"#6-实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"6. 实现三栏布局有哪些方法, 分别描述一下\"></a>6. 实现三栏布局有哪些方法, 分别描述一下</h2><p>三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:</p>\n<ul>\n<li>Flex 布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display:flex;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: #eee;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">   width: 200px;</span><br><span class=\"line\">   background-color: red;</span><br><span class=\"line\">   height: 100%;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">    background-color: yellow;</span><br><span class=\"line\">    flex: 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    background-color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。</p>\n<ul>\n<li>绝对定位布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  background:#eee;</span><br><span class=\"line\">  height:200px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  margin: 0 120px;</span><br><span class=\"line\">  background-color: yellow;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  background-color: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background-color: green;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">```* </span><br><span class=\"line\">这种方案也简单实用, 并且可以将 &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;元素放到第一位,使得主要内容优先加载!</span><br><span class=\"line\"></span><br><span class=\"line\">双飞翼布局</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}    \n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 圣杯布局</span><br></pre></td></tr></table></figure>\n\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 7. css3实现0.5px的细线</span><br></pre></td></tr></table></figure>\n\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<p><div class=\"line\"></div><br><code>`</code></p>\n<h2 id=\"8-link-与-import-的区别\"><a href=\"#8-link-与-import-的区别\" class=\"headerlink\" title=\"8. link 与 @import 的区别\"></a>8. link 与 @import 的区别</h2><ul>\n<li>从属关系区别<br>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等</li>\n<li>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</li>\n<li>兼容性区别<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。<br>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。<br>css部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他<h2 id=\"9-开发中为什么要初始化css样式\"><a href=\"#9-开发中为什么要初始化css样式\" class=\"headerlink\" title=\"9. 开发中为什么要初始化css样式\"></a>9. 开发中为什么要初始化css样式</h2></li>\n</ul>\n<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>\n<ol start=\"10\">\n<li>CSS优化、提高性能的方法有哪些</li>\n</ol>\n<p>尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：</p>\n<ul>\n<li>内容和样式分离，易于管理和维护</li>\n<li>减少页面体积</li>\n<li>css文件可以被缓存、重用，维护成本降低</li>\n<li>不使用@import</li>\n<li>避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：<br>精简页面的样式文件，去掉不用的样式</li>\n<li>利用CSS继承减少代码量</li>\n<li>避免！important，可以选择其他选择器</li>\n</ul>\n<p>参考链接：<a href=\"http://www.pinlue.com/article/2019/05/2002/158990051021.html\" target=\"_blank\" rel=\"noopener\">http://www.pinlue.com/article/2019/05/2002/158990051021.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-19 15:46:24</p>\n<h2 id=\"1-什么是-BFC机制\"><a href=\"#1-什么是-BFC机制\" class=\"headerlink\" title=\"1.什么是 BFC机制\"></a>1.什么是 BFC机制</h2><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>\n<ul>\n<li>触发条件 (以下任意一条)</li>\n</ul>\n<ol>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为table-cell、tabble-caption和inline-block之一</li>\n<li>position的值不为static或则releative中的任何一个<br><code>在IE下, Layout,可通过zoom:1 触发</code></li>\n</ol>\n<ul>\n<li>BFC布局与普通文档流布局区别:</li>\n</ul>\n<h6 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则:\"></a>BFC布局规则:</h6><ol>\n<li>浮动的元素会被父级计算高度(父级元素触发了BFC)</li>\n<li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)</li>\n<li>margin不会传递给父级(父级触发BFC)</li>\n<li>属于同一个BFC的两个相邻元素上下margin会重叠</li>\n<li>普通文档流布局: 浮动的元素是不会被父级计算高度</li>\n<li>非浮动元素会覆盖浮动元素的位置</li>\n<li>margin会传递给父级元素</li>\n<li>两个相邻元素上下的margin会重叠</li>\n</ol>\n<ul>\n<li>开发中的应用</li>\n</ul>\n<ol>\n<li>阻止margin重叠</li>\n<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)</li>\n<li>自适应两栏布局</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n</ol>\n<h2 id=\"2-CSS3中新增的选择器以及属性\"><a href=\"#2-CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"2. CSS3中新增的选择器以及属性\"></a>2. CSS3中新增的选择器以及属性</h2><ul>\n<li>属性选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E[att^=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”开头的元素</td>\n</tr>\n<tr>\n<td>E[att$=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”结尾的元素</td>\n</tr>\n<tr>\n<td>E[att*=”val”]</td>\n<td style=\"text-align:right\">属性att的值包含”val”字符串的元素</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>结构伪类选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E:root</td>\n<td style=\"text-align:right\">匹配文档的根元素，对于HTML文档，就是HTML元素</td>\n</tr>\n<tr>\n<td>E:nth-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-last-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的倒数第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:nth-last-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:last-child</td>\n<td style=\"text-align:right\">匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:first-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>\n</tr>\n<tr>\n<td>E:last-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:only-child</td>\n<td style=\"text-align:right\">匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:only-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:empty</td>\n<td style=\"text-align:right\">匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>\n</tr>\n</tbody>\n</table>\n<p>css3新增属性</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:right\">含义描述</th>\n<th style=\"text-align:right\">兼容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>transition</td>\n<td style=\"text-align:right\">设置过渡效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>transform</td>\n<td style=\"text-align:right\">变换效果(移动、缩放、转动、拉长或拉伸)</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>animation</td>\n<td style=\"text-align:right\">动画效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>box-shadow</td>\n<td style=\"text-align:right\">阴影效果</td>\n<td style=\"text-align:right\">FF3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-shadow</td>\n<td style=\"text-align:right\">文本阴影</td>\n<td style=\"text-align:right\">FF 3.5, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-colors</td>\n<td style=\"text-align:right\">为边框设置多种颜色</td>\n<td style=\"text-align:right\">FF3+</td>\n</tr>\n<tr>\n<td>boder-image</td>\n<td style=\"text-align:right\">图片边框</td>\n<td style=\"text-align:right\">FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-overflow</td>\n<td style=\"text-align:right\">文本截断</td>\n<td style=\"text-align:right\">IE6+, Safari4, Chrome3, Opera10</td>\n</tr>\n<tr>\n<td>word-wrap</td>\n<td style=\"text-align:right\">自动换行</td>\n<td style=\"text-align:right\">IE6+, FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-radius</td>\n<td style=\"text-align:right\">圆角边框</td>\n<td style=\"text-align:right\">FF 3+, Safari 4 , Chrome 3</td>\n</tr>\n<tr>\n<td>opacity</td>\n<td style=\"text-align:right\">不透明度</td>\n<td style=\"text-align:right\">all</td>\n</tr>\n<tr>\n<td>box-sizing</td>\n<td style=\"text-align:right\">控制盒模型的组成模式</td>\n<td style=\"text-align:right\">FF3+, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>outline</td>\n<td style=\"text-align:right\">外边框</td>\n<td style=\"text-align:right\">FF3+, safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-size</td>\n<td style=\"text-align:right\">不指定背景图片的尺寸</td>\n<td style=\"text-align:right\">safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-origin</td>\n<td style=\"text-align:right\">指定背景图片从哪里开始显示</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF 3+</td>\n</tr>\n<tr>\n<td>background-clip</td>\n<td style=\"text-align:right\">指定背景图片从什么位置开始裁切</td>\n<td style=\"text-align:right\">safari 4, chrome 3</td>\n</tr>\n<tr>\n<td>rgba</td>\n<td style=\"text-align:right\">基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF3, opera 10</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-居中布局\"><a href=\"#3-居中布局\" class=\"headerlink\" title=\"3. 居中布局\"></a>3. 居中布局</h2><ul>\n<li>水平居中</li>\n</ul>\n<ol>\n<li>行内元素: text-align:center</li>\n<li>块级元素: margin:0 auto</li>\n<li>绝对定位和移动: absolute + transform</li>\n<li>绝对定位和负边距: absolute + margin</li>\n<li>flex布局: flex + justify-content:center</li>\n</ol>\n<ul>\n<li>垂直居中</li>\n</ul>\n<ol>\n<li>子元素为单行文本: line-height:height;<pre><code>absolute + transform;\nflex + align-items:center;\ntable: display:table-cell; vertical-align: middle;\n</code></pre></li>\n<li>利用position和top和负margin</li>\n</ol>\n<ul>\n<li>水平垂直居中</li>\n</ul>\n<ol>\n<li><p>已知元素宽高:绝对定位+margin:auto:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知元素宽高:  绝对定位+负margin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>absolute+transform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">  position:absolute;</span><br><span class=\"line\">  left:50%;    /* 定位父级的50% */</span><br><span class=\"line\">  top:50%;</span><br><span class=\"line\">  transform: translate(-50%,-50%); /*自己的50% */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.flex + justify-content + align-items<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">   height:600px;</span><br><span class=\"line\"></span><br><span class=\"line\">   display:flex;</span><br><span class=\"line\">   justify-content:center;  //子元素水平居中</span><br><span class=\"line\">   align-items:center;      //子元素垂直居中</span><br><span class=\"line\">     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  .box&gt;div&#123;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-清除浮动有哪些方法-各有什么优缺点\"><a href=\"#4-清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"4. 清除浮动有哪些方法, 各有什么优缺点\"></a>4. 清除浮动有哪些方法, 各有什么优缺点</h2><ul>\n<li>使用clear属性的空元素<br>在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\">或<hr class=\"clear\">来进行清理。</li>\n</ul>\n<p>优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大</p>\n<ul>\n<li>使用css的overflow属性<br>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</li>\n</ul>\n<p>优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden</p>\n<ul>\n<li>使用CSS的:after伪元素 结合 :after 伪元素<br>（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个    clearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</li>\n</ul>\n<p>优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持<br>给父级元素设置高度<br>简单, 代码少,好掌握 缺点: 只适用于高度固定的布局</p>\n<h2 id=\"5-用纯CSS创建一个三角形的原理是什么\"><a href=\"#5-用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"5. 用纯CSS创建一个三角形的原理是什么\"></a>5. 用纯CSS创建一个三角形的原理是什么</h2><p>之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就……回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:</p>\n<ol>\n<li>写一个我们最熟悉的 border应用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 3px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>效果如下:</p>\n<ol start=\"2\">\n<li>接下来,我们将border值增大<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>很容易发现, border渲染并不是正方形, 而是梯形的.</p>\n<ol start=\"3\">\n<li>在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;</p>\n<ol start=\"4\">\n<li>设置透明, 隐藏其中三个三角形<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> .box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:transparent transparent transparent #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid transparent;</span><br><span class=\"line\">\tborder-left:50px solid #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用</p>\n<h2 id=\"6-实现三栏布局有哪些方法-分别描述一下\"><a href=\"#6-实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"6. 实现三栏布局有哪些方法, 分别描述一下\"></a>6. 实现三栏布局有哪些方法, 分别描述一下</h2><p>三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:</p>\n<ul>\n<li>Flex 布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display:flex;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: #eee;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">   width: 200px;</span><br><span class=\"line\">   background-color: red;</span><br><span class=\"line\">   height: 100%;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">    background-color: yellow;</span><br><span class=\"line\">    flex: 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    background-color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。</p>\n<ul>\n<li>绝对定位布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  background:#eee;</span><br><span class=\"line\">  height:200px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  margin: 0 120px;</span><br><span class=\"line\">  background-color: yellow;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  background-color: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background-color: green;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">```* </span><br><span class=\"line\">这种方案也简单实用, 并且可以将 &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;元素放到第一位,使得主要内容优先加载!</span><br><span class=\"line\"></span><br><span class=\"line\">双飞翼布局</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}    \n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 圣杯布局</span><br></pre></td></tr></table></figure>\n\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 7. css3实现0.5px的细线</span><br></pre></td></tr></table></figure>\n\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<p><div class=\"line\"></div><br><code>`</code></p>\n<h2 id=\"8-link-与-import-的区别\"><a href=\"#8-link-与-import-的区别\" class=\"headerlink\" title=\"8. link 与 @import 的区别\"></a>8. link 与 @import 的区别</h2><ul>\n<li>从属关系区别<br>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等</li>\n<li>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</li>\n<li>兼容性区别<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。<br>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。<br>css部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他<h2 id=\"9-开发中为什么要初始化css样式\"><a href=\"#9-开发中为什么要初始化css样式\" class=\"headerlink\" title=\"9. 开发中为什么要初始化css样式\"></a>9. 开发中为什么要初始化css样式</h2></li>\n</ul>\n<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>\n<ol start=\"10\">\n<li>CSS优化、提高性能的方法有哪些</li>\n</ol>\n<p>尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：</p>\n<ul>\n<li>内容和样式分离，易于管理和维护</li>\n<li>减少页面体积</li>\n<li>css文件可以被缓存、重用，维护成本降低</li>\n<li>不使用@import</li>\n<li>避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：<br>精简页面的样式文件，去掉不用的样式</li>\n<li>利用CSS继承减少代码量</li>\n<li>避免！important，可以选择其他选择器</li>\n</ul>\n<p>参考链接：<a href=\"http://www.pinlue.com/article/2019/05/2002/158990051021.html\" target=\"_blank\" rel=\"noopener\">http://www.pinlue.com/article/2019/05/2002/158990051021.html</a></p>\n"},{"title":"模拟element-ui写message组件思路","date":"2019-08-15T08:05:21.000Z","_content":"Author: Echo\nTime: 2019-08-15 16:05:21\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 写一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 写一个 message.js\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行一下代码：\n![image](https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n再见吧！\n\n参考 连接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n","source":"_posts/message-comp.md","raw":"---\ntitle: 模拟element-ui写message组件思路\ndate: 2019-08-15 16:05:21\ntags: vue\n---\nAuthor: Echo\nTime: 2019-08-15 16:05:21\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 写一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 写一个 message.js\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行一下代码：\n![image](https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n再见吧！\n\n参考 连接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n","slug":"message-comp","published":1,"updated":"2019-09-19T12:10:37.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4tu001dygkcjtjb0etr","content":"<p>Author: Echo<br>Time: 2019-08-15 16:05:21</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"写一个-message-组件\"><a href=\"#写一个-message-组件\" class=\"headerlink\" title=\"写一个 message 组件\"></a>写一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"写一个-message-js\"><a href=\"#写一个-message-js\" class=\"headerlink\" title=\"写一个 message.js\"></a>写一个 message.js</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>运行一下代码：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"duration-lt-0-message一直存在\"><a href=\"#duration-lt-0-message一直存在\" class=\"headerlink\" title=\"duration &lt;= 0,message一直存在\"></a>duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>再见吧！</p>\n<p>参考 连接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-15 16:05:21</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"写一个-message-组件\"><a href=\"#写一个-message-组件\" class=\"headerlink\" title=\"写一个 message 组件\"></a>写一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"写一个-message-js\"><a href=\"#写一个-message-js\" class=\"headerlink\" title=\"写一个 message.js\"></a>写一个 message.js</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>运行一下代码：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"duration-lt-0-message一直存在\"><a href=\"#duration-lt-0-message一直存在\" class=\"headerlink\" title=\"duration &lt;= 0,message一直存在\"></a>duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>再见吧！</p>\n<p>参考 连接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n"},{"title":"node 基础知识","date":"2019-08-14T07:37:18.000Z","_content":"Author: Echo\nTime: 2019-08-14 15:37:18\n\n# 有助于理解前端工具的 node 知识\n\n## 缘起\n平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。\n想想我们是不是时常看到过这种东西：`const path = require('path');`。\n假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。\n后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。\n言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。\n ## node 初识\n#### node 是什么\n首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。\n#### node 遵循的规范\n其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：\n```\nrequire('./module')\nmodule.exports = {\n    a: 1,\n}\nexports.a = 1;\n\n```\n这就是 node 的规范，用` require` 导入、用 `module.exports` 导出。那 node 为什么不支持 ESM（就是用 `import` 导入、用 `export` 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 `require()` 字样却没有看见 `import()`就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 `require()`。\n\n这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：\n\n![16ad4be6bc803f68.png](https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## require 寻找依赖\nrequire() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：\n```\nrequire('./module'); // 带相对路径\nrequire('/module'); // 带绝对路径\nrequire('module'); // 不带路径\n```\n这种不带路径的 `require('module') `引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。\n\n另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。\n## node 模块包装\nnode 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：\n```\n(function(exports, require, module, __filename, __dirname) {\n    // module: 表示当前模块\n    // __filename: 当前模块的带有完整绝对路径的文件名\n    // __dirname: 当前模块的完整绝对路径\n    module.exports = exports = this = {};\n    // 我们的代码就在这里...\n    return module.exports;\n})()\n```\n想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。\n## node 的应用场景\n一般来说，node 主要应用于以下几个方面：\n\n* 自动化构建等工具\n* 中间层\n* 小项目\n\n第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。\n## node 的优点\n\n* 适合前端大大们\n* 基于事件驱动和无阻塞的I/O（适合处理并发请求）\n* 性能较好（别人做过性能分析）\n\n## node 内置模块\nok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。\n### http 模块\n这是 node 最最基础的功能了，我们用 `node http.js` 运行一下下面的文件就能开启一个服务器，在浏览器中输入 `http://localhost:8888` 即可访问，http.js 具体内容如下：\n```\n// http.js\nconst http = require('http');\nhttp.createServer((req, res) => { // 开启一个服务\n  console.log('请求来了'); // 如果你打开 http://localhost:8888，控制台就会打印此消息\n  res.write('hello'); // 返回给页面的值，也就是页面会显示 hello\n  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态\n}).listen(8888); // 端口号\n```\n### fs 文件系统\n\n由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 `<input type='file'>`），但是需要用户手动操作才行。\n但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：\n\n```\nconst fs = require('fs');\n\n// 写入文件：fs.writeFile(path, fileData, cb);\nfs.writeFile('./text.txt', 'hello xr!', err => {\n  if (err) {\n    console.log('写入失败', err);\n  } else {\n    console.log('写入成功');\n  }\n});\n\n// 读取文件：fs.readFile(path, cb);\nfs.readFile('./text.txt', (err, fileData) => {\n  if (err) {\n    console.log('读取失败', err);\n  } else {\n    console.log('读取成功', fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下\n  }\n});\n```\n\n需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em...就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 `toString()` 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 `toString()` 转换的话会丢失掉原始信息，所以不能乱转。二进制和 `toString` 的效果就像下面这样：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。\n## path 路径\n这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：\n```\nconst path = require('path');\n\nlet str = '/root/a/b/index.html';\nconsole.log(path.dirname(str)); // 路径\n// /root/a/b\nconsole.log(path.extname(str)); // 后缀名\n// .html\nconsole.log(path.basename(str)); // 文件名\n// index.html\n\n// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径\nlet pathOne = path.resolve('rooot/a/b', '../c', 'd', '..', 'e');\n\n// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录\nlet pathTwo = path.resolve(__dirname, 'build'); // 这个用法很常见，你应该在 webpack 中有见过\n\nconsole.log(pathOne, pathTwo, __dirname);\n// pathOne  =>  /Users/lgq/Desktop/node/rooot/a/c/e\n// pathTwo  =>  /Users/lgq/Desktop/node/build\n// __dirname  =>  /Users/lgq/Desktop/node\n```\n嗯，下次看到 path 这个东西就不会迷茫了。\n### url 模块\n\n很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：\n\n```\nconst url = require('url');\n\nlet site = 'http://www.xr.com/a/b/index.html?a=1&b=2';\nlet { pathname, query } = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象\n\nconsole.log(pathname, query);\n// /a/b/index.html  { a: '1', b: '2' }\n```\n\n### querystring 查询字符串\n\n这个主要是用来把形如这样的字符串 `a=1&b=2&c=3`（&和=可以换成别的）解析成 `{ a: '1', b: '2', c: '3' }` 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：\n\n```\nconst querystring = require('querystring');\n\nlet query = 'a=1&b=2&c=3'; // 形如这样的字符串就能被解析\nlet obj = querystring.parse(query);\nconsole.log(obj, obj.a); // { a: '1', b: '2', c: '3' }   '1'\n\nquery = 'a=1&b=2&c=3&a=3'; // 如果参数重复，其所对应的值会变成数组\nobj = querystring.parse(query);\nconsole.log(obj); // { a: [ '1', '3' ], b: '2', c: '3' }\n\n// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串\nquery = querystring.stringify(obj);\nconsole.log(query); // a=1&a=3&b=2&c=3\n```\n\n### assert 断言\n\n这个我们直接看下面代码就知道它的作用了：\n\n```\n// assert.js\nconst assert = require('assert');\n\n// assert(条件，错误消息)，条件这部分会返回一个布尔值\nassert(2 < 1, '断言失败');\n```\n\n`node assert.js` 运行一下代码就能看到如下结果：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 `false` 则阻止程序运行，并抛出一个错误，如果返回值为 `true` 则继续执行，一般用于函数中间和参数判断。\n另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：\n\n```\n// assert.js\nconst assert = require('assert');\n\nconst obj1 = { a: { b: 1 } };\nconst obj2 = { a: { b: 1 } };\nconst obj3 = { a: { b: '1' } };\n\n// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值\n// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值\n// 同样也是错误的时候抛出信息，正确的时候继续默默执行\nassert.deepEqual(obj1, obj2, '不等哦'); // true\nassert.deepEqual(obj1, obj3, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj2, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj3, '不等哦'); // false，这个会抛出错误信息\n```\n\n### stream 流\n\nstream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 `fs.readFile` 和 `fs.writeFile` 的升级版。\n我们要知道 `readFile` 和 `writeFile` 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。\n\n```\nconst fs = require('fs');\n\n// 读取流：fs.createReadStream();\n// 写入流：fs.createWriteStream();\nlet rs = fs.createReadStream('a.txt'); // 要读取的文件\nlet ws = fs.createWriteStream('a2.txt'); // 输出的文件\n\nrs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n\n```\n\n流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。\n\n### zlib 压缩\n\n这个用法简单，作用也明了，直接看下面的代码就能理解：\n\n```\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nlet rs = fs.createReadStream('tree.jpg');\nlet gz = zlib.createGzip();\nlet ws = fs.createWriteStream('tree.jpg.gz');\n\nrs.pipe(gz).pipe(ws);  // 原始文件 => 压缩 => 写入\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n```\n\n## 小结\n\nok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。\n参考作者：尤水就下\n参考链接：https://juejin.im/post/5ccacfb96fb9a03201243cb9","source":"_posts/nodeBasics.md","raw":"---\ntitle: node 基础知识\ndate: 2019-08-14 15:37:18\ntags: node\n---\nAuthor: Echo\nTime: 2019-08-14 15:37:18\n\n# 有助于理解前端工具的 node 知识\n\n## 缘起\n平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。\n想想我们是不是时常看到过这种东西：`const path = require('path');`。\n假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。\n后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。\n言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。\n ## node 初识\n#### node 是什么\n首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。\n#### node 遵循的规范\n其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：\n```\nrequire('./module')\nmodule.exports = {\n    a: 1,\n}\nexports.a = 1;\n\n```\n这就是 node 的规范，用` require` 导入、用 `module.exports` 导出。那 node 为什么不支持 ESM（就是用 `import` 导入、用 `export` 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 `require()` 字样却没有看见 `import()`就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 `require()`。\n\n这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：\n\n![16ad4be6bc803f68.png](https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## require 寻找依赖\nrequire() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：\n```\nrequire('./module'); // 带相对路径\nrequire('/module'); // 带绝对路径\nrequire('module'); // 不带路径\n```\n这种不带路径的 `require('module') `引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。\n\n另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。\n## node 模块包装\nnode 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：\n```\n(function(exports, require, module, __filename, __dirname) {\n    // module: 表示当前模块\n    // __filename: 当前模块的带有完整绝对路径的文件名\n    // __dirname: 当前模块的完整绝对路径\n    module.exports = exports = this = {};\n    // 我们的代码就在这里...\n    return module.exports;\n})()\n```\n想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。\n## node 的应用场景\n一般来说，node 主要应用于以下几个方面：\n\n* 自动化构建等工具\n* 中间层\n* 小项目\n\n第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。\n## node 的优点\n\n* 适合前端大大们\n* 基于事件驱动和无阻塞的I/O（适合处理并发请求）\n* 性能较好（别人做过性能分析）\n\n## node 内置模块\nok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。\n### http 模块\n这是 node 最最基础的功能了，我们用 `node http.js` 运行一下下面的文件就能开启一个服务器，在浏览器中输入 `http://localhost:8888` 即可访问，http.js 具体内容如下：\n```\n// http.js\nconst http = require('http');\nhttp.createServer((req, res) => { // 开启一个服务\n  console.log('请求来了'); // 如果你打开 http://localhost:8888，控制台就会打印此消息\n  res.write('hello'); // 返回给页面的值，也就是页面会显示 hello\n  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态\n}).listen(8888); // 端口号\n```\n### fs 文件系统\n\n由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 `<input type='file'>`），但是需要用户手动操作才行。\n但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：\n\n```\nconst fs = require('fs');\n\n// 写入文件：fs.writeFile(path, fileData, cb);\nfs.writeFile('./text.txt', 'hello xr!', err => {\n  if (err) {\n    console.log('写入失败', err);\n  } else {\n    console.log('写入成功');\n  }\n});\n\n// 读取文件：fs.readFile(path, cb);\nfs.readFile('./text.txt', (err, fileData) => {\n  if (err) {\n    console.log('读取失败', err);\n  } else {\n    console.log('读取成功', fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下\n  }\n});\n```\n\n需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em...就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 `toString()` 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 `toString()` 转换的话会丢失掉原始信息，所以不能乱转。二进制和 `toString` 的效果就像下面这样：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。\n## path 路径\n这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：\n```\nconst path = require('path');\n\nlet str = '/root/a/b/index.html';\nconsole.log(path.dirname(str)); // 路径\n// /root/a/b\nconsole.log(path.extname(str)); // 后缀名\n// .html\nconsole.log(path.basename(str)); // 文件名\n// index.html\n\n// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径\nlet pathOne = path.resolve('rooot/a/b', '../c', 'd', '..', 'e');\n\n// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录\nlet pathTwo = path.resolve(__dirname, 'build'); // 这个用法很常见，你应该在 webpack 中有见过\n\nconsole.log(pathOne, pathTwo, __dirname);\n// pathOne  =>  /Users/lgq/Desktop/node/rooot/a/c/e\n// pathTwo  =>  /Users/lgq/Desktop/node/build\n// __dirname  =>  /Users/lgq/Desktop/node\n```\n嗯，下次看到 path 这个东西就不会迷茫了。\n### url 模块\n\n很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：\n\n```\nconst url = require('url');\n\nlet site = 'http://www.xr.com/a/b/index.html?a=1&b=2';\nlet { pathname, query } = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象\n\nconsole.log(pathname, query);\n// /a/b/index.html  { a: '1', b: '2' }\n```\n\n### querystring 查询字符串\n\n这个主要是用来把形如这样的字符串 `a=1&b=2&c=3`（&和=可以换成别的）解析成 `{ a: '1', b: '2', c: '3' }` 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：\n\n```\nconst querystring = require('querystring');\n\nlet query = 'a=1&b=2&c=3'; // 形如这样的字符串就能被解析\nlet obj = querystring.parse(query);\nconsole.log(obj, obj.a); // { a: '1', b: '2', c: '3' }   '1'\n\nquery = 'a=1&b=2&c=3&a=3'; // 如果参数重复，其所对应的值会变成数组\nobj = querystring.parse(query);\nconsole.log(obj); // { a: [ '1', '3' ], b: '2', c: '3' }\n\n// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串\nquery = querystring.stringify(obj);\nconsole.log(query); // a=1&a=3&b=2&c=3\n```\n\n### assert 断言\n\n这个我们直接看下面代码就知道它的作用了：\n\n```\n// assert.js\nconst assert = require('assert');\n\n// assert(条件，错误消息)，条件这部分会返回一个布尔值\nassert(2 < 1, '断言失败');\n```\n\n`node assert.js` 运行一下代码就能看到如下结果：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 `false` 则阻止程序运行，并抛出一个错误，如果返回值为 `true` 则继续执行，一般用于函数中间和参数判断。\n另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：\n\n```\n// assert.js\nconst assert = require('assert');\n\nconst obj1 = { a: { b: 1 } };\nconst obj2 = { a: { b: 1 } };\nconst obj3 = { a: { b: '1' } };\n\n// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值\n// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值\n// 同样也是错误的时候抛出信息，正确的时候继续默默执行\nassert.deepEqual(obj1, obj2, '不等哦'); // true\nassert.deepEqual(obj1, obj3, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj2, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj3, '不等哦'); // false，这个会抛出错误信息\n```\n\n### stream 流\n\nstream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 `fs.readFile` 和 `fs.writeFile` 的升级版。\n我们要知道 `readFile` 和 `writeFile` 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。\n\n```\nconst fs = require('fs');\n\n// 读取流：fs.createReadStream();\n// 写入流：fs.createWriteStream();\nlet rs = fs.createReadStream('a.txt'); // 要读取的文件\nlet ws = fs.createWriteStream('a2.txt'); // 输出的文件\n\nrs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n\n```\n\n流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。\n\n### zlib 压缩\n\n这个用法简单，作用也明了，直接看下面的代码就能理解：\n\n```\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nlet rs = fs.createReadStream('tree.jpg');\nlet gz = zlib.createGzip();\nlet ws = fs.createWriteStream('tree.jpg.gz');\n\nrs.pipe(gz).pipe(ws);  // 原始文件 => 压缩 => 写入\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n```\n\n## 小结\n\nok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。\n参考作者：尤水就下\n参考链接：https://juejin.im/post/5ccacfb96fb9a03201243cb9","slug":"nodeBasics","published":1,"updated":"2019-08-21T07:39:40.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4tv001eygkcmbzyp7ij","content":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h1 id=\"有助于理解前端工具的-node-知识\"><a href=\"#有助于理解前端工具的-node-知识\" class=\"headerlink\" title=\"有助于理解前端工具的 node 知识\"></a>有助于理解前端工具的 node 知识</h1><h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>\n<h2 id=\"node-初识\"><a href=\"#node-初识\" class=\"headerlink\" title=\"node 初识\"></a>node 初识</h2><h4 id=\"node-是什么\"><a href=\"#node-是什么\" class=\"headerlink\" title=\"node 是什么\"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>\n<h4 id=\"node-遵循的规范\"><a href=\"#node-遵循的规范\" class=\"headerlink\" title=\"node 遵循的规范\"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    a: 1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.a = 1;</span><br></pre></td></tr></table></figure></p>\n<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>\n<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"16ad4be6bc803f68.png\"></p>\n<h2 id=\"require-寻找依赖\"><a href=\"#require-寻找依赖\" class=\"headerlink\" title=\"require 寻找依赖\"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;); // 带相对路径</span><br><span class=\"line\">require(&apos;/module&apos;); // 带绝对路径</span><br><span class=\"line\">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>\n<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>\n<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>\n<h2 id=\"node-模块包装\"><a href=\"#node-模块包装\" class=\"headerlink\" title=\"node 模块包装\"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">    // module: 表示当前模块</span><br><span class=\"line\">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class=\"line\">    // __dirname: 当前模块的完整绝对路径</span><br><span class=\"line\">    module.exports = exports = this = &#123;&#125;;</span><br><span class=\"line\">    // 我们的代码就在这里...</span><br><span class=\"line\">    return module.exports;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>\n<h2 id=\"node-的应用场景\"><a href=\"#node-的应用场景\" class=\"headerlink\" title=\"node 的应用场景\"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>\n<ul>\n<li>自动化构建等工具</li>\n<li>中间层</li>\n<li>小项目</li>\n</ul>\n<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>\n<h2 id=\"node-的优点\"><a href=\"#node-的优点\" class=\"headerlink\" title=\"node 的优点\"></a>node 的优点</h2><ul>\n<li>适合前端大大们</li>\n<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>\n<li>性能较好（别人做过性能分析）</li>\n</ul>\n<h2 id=\"node-内置模块\"><a href=\"#node-内置模块\" class=\"headerlink\" title=\"node 内置模块\"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>\n<h3 id=\"http-模块\"><a href=\"#http-模块\" class=\"headerlink\" title=\"http 模块\"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http.js</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class=\"line\">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class=\"line\">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class=\"line\">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class=\"line\">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"fs-文件系统\"><a href=\"#fs-文件系统\" class=\"headerlink\" title=\"fs 文件系统\"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class=\"line\">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;写入失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;写入成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取文件：fs.readFile(path, cb);</span><br><span class=\"line\">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;读取失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>\n<h2 id=\"path-路径\"><a href=\"#path-路径\" class=\"headerlink\" title=\"path 路径\"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class=\"line\">console.log(path.dirname(str)); // 路径</span><br><span class=\"line\">// /root/a/b</span><br><span class=\"line\">console.log(path.extname(str)); // 后缀名</span><br><span class=\"line\">// .html</span><br><span class=\"line\">console.log(path.basename(str)); // 文件名</span><br><span class=\"line\">// index.html</span><br><span class=\"line\"></span><br><span class=\"line\">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class=\"line\">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class=\"line\">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathOne, pathTwo, __dirname);</span><br><span class=\"line\">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class=\"line\">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class=\"line\">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>\n<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>\n<h3 id=\"url-模块\"><a href=\"#url-模块\" class=\"headerlink\" title=\"url 模块\"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = require(&apos;url&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class=\"line\">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathname, query);</span><br><span class=\"line\">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"querystring-查询字符串\"><a href=\"#querystring-查询字符串\" class=\"headerlink\" title=\"querystring 查询字符串\"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring = require(&apos;querystring&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class=\"line\">let obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class=\"line\">obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class=\"line\">query = querystring.stringify(obj);</span><br><span class=\"line\">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert 断言\"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class=\"line\">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>\n<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class=\"line\">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class=\"line\">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class=\"line\">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"stream-流\"><a href=\"#stream-流\" class=\"headerlink\" title=\"stream 流\"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取流：fs.createReadStream();</span><br><span class=\"line\">// 写入流：fs.createWriteStream();</span><br><span class=\"line\">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>\n<h3 id=\"zlib-压缩\"><a href=\"#zlib-压缩\" class=\"headerlink\" title=\"zlib 压缩\"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const zlib = require(&apos;zlib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class=\"line\">let gz = zlib.createGzip();</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href=\"https://juejin.im/post/5ccacfb96fb9a03201243cb9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h1 id=\"有助于理解前端工具的-node-知识\"><a href=\"#有助于理解前端工具的-node-知识\" class=\"headerlink\" title=\"有助于理解前端工具的 node 知识\"></a>有助于理解前端工具的 node 知识</h1><h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>\n<h2 id=\"node-初识\"><a href=\"#node-初识\" class=\"headerlink\" title=\"node 初识\"></a>node 初识</h2><h4 id=\"node-是什么\"><a href=\"#node-是什么\" class=\"headerlink\" title=\"node 是什么\"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>\n<h4 id=\"node-遵循的规范\"><a href=\"#node-遵循的规范\" class=\"headerlink\" title=\"node 遵循的规范\"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    a: 1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.a = 1;</span><br></pre></td></tr></table></figure></p>\n<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>\n<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"16ad4be6bc803f68.png\"></p>\n<h2 id=\"require-寻找依赖\"><a href=\"#require-寻找依赖\" class=\"headerlink\" title=\"require 寻找依赖\"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;); // 带相对路径</span><br><span class=\"line\">require(&apos;/module&apos;); // 带绝对路径</span><br><span class=\"line\">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>\n<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>\n<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>\n<h2 id=\"node-模块包装\"><a href=\"#node-模块包装\" class=\"headerlink\" title=\"node 模块包装\"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">    // module: 表示当前模块</span><br><span class=\"line\">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class=\"line\">    // __dirname: 当前模块的完整绝对路径</span><br><span class=\"line\">    module.exports = exports = this = &#123;&#125;;</span><br><span class=\"line\">    // 我们的代码就在这里...</span><br><span class=\"line\">    return module.exports;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>\n<h2 id=\"node-的应用场景\"><a href=\"#node-的应用场景\" class=\"headerlink\" title=\"node 的应用场景\"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>\n<ul>\n<li>自动化构建等工具</li>\n<li>中间层</li>\n<li>小项目</li>\n</ul>\n<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>\n<h2 id=\"node-的优点\"><a href=\"#node-的优点\" class=\"headerlink\" title=\"node 的优点\"></a>node 的优点</h2><ul>\n<li>适合前端大大们</li>\n<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>\n<li>性能较好（别人做过性能分析）</li>\n</ul>\n<h2 id=\"node-内置模块\"><a href=\"#node-内置模块\" class=\"headerlink\" title=\"node 内置模块\"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>\n<h3 id=\"http-模块\"><a href=\"#http-模块\" class=\"headerlink\" title=\"http 模块\"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http.js</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class=\"line\">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class=\"line\">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class=\"line\">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class=\"line\">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"fs-文件系统\"><a href=\"#fs-文件系统\" class=\"headerlink\" title=\"fs 文件系统\"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class=\"line\">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;写入失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;写入成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取文件：fs.readFile(path, cb);</span><br><span class=\"line\">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;读取失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>\n<h2 id=\"path-路径\"><a href=\"#path-路径\" class=\"headerlink\" title=\"path 路径\"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class=\"line\">console.log(path.dirname(str)); // 路径</span><br><span class=\"line\">// /root/a/b</span><br><span class=\"line\">console.log(path.extname(str)); // 后缀名</span><br><span class=\"line\">// .html</span><br><span class=\"line\">console.log(path.basename(str)); // 文件名</span><br><span class=\"line\">// index.html</span><br><span class=\"line\"></span><br><span class=\"line\">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class=\"line\">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class=\"line\">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathOne, pathTwo, __dirname);</span><br><span class=\"line\">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class=\"line\">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class=\"line\">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>\n<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>\n<h3 id=\"url-模块\"><a href=\"#url-模块\" class=\"headerlink\" title=\"url 模块\"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = require(&apos;url&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class=\"line\">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathname, query);</span><br><span class=\"line\">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"querystring-查询字符串\"><a href=\"#querystring-查询字符串\" class=\"headerlink\" title=\"querystring 查询字符串\"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring = require(&apos;querystring&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class=\"line\">let obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class=\"line\">obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class=\"line\">query = querystring.stringify(obj);</span><br><span class=\"line\">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert 断言\"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class=\"line\">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>\n<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class=\"line\">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class=\"line\">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class=\"line\">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"stream-流\"><a href=\"#stream-流\" class=\"headerlink\" title=\"stream 流\"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取流：fs.createReadStream();</span><br><span class=\"line\">// 写入流：fs.createWriteStream();</span><br><span class=\"line\">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>\n<h3 id=\"zlib-压缩\"><a href=\"#zlib-压缩\" class=\"headerlink\" title=\"zlib 压缩\"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const zlib = require(&apos;zlib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class=\"line\">let gz = zlib.createGzip();</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href=\"https://juejin.im/post/5ccacfb96fb9a03201243cb9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>\n"},{"title":"npm 部署自己的组件库","date":"2019-07-26T06:18:53.000Z","_content":"Author: Echo\nTime: 2019-07-24 15:28:39\n# 基于 vue-cli 打造属于自己的 UI 库\n\n## 写在前面\n \n## 知识前置\n我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：\n```\nimport Loading from '../components/loading'\n// 方法一：name 是组件的名字\nVue.component(Loading.name, Loading)\n// 方法二：前提是 Loading 有提供 install 这个方法\nVue.use(Loading);\n```\n# 基于vue-cli3打造组件库\n# 搭建目录\n#### 快速创建项目\n* vue-cli3\n```\nvue create projectName\n```\n### 修改目录结构\n\n*  把 src 目录名字改成 examples，这是用于展示组件示例的\n*  在根目录下新建一个 packages 文件夹，这是用来放组件的\n![1ll.png](/images/1.png)\n    你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：\n当我们水平不够的时候，模仿是一种强大的学习能力👏。\n\n### 添加配置文件\n\n小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：\n\n```\nconst path = require('path')\nmodule.exports = {\n  // 修改 pages 入口\n  pages: {\n    index: {\n      entry: 'examples/main.js', // 入口\n      template: 'public/index.html', // 模板\n      filename: 'index.html' // 输出文件\n    }\n  },\n  // 扩展 webpack 配置\n  chainWebpack: config => {\n    // @ 默认指向 src 目录，这里要改成 examples\n    // 另外也可以新增一个 ~ 指向 packages\n    config.resolve.alias\n      .set('@', path.resolve('examples'))\n      .set('~', path.resolve('packages'))\n\n    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的\n    config.module\n      .rule('js')\n      .include.add(/packages/).end()\n      .include.add(/examples/).end()\n      .use('babel')\n      .loader('babel-loader')\n      .tap(options => {\n        // 修改它的选项...\n        return options\n      })\n  }\n}\n\n```\n\n上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 [Vue Cli](https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE) 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。\n\n## 编写组件\n\n一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：\n\n![1ll.png](/images/2.png)\n\n\n```\n<!--test.vue-->\n<template>\n  <div class=\"echojoy-test\" @click=\"handleClick\">{{ num }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'EchojoyTest',\n  data () {\n    return {\n      num: 0\n    }\n  },\n  methods: {\n    handleClick () {\n      this.num++\n    }\n  }\n}\n</script>\n\n<style >\n.echojoy-test {\n  width: 100px;\n  height: 100px;\n  line-height: 100px;\n  border-radius: 50%;\n  font-size: 30px;\n  text-align: center;\n  background: #24292e;\n  color: white;\n}\n</style>\n\n\n```\n\n应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 `EchojoyTest`，到时候我们写的标签就长这样 `<echojoy-test></echojoy-test>`，就像 Element 一样，name 是 `ElButton`，用的时候就是 `<el-button></el-button>`。\n\n## 暴露组件\n\n让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：\n\n```\n// 对外提供对组件的引用，注意组件必须声明 name\nimport EchojoyTest from './src/test'\n// 为组件提供 install 安装方法，供按需引入\nEchojoyTest.install = Vue => {\n  Vue.component(EchojoyTest.name, EchojoyTest)\n}\nexport default EchojoyTest\n\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 `Vue.use()` 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：\n\n```\nimport EchojoyTest from './test'\n// 存储组件列表\nconst components = [\n  EchojoyTest\n]\n// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册\nconst install = function (Vue) {\n  // 判断是否安装\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册全局组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 判断是否是直接引入文件\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nexport default {\n  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装\n  install,\n  // 以下是具体的组件列表\n  ...components\n}\n\n\n```\n\n这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：\n\n![1ll.png](/images/3.png)\n\n因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。\n当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。\n\n## 组件测试\n\nok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：\n```\nimport EchojoyUI from './../packages'\nVue.use(EchojoyUI);\n```\n然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：\n\n![1ll.png](/images/11.png)\n\n\n好了，最后让我们运行一下项目 `npm run  serve`，看看效果，嗯，还凑合吧。\n\n## 库模式打包\n\n在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：\n\n```\n// target: 默认为构建应用，改为 lib 即可启用构建库模式\n// name: 输出文件名\n// dest: 输出目录，默认为 dist，这里我们改为 lib\n// entry: 入口文件路径\nvue-cli-service build --target lib --name lib [entry]\n\n```\n\n要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：\n\n![1ll.png](/images/5.png)\n\n\n\n接着执行 `npm run lib` 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。\n![1ll.png](/images/6.png)\n\n\n\n补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。\n\n## 发布到npm\n\n万事俱备，只欠发布。\n\n1.  完善一下 README.md 文档，这个随便写两句就好\n2.  修改一下 package.json 文件：\n\n```\n{ \n  \"name\": \"echojoy-ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"description\": \"基于 vue-cli3 的 UI 组件库\",\n  \"main\": \"lib/xr-ui.umd.min.js\",\n  \"keywords\": \"echojoy-ui\",\n  \"private\": false,\n  \"license\": \"MIT\"\n}\n\n```\n\n3.  在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：\n\n```\n# 这是复制 .gitignore 里面的\n.DS_Store\nnode_modules\n/dist\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw*\n\n# 以下是新增的\n# 要忽略目录和指定文件\nexamples/\npackages/\npublic/\nvue.config.js\nbabel.config.js\n*.map\n*.html\n\n```\n\n最后执行 `npm login` 登入 npm 账号，再执行 `npm publish` 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n## 小试牛刀\n\n终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 `vue create echojoy-ui-use` 另起一个新项目，然后 `npm i echojoy-ui -S`，可以在 node_modules 里面看到我们的包大概长这样：\n![1ll.png](/images/7.png)\n\n\n\n然后在 main.js 引入：\n\n```\nimport EchojoyUI from \"echojoy-ui\";\nimport \"echojoy-ui/lib/echojoy-ui.css\";\nVue.use(EchojoyUI);\n```\n\n这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。\n\n```\n<echojoy-test></echojoy-test>\n```\n\n# ! vue-cli3（vue-cli2）\n```\n vue init webpack projectName\n```\n![1ll.png](/images/8.png)\n\n\n####  启动项目\n`\n npm run dev\n`\n![1ll.png](/images/9.png)\n浏览器输入\n```\nhttp://localhost:8080\n```\n#### 编写组件\n\n在src的components新建组件limit：即文件夹`EchoLimit`->文件`index.vue` + 文件`index+css`\n```\n// index.vue\n<template>\n  <div class=\"echo-limit-container\" v-if=\"visible === false\">\n    <div class=\"echo-limit-container-inner\">\n      <span class=\"echo-limit-text\">\n        {{limitTip}}\n      </span>\n    </div>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    limitTip: {\n      type: String,\n      default: '没有权限！！'\n    },\n  },\n  name: \"EchoLimit\" // 这个名字很重要，它就是未来的标签名<echo-limit></echo-limit>\n};\n</script>\n<style>\n  @import \"./index\"\n</style>\n\n\n```\n   \n\n⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。\n\n#### 暴露组件\n\n* 注册单个组件\n\n在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：\n// 为组件提供 install 方法，供组件对外按需引入\n```\nimport EchoLimit from \"./EchoLimit/index.vue\";\nEchoLimit.install = Vue => {\n  Vue.component(EchoLimit.name, EchoLimit);\n};\nexport default EchoLimit;\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。\n\n* 注册全局组件\n让我们在 components 下面新建一个 index.js 文件，具体代码如下：\n```\n// index.js\nimport EchoLimit from './EchoLimit'\n// 所有组件列表\nconst components = [\n  EchoLimit\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n  // 判断是否安装，安装过就不继续往下执行\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册所有组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nconsole.log(components[0].name) // 控制台输出组件的name,方便引用组件\n\nexport default {\n  install,\n  // 所有组件，必须具有 install，才能使用 Vue.use()\n  ...components\n}\n\n```\n\n目录结构方便大家观看：\n![1ll.png](/images/4.png)\n\n#### 组件测试\n\nok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：\n\n```\nimport EchoUI from './components'\nVue.use(EchoUI)\n```\n在 HelloWorld.vue中引入组件EchoLimit.\n```\n<template>\n  <div>\n    <EchoLimit></EchoLimit>\n     <echo-limit></echo-limit>\n  </div>\n</echo-limit>\n```\n运行项目`npm run dev`,会发现成功了！！!\n![1ll.png](/images/10.png)\n\n\n过程同上！！！！！！！！！\n\n\n参考 连接：https://www.jianshu.com/p/41cc796488df\n参考 链接：https://juejin.im/post/5c95c61f6fb9a070c40acf65\n","source":"_posts/npmBuild.md","raw":"---\ntitle: npm 部署自己的组件库\ndate: 2019-07-26 14:18:53\ntags: npm \n---\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n# 基于 vue-cli 打造属于自己的 UI 库\n\n## 写在前面\n \n## 知识前置\n我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：\n```\nimport Loading from '../components/loading'\n// 方法一：name 是组件的名字\nVue.component(Loading.name, Loading)\n// 方法二：前提是 Loading 有提供 install 这个方法\nVue.use(Loading);\n```\n# 基于vue-cli3打造组件库\n# 搭建目录\n#### 快速创建项目\n* vue-cli3\n```\nvue create projectName\n```\n### 修改目录结构\n\n*  把 src 目录名字改成 examples，这是用于展示组件示例的\n*  在根目录下新建一个 packages 文件夹，这是用来放组件的\n![1ll.png](/images/1.png)\n    你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：\n当我们水平不够的时候，模仿是一种强大的学习能力👏。\n\n### 添加配置文件\n\n小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：\n\n```\nconst path = require('path')\nmodule.exports = {\n  // 修改 pages 入口\n  pages: {\n    index: {\n      entry: 'examples/main.js', // 入口\n      template: 'public/index.html', // 模板\n      filename: 'index.html' // 输出文件\n    }\n  },\n  // 扩展 webpack 配置\n  chainWebpack: config => {\n    // @ 默认指向 src 目录，这里要改成 examples\n    // 另外也可以新增一个 ~ 指向 packages\n    config.resolve.alias\n      .set('@', path.resolve('examples'))\n      .set('~', path.resolve('packages'))\n\n    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的\n    config.module\n      .rule('js')\n      .include.add(/packages/).end()\n      .include.add(/examples/).end()\n      .use('babel')\n      .loader('babel-loader')\n      .tap(options => {\n        // 修改它的选项...\n        return options\n      })\n  }\n}\n\n```\n\n上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 [Vue Cli](https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE) 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。\n\n## 编写组件\n\n一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：\n\n![1ll.png](/images/2.png)\n\n\n```\n<!--test.vue-->\n<template>\n  <div class=\"echojoy-test\" @click=\"handleClick\">{{ num }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'EchojoyTest',\n  data () {\n    return {\n      num: 0\n    }\n  },\n  methods: {\n    handleClick () {\n      this.num++\n    }\n  }\n}\n</script>\n\n<style >\n.echojoy-test {\n  width: 100px;\n  height: 100px;\n  line-height: 100px;\n  border-radius: 50%;\n  font-size: 30px;\n  text-align: center;\n  background: #24292e;\n  color: white;\n}\n</style>\n\n\n```\n\n应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 `EchojoyTest`，到时候我们写的标签就长这样 `<echojoy-test></echojoy-test>`，就像 Element 一样，name 是 `ElButton`，用的时候就是 `<el-button></el-button>`。\n\n## 暴露组件\n\n让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：\n\n```\n// 对外提供对组件的引用，注意组件必须声明 name\nimport EchojoyTest from './src/test'\n// 为组件提供 install 安装方法，供按需引入\nEchojoyTest.install = Vue => {\n  Vue.component(EchojoyTest.name, EchojoyTest)\n}\nexport default EchojoyTest\n\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 `Vue.use()` 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：\n\n```\nimport EchojoyTest from './test'\n// 存储组件列表\nconst components = [\n  EchojoyTest\n]\n// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册\nconst install = function (Vue) {\n  // 判断是否安装\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册全局组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 判断是否是直接引入文件\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nexport default {\n  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装\n  install,\n  // 以下是具体的组件列表\n  ...components\n}\n\n\n```\n\n这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：\n\n![1ll.png](/images/3.png)\n\n因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。\n当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。\n\n## 组件测试\n\nok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：\n```\nimport EchojoyUI from './../packages'\nVue.use(EchojoyUI);\n```\n然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：\n\n![1ll.png](/images/11.png)\n\n\n好了，最后让我们运行一下项目 `npm run  serve`，看看效果，嗯，还凑合吧。\n\n## 库模式打包\n\n在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：\n\n```\n// target: 默认为构建应用，改为 lib 即可启用构建库模式\n// name: 输出文件名\n// dest: 输出目录，默认为 dist，这里我们改为 lib\n// entry: 入口文件路径\nvue-cli-service build --target lib --name lib [entry]\n\n```\n\n要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：\n\n![1ll.png](/images/5.png)\n\n\n\n接着执行 `npm run lib` 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。\n![1ll.png](/images/6.png)\n\n\n\n补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。\n\n## 发布到npm\n\n万事俱备，只欠发布。\n\n1.  完善一下 README.md 文档，这个随便写两句就好\n2.  修改一下 package.json 文件：\n\n```\n{ \n  \"name\": \"echojoy-ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"description\": \"基于 vue-cli3 的 UI 组件库\",\n  \"main\": \"lib/xr-ui.umd.min.js\",\n  \"keywords\": \"echojoy-ui\",\n  \"private\": false,\n  \"license\": \"MIT\"\n}\n\n```\n\n3.  在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：\n\n```\n# 这是复制 .gitignore 里面的\n.DS_Store\nnode_modules\n/dist\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw*\n\n# 以下是新增的\n# 要忽略目录和指定文件\nexamples/\npackages/\npublic/\nvue.config.js\nbabel.config.js\n*.map\n*.html\n\n```\n\n最后执行 `npm login` 登入 npm 账号，再执行 `npm publish` 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n## 小试牛刀\n\n终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 `vue create echojoy-ui-use` 另起一个新项目，然后 `npm i echojoy-ui -S`，可以在 node_modules 里面看到我们的包大概长这样：\n![1ll.png](/images/7.png)\n\n\n\n然后在 main.js 引入：\n\n```\nimport EchojoyUI from \"echojoy-ui\";\nimport \"echojoy-ui/lib/echojoy-ui.css\";\nVue.use(EchojoyUI);\n```\n\n这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。\n\n```\n<echojoy-test></echojoy-test>\n```\n\n# ! vue-cli3（vue-cli2）\n```\n vue init webpack projectName\n```\n![1ll.png](/images/8.png)\n\n\n####  启动项目\n`\n npm run dev\n`\n![1ll.png](/images/9.png)\n浏览器输入\n```\nhttp://localhost:8080\n```\n#### 编写组件\n\n在src的components新建组件limit：即文件夹`EchoLimit`->文件`index.vue` + 文件`index+css`\n```\n// index.vue\n<template>\n  <div class=\"echo-limit-container\" v-if=\"visible === false\">\n    <div class=\"echo-limit-container-inner\">\n      <span class=\"echo-limit-text\">\n        {{limitTip}}\n      </span>\n    </div>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    limitTip: {\n      type: String,\n      default: '没有权限！！'\n    },\n  },\n  name: \"EchoLimit\" // 这个名字很重要，它就是未来的标签名<echo-limit></echo-limit>\n};\n</script>\n<style>\n  @import \"./index\"\n</style>\n\n\n```\n   \n\n⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。\n\n#### 暴露组件\n\n* 注册单个组件\n\n在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：\n// 为组件提供 install 方法，供组件对外按需引入\n```\nimport EchoLimit from \"./EchoLimit/index.vue\";\nEchoLimit.install = Vue => {\n  Vue.component(EchoLimit.name, EchoLimit);\n};\nexport default EchoLimit;\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。\n\n* 注册全局组件\n让我们在 components 下面新建一个 index.js 文件，具体代码如下：\n```\n// index.js\nimport EchoLimit from './EchoLimit'\n// 所有组件列表\nconst components = [\n  EchoLimit\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n  // 判断是否安装，安装过就不继续往下执行\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册所有组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nconsole.log(components[0].name) // 控制台输出组件的name,方便引用组件\n\nexport default {\n  install,\n  // 所有组件，必须具有 install，才能使用 Vue.use()\n  ...components\n}\n\n```\n\n目录结构方便大家观看：\n![1ll.png](/images/4.png)\n\n#### 组件测试\n\nok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：\n\n```\nimport EchoUI from './components'\nVue.use(EchoUI)\n```\n在 HelloWorld.vue中引入组件EchoLimit.\n```\n<template>\n  <div>\n    <EchoLimit></EchoLimit>\n     <echo-limit></echo-limit>\n  </div>\n</echo-limit>\n```\n运行项目`npm run dev`,会发现成功了！！!\n![1ll.png](/images/10.png)\n\n\n过程同上！！！！！！！！！\n\n\n参考 连接：https://www.jianshu.com/p/41cc796488df\n参考 链接：https://juejin.im/post/5c95c61f6fb9a070c40acf65\n","slug":"npmBuild","published":1,"updated":"2019-08-21T07:40:00.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4tw001gygkcnia1xh6z","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<h1 id=\"基于-vue-cli-打造属于自己的-UI-库\"><a href=\"#基于-vue-cli-打造属于自己的-UI-库\" class=\"headerlink\" title=\"基于 vue-cli 打造属于自己的 UI 库\"></a>基于 vue-cli 打造属于自己的 UI 库</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><h2 id=\"知识前置\"><a href=\"#知识前置\" class=\"headerlink\" title=\"知识前置\"></a>知识前置</h2><p>我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Loading from &apos;../components/loading&apos;</span><br><span class=\"line\">// 方法一：name 是组件的名字</span><br><span class=\"line\">Vue.component(Loading.name, Loading)</span><br><span class=\"line\">// 方法二：前提是 Loading 有提供 install 这个方法</span><br><span class=\"line\">Vue.use(Loading);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基于vue-cli3打造组件库\"><a href=\"#基于vue-cli3打造组件库\" class=\"headerlink\" title=\"基于vue-cli3打造组件库\"></a>基于vue-cli3打造组件库</h1><h1 id=\"搭建目录\"><a href=\"#搭建目录\" class=\"headerlink\" title=\"搭建目录\"></a>搭建目录</h1><h4 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h4><ul>\n<li>vue-cli3<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create projectName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改目录结构\"><a href=\"#修改目录结构\" class=\"headerlink\" title=\"修改目录结构\"></a>修改目录结构</h3><ul>\n<li>把 src 目录名字改成 examples，这是用于展示组件示例的</li>\n<li>在根目录下新建一个 packages 文件夹，这是用来放组件的<br><img src=\"/images/1.png\" alt=\"1ll.png\"><br> 你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：<br>当我们水平不够的时候，模仿是一种强大的学习能力👏。</li>\n</ul>\n<h3 id=\"添加配置文件\"><a href=\"#添加配置文件\" class=\"headerlink\" title=\"添加配置文件\"></a>添加配置文件</h3><p>小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 修改 pages 入口</span><br><span class=\"line\">  pages: &#123;</span><br><span class=\"line\">    index: &#123;</span><br><span class=\"line\">      entry: &apos;examples/main.js&apos;, // 入口</span><br><span class=\"line\">      template: &apos;public/index.html&apos;, // 模板</span><br><span class=\"line\">      filename: &apos;index.html&apos; // 输出文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 扩展 webpack 配置</span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    // @ 默认指向 src 目录，这里要改成 examples</span><br><span class=\"line\">    // 另外也可以新增一个 ~ 指向 packages</span><br><span class=\"line\">    config.resolve.alias</span><br><span class=\"line\">      .set(&apos;@&apos;, path.resolve(&apos;examples&apos;))</span><br><span class=\"line\">      .set(&apos;~&apos;, path.resolve(&apos;packages&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(&apos;js&apos;)</span><br><span class=\"line\">      .include.add(/packages/).end()</span><br><span class=\"line\">      .include.add(/examples/).end()</span><br><span class=\"line\">      .use(&apos;babel&apos;)</span><br><span class=\"line\">      .loader(&apos;babel-loader&apos;)</span><br><span class=\"line\">      .tap(options =&gt; &#123;</span><br><span class=\"line\">        // 修改它的选项...</span><br><span class=\"line\">        return options</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE\" target=\"_blank\" rel=\"noopener\">Vue Cli</a> 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。</p>\n<h2 id=\"编写组件\"><a href=\"#编写组件\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h2><p>一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：</p>\n<p><img src=\"/images/2.png\" alt=\"1ll.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--test.vue--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-test&quot; @click=&quot;handleClick&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;EchojoyTest&apos;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      num: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick () &#123;</span><br><span class=\"line\">      this.num++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style &gt;</span><br><span class=\"line\">.echojoy-test &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100px;</span><br><span class=\"line\">  line-height: 100px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  font-size: 30px;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  background: #24292e;</span><br><span class=\"line\">  color: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 <code>EchojoyTest</code>，到时候我们写的标签就长这样 <code>&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</code>，就像 Element 一样，name 是 <code>ElButton</code>，用的时候就是 <code>&lt;el-button&gt;&lt;/el-button&gt;</code>。</p>\n<h2 id=\"暴露组件\"><a href=\"#暴露组件\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h2><p>让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对外提供对组件的引用，注意组件必须声明 name</span><br><span class=\"line\">import EchojoyTest from &apos;./src/test&apos;</span><br><span class=\"line\">// 为组件提供 install 安装方法，供按需引入</span><br><span class=\"line\">EchojoyTest.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchojoyTest.name, EchojoyTest)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default EchojoyTest</span><br></pre></td></tr></table></figure>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 <code>Vue.use()</code> 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyTest from &apos;./test&apos;</span><br><span class=\"line\">// 存储组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchojoyTest</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册全局组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是直接引入文件</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 以下是具体的组件列表</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：</p>\n<p><img src=\"/images/3.png\" alt=\"1ll.png\"></p>\n<p>因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。<br>当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。</p>\n<h2 id=\"组件测试\"><a href=\"#组件测试\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h2><p>ok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &apos;./../packages&apos;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure></p>\n<p>然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：</p>\n<p><img src=\"/images/11.png\" alt=\"1ll.png\"></p>\n<p>好了，最后让我们运行一下项目 <code>npm run  serve</code>，看看效果，嗯，还凑合吧。</p>\n<h2 id=\"库模式打包\"><a href=\"#库模式打包\" class=\"headerlink\" title=\"库模式打包\"></a>库模式打包</h2><p>在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// target: 默认为构建应用，改为 lib 即可启用构建库模式</span><br><span class=\"line\">// name: 输出文件名</span><br><span class=\"line\">// dest: 输出目录，默认为 dist，这里我们改为 lib</span><br><span class=\"line\">// entry: 入口文件路径</span><br><span class=\"line\">vue-cli-service build --target lib --name lib [entry]</span><br></pre></td></tr></table></figure>\n<p>要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：</p>\n<p><img src=\"/images/5.png\" alt=\"1ll.png\"></p>\n<p>接着执行 <code>npm run lib</code> 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。<br><img src=\"/images/6.png\" alt=\"1ll.png\"></p>\n<p>补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。</p>\n<h2 id=\"发布到npm\"><a href=\"#发布到npm\" class=\"headerlink\" title=\"发布到npm\"></a>发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ol>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>修改一下 package.json 文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  &quot;name&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;description&quot;: &quot;基于 vue-cli3 的 UI 组件库&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;lib/xr-ui.umd.min.js&quot;,</span><br><span class=\"line\">  &quot;keywords&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;private&quot;: false,</span><br><span class=\"line\">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是复制 .gitignore 里面的</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">/dist</span><br><span class=\"line\"></span><br><span class=\"line\"># local env files</span><br><span class=\"line\">.env.local</span><br><span class=\"line\">.env.*.local</span><br><span class=\"line\"></span><br><span class=\"line\"># Log files</span><br><span class=\"line\">npm-debug.log*</span><br><span class=\"line\">yarn-debug.log*</span><br><span class=\"line\">yarn-error.log*</span><br><span class=\"line\"></span><br><span class=\"line\"># Editor directories and files</span><br><span class=\"line\">.idea</span><br><span class=\"line\">.vscode</span><br><span class=\"line\">*.suo</span><br><span class=\"line\">*.ntvs*</span><br><span class=\"line\">*.njsproj</span><br><span class=\"line\">*.sln</span><br><span class=\"line\">*.sw*</span><br><span class=\"line\"></span><br><span class=\"line\"># 以下是新增的</span><br><span class=\"line\"># 要忽略目录和指定文件</span><br><span class=\"line\">examples/</span><br><span class=\"line\">packages/</span><br><span class=\"line\">public/</span><br><span class=\"line\">vue.config.js</span><br><span class=\"line\">babel.config.js</span><br><span class=\"line\">*.map</span><br><span class=\"line\">*.html</span><br></pre></td></tr></table></figure>\n<p>最后执行 <code>npm login</code> 登入 npm 账号，再执行 <code>npm publish</code> 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</p>\n<h2 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h2><p>终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 <code>vue create echojoy-ui-use</code> 另起一个新项目，然后 <code>npm i echojoy-ui -S</code>，可以在 node_modules 里面看到我们的包大概长这样：<br><img src=\"/images/7.png\" alt=\"1ll.png\"></p>\n<p>然后在 main.js 引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &quot;echojoy-ui&quot;;</span><br><span class=\"line\">import &quot;echojoy-ui/lib/echojoy-ui.css&quot;;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure>\n<p>这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli3（vue-cli2）\"><a href=\"#vue-cli3（vue-cli2）\" class=\"headerlink\" title=\"! vue-cli3（vue-cli2）\"></a>! vue-cli3（vue-cli2）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack projectName</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/8.png\" alt=\"1ll.png\"></p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><code>npm run dev</code><br><img src=\"/images/9.png\" alt=\"1ll.png\"><br>浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写组件-1\"><a href=\"#编写组件-1\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h4><p>在src的components新建组件limit：即文件夹<code>EchoLimit</code>-&gt;文件<code>index.vue</code> + 文件<code>index+css</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echo-limit-container&quot; v-if=&quot;visible === false&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;echo-limit-container-inner&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;echo-limit-text&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;limitTip&#125;&#125;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    visible: &#123;</span><br><span class=\"line\">      type: Boolean,</span><br><span class=\"line\">      default: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    limitTip: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &apos;没有权限！！&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: &quot;EchoLimit&quot; // 这个名字很重要，它就是未来的标签名&lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  @import &quot;./index&quot;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。</p>\n<h4 id=\"暴露组件-1\"><a href=\"#暴露组件-1\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h4><ul>\n<li>注册单个组件</li>\n</ul>\n<p>在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：<br>// 为组件提供 install 方法，供组件对外按需引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoLimit from &quot;./EchoLimit/index.vue&quot;;</span><br><span class=\"line\">EchoLimit.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchoLimit.name, EchoLimit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default EchoLimit;</span><br></pre></td></tr></table></figure></p>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。</p>\n<ul>\n<li>注册全局组件<br>让我们在 components 下面新建一个 index.js 文件，具体代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.js</span><br><span class=\"line\">import EchoLimit from &apos;./EchoLimit&apos;</span><br><span class=\"line\">// 所有组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchoLimit</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装，安装过就不继续往下执行</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册所有组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检测到 Vue 才执行，毕竟我们是基于 Vue 的</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(components[0].name) // 控制台输出组件的name,方便引用组件</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 所有组件，必须具有 install，才能使用 Vue.use()</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>目录结构方便大家观看：<br><img src=\"/images/4.png\" alt=\"1ll.png\"></p>\n<h4 id=\"组件测试-1\"><a href=\"#组件测试-1\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h4><p>ok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoUI from &apos;./components&apos;</span><br><span class=\"line\">Vue.use(EchoUI)</span><br></pre></td></tr></table></figure>\n<p>在 HelloWorld.vue中引入组件EchoLimit.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;EchoLimit&gt;&lt;/EchoLimit&gt;</span><br><span class=\"line\">     &lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/echo-limit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行项目<code>npm run dev</code>,会发现成功了！！!<br><img src=\"/images/10.png\" alt=\"1ll.png\"></p>\n<p>过程同上！！！！！！！！！</p>\n<p>参考 连接：<a href=\"https://www.jianshu.com/p/41cc796488df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/41cc796488df</a><br>参考 链接：<a href=\"https://juejin.im/post/5c95c61f6fb9a070c40acf65\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c95c61f6fb9a070c40acf65</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<h1 id=\"基于-vue-cli-打造属于自己的-UI-库\"><a href=\"#基于-vue-cli-打造属于自己的-UI-库\" class=\"headerlink\" title=\"基于 vue-cli 打造属于自己的 UI 库\"></a>基于 vue-cli 打造属于自己的 UI 库</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><h2 id=\"知识前置\"><a href=\"#知识前置\" class=\"headerlink\" title=\"知识前置\"></a>知识前置</h2><p>我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Loading from &apos;../components/loading&apos;</span><br><span class=\"line\">// 方法一：name 是组件的名字</span><br><span class=\"line\">Vue.component(Loading.name, Loading)</span><br><span class=\"line\">// 方法二：前提是 Loading 有提供 install 这个方法</span><br><span class=\"line\">Vue.use(Loading);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基于vue-cli3打造组件库\"><a href=\"#基于vue-cli3打造组件库\" class=\"headerlink\" title=\"基于vue-cli3打造组件库\"></a>基于vue-cli3打造组件库</h1><h1 id=\"搭建目录\"><a href=\"#搭建目录\" class=\"headerlink\" title=\"搭建目录\"></a>搭建目录</h1><h4 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h4><ul>\n<li>vue-cli3<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create projectName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改目录结构\"><a href=\"#修改目录结构\" class=\"headerlink\" title=\"修改目录结构\"></a>修改目录结构</h3><ul>\n<li>把 src 目录名字改成 examples，这是用于展示组件示例的</li>\n<li>在根目录下新建一个 packages 文件夹，这是用来放组件的<br><img src=\"/images/1.png\" alt=\"1ll.png\"><br> 你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：<br>当我们水平不够的时候，模仿是一种强大的学习能力👏。</li>\n</ul>\n<h3 id=\"添加配置文件\"><a href=\"#添加配置文件\" class=\"headerlink\" title=\"添加配置文件\"></a>添加配置文件</h3><p>小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 修改 pages 入口</span><br><span class=\"line\">  pages: &#123;</span><br><span class=\"line\">    index: &#123;</span><br><span class=\"line\">      entry: &apos;examples/main.js&apos;, // 入口</span><br><span class=\"line\">      template: &apos;public/index.html&apos;, // 模板</span><br><span class=\"line\">      filename: &apos;index.html&apos; // 输出文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 扩展 webpack 配置</span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    // @ 默认指向 src 目录，这里要改成 examples</span><br><span class=\"line\">    // 另外也可以新增一个 ~ 指向 packages</span><br><span class=\"line\">    config.resolve.alias</span><br><span class=\"line\">      .set(&apos;@&apos;, path.resolve(&apos;examples&apos;))</span><br><span class=\"line\">      .set(&apos;~&apos;, path.resolve(&apos;packages&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(&apos;js&apos;)</span><br><span class=\"line\">      .include.add(/packages/).end()</span><br><span class=\"line\">      .include.add(/examples/).end()</span><br><span class=\"line\">      .use(&apos;babel&apos;)</span><br><span class=\"line\">      .loader(&apos;babel-loader&apos;)</span><br><span class=\"line\">      .tap(options =&gt; &#123;</span><br><span class=\"line\">        // 修改它的选项...</span><br><span class=\"line\">        return options</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE\" target=\"_blank\" rel=\"noopener\">Vue Cli</a> 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。</p>\n<h2 id=\"编写组件\"><a href=\"#编写组件\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h2><p>一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：</p>\n<p><img src=\"/images/2.png\" alt=\"1ll.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--test.vue--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-test&quot; @click=&quot;handleClick&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;EchojoyTest&apos;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      num: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick () &#123;</span><br><span class=\"line\">      this.num++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style &gt;</span><br><span class=\"line\">.echojoy-test &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100px;</span><br><span class=\"line\">  line-height: 100px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  font-size: 30px;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  background: #24292e;</span><br><span class=\"line\">  color: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 <code>EchojoyTest</code>，到时候我们写的标签就长这样 <code>&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</code>，就像 Element 一样，name 是 <code>ElButton</code>，用的时候就是 <code>&lt;el-button&gt;&lt;/el-button&gt;</code>。</p>\n<h2 id=\"暴露组件\"><a href=\"#暴露组件\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h2><p>让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对外提供对组件的引用，注意组件必须声明 name</span><br><span class=\"line\">import EchojoyTest from &apos;./src/test&apos;</span><br><span class=\"line\">// 为组件提供 install 安装方法，供按需引入</span><br><span class=\"line\">EchojoyTest.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchojoyTest.name, EchojoyTest)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default EchojoyTest</span><br></pre></td></tr></table></figure>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 <code>Vue.use()</code> 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyTest from &apos;./test&apos;</span><br><span class=\"line\">// 存储组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchojoyTest</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册全局组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是直接引入文件</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 以下是具体的组件列表</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：</p>\n<p><img src=\"/images/3.png\" alt=\"1ll.png\"></p>\n<p>因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。<br>当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。</p>\n<h2 id=\"组件测试\"><a href=\"#组件测试\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h2><p>ok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &apos;./../packages&apos;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure></p>\n<p>然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：</p>\n<p><img src=\"/images/11.png\" alt=\"1ll.png\"></p>\n<p>好了，最后让我们运行一下项目 <code>npm run  serve</code>，看看效果，嗯，还凑合吧。</p>\n<h2 id=\"库模式打包\"><a href=\"#库模式打包\" class=\"headerlink\" title=\"库模式打包\"></a>库模式打包</h2><p>在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// target: 默认为构建应用，改为 lib 即可启用构建库模式</span><br><span class=\"line\">// name: 输出文件名</span><br><span class=\"line\">// dest: 输出目录，默认为 dist，这里我们改为 lib</span><br><span class=\"line\">// entry: 入口文件路径</span><br><span class=\"line\">vue-cli-service build --target lib --name lib [entry]</span><br></pre></td></tr></table></figure>\n<p>要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：</p>\n<p><img src=\"/images/5.png\" alt=\"1ll.png\"></p>\n<p>接着执行 <code>npm run lib</code> 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。<br><img src=\"/images/6.png\" alt=\"1ll.png\"></p>\n<p>补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。</p>\n<h2 id=\"发布到npm\"><a href=\"#发布到npm\" class=\"headerlink\" title=\"发布到npm\"></a>发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ol>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>修改一下 package.json 文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  &quot;name&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;description&quot;: &quot;基于 vue-cli3 的 UI 组件库&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;lib/xr-ui.umd.min.js&quot;,</span><br><span class=\"line\">  &quot;keywords&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;private&quot;: false,</span><br><span class=\"line\">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是复制 .gitignore 里面的</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">/dist</span><br><span class=\"line\"></span><br><span class=\"line\"># local env files</span><br><span class=\"line\">.env.local</span><br><span class=\"line\">.env.*.local</span><br><span class=\"line\"></span><br><span class=\"line\"># Log files</span><br><span class=\"line\">npm-debug.log*</span><br><span class=\"line\">yarn-debug.log*</span><br><span class=\"line\">yarn-error.log*</span><br><span class=\"line\"></span><br><span class=\"line\"># Editor directories and files</span><br><span class=\"line\">.idea</span><br><span class=\"line\">.vscode</span><br><span class=\"line\">*.suo</span><br><span class=\"line\">*.ntvs*</span><br><span class=\"line\">*.njsproj</span><br><span class=\"line\">*.sln</span><br><span class=\"line\">*.sw*</span><br><span class=\"line\"></span><br><span class=\"line\"># 以下是新增的</span><br><span class=\"line\"># 要忽略目录和指定文件</span><br><span class=\"line\">examples/</span><br><span class=\"line\">packages/</span><br><span class=\"line\">public/</span><br><span class=\"line\">vue.config.js</span><br><span class=\"line\">babel.config.js</span><br><span class=\"line\">*.map</span><br><span class=\"line\">*.html</span><br></pre></td></tr></table></figure>\n<p>最后执行 <code>npm login</code> 登入 npm 账号，再执行 <code>npm publish</code> 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</p>\n<h2 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h2><p>终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 <code>vue create echojoy-ui-use</code> 另起一个新项目，然后 <code>npm i echojoy-ui -S</code>，可以在 node_modules 里面看到我们的包大概长这样：<br><img src=\"/images/7.png\" alt=\"1ll.png\"></p>\n<p>然后在 main.js 引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &quot;echojoy-ui&quot;;</span><br><span class=\"line\">import &quot;echojoy-ui/lib/echojoy-ui.css&quot;;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure>\n<p>这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli3（vue-cli2）\"><a href=\"#vue-cli3（vue-cli2）\" class=\"headerlink\" title=\"! vue-cli3（vue-cli2）\"></a>! vue-cli3（vue-cli2）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack projectName</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/8.png\" alt=\"1ll.png\"></p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><code>npm run dev</code><br><img src=\"/images/9.png\" alt=\"1ll.png\"><br>浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写组件-1\"><a href=\"#编写组件-1\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h4><p>在src的components新建组件limit：即文件夹<code>EchoLimit</code>-&gt;文件<code>index.vue</code> + 文件<code>index+css</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echo-limit-container&quot; v-if=&quot;visible === false&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;echo-limit-container-inner&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;echo-limit-text&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;limitTip&#125;&#125;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    visible: &#123;</span><br><span class=\"line\">      type: Boolean,</span><br><span class=\"line\">      default: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    limitTip: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &apos;没有权限！！&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: &quot;EchoLimit&quot; // 这个名字很重要，它就是未来的标签名&lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  @import &quot;./index&quot;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。</p>\n<h4 id=\"暴露组件-1\"><a href=\"#暴露组件-1\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h4><ul>\n<li>注册单个组件</li>\n</ul>\n<p>在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：<br>// 为组件提供 install 方法，供组件对外按需引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoLimit from &quot;./EchoLimit/index.vue&quot;;</span><br><span class=\"line\">EchoLimit.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchoLimit.name, EchoLimit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default EchoLimit;</span><br></pre></td></tr></table></figure></p>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。</p>\n<ul>\n<li>注册全局组件<br>让我们在 components 下面新建一个 index.js 文件，具体代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.js</span><br><span class=\"line\">import EchoLimit from &apos;./EchoLimit&apos;</span><br><span class=\"line\">// 所有组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchoLimit</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装，安装过就不继续往下执行</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册所有组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检测到 Vue 才执行，毕竟我们是基于 Vue 的</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(components[0].name) // 控制台输出组件的name,方便引用组件</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 所有组件，必须具有 install，才能使用 Vue.use()</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>目录结构方便大家观看：<br><img src=\"/images/4.png\" alt=\"1ll.png\"></p>\n<h4 id=\"组件测试-1\"><a href=\"#组件测试-1\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h4><p>ok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoUI from &apos;./components&apos;</span><br><span class=\"line\">Vue.use(EchoUI)</span><br></pre></td></tr></table></figure>\n<p>在 HelloWorld.vue中引入组件EchoLimit.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;EchoLimit&gt;&lt;/EchoLimit&gt;</span><br><span class=\"line\">     &lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/echo-limit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行项目<code>npm run dev</code>,会发现成功了！！!<br><img src=\"/images/10.png\" alt=\"1ll.png\"></p>\n<p>过程同上！！！！！！！！！</p>\n<p>参考 连接：<a href=\"https://www.jianshu.com/p/41cc796488df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/41cc796488df</a><br>参考 链接：<a href=\"https://juejin.im/post/5c95c61f6fb9a070c40acf65\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c95c61f6fb9a070c40acf65</a></p>\n"},{"title":"Promise","date":"2019-08-26T02:44:24.000Z","_content":"\nAuthor: Echo\nTime: 2019-08-26 10:44:24\n\n# 理解【ES6】Promise\n\n## 什么是Promise\n\nPromise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。\n\n* 从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。\n\n## 代码书写比较\n\n首先封装一个支持Promise的ajax方法：\n```\nfunction request(url,data = {}){\n    return new Promise((resolve,reject)=>{\n        $.ajax({\n            url,\n            data,\n            success:function (data) {\n                resolve(data);\n            },\n            error:function (error) {\n                reject(error);\n            }\n        })\n    });\n}。\n```\n用 request 方法实现多个互相依赖的网络请求\n```\nlet url1 = 'http://xxx.xxx.1';\nlet url2 = 'http://xxx.xxx.2';\nlet url3 = 'http://xxx.xxx.3';\nrequest(url1)\n    .then((data)=>{\n        console.log(data);\n        return request(url2,data)\n    })\n    .then((data)=>{\n        console.log(data);\n        return request(url3,data)\n    })\n    .then((data)=>{\n        console.log(data)\n    })\n    .catch((error)=>{\n        console.log(error);\n    });\n```\n\n## Promise 的特性\n\n### Promise 的状态、\n\n* pending (等待态)\n* fulfilled (完成态)\n* rejected (拒绝态)\n\n### 终值与拒因\n* 终值： 指的是promise被解决时传递给解决回掉的值\n* 拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因\n\n### 状态与状态关系，状态与终值和拒因的关系\n\n* pending可以迁移至fulfilled或rejected\n* fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值\n* rejected 不能迁移至其他状态，必须拥有一个不可变的据因\n\n## Promise 的使用\n\n### 构造函数\nPromise 是一个构造函数，使用new操作符返回一个promise对象\n\n构造函数接收一个 excutor函数作为参数\n\nexcutor函数有两个函数类型的参数resolve和reject\n\n```\nlet p = new Promise((resolve,reject)=>{\n     // 在 excutor 函数中执行异步操作\n     // 当异步操作完成后，调用 resolve 函数或 reject 函数\n});\n```\n\n* 构造函数在调用时，excutor函数会作为同步代码立即执行\n* 我们通常在excutor函数中执行我们的异步操作\n* 未调用resolve、reject函数时，promise对象的状态为pending\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p1');\n    },1000);\n});\n// p1 的状态一直为 pending\n```\n* 当调用resolve函数，resolve的参数为非promise对象，非thenable对象\n1. resolve 函数的参数，作为 promise 对象的终值\n2. promise 对象的状态变为 fulfilled\n\n```\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p2');\n        resolve('我是p2的终值')\n    },1000);\n});\n// 代码执行，1000ms内，p2 的状态为 pending\n// 代码执行，1000ms后，p2 的状态为 fulfilled\n// 代码执行，1000ms后，p2 的终值为 '我是p2的终值'\n\n```\n* 当调用 resolve 函数, resolve 的参数为 promise 对象\n1. promise 对象的状态、终值、拒因与传入的 promise 对象同步\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('error')\n})\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(p)\n})\n// p1 的状态为 rejected ，拒因为 error\n```\n\n* 当调用 resolve 函数, resolve 的参数为 thenable 对象\n1. 会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet thenable3 = {\n    then:function(resolve,reject){\n        throw new Error(3)\n    }\n}\nlet thenable4 = {\n    then:function(fn1,fn2){\n        //不调用 fn1 fn2\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(thenable1);\n})\nlet p2 = new Promise((resolve,reject)=>{\n    resolve(thenable2);\n})\nlet p3 = new Promise((resolve,reject)=>{\n    resolve(thenable3);\n})\nlet p4 = new Promise((resolve,reject)=>{\n    resolve(thenable4);\n})\n// p1 的状态为 fulfilled 终值为 1\n// p2 的状态为 rejected  终值为 2\n// p3 的状态为 rejected  拒因为 Error：3\n// p4 的状态为 pending\n```\n* 当调用reject函数，reject函数的参数，作为promise对象的拒因\n* promise对象的状态变为rejected\n\n```\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p3');\n        reject('我是p3的拒因')\n    },1000);\n});\n// 代码执行，1000ms内，p3 的状态为 pending\n// 代码执行，1000ms后，p3 的状态为 rejected\n// 代码执行，1000ms后，p3 的拒因为 '我是p3的拒因'\n```\n\n## Promise对象上的方法\n### then方法\npromise提供一个then方法，用于访问其终值和拒因。\npromise的then 方法接受两个参数：\n```\npromise.then(onFulfilled, onRejected)\n```\n\n* onFulfilled函数用于当promise状态变为fulfilled时，接收终值。\n* onRejected函数用于当promise状态变为rejected时，接收拒因\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('异步任务获取的数据')\n    },50)\n}).then((data)=>{\n    console.log(data)\n})\n// 异步任务获取的数据\n\n```\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        reject(new Error('异步任务异常'))\n    },50)\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 异步任务异常\n```\n```\nnew Promise((resolve,reject)=>{\n    throw new Error('抛出一个异常');\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 抛出一个异常\n```\n### onFulfilled 和 onRejected 参数可选\n\n* 如果 onFulfilled 不是函数，其必须被忽略\n* 如果 onRejected 不是函数，其必须被忽略\n\n#### onFulfilled 的特性\n如果onFulfilled是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的终值\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onRejected 的特性\n如果onRejected是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的拒因\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onFulfilled 和 onRejected 的调用时机\n\n* 当 promise 对象的状态变为 fulfilled 或 rejected 时调用\n* onFulfilled、onRejected 永远都是异步调用\n* onFulfilled、onRejected 在事件队列中作为微任务来处理\n\n```\nconsole.log(1);\nsetTimeout(function(){\n    console.log(2)\n},0)\nnew Promise((resolve,reject)=>{\n    resolve(3);\n}).then((data)=>{\n    console.log(data);\n})\nconsole.log(4)\n// print: 1 4 3 2\n```\n#### onFulfilled 和 onRejected 的调用要求\n* onFulfilled 和 onRejected 必须被作为函数调用\n* 非严格模式下，this 为全局对象\n* 严格模式下，this 为 undefined\n```\nfunction fn1(){\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfunction fn2(){\n    \"use strict\";\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfn1(); // print: window\nfn2(); // print: undefined\n```\n## then方法的多次调用\n\n* then方法可以被同一个promise对象多次调用\n* then方法会返回一个新的promise对象\n* 当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调\n* 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调\n```\nlet p = new Promise((resolve)=>{\n    resolve()\n});\nlet p1 = p.then(()=>{\n    console.log('异步执行，第一个onFulfilled');\n});\nlet p2 = p.then(()=>{\n    console.log('异步执行，第二个onFulfilled');\n});\nconsole.log(p1.constructor === Promise);\nconsole.log(p === p1);\nconsole.log(p === p2);\nconsole.log(p1 === p2);\n// print: true\n// print: false\n// print: false\n// print: false\n// print: 异步执行，第一个onFulfilled\n// print: 异步执行，第二个onFulfilled\n```\n#### then方法的返回值\nthen方法返回一个promise对象\n```\npromise2 = promise1.then(onFulfilled, onRejected);   \n```\n* 若onFulfilled 、onRejected 返回一个非promise\n对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x\n```\nlet p = new Promise((resolve,reject)=>{\n    throw new Error();\n});\nlet p1 = p.then(null,(data)=>{\n    return '我是p2的终值'\n});\np1.then((data)=>{\n    console.log(data)\n});\n// print: 我是p2的终值\n```\n* 若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\nlet p3 = new Promise((resolve)=>{\n    resolve()\n})\nlet p4 = p3.then(()=>{\n    return p1;\n})\nlet p5 = p3.then(()=>{\n    return p2;\n})\n// p4 的状态为 fulfilled 终值为 1\n// p5 的状态为 rejected  拒因为 2\n\n```\n* 若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve()\n})\nlet p2 = p1.then(()=>{\n    return thenable1;\n})\nlet p3 = p1.then(()=>{\n    return thenable2;\n})\n// p2 的状态为 fulfilled 终值为 1\n// p3 的状态为 rejected  拒因为 2\n```\n* 若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve();\n});\nlet p1 = p.then((data)=>{\n    throw new Error('error')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:&emsp;Error: error\n```\n* 若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p1的终值');\n});\nlet p1 = p.then(null,null);\np1.then((data)=>{\n    console.log(data);\n});\n// print:&emsp;我是p1的终值\n```\n* 若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('我是p1的拒因');\n});\nlet p1 = p.then(null,null);\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:我是p1的拒因\n```\n* 若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p的终值');\n});\nlet p1 = p.then((data)=>{\n    throw new Error('异常')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:Error: 异常\n```\n### 终值和拒因的穿透特性\n\n* 如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled\n\n1. then 方法返回的 promise 对象的状态变为 fulfilled\n2. then 方法返回的 promise 对象的终值与原 promise 对象的终值相同\n\n\n* 如果 promise 的状态变为 rejected，then 方法没有注册 onRejected\n\n1. then 方法返回的 promise 对象的状态变为 rejected\n2. then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\n\nlet p3 = p1.then(null,null);\nlet p4 = p2.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n\n\np5 = p3.then(null,null);\np6 = p4.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n```\n\n* 穿透特性主要用于异常处理\n```\nlet fn1 = function(){}\nlet fn2 = function(){}\nlet fn3 = function(){}\nlet fn4 = function(){}\nlet fn5 = function(){}\nlet onError = function(){};\nnew Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject()\n    })\n})\n.then(fn1)\n.then(fn2)\n.then(fn3)\n.then(fn4)\n.then(fn5)\n.then(null,onError)\n```\nfn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误\n\n### catch方法：\ncatch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同\n```\nnew Promise((resolve,reject)=>{\n    reject()\n}).then(null,function(error){\n\n})\n// 等同于\nnew Promise((resolve,reject)=>{\n    reject()\n}).catch(function(error){\n\n})\n```\n## Promise 的静态方法\n### Promise.resolve\nPromise.resolve 方法用于将现有数据转换为 promise 对象\n\n* 若入参为 promise 对象\n\n返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步\n\n* 若入参为 thenable 对象\n\n会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n* 若入参为非 promise 非 thenable 对象\n\n1.返回的 promise 对象的状态为 fulfilled\n2.返回的 promise 对象的终值为 Promise.resolve 方法的入参\n\n```\nlet p = Promise.resolve(x)\n// 等价于\nlet p = new Promise((resolve)=>{\n    resolve(x)\n})\n\n```\n\n### Promise.reject\n* Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象\n```\n\nlet p = Promise.reject(x)\n// 等价于\nlet p = new Promise((resolve,reject)=>{\n    reject(x)\n})\n```\n### Promise.all\n* Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.all([p1, p2, p3]);\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\np 的状态由 p1、p2、p3 决定\n\n* 当 p1、p2、p3 的状态都变成 fulfilled\n\np 的状态为 fulfilled\n此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值\n\n* 当 p1、p2、p3 的状态有一个变成 rejected\n\np 的状态变为 rejected\n此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因\n```\nlet p1 = Promise.resolve(1);\nlet p2 = Promise.resolve(2);\nlet p3 = 3;\n\nPromise.all([p1,p2,p3]).then((data)=>{\n    console.log(data); // print: [1,2,3]\n})\n```\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.all([p1,p2,p3]).catch((error)=>{\n    console.log(error); // print: p3 error\n})\n```\n### Promise.race\n* Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.race([p1, p2, p3]);\n\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\n* p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定\n* p 的终值或拒因由最先变更状态的 promise 对象所决定\n\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: 1\n```\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        resolve(1)\n    },1000)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },800)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\n\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: p3 error\n```\n## Promise 的错误捕获\n当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误\n```\n// node 环境下\nprocess.on('unhandledRejection', error => {\n    console.log('unhandledRejection', error);\n});\n// 浏览器下\nwindow.addEventListener('unhandledrejection',(e)=>{\n    e.preventDefault();\n    console.log(e);\n});\n\n```\n## Promise 的问题\n\n* 无法取消Promise，若没有状态变更，也无法停止 promise 的等待\n* 不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获\n* 未完成状态时，无法得知是刚开始，还是即将完成\n\n参考链接：https://juejin.im/post/5d06e9c76fb9a07ee4636235","source":"_posts/promise.md","raw":"---\ntitle: Promise\ndate: 2019-08-26 10:44:24\ntags: es6\n---\n\nAuthor: Echo\nTime: 2019-08-26 10:44:24\n\n# 理解【ES6】Promise\n\n## 什么是Promise\n\nPromise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。\n\n* 从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。\n\n## 代码书写比较\n\n首先封装一个支持Promise的ajax方法：\n```\nfunction request(url,data = {}){\n    return new Promise((resolve,reject)=>{\n        $.ajax({\n            url,\n            data,\n            success:function (data) {\n                resolve(data);\n            },\n            error:function (error) {\n                reject(error);\n            }\n        })\n    });\n}。\n```\n用 request 方法实现多个互相依赖的网络请求\n```\nlet url1 = 'http://xxx.xxx.1';\nlet url2 = 'http://xxx.xxx.2';\nlet url3 = 'http://xxx.xxx.3';\nrequest(url1)\n    .then((data)=>{\n        console.log(data);\n        return request(url2,data)\n    })\n    .then((data)=>{\n        console.log(data);\n        return request(url3,data)\n    })\n    .then((data)=>{\n        console.log(data)\n    })\n    .catch((error)=>{\n        console.log(error);\n    });\n```\n\n## Promise 的特性\n\n### Promise 的状态、\n\n* pending (等待态)\n* fulfilled (完成态)\n* rejected (拒绝态)\n\n### 终值与拒因\n* 终值： 指的是promise被解决时传递给解决回掉的值\n* 拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因\n\n### 状态与状态关系，状态与终值和拒因的关系\n\n* pending可以迁移至fulfilled或rejected\n* fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值\n* rejected 不能迁移至其他状态，必须拥有一个不可变的据因\n\n## Promise 的使用\n\n### 构造函数\nPromise 是一个构造函数，使用new操作符返回一个promise对象\n\n构造函数接收一个 excutor函数作为参数\n\nexcutor函数有两个函数类型的参数resolve和reject\n\n```\nlet p = new Promise((resolve,reject)=>{\n     // 在 excutor 函数中执行异步操作\n     // 当异步操作完成后，调用 resolve 函数或 reject 函数\n});\n```\n\n* 构造函数在调用时，excutor函数会作为同步代码立即执行\n* 我们通常在excutor函数中执行我们的异步操作\n* 未调用resolve、reject函数时，promise对象的状态为pending\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p1');\n    },1000);\n});\n// p1 的状态一直为 pending\n```\n* 当调用resolve函数，resolve的参数为非promise对象，非thenable对象\n1. resolve 函数的参数，作为 promise 对象的终值\n2. promise 对象的状态变为 fulfilled\n\n```\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p2');\n        resolve('我是p2的终值')\n    },1000);\n});\n// 代码执行，1000ms内，p2 的状态为 pending\n// 代码执行，1000ms后，p2 的状态为 fulfilled\n// 代码执行，1000ms后，p2 的终值为 '我是p2的终值'\n\n```\n* 当调用 resolve 函数, resolve 的参数为 promise 对象\n1. promise 对象的状态、终值、拒因与传入的 promise 对象同步\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('error')\n})\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(p)\n})\n// p1 的状态为 rejected ，拒因为 error\n```\n\n* 当调用 resolve 函数, resolve 的参数为 thenable 对象\n1. 会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet thenable3 = {\n    then:function(resolve,reject){\n        throw new Error(3)\n    }\n}\nlet thenable4 = {\n    then:function(fn1,fn2){\n        //不调用 fn1 fn2\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(thenable1);\n})\nlet p2 = new Promise((resolve,reject)=>{\n    resolve(thenable2);\n})\nlet p3 = new Promise((resolve,reject)=>{\n    resolve(thenable3);\n})\nlet p4 = new Promise((resolve,reject)=>{\n    resolve(thenable4);\n})\n// p1 的状态为 fulfilled 终值为 1\n// p2 的状态为 rejected  终值为 2\n// p3 的状态为 rejected  拒因为 Error：3\n// p4 的状态为 pending\n```\n* 当调用reject函数，reject函数的参数，作为promise对象的拒因\n* promise对象的状态变为rejected\n\n```\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p3');\n        reject('我是p3的拒因')\n    },1000);\n});\n// 代码执行，1000ms内，p3 的状态为 pending\n// 代码执行，1000ms后，p3 的状态为 rejected\n// 代码执行，1000ms后，p3 的拒因为 '我是p3的拒因'\n```\n\n## Promise对象上的方法\n### then方法\npromise提供一个then方法，用于访问其终值和拒因。\npromise的then 方法接受两个参数：\n```\npromise.then(onFulfilled, onRejected)\n```\n\n* onFulfilled函数用于当promise状态变为fulfilled时，接收终值。\n* onRejected函数用于当promise状态变为rejected时，接收拒因\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('异步任务获取的数据')\n    },50)\n}).then((data)=>{\n    console.log(data)\n})\n// 异步任务获取的数据\n\n```\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        reject(new Error('异步任务异常'))\n    },50)\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 异步任务异常\n```\n```\nnew Promise((resolve,reject)=>{\n    throw new Error('抛出一个异常');\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 抛出一个异常\n```\n### onFulfilled 和 onRejected 参数可选\n\n* 如果 onFulfilled 不是函数，其必须被忽略\n* 如果 onRejected 不是函数，其必须被忽略\n\n#### onFulfilled 的特性\n如果onFulfilled是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的终值\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onRejected 的特性\n如果onRejected是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的拒因\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onFulfilled 和 onRejected 的调用时机\n\n* 当 promise 对象的状态变为 fulfilled 或 rejected 时调用\n* onFulfilled、onRejected 永远都是异步调用\n* onFulfilled、onRejected 在事件队列中作为微任务来处理\n\n```\nconsole.log(1);\nsetTimeout(function(){\n    console.log(2)\n},0)\nnew Promise((resolve,reject)=>{\n    resolve(3);\n}).then((data)=>{\n    console.log(data);\n})\nconsole.log(4)\n// print: 1 4 3 2\n```\n#### onFulfilled 和 onRejected 的调用要求\n* onFulfilled 和 onRejected 必须被作为函数调用\n* 非严格模式下，this 为全局对象\n* 严格模式下，this 为 undefined\n```\nfunction fn1(){\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfunction fn2(){\n    \"use strict\";\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfn1(); // print: window\nfn2(); // print: undefined\n```\n## then方法的多次调用\n\n* then方法可以被同一个promise对象多次调用\n* then方法会返回一个新的promise对象\n* 当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调\n* 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调\n```\nlet p = new Promise((resolve)=>{\n    resolve()\n});\nlet p1 = p.then(()=>{\n    console.log('异步执行，第一个onFulfilled');\n});\nlet p2 = p.then(()=>{\n    console.log('异步执行，第二个onFulfilled');\n});\nconsole.log(p1.constructor === Promise);\nconsole.log(p === p1);\nconsole.log(p === p2);\nconsole.log(p1 === p2);\n// print: true\n// print: false\n// print: false\n// print: false\n// print: 异步执行，第一个onFulfilled\n// print: 异步执行，第二个onFulfilled\n```\n#### then方法的返回值\nthen方法返回一个promise对象\n```\npromise2 = promise1.then(onFulfilled, onRejected);   \n```\n* 若onFulfilled 、onRejected 返回一个非promise\n对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x\n```\nlet p = new Promise((resolve,reject)=>{\n    throw new Error();\n});\nlet p1 = p.then(null,(data)=>{\n    return '我是p2的终值'\n});\np1.then((data)=>{\n    console.log(data)\n});\n// print: 我是p2的终值\n```\n* 若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\nlet p3 = new Promise((resolve)=>{\n    resolve()\n})\nlet p4 = p3.then(()=>{\n    return p1;\n})\nlet p5 = p3.then(()=>{\n    return p2;\n})\n// p4 的状态为 fulfilled 终值为 1\n// p5 的状态为 rejected  拒因为 2\n\n```\n* 若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve()\n})\nlet p2 = p1.then(()=>{\n    return thenable1;\n})\nlet p3 = p1.then(()=>{\n    return thenable2;\n})\n// p2 的状态为 fulfilled 终值为 1\n// p3 的状态为 rejected  拒因为 2\n```\n* 若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve();\n});\nlet p1 = p.then((data)=>{\n    throw new Error('error')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:&emsp;Error: error\n```\n* 若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p1的终值');\n});\nlet p1 = p.then(null,null);\np1.then((data)=>{\n    console.log(data);\n});\n// print:&emsp;我是p1的终值\n```\n* 若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('我是p1的拒因');\n});\nlet p1 = p.then(null,null);\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:我是p1的拒因\n```\n* 若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p的终值');\n});\nlet p1 = p.then((data)=>{\n    throw new Error('异常')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:Error: 异常\n```\n### 终值和拒因的穿透特性\n\n* 如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled\n\n1. then 方法返回的 promise 对象的状态变为 fulfilled\n2. then 方法返回的 promise 对象的终值与原 promise 对象的终值相同\n\n\n* 如果 promise 的状态变为 rejected，then 方法没有注册 onRejected\n\n1. then 方法返回的 promise 对象的状态变为 rejected\n2. then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\n\nlet p3 = p1.then(null,null);\nlet p4 = p2.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n\n\np5 = p3.then(null,null);\np6 = p4.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n```\n\n* 穿透特性主要用于异常处理\n```\nlet fn1 = function(){}\nlet fn2 = function(){}\nlet fn3 = function(){}\nlet fn4 = function(){}\nlet fn5 = function(){}\nlet onError = function(){};\nnew Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject()\n    })\n})\n.then(fn1)\n.then(fn2)\n.then(fn3)\n.then(fn4)\n.then(fn5)\n.then(null,onError)\n```\nfn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误\n\n### catch方法：\ncatch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同\n```\nnew Promise((resolve,reject)=>{\n    reject()\n}).then(null,function(error){\n\n})\n// 等同于\nnew Promise((resolve,reject)=>{\n    reject()\n}).catch(function(error){\n\n})\n```\n## Promise 的静态方法\n### Promise.resolve\nPromise.resolve 方法用于将现有数据转换为 promise 对象\n\n* 若入参为 promise 对象\n\n返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步\n\n* 若入参为 thenable 对象\n\n会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n* 若入参为非 promise 非 thenable 对象\n\n1.返回的 promise 对象的状态为 fulfilled\n2.返回的 promise 对象的终值为 Promise.resolve 方法的入参\n\n```\nlet p = Promise.resolve(x)\n// 等价于\nlet p = new Promise((resolve)=>{\n    resolve(x)\n})\n\n```\n\n### Promise.reject\n* Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象\n```\n\nlet p = Promise.reject(x)\n// 等价于\nlet p = new Promise((resolve,reject)=>{\n    reject(x)\n})\n```\n### Promise.all\n* Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.all([p1, p2, p3]);\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\np 的状态由 p1、p2、p3 决定\n\n* 当 p1、p2、p3 的状态都变成 fulfilled\n\np 的状态为 fulfilled\n此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值\n\n* 当 p1、p2、p3 的状态有一个变成 rejected\n\np 的状态变为 rejected\n此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因\n```\nlet p1 = Promise.resolve(1);\nlet p2 = Promise.resolve(2);\nlet p3 = 3;\n\nPromise.all([p1,p2,p3]).then((data)=>{\n    console.log(data); // print: [1,2,3]\n})\n```\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.all([p1,p2,p3]).catch((error)=>{\n    console.log(error); // print: p3 error\n})\n```\n### Promise.race\n* Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.race([p1, p2, p3]);\n\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\n* p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定\n* p 的终值或拒因由最先变更状态的 promise 对象所决定\n\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: 1\n```\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        resolve(1)\n    },1000)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },800)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\n\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: p3 error\n```\n## Promise 的错误捕获\n当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误\n```\n// node 环境下\nprocess.on('unhandledRejection', error => {\n    console.log('unhandledRejection', error);\n});\n// 浏览器下\nwindow.addEventListener('unhandledrejection',(e)=>{\n    e.preventDefault();\n    console.log(e);\n});\n\n```\n## Promise 的问题\n\n* 无法取消Promise，若没有状态变更，也无法停止 promise 的等待\n* 不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获\n* 未完成状态时，无法得知是刚开始，还是即将完成\n\n参考链接：https://juejin.im/post/5d06e9c76fb9a07ee4636235","slug":"promise","published":1,"updated":"2019-09-04T09:41:36.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4u5001nygkcv73a4g40","content":"<p>Author: Echo<br>Time: 2019-08-26 10:44:24</p>\n<h1 id=\"理解【ES6】Promise\"><a href=\"#理解【ES6】Promise\" class=\"headerlink\" title=\"理解【ES6】Promise\"></a>理解【ES6】Promise</h1><h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h2><p>Promise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>\n<ul>\n<li>从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。</li>\n</ul>\n<h2 id=\"代码书写比较\"><a href=\"#代码书写比较\" class=\"headerlink\" title=\"代码书写比较\"></a>代码书写比较</h2><p>首先封装一个支持Promise的ajax方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function request(url,data = &#123;&#125;)&#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url,</span><br><span class=\"line\">            data,</span><br><span class=\"line\">            success:function (data) &#123;</span><br><span class=\"line\">                resolve(data);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error:function (error) &#123;</span><br><span class=\"line\">                reject(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;。</span><br></pre></td></tr></table></figure></p>\n<p>用 request 方法实现多个互相依赖的网络请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let url1 = &apos;http://xxx.xxx.1&apos;;</span><br><span class=\"line\">let url2 = &apos;http://xxx.xxx.2&apos;;</span><br><span class=\"line\">let url3 = &apos;http://xxx.xxx.3&apos;;</span><br><span class=\"line\">request(url1)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url2,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url3,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch((error)=&gt;&#123;</span><br><span class=\"line\">        console.log(error);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的特性\"><a href=\"#Promise-的特性\" class=\"headerlink\" title=\"Promise 的特性\"></a>Promise 的特性</h2><h3 id=\"Promise-的状态、\"><a href=\"#Promise-的状态、\" class=\"headerlink\" title=\"Promise 的状态、\"></a>Promise 的状态、</h3><ul>\n<li>pending (等待态)</li>\n<li>fulfilled (完成态)</li>\n<li>rejected (拒绝态)</li>\n</ul>\n<h3 id=\"终值与拒因\"><a href=\"#终值与拒因\" class=\"headerlink\" title=\"终值与拒因\"></a>终值与拒因</h3><ul>\n<li>终值： 指的是promise被解决时传递给解决回掉的值</li>\n<li>拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因</li>\n</ul>\n<h3 id=\"状态与状态关系，状态与终值和拒因的关系\"><a href=\"#状态与状态关系，状态与终值和拒因的关系\" class=\"headerlink\" title=\"状态与状态关系，状态与终值和拒因的关系\"></a>状态与状态关系，状态与终值和拒因的关系</h3><ul>\n<li>pending可以迁移至fulfilled或rejected</li>\n<li>fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值</li>\n<li>rejected 不能迁移至其他状态，必须拥有一个不可变的据因</li>\n</ul>\n<h2 id=\"Promise-的使用\"><a href=\"#Promise-的使用\" class=\"headerlink\" title=\"Promise 的使用\"></a>Promise 的使用</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>Promise 是一个构造函数，使用new操作符返回一个promise对象</p>\n<p>构造函数接收一个 excutor函数作为参数</p>\n<p>excutor函数有两个函数类型的参数resolve和reject</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">     // 在 excutor 函数中执行异步操作</span><br><span class=\"line\">     // 当异步操作完成后，调用 resolve 函数或 reject 函数</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数在调用时，excutor函数会作为同步代码立即执行</li>\n<li>我们通常在excutor函数中执行我们的异步操作</li>\n<li>未调用resolve、reject函数时，promise对象的状态为pending</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p1&apos;);</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// p1 的状态一直为 pending</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用resolve函数，resolve的参数为非promise对象，非thenable对象</li>\n</ul>\n<ol>\n<li>resolve 函数的参数，作为 promise 对象的终值</li>\n<li>promise 对象的状态变为 fulfilled</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p2&apos;);</span><br><span class=\"line\">        resolve(&apos;我是p2的终值&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p2 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的状态为 fulfilled</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的终值为 &apos;我是p2的终值&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 promise 对象</li>\n</ul>\n<ol>\n<li>promise 对象的状态、终值、拒因与传入的 promise 对象同步<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;error&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(p)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 rejected ，拒因为 error</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 thenable 对象</li>\n</ul>\n<ol>\n<li>会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable3 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        throw new Error(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable4 = &#123;</span><br><span class=\"line\">    then:function(fn1,fn2)&#123;</span><br><span class=\"line\">        //不调用 fn1 fn2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable1);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable2);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable3);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable4);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p2 的状态为 rejected  终值为 2</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 Error：3</span><br><span class=\"line\">// p4 的状态为 pending</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用reject函数，reject函数的参数，作为promise对象的拒因</li>\n<li>promise对象的状态变为rejected</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p3&apos;);</span><br><span class=\"line\">        reject(&apos;我是p3的拒因&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p3 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的状态为 rejected</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的拒因为 &apos;我是p3的拒因&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise对象上的方法\"><a href=\"#Promise对象上的方法\" class=\"headerlink\" title=\"Promise对象上的方法\"></a>Promise对象上的方法</h2><h3 id=\"then方法\"><a href=\"#then方法\" class=\"headerlink\" title=\"then方法\"></a>then方法</h3><p>promise提供一个then方法，用于访问其终值和拒因。<br>promise的then 方法接受两个参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>onFulfilled函数用于当promise状态变为fulfilled时，接收终值。</li>\n<li>onRejected函数用于当promise状态变为rejected时，接收拒因<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;异步任务获取的数据&apos;)</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 异步任务获取的数据</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        reject(new Error(&apos;异步任务异常&apos;))</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 异步任务异常</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;抛出一个异常&apos;);</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 抛出一个异常</span><br></pre></td></tr></table></figure>\n<h3 id=\"onFulfilled-和-onRejected-参数可选\"><a href=\"#onFulfilled-和-onRejected-参数可选\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 参数可选\"></a>onFulfilled 和 onRejected 参数可选</h3><ul>\n<li>如果 onFulfilled 不是函数，其必须被忽略</li>\n<li>如果 onRejected 不是函数，其必须被忽略</li>\n</ul>\n<h4 id=\"onFulfilled-的特性\"><a href=\"#onFulfilled-的特性\" class=\"headerlink\" title=\"onFulfilled 的特性\"></a>onFulfilled 的特性</h4><p>如果onFulfilled是函数：</p>\n<ul>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的终值</li>\n<li>当promise执行结束前其不可被调用</li>\n<li>其调用次数不可超过1次<h4 id=\"onRejected-的特性\"><a href=\"#onRejected-的特性\" class=\"headerlink\" title=\"onRejected 的特性\"></a>onRejected 的特性</h4>如果onRejected是函数：</li>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的拒因</li>\n<li>当promise执行结束前其不可被调用</li>\n<li><p>其调用次数不可超过1次</p>\n<h4 id=\"onFulfilled-和-onRejected-的调用时机\"><a href=\"#onFulfilled-和-onRejected-的调用时机\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用时机\"></a>onFulfilled 和 onRejected 的调用时机</h4></li>\n<li><p>当 promise 对象的状态变为 fulfilled 或 rejected 时调用</p>\n</li>\n<li>onFulfilled、onRejected 永远都是异步调用</li>\n<li>onFulfilled、onRejected 在事件队列中作为微任务来处理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;,0)</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(3);</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(4)</span><br><span class=\"line\">// print: 1 4 3 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"onFulfilled-和-onRejected-的调用要求\"><a href=\"#onFulfilled-和-onRejected-的调用要求\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用要求\"></a>onFulfilled 和 onRejected 的调用要求</h4><ul>\n<li>onFulfilled 和 onRejected 必须被作为函数调用</li>\n<li>非严格模式下，this 为全局对象</li>\n<li>严格模式下，this 为 undefined<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\">    &quot;use strict&quot;;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1(); // print: window</span><br><span class=\"line\">fn2(); // print: undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"then方法的多次调用\"><a href=\"#then方法的多次调用\" class=\"headerlink\" title=\"then方法的多次调用\"></a>then方法的多次调用</h2><ul>\n<li>then方法可以被同一个promise对象多次调用</li>\n<li>then方法会返回一个新的promise对象</li>\n<li>当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调</li>\n<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第一个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p2 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第二个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1.constructor === Promise);</span><br><span class=\"line\">console.log(p === p1);</span><br><span class=\"line\">console.log(p === p2);</span><br><span class=\"line\">console.log(p1 === p2);</span><br><span class=\"line\">// print: true</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: 异步执行，第一个onFulfilled</span><br><span class=\"line\">// print: 异步执行，第二个onFulfilled</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"then方法的返回值\"><a href=\"#then方法的返回值\" class=\"headerlink\" title=\"then方法的返回值\"></a>then方法的返回值</h4><p>then方法返回一个promise对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>若onFulfilled 、onRejected 返回一个非promise<br>对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,(data)=&gt;&#123;</span><br><span class=\"line\">    return &apos;我是p2的终值&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print: 我是p2的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p5 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p4 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p5 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p2 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;error&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;Error: error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p1的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;我是p1的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;我是p1的拒因&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:我是p1的拒因</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;异常&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:Error: 异常</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"终值和拒因的穿透特性\"><a href=\"#终值和拒因的穿透特性\" class=\"headerlink\" title=\"终值和拒因的穿透特性\"></a>终值和拒因的穿透特性</h3><ul>\n<li>如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 fulfilled</li>\n<li>then 方法返回的 promise 对象的终值与原 promise 对象的终值相同</li>\n</ol>\n<ul>\n<li>如果 promise 的状态变为 rejected，then 方法没有注册 onRejected</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 rejected</li>\n<li>then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">let p3 = p1.then(null,null);</span><br><span class=\"line\">let p4 = p2.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p5 = p3.then(null,null);</span><br><span class=\"line\">p6 = p4.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>穿透特性主要用于异常处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn1 = function()&#123;&#125;</span><br><span class=\"line\">let fn2 = function()&#123;&#125;</span><br><span class=\"line\">let fn3 = function()&#123;&#125;</span><br><span class=\"line\">let fn4 = function()&#123;&#125;</span><br><span class=\"line\">let fn5 = function()&#123;&#125;</span><br><span class=\"line\">let onError = function()&#123;&#125;;</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(fn1)</span><br><span class=\"line\">.then(fn2)</span><br><span class=\"line\">.then(fn3)</span><br><span class=\"line\">.then(fn4)</span><br><span class=\"line\">.then(fn5)</span><br><span class=\"line\">.then(null,onError)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>fn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误</p>\n<h3 id=\"catch方法：\"><a href=\"#catch方法：\" class=\"headerlink\" title=\"catch方法：\"></a>catch方法：</h3><p>catch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).then(null,function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).catch(function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的静态方法\"><a href=\"#Promise-的静态方法\" class=\"headerlink\" title=\"Promise 的静态方法\"></a>Promise 的静态方法</h2><h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p>Promise.resolve 方法用于将现有数据转换为 promise 对象</p>\n<ul>\n<li>若入参为 promise 对象</li>\n</ul>\n<p>返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步</p>\n<ul>\n<li>若入参为 thenable 对象</li>\n</ul>\n<p>会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</p>\n<ul>\n<li>若入参为非 promise 非 thenable 对象</li>\n</ul>\n<p>1.返回的 promise 对象的状态为 fulfilled<br>2.返回的 promise 对象的终值为 Promise.resolve 方法的入参</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = Promise.resolve(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><ul>\n<li>Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let p = Promise.reject(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><ul>\n<li><p>Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象<br>p 的状态由 p1、p2、p3 决定</p>\n</li>\n<li><p>当 p1、p2、p3 的状态都变成 fulfilled</p>\n</li>\n</ul>\n<p>p 的状态为 fulfilled<br>此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值</p>\n<ul>\n<li>当 p1、p2、p3 的状态有一个变成 rejected</li>\n</ul>\n<p>p 的状态变为 rejected<br>此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = Promise.resolve(2);</span><br><span class=\"line\">let p3 = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p3]).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data); // print: [1,2,3]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.all([p1,p2,p3]).catch((error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error); // print: p3 error</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><ul>\n<li><p>Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象</p>\n</li>\n<li>p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定</li>\n<li>p 的终值或拒因由最先变更状态的 promise 对象所决定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,800)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: p3 error</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise-的错误捕获\"><a href=\"#Promise-的错误捕获\" class=\"headerlink\" title=\"Promise 的错误捕获\"></a>Promise 的错误捕获</h2><p>当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// node 环境下</span><br><span class=\"line\">process.on(&apos;unhandledRejection&apos;, error =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;unhandledRejection&apos;, error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 浏览器下</span><br><span class=\"line\">window.addEventListener(&apos;unhandledrejection&apos;,(e)=&gt;&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的问题\"><a href=\"#Promise-的问题\" class=\"headerlink\" title=\"Promise 的问题\"></a>Promise 的问题</h2><ul>\n<li>无法取消Promise，若没有状态变更，也无法停止 promise 的等待</li>\n<li>不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获</li>\n<li>未完成状态时，无法得知是刚开始，还是即将完成</li>\n</ul>\n<p>参考链接：<a href=\"https://juejin.im/post/5d06e9c76fb9a07ee4636235\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d06e9c76fb9a07ee4636235</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-26 10:44:24</p>\n<h1 id=\"理解【ES6】Promise\"><a href=\"#理解【ES6】Promise\" class=\"headerlink\" title=\"理解【ES6】Promise\"></a>理解【ES6】Promise</h1><h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h2><p>Promise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>\n<ul>\n<li>从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。</li>\n</ul>\n<h2 id=\"代码书写比较\"><a href=\"#代码书写比较\" class=\"headerlink\" title=\"代码书写比较\"></a>代码书写比较</h2><p>首先封装一个支持Promise的ajax方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function request(url,data = &#123;&#125;)&#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url,</span><br><span class=\"line\">            data,</span><br><span class=\"line\">            success:function (data) &#123;</span><br><span class=\"line\">                resolve(data);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error:function (error) &#123;</span><br><span class=\"line\">                reject(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;。</span><br></pre></td></tr></table></figure></p>\n<p>用 request 方法实现多个互相依赖的网络请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let url1 = &apos;http://xxx.xxx.1&apos;;</span><br><span class=\"line\">let url2 = &apos;http://xxx.xxx.2&apos;;</span><br><span class=\"line\">let url3 = &apos;http://xxx.xxx.3&apos;;</span><br><span class=\"line\">request(url1)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url2,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url3,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch((error)=&gt;&#123;</span><br><span class=\"line\">        console.log(error);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的特性\"><a href=\"#Promise-的特性\" class=\"headerlink\" title=\"Promise 的特性\"></a>Promise 的特性</h2><h3 id=\"Promise-的状态、\"><a href=\"#Promise-的状态、\" class=\"headerlink\" title=\"Promise 的状态、\"></a>Promise 的状态、</h3><ul>\n<li>pending (等待态)</li>\n<li>fulfilled (完成态)</li>\n<li>rejected (拒绝态)</li>\n</ul>\n<h3 id=\"终值与拒因\"><a href=\"#终值与拒因\" class=\"headerlink\" title=\"终值与拒因\"></a>终值与拒因</h3><ul>\n<li>终值： 指的是promise被解决时传递给解决回掉的值</li>\n<li>拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因</li>\n</ul>\n<h3 id=\"状态与状态关系，状态与终值和拒因的关系\"><a href=\"#状态与状态关系，状态与终值和拒因的关系\" class=\"headerlink\" title=\"状态与状态关系，状态与终值和拒因的关系\"></a>状态与状态关系，状态与终值和拒因的关系</h3><ul>\n<li>pending可以迁移至fulfilled或rejected</li>\n<li>fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值</li>\n<li>rejected 不能迁移至其他状态，必须拥有一个不可变的据因</li>\n</ul>\n<h2 id=\"Promise-的使用\"><a href=\"#Promise-的使用\" class=\"headerlink\" title=\"Promise 的使用\"></a>Promise 的使用</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>Promise 是一个构造函数，使用new操作符返回一个promise对象</p>\n<p>构造函数接收一个 excutor函数作为参数</p>\n<p>excutor函数有两个函数类型的参数resolve和reject</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">     // 在 excutor 函数中执行异步操作</span><br><span class=\"line\">     // 当异步操作完成后，调用 resolve 函数或 reject 函数</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数在调用时，excutor函数会作为同步代码立即执行</li>\n<li>我们通常在excutor函数中执行我们的异步操作</li>\n<li>未调用resolve、reject函数时，promise对象的状态为pending</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p1&apos;);</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// p1 的状态一直为 pending</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用resolve函数，resolve的参数为非promise对象，非thenable对象</li>\n</ul>\n<ol>\n<li>resolve 函数的参数，作为 promise 对象的终值</li>\n<li>promise 对象的状态变为 fulfilled</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p2&apos;);</span><br><span class=\"line\">        resolve(&apos;我是p2的终值&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p2 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的状态为 fulfilled</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的终值为 &apos;我是p2的终值&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 promise 对象</li>\n</ul>\n<ol>\n<li>promise 对象的状态、终值、拒因与传入的 promise 对象同步<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;error&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(p)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 rejected ，拒因为 error</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 thenable 对象</li>\n</ul>\n<ol>\n<li>会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable3 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        throw new Error(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable4 = &#123;</span><br><span class=\"line\">    then:function(fn1,fn2)&#123;</span><br><span class=\"line\">        //不调用 fn1 fn2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable1);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable2);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable3);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable4);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p2 的状态为 rejected  终值为 2</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 Error：3</span><br><span class=\"line\">// p4 的状态为 pending</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用reject函数，reject函数的参数，作为promise对象的拒因</li>\n<li>promise对象的状态变为rejected</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p3&apos;);</span><br><span class=\"line\">        reject(&apos;我是p3的拒因&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p3 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的状态为 rejected</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的拒因为 &apos;我是p3的拒因&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise对象上的方法\"><a href=\"#Promise对象上的方法\" class=\"headerlink\" title=\"Promise对象上的方法\"></a>Promise对象上的方法</h2><h3 id=\"then方法\"><a href=\"#then方法\" class=\"headerlink\" title=\"then方法\"></a>then方法</h3><p>promise提供一个then方法，用于访问其终值和拒因。<br>promise的then 方法接受两个参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>onFulfilled函数用于当promise状态变为fulfilled时，接收终值。</li>\n<li>onRejected函数用于当promise状态变为rejected时，接收拒因<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;异步任务获取的数据&apos;)</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 异步任务获取的数据</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        reject(new Error(&apos;异步任务异常&apos;))</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 异步任务异常</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;抛出一个异常&apos;);</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 抛出一个异常</span><br></pre></td></tr></table></figure>\n<h3 id=\"onFulfilled-和-onRejected-参数可选\"><a href=\"#onFulfilled-和-onRejected-参数可选\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 参数可选\"></a>onFulfilled 和 onRejected 参数可选</h3><ul>\n<li>如果 onFulfilled 不是函数，其必须被忽略</li>\n<li>如果 onRejected 不是函数，其必须被忽略</li>\n</ul>\n<h4 id=\"onFulfilled-的特性\"><a href=\"#onFulfilled-的特性\" class=\"headerlink\" title=\"onFulfilled 的特性\"></a>onFulfilled 的特性</h4><p>如果onFulfilled是函数：</p>\n<ul>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的终值</li>\n<li>当promise执行结束前其不可被调用</li>\n<li>其调用次数不可超过1次<h4 id=\"onRejected-的特性\"><a href=\"#onRejected-的特性\" class=\"headerlink\" title=\"onRejected 的特性\"></a>onRejected 的特性</h4>如果onRejected是函数：</li>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的拒因</li>\n<li>当promise执行结束前其不可被调用</li>\n<li><p>其调用次数不可超过1次</p>\n<h4 id=\"onFulfilled-和-onRejected-的调用时机\"><a href=\"#onFulfilled-和-onRejected-的调用时机\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用时机\"></a>onFulfilled 和 onRejected 的调用时机</h4></li>\n<li><p>当 promise 对象的状态变为 fulfilled 或 rejected 时调用</p>\n</li>\n<li>onFulfilled、onRejected 永远都是异步调用</li>\n<li>onFulfilled、onRejected 在事件队列中作为微任务来处理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;,0)</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(3);</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(4)</span><br><span class=\"line\">// print: 1 4 3 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"onFulfilled-和-onRejected-的调用要求\"><a href=\"#onFulfilled-和-onRejected-的调用要求\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用要求\"></a>onFulfilled 和 onRejected 的调用要求</h4><ul>\n<li>onFulfilled 和 onRejected 必须被作为函数调用</li>\n<li>非严格模式下，this 为全局对象</li>\n<li>严格模式下，this 为 undefined<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\">    &quot;use strict&quot;;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1(); // print: window</span><br><span class=\"line\">fn2(); // print: undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"then方法的多次调用\"><a href=\"#then方法的多次调用\" class=\"headerlink\" title=\"then方法的多次调用\"></a>then方法的多次调用</h2><ul>\n<li>then方法可以被同一个promise对象多次调用</li>\n<li>then方法会返回一个新的promise对象</li>\n<li>当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调</li>\n<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第一个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p2 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第二个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1.constructor === Promise);</span><br><span class=\"line\">console.log(p === p1);</span><br><span class=\"line\">console.log(p === p2);</span><br><span class=\"line\">console.log(p1 === p2);</span><br><span class=\"line\">// print: true</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: 异步执行，第一个onFulfilled</span><br><span class=\"line\">// print: 异步执行，第二个onFulfilled</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"then方法的返回值\"><a href=\"#then方法的返回值\" class=\"headerlink\" title=\"then方法的返回值\"></a>then方法的返回值</h4><p>then方法返回一个promise对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>若onFulfilled 、onRejected 返回一个非promise<br>对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,(data)=&gt;&#123;</span><br><span class=\"line\">    return &apos;我是p2的终值&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print: 我是p2的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p5 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p4 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p5 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p2 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;error&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;Error: error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p1的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;我是p1的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;我是p1的拒因&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:我是p1的拒因</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;异常&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:Error: 异常</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"终值和拒因的穿透特性\"><a href=\"#终值和拒因的穿透特性\" class=\"headerlink\" title=\"终值和拒因的穿透特性\"></a>终值和拒因的穿透特性</h3><ul>\n<li>如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 fulfilled</li>\n<li>then 方法返回的 promise 对象的终值与原 promise 对象的终值相同</li>\n</ol>\n<ul>\n<li>如果 promise 的状态变为 rejected，then 方法没有注册 onRejected</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 rejected</li>\n<li>then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">let p3 = p1.then(null,null);</span><br><span class=\"line\">let p4 = p2.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p5 = p3.then(null,null);</span><br><span class=\"line\">p6 = p4.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>穿透特性主要用于异常处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn1 = function()&#123;&#125;</span><br><span class=\"line\">let fn2 = function()&#123;&#125;</span><br><span class=\"line\">let fn3 = function()&#123;&#125;</span><br><span class=\"line\">let fn4 = function()&#123;&#125;</span><br><span class=\"line\">let fn5 = function()&#123;&#125;</span><br><span class=\"line\">let onError = function()&#123;&#125;;</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(fn1)</span><br><span class=\"line\">.then(fn2)</span><br><span class=\"line\">.then(fn3)</span><br><span class=\"line\">.then(fn4)</span><br><span class=\"line\">.then(fn5)</span><br><span class=\"line\">.then(null,onError)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>fn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误</p>\n<h3 id=\"catch方法：\"><a href=\"#catch方法：\" class=\"headerlink\" title=\"catch方法：\"></a>catch方法：</h3><p>catch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).then(null,function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).catch(function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的静态方法\"><a href=\"#Promise-的静态方法\" class=\"headerlink\" title=\"Promise 的静态方法\"></a>Promise 的静态方法</h2><h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p>Promise.resolve 方法用于将现有数据转换为 promise 对象</p>\n<ul>\n<li>若入参为 promise 对象</li>\n</ul>\n<p>返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步</p>\n<ul>\n<li>若入参为 thenable 对象</li>\n</ul>\n<p>会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</p>\n<ul>\n<li>若入参为非 promise 非 thenable 对象</li>\n</ul>\n<p>1.返回的 promise 对象的状态为 fulfilled<br>2.返回的 promise 对象的终值为 Promise.resolve 方法的入参</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = Promise.resolve(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><ul>\n<li>Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let p = Promise.reject(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><ul>\n<li><p>Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象<br>p 的状态由 p1、p2、p3 决定</p>\n</li>\n<li><p>当 p1、p2、p3 的状态都变成 fulfilled</p>\n</li>\n</ul>\n<p>p 的状态为 fulfilled<br>此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值</p>\n<ul>\n<li>当 p1、p2、p3 的状态有一个变成 rejected</li>\n</ul>\n<p>p 的状态变为 rejected<br>此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = Promise.resolve(2);</span><br><span class=\"line\">let p3 = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p3]).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data); // print: [1,2,3]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.all([p1,p2,p3]).catch((error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error); // print: p3 error</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><ul>\n<li><p>Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象</p>\n</li>\n<li>p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定</li>\n<li>p 的终值或拒因由最先变更状态的 promise 对象所决定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,800)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: p3 error</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise-的错误捕获\"><a href=\"#Promise-的错误捕获\" class=\"headerlink\" title=\"Promise 的错误捕获\"></a>Promise 的错误捕获</h2><p>当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// node 环境下</span><br><span class=\"line\">process.on(&apos;unhandledRejection&apos;, error =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;unhandledRejection&apos;, error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 浏览器下</span><br><span class=\"line\">window.addEventListener(&apos;unhandledrejection&apos;,(e)=&gt;&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的问题\"><a href=\"#Promise-的问题\" class=\"headerlink\" title=\"Promise 的问题\"></a>Promise 的问题</h2><ul>\n<li>无法取消Promise，若没有状态变更，也无法停止 promise 的等待</li>\n<li>不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获</li>\n<li>未完成状态时，无法得知是刚开始，还是即将完成</li>\n</ul>\n<p>参考链接：<a href=\"https://juejin.im/post/5d06e9c76fb9a07ee4636235\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d06e9c76fb9a07ee4636235</a></p>\n"},{"title":"了解vue源码","date":"2019-09-03T01:47:57.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-03 09:47:57\n\n## new Vue()做了什么？\nnew关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是\n`/src/core/instance/index.js`\n```\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n接着我们跳转追踪至`this._init()`，即`Vue.prototype._init`,位于`src\\core\\instance\\init.js`.\n在`_init()`方法的内部有一系列 `init*` 的方法\n```\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // ...忽略，从第45行看起\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n    // ...忽略\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n统一概述一遍new Vue()时做了什么处理:\n\n* `initProxy`，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)\n* `initLifecycle`（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。\n* `initEvents`，用来存放除@hook:生命周期钩子名称=\"绑定的函数\"事件的对象。如:$on、$emit等。\n* `initRender`，用于初始化$slots、$attrs、$listeners\n* `initInjections`，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。\n* `initState`，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。\n* `initProvide`，初始化provide。\n* `vm.$mount`，挂载实例。\n\n## 什么阶段才能访问DOM？\n这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:\n```\ncallHook(vm, 'beforeCreate')\n// 初始化 inject\n// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)\n// 初始化 provide\ncallHook(vm, 'created')\n// 挂载实例 vm.$mount(vm.$options.el)\n// vue实例的数据对象data有了\n```\n所以当面试官问你:\n\n* beforeCreate以及 created 调用时，哪些数据能用与否？\n* 什么阶段才能访问DOM？\n* 为什么created之后才挂载实例？\n\n## 谈谈你对Vue的生命周期的理解？\n生命周期函数解释说明（图片）：https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\n##### 理解:\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会\n##### 生命周期的几个阶段:\n1. created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=>挂载=>更新=>销毁\n* beforeCreate & created 看上一题\n* beforeMount & mounted\n```\ncallHook(vm, 'beforeMount')\n// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，\ncallHook(vm, 'mounted')\n// vue实例挂载完成，data.message成功渲染\n```\n* beforeUpdate & updated\n```\ndata变化会触发beforeUpdate和updated方法\n```\n* beforeDestroy & destroyed\n```\ncallHook(vm, 'destroyed')\n// data的改变不会再触发周期函数\n// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。\n```\n\n深入理解源码:\n\n2. Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。\n```\n// v2.6.10 最新版\nvar LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    // v2.6+ \n    'serverPrefetch' //看下一题\n];\n```\n于是，你可以答多`activated & deactivated`（keep-alive 组件激活/停用）、`errorCaptured`（v2.5 以上版本有的一个钩子，用于处理错误）这三个。\n\n-----\n\n## 生命周期钩子的合并策略\nhttps://www.cnblogs.com/xweizi/p/10572281.html\n\n----- \n单独抽出一天来处理\n\n## 新生命周期钩子：serverPrefetch是什么？\n```\n// v2.6.10的变化\n```\n可以看到，`serverPrefetch`前身是`ssrPrefetch`。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。\n![image](https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n这里我们贴出一段官方例子：\n```\n<!-- Item.vue -->\n<template>\n  <div v-if=\"item\">{{ item.title }}</div>\n  <div v-else>...</div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    item () {\n      return this.$store.state.items[this.$route.params.id]\n    }\n  },\n  serverPrefetch () {\n    return this.fetchItem()\n  },\n  mounted () {\n    if (!this.item) {\n      this.fetchItem()\n    }\n  },\n  methods: {\n    fetchItem () {\n      // return the Promise from the action\n      return this.$store.dispatch('fetchItem', this.$route.params.id)\n    }\n  }\n}\n</script>\n```\n## Vue-router 路由模式有几种？\n三种 \"hash\" | \"history\" | \"abstract\"，一般人只知道两种\"hash\" | \"history\"\n```\n// 源码：\n\nswitch (mode) {\n  case 'history':\n    this.history = new HTML5History(this, options.base)\n    break\n  case 'hash':\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case 'abstract':\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== 'production') {\n      assert(false, `invalid mode: ${mode}`)\n    }\n}\n```\n##### mode\n* 类型: string\n* 默认值: \"hash\" (浏览器环境) | \"abstract\" (Node.js 环境)\n* 可选值: \"hash\" | \"history\" | \"abstract\"\n\n配置路由模式:\n\n* hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。\n* history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。\n* abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.\n\n###### 路由模式解析\n对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.\n\n前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求\n`\n浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。\n`\n\n.\n\n* vue-router: hash\n\nhash模式中url带有#号，修改成history模式，url中的#自动就去除了。\n\nhash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：\n```\nwindow.onhashchange = function(event){\n    console.log(event.oldURL, event.newURL);\n    let hash = location.hash.slice(1)\n}\n```\n\nhash模式下，仅hash符号之前的内容会被包含在请求中,如 http://www.abc.com, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.\n\n* vue-router: history\n随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。\n　history api可以分为两大部分：切换和修改\n1. 切换历史状态\n\n包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：\n```\nhistory.go(-2);//后退两次\nhistory.go(2);//前进两次\nhistory.back(); //后退\nhsitory.forward(); //前进\n```\n`\n坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页\n`\n\n2. 修改历史状态\n包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url\n```\nhistory.pushState(stateObj，title，url)\nwindow.onpopstate = function(event){\n    console.log(event.state)\n    if(event.state && event.state.color === 'red'){\n        document.body.style.color = 'red';\n    }\n}\n\n```\n`\n坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。\n`\n3. popstate实现history路由拦截，监听页面返回事件\n当活动历史记录条目更改时，将触发popstate事件\n\n*  如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。\n\n* 需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；\n\n  　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）\n* vue-router: abstract\nabstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。\n\n根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式\n\n## 谈谈你对keep-alive的了解\n先贴一个常规回答：\n`\nkeep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。\n在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。\n<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n`\n\n`然后你可以开始骚了：`\n\n1. `<keep-alive>`是 Vue 源码中实现的一个全局抽象组件，通过自定义 `render` 函数并且利用了`插槽`来实现数据缓存和更新。它的定义在`src/core/components/keep-alive.js` 中：\n```\nexport default {\n  name: 'keep-alive',\n  abstract: true,\n  ...\n}\n```\n2. 所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：\n```\nif (parent && !options.abstract) {\n  // abstract 即 `ptions.abstract`\n  // while 循环查找第一个非抽象的父组件\n  while (parent.$options.abstract && parent.$parent) {\n    parent = parent.$parent\n  }\n  parent.$children.push(vm)\n}\n```\n\n3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。\n\n## vue源码中内置的组件？\n* component\n* transition\n* transition-group\n* keep-alive\n* slot\n## 了解Vue2.6+新全局API：Vue.observable()吗？\nVue2.6+新的全局API是Vue.observable(),它的使用方式：\n```\n// 准备个文件store.js - /store/store.js\nimport Vue from 'vue'\n\nexport const store = Vue.observable({ count: 0 })  //定义一个变量\nexport const mutations = {  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值\n  setCount (count) {\n    store.count = count\n  }\n}\n```\n返回的对象可以直接用于`渲染函数`和`计算属性`内，并且会在发生改变时触发相应的更新。\n```\n<template>\n    <div>\n        <p>你点+-，看我能不能根据状态去动态改变</p>\n        <label for=\"bookNum\">数量</label>\n        <button @click=\"setCount(count+1)\">+</button>\n        <span>{{count}}</span>\n        <button @click=\"setCount(count-1)\">-</button>\n    </div>\n</template>\n\n<script>\nimport { store, mutations } from '../store/store' // Vue2.6新增API Observable\n\nexport default {\n  name: 'Add',\n  computed: {\n    count () {\n      return store.count //用于去渲染之前Observable中定义的变量count\n    }\n  },\n  methods: {\n    setCount: mutations.setCount\n  }\n}\n</script>\n```\n## 了解Vue数据绑定原理？\n参考Vue.js官网介绍响应式原理图，我们进行分析：\n\n这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。\nVue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。\n\nVue在初始化组件数据时，在生命周期的`beforeCreate`与`created`钩子函数之间实现了对`data、props、computed、methods、events`以及`watch`的处理.\n\n* initData\n参考源码instance下的state.js文件\n\ninitData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。\n\n\n```\nfunction initData (vm: Component) {  \n  /*得到data数据*/\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} \n  /*判断是否是对象*/\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' +'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm)\n  }  \n  // proxy data on instance\n  /*遍历data对象*/\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  //遍历data中的数据\n  while (i--) {\n    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(`The data property \"${keys[i]}\" is already declared as a prop. ` +`Use prop default value instead.`,vm)\n    } else if (!isReserved(keys[i])) {\n      /*判断是否是保留字段*/\n      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/\n      proxy(vm, `_data`, keys[i])\n    }\n  }\n  // observe data\n  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  \n  observe(data, true /* asRootData */)\n  }\n```\n其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。\n\n* proxy\n接下来看一下proxy代理。\n\n```\n/*添加代理*/\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。\n\n* observe\n参考源码文件在core文件下oberver的index.js文件中\n\n\n```\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n /*\n 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  /*判断是否是一个对象*/\n  if (!isObject(value)) {\n    return\n  }\n  let ob: Observer | void\n\n  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n\n    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n\n    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/\n    ob.vmCount++\n  }\n  return ob\n}\n\n```\nVue的响应式数据都会有一个__ob__的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。\n* Observer\nObserver的作用就是遍历对象的所有属性将其进行双向绑定。\n\n```\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nexport class  {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n\n    /*\n    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16\n    */\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n\n      /*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      */\n      const augment = hasProto\n        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/\n        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/\n      augment(value, arrayMethods, arrayKeys)\n\n      /*如果是数组则需要遍历数组的每一个成员进行observe*/\n      this.observeArray(value)\n    } else {\n\n      /*如果是对象则直接walk进行绑定*/\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n\n    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n\n    /*数组需要便利每一个成员进行observe*/\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n```\nObserver为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。\n如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。\n但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？\n\nVue.js提供的方法是重写 `push、pop、shift、unshift、splice、sort、reverse`这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。\n```\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nimport { def } from '../util/index'\n\n/*取得原生数组的原型*/\nconst arrayProto = Array.prototype\n/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/\nexport const arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  /*将数组的原生方法缓存起来，后面要调用*/\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    let i = arguments.length\n    const args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    /*调用原生的数组方法*/\n    const result = original.apply(this, args)\n\n    /*数组新插入的元素需要重新进行observe才能响应式*/\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n      \n    // notify change\n    /*dep通知所有注册的观察者进行响应式处理*/\n    ob.dep.notify()\n    return result\n  })\n})\n```\n从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持__proto__这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。\n\n如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。\n\n在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。\n\n但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。\n\n* Watcher\n\nWatcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。\n\n\n```\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    this.vm = vm\n    /*_watchers存放订阅者实例*/\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.lazy // for lazy watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    /*把表达式expOrFn解析成getter*/\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n   /*获得getter的值并且重新进行依赖收集*/\n  get () {\n    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/\n    pushTarget(this)\n    let value\n    const vm = this.vm\n\n    /*\n      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。\n      在将Dep.target设置为自生观察者实例以后，执行getter操作。\n      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，\n      那么在执行getter的时候就会触发a跟c两个数据的getter函数，\n      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，\n      将该观察者对象放入闭包中的Dep的subs中去。\n    */\n    if (this.user) {\n      try {\n        value = this.getter.call(vm, vm)\n      } catch (e) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      }\n    } else {\n      value = this.getter.call(vm, vm)\n    }\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/\n    if (this.deep) {\n      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/\n      traverse(value)\n    }\n\n    /*将观察者实例从target栈中取出并设置给Dep.target*/\n    popTarget()\n    this.cleanupDeps()\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n   /*添加一个依赖关系到Deps集合中*/\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n   /*清理依赖收集*/\n  cleanupDeps () {\n    /*移除所有观察者对象*/\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n   /*\n      调度者接口，当依赖发生改变的时候进行回调。\n   */\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      /*同步则执行run直接渲染视图*/\n      this.run()\n    } else {\n      /*异步推送到观察者队列中，由调度者调用。*/\n      queueWatcher(this)\n    }\n  }\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n   /*\n      调度者工作接口，将被调度者回调。\n    */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        /*\n            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。\n        */\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        /*设置新的值*/\n        this.value = value\n\n        /*触发回调渲染视图*/\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n   /*获取观察者的值*/\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n   /*收集该watcher的所有deps依赖*/\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n   /*将自身从所有依赖收集订阅列表删除*/\n  teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n}\n```\n* Dep\n\n来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。\n\n```\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  /*添加一个观察者对象*/\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  /*移除一个观察者对象*/\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  /*依赖收集，当存在Dep.target的时候添加观察者对象*/\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  /*通知所有订阅者*/\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/\n```\n\n* defineReactive\n\n接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。\n触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。\n\n```\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  /*在闭包中定义一个dep对象*/\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n\n  /*对象的子对象递归进行observe并返回子节点的Observer对象*/\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n\n      /*如果原本对象拥有getter方法则执行*/\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n\n        /*进行依赖收集*/\n        dep.depend()\n        if (childOb) {\n\n          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/\n          childOb.dep.depend()\n        }\n        if (Array.isArray(value)) {\n\n          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/\n          dependArray(value)\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n\n      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (setter) {\n\n        /*如果原本对象拥有setter方法则执行setter*/\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n\n      /*新的值需要重新进行observe，保证数据响应式*/\n      childOb = observe(newVal)\n\n      /*dep对象通知所有的观察者*/\n      dep.notify()\n    }\n  })\n}\n```\n----\n整篇文章主要参考链接：https://juejin.im/post/5c959f74f265da610c068fa8\n源码解析参考链接：https://github.com/answershuto/learnVue\n\n\n\n","source":"_posts/vueSourceCoding.md","raw":"---\ntitle: 了解vue源码\ndate: 2019-09-03 09:47:57\ntags: vue\n---\n\nAuthor: Echo\nTime: 2019-09-03 09:47:57\n\n## new Vue()做了什么？\nnew关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是\n`/src/core/instance/index.js`\n```\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n接着我们跳转追踪至`this._init()`，即`Vue.prototype._init`,位于`src\\core\\instance\\init.js`.\n在`_init()`方法的内部有一系列 `init*` 的方法\n```\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // ...忽略，从第45行看起\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n    // ...忽略\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n统一概述一遍new Vue()时做了什么处理:\n\n* `initProxy`，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)\n* `initLifecycle`（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。\n* `initEvents`，用来存放除@hook:生命周期钩子名称=\"绑定的函数\"事件的对象。如:$on、$emit等。\n* `initRender`，用于初始化$slots、$attrs、$listeners\n* `initInjections`，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。\n* `initState`，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。\n* `initProvide`，初始化provide。\n* `vm.$mount`，挂载实例。\n\n## 什么阶段才能访问DOM？\n这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:\n```\ncallHook(vm, 'beforeCreate')\n// 初始化 inject\n// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)\n// 初始化 provide\ncallHook(vm, 'created')\n// 挂载实例 vm.$mount(vm.$options.el)\n// vue实例的数据对象data有了\n```\n所以当面试官问你:\n\n* beforeCreate以及 created 调用时，哪些数据能用与否？\n* 什么阶段才能访问DOM？\n* 为什么created之后才挂载实例？\n\n## 谈谈你对Vue的生命周期的理解？\n生命周期函数解释说明（图片）：https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\n##### 理解:\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会\n##### 生命周期的几个阶段:\n1. created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=>挂载=>更新=>销毁\n* beforeCreate & created 看上一题\n* beforeMount & mounted\n```\ncallHook(vm, 'beforeMount')\n// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，\ncallHook(vm, 'mounted')\n// vue实例挂载完成，data.message成功渲染\n```\n* beforeUpdate & updated\n```\ndata变化会触发beforeUpdate和updated方法\n```\n* beforeDestroy & destroyed\n```\ncallHook(vm, 'destroyed')\n// data的改变不会再触发周期函数\n// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。\n```\n\n深入理解源码:\n\n2. Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。\n```\n// v2.6.10 最新版\nvar LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    // v2.6+ \n    'serverPrefetch' //看下一题\n];\n```\n于是，你可以答多`activated & deactivated`（keep-alive 组件激活/停用）、`errorCaptured`（v2.5 以上版本有的一个钩子，用于处理错误）这三个。\n\n-----\n\n## 生命周期钩子的合并策略\nhttps://www.cnblogs.com/xweizi/p/10572281.html\n\n----- \n单独抽出一天来处理\n\n## 新生命周期钩子：serverPrefetch是什么？\n```\n// v2.6.10的变化\n```\n可以看到，`serverPrefetch`前身是`ssrPrefetch`。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。\n![image](https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n这里我们贴出一段官方例子：\n```\n<!-- Item.vue -->\n<template>\n  <div v-if=\"item\">{{ item.title }}</div>\n  <div v-else>...</div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    item () {\n      return this.$store.state.items[this.$route.params.id]\n    }\n  },\n  serverPrefetch () {\n    return this.fetchItem()\n  },\n  mounted () {\n    if (!this.item) {\n      this.fetchItem()\n    }\n  },\n  methods: {\n    fetchItem () {\n      // return the Promise from the action\n      return this.$store.dispatch('fetchItem', this.$route.params.id)\n    }\n  }\n}\n</script>\n```\n## Vue-router 路由模式有几种？\n三种 \"hash\" | \"history\" | \"abstract\"，一般人只知道两种\"hash\" | \"history\"\n```\n// 源码：\n\nswitch (mode) {\n  case 'history':\n    this.history = new HTML5History(this, options.base)\n    break\n  case 'hash':\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case 'abstract':\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== 'production') {\n      assert(false, `invalid mode: ${mode}`)\n    }\n}\n```\n##### mode\n* 类型: string\n* 默认值: \"hash\" (浏览器环境) | \"abstract\" (Node.js 环境)\n* 可选值: \"hash\" | \"history\" | \"abstract\"\n\n配置路由模式:\n\n* hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。\n* history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。\n* abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.\n\n###### 路由模式解析\n对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.\n\n前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求\n`\n浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。\n`\n\n.\n\n* vue-router: hash\n\nhash模式中url带有#号，修改成history模式，url中的#自动就去除了。\n\nhash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：\n```\nwindow.onhashchange = function(event){\n    console.log(event.oldURL, event.newURL);\n    let hash = location.hash.slice(1)\n}\n```\n\nhash模式下，仅hash符号之前的内容会被包含在请求中,如 http://www.abc.com, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.\n\n* vue-router: history\n随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。\n　history api可以分为两大部分：切换和修改\n1. 切换历史状态\n\n包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：\n```\nhistory.go(-2);//后退两次\nhistory.go(2);//前进两次\nhistory.back(); //后退\nhsitory.forward(); //前进\n```\n`\n坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页\n`\n\n2. 修改历史状态\n包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url\n```\nhistory.pushState(stateObj，title，url)\nwindow.onpopstate = function(event){\n    console.log(event.state)\n    if(event.state && event.state.color === 'red'){\n        document.body.style.color = 'red';\n    }\n}\n\n```\n`\n坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。\n`\n3. popstate实现history路由拦截，监听页面返回事件\n当活动历史记录条目更改时，将触发popstate事件\n\n*  如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。\n\n* 需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；\n\n  　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）\n* vue-router: abstract\nabstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。\n\n根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式\n\n## 谈谈你对keep-alive的了解\n先贴一个常规回答：\n`\nkeep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。\n在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。\n<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n`\n\n`然后你可以开始骚了：`\n\n1. `<keep-alive>`是 Vue 源码中实现的一个全局抽象组件，通过自定义 `render` 函数并且利用了`插槽`来实现数据缓存和更新。它的定义在`src/core/components/keep-alive.js` 中：\n```\nexport default {\n  name: 'keep-alive',\n  abstract: true,\n  ...\n}\n```\n2. 所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：\n```\nif (parent && !options.abstract) {\n  // abstract 即 `ptions.abstract`\n  // while 循环查找第一个非抽象的父组件\n  while (parent.$options.abstract && parent.$parent) {\n    parent = parent.$parent\n  }\n  parent.$children.push(vm)\n}\n```\n\n3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。\n\n## vue源码中内置的组件？\n* component\n* transition\n* transition-group\n* keep-alive\n* slot\n## 了解Vue2.6+新全局API：Vue.observable()吗？\nVue2.6+新的全局API是Vue.observable(),它的使用方式：\n```\n// 准备个文件store.js - /store/store.js\nimport Vue from 'vue'\n\nexport const store = Vue.observable({ count: 0 })  //定义一个变量\nexport const mutations = {  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值\n  setCount (count) {\n    store.count = count\n  }\n}\n```\n返回的对象可以直接用于`渲染函数`和`计算属性`内，并且会在发生改变时触发相应的更新。\n```\n<template>\n    <div>\n        <p>你点+-，看我能不能根据状态去动态改变</p>\n        <label for=\"bookNum\">数量</label>\n        <button @click=\"setCount(count+1)\">+</button>\n        <span>{{count}}</span>\n        <button @click=\"setCount(count-1)\">-</button>\n    </div>\n</template>\n\n<script>\nimport { store, mutations } from '../store/store' // Vue2.6新增API Observable\n\nexport default {\n  name: 'Add',\n  computed: {\n    count () {\n      return store.count //用于去渲染之前Observable中定义的变量count\n    }\n  },\n  methods: {\n    setCount: mutations.setCount\n  }\n}\n</script>\n```\n## 了解Vue数据绑定原理？\n参考Vue.js官网介绍响应式原理图，我们进行分析：\n\n这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。\nVue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。\n\nVue在初始化组件数据时，在生命周期的`beforeCreate`与`created`钩子函数之间实现了对`data、props、computed、methods、events`以及`watch`的处理.\n\n* initData\n参考源码instance下的state.js文件\n\ninitData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。\n\n\n```\nfunction initData (vm: Component) {  \n  /*得到data数据*/\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} \n  /*判断是否是对象*/\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' +'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm)\n  }  \n  // proxy data on instance\n  /*遍历data对象*/\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  //遍历data中的数据\n  while (i--) {\n    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(`The data property \"${keys[i]}\" is already declared as a prop. ` +`Use prop default value instead.`,vm)\n    } else if (!isReserved(keys[i])) {\n      /*判断是否是保留字段*/\n      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/\n      proxy(vm, `_data`, keys[i])\n    }\n  }\n  // observe data\n  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  \n  observe(data, true /* asRootData */)\n  }\n```\n其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。\n\n* proxy\n接下来看一下proxy代理。\n\n```\n/*添加代理*/\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。\n\n* observe\n参考源码文件在core文件下oberver的index.js文件中\n\n\n```\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n /*\n 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  /*判断是否是一个对象*/\n  if (!isObject(value)) {\n    return\n  }\n  let ob: Observer | void\n\n  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n\n    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n\n    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/\n    ob.vmCount++\n  }\n  return ob\n}\n\n```\nVue的响应式数据都会有一个__ob__的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。\n* Observer\nObserver的作用就是遍历对象的所有属性将其进行双向绑定。\n\n```\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nexport class  {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n\n    /*\n    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16\n    */\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n\n      /*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      */\n      const augment = hasProto\n        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/\n        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/\n      augment(value, arrayMethods, arrayKeys)\n\n      /*如果是数组则需要遍历数组的每一个成员进行observe*/\n      this.observeArray(value)\n    } else {\n\n      /*如果是对象则直接walk进行绑定*/\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n\n    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n\n    /*数组需要便利每一个成员进行observe*/\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n```\nObserver为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。\n如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。\n但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？\n\nVue.js提供的方法是重写 `push、pop、shift、unshift、splice、sort、reverse`这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。\n```\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nimport { def } from '../util/index'\n\n/*取得原生数组的原型*/\nconst arrayProto = Array.prototype\n/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/\nexport const arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  /*将数组的原生方法缓存起来，后面要调用*/\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    let i = arguments.length\n    const args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    /*调用原生的数组方法*/\n    const result = original.apply(this, args)\n\n    /*数组新插入的元素需要重新进行observe才能响应式*/\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n      \n    // notify change\n    /*dep通知所有注册的观察者进行响应式处理*/\n    ob.dep.notify()\n    return result\n  })\n})\n```\n从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持__proto__这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。\n\n如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。\n\n在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。\n\n但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。\n\n* Watcher\n\nWatcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。\n\n\n```\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    this.vm = vm\n    /*_watchers存放订阅者实例*/\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.lazy // for lazy watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    /*把表达式expOrFn解析成getter*/\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n   /*获得getter的值并且重新进行依赖收集*/\n  get () {\n    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/\n    pushTarget(this)\n    let value\n    const vm = this.vm\n\n    /*\n      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。\n      在将Dep.target设置为自生观察者实例以后，执行getter操作。\n      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，\n      那么在执行getter的时候就会触发a跟c两个数据的getter函数，\n      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，\n      将该观察者对象放入闭包中的Dep的subs中去。\n    */\n    if (this.user) {\n      try {\n        value = this.getter.call(vm, vm)\n      } catch (e) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      }\n    } else {\n      value = this.getter.call(vm, vm)\n    }\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/\n    if (this.deep) {\n      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/\n      traverse(value)\n    }\n\n    /*将观察者实例从target栈中取出并设置给Dep.target*/\n    popTarget()\n    this.cleanupDeps()\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n   /*添加一个依赖关系到Deps集合中*/\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n   /*清理依赖收集*/\n  cleanupDeps () {\n    /*移除所有观察者对象*/\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n   /*\n      调度者接口，当依赖发生改变的时候进行回调。\n   */\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      /*同步则执行run直接渲染视图*/\n      this.run()\n    } else {\n      /*异步推送到观察者队列中，由调度者调用。*/\n      queueWatcher(this)\n    }\n  }\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n   /*\n      调度者工作接口，将被调度者回调。\n    */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        /*\n            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。\n        */\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        /*设置新的值*/\n        this.value = value\n\n        /*触发回调渲染视图*/\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n   /*获取观察者的值*/\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n   /*收集该watcher的所有deps依赖*/\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n   /*将自身从所有依赖收集订阅列表删除*/\n  teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n}\n```\n* Dep\n\n来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。\n\n```\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  /*添加一个观察者对象*/\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  /*移除一个观察者对象*/\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  /*依赖收集，当存在Dep.target的时候添加观察者对象*/\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  /*通知所有订阅者*/\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/\n```\n\n* defineReactive\n\n接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。\n触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。\n\n```\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  /*在闭包中定义一个dep对象*/\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n\n  /*对象的子对象递归进行observe并返回子节点的Observer对象*/\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n\n      /*如果原本对象拥有getter方法则执行*/\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n\n        /*进行依赖收集*/\n        dep.depend()\n        if (childOb) {\n\n          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/\n          childOb.dep.depend()\n        }\n        if (Array.isArray(value)) {\n\n          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/\n          dependArray(value)\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n\n      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (setter) {\n\n        /*如果原本对象拥有setter方法则执行setter*/\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n\n      /*新的值需要重新进行observe，保证数据响应式*/\n      childOb = observe(newVal)\n\n      /*dep对象通知所有的观察者*/\n      dep.notify()\n    }\n  })\n}\n```\n----\n整篇文章主要参考链接：https://juejin.im/post/5c959f74f265da610c068fa8\n源码解析参考链接：https://github.com/answershuto/learnVue\n\n\n\n","slug":"vueSourceCoding","published":1,"updated":"2019-09-16T08:15:17.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4ud001qygkcjk7aoyc5","content":"<p>Author: Echo<br>Time: 2019-09-03 09:47:57</p>\n<h2 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h2><p>new关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是<br><code>/src/core/instance/index.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们跳转追踪至<code>this._init()</code>，即<code>Vue.prototype._init</code>,位于<code>src\\core\\instance\\init.js</code>.<br>在<code>_init()</code>方法的内部有一系列 <code>init*</code> 的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // ...忽略，从第45行看起</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">    // ...忽略</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>统一概述一遍new Vue()时做了什么处理:</p>\n<ul>\n<li><code>initProxy</code>，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)</li>\n<li><code>initLifecycle</code>（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。</li>\n<li><code>initEvents</code>，用来存放除@hook:生命周期钩子名称=”绑定的函数”事件的对象。如:$on、$emit等。</li>\n<li><code>initRender</code>，用于初始化$slots、$attrs、$listeners</li>\n<li><code>initInjections</code>，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。</li>\n<li><code>initState</code>，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。</li>\n<li><code>initProvide</code>，初始化provide。</li>\n<li><code>vm.$mount</code>，挂载实例。</li>\n</ul>\n<h2 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h2><p>这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">// 初始化 inject</span><br><span class=\"line\">// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)</span><br><span class=\"line\">// 初始化 provide</span><br><span class=\"line\">callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">// 挂载实例 vm.$mount(vm.$options.el)</span><br><span class=\"line\">// vue实例的数据对象data有了</span><br></pre></td></tr></table></figure></p>\n<p>所以当面试官问你:</p>\n<ul>\n<li>beforeCreate以及 created 调用时，哪些数据能用与否？</li>\n<li>什么阶段才能访问DOM？</li>\n<li>为什么created之后才挂载实例？</li>\n</ul>\n<h2 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h2><p>生命周期函数解释说明（图片）：<a href=\"https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\" target=\"_blank\" rel=\"noopener\">https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png</a></p>\n<h5 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解:\"></a>理解:</h5><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会</p>\n<h5 id=\"生命周期的几个阶段\"><a href=\"#生命周期的几个阶段\" class=\"headerlink\" title=\"生命周期的几个阶段:\"></a>生命周期的几个阶段:</h5><ol>\n<li>created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁</li>\n</ol>\n<ul>\n<li>beforeCreate &amp; created 看上一题</li>\n<li><p>beforeMount &amp; mounted</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeMount&apos;)</span><br><span class=\"line\">// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，</span><br><span class=\"line\">callHook(vm, &apos;mounted&apos;)</span><br><span class=\"line\">// vue实例挂载完成，data.message成功渲染</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeUpdate &amp; updated</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data变化会触发beforeUpdate和updated方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeDestroy &amp; destroyed</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;destroyed&apos;)</span><br><span class=\"line\">// data的改变不会再触发周期函数</span><br><span class=\"line\">// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>深入理解源码:</p>\n<ol start=\"2\">\n<li>Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10 最新版</span><br><span class=\"line\">var LIFECYCLE_HOOKS = [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;,</span><br><span class=\"line\">    &apos;errorCaptured&apos;,</span><br><span class=\"line\">    // v2.6+ </span><br><span class=\"line\">    &apos;serverPrefetch&apos; //看下一题</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>于是，你可以答多<code>activated &amp; deactivated</code>（keep-alive 组件激活/停用）、<code>errorCaptured</code>（v2.5 以上版本有的一个钩子，用于处理错误）这三个。</p>\n<hr>\n<h2 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h2><p><a href=\"https://www.cnblogs.com/xweizi/p/10572281.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xweizi/p/10572281.html</a></p>\n<hr>\n<p>单独抽出一天来处理</p>\n<h2 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10的变化</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>serverPrefetch</code>前身是<code>ssrPrefetch</code>。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。<br><img src=\"https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>这里我们贴出一段官方例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Item.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;item&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    item () &#123;</span><br><span class=\"line\">      return this.$store.state.items[this.$route.params.id]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  serverPrefetch () &#123;</span><br><span class=\"line\">    return this.fetchItem()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    if (!this.item) &#123;</span><br><span class=\"line\">      this.fetchItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    fetchItem () &#123;</span><br><span class=\"line\">      // return the Promise from the action</span><br><span class=\"line\">      return this.$store.dispatch(&apos;fetchItem&apos;, this.$route.params.id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h2><p>三种 “hash” | “history” | “abstract”，一般人只知道两种”hash” | “history”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码：</span><br><span class=\"line\"></span><br><span class=\"line\">switch (mode) &#123;</span><br><span class=\"line\">  case &apos;history&apos;:</span><br><span class=\"line\">    this.history = new HTML5History(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;hash&apos;:</span><br><span class=\"line\">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;abstract&apos;:</span><br><span class=\"line\">    this.history = new AbstractHistory(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h5><ul>\n<li>类型: string</li>\n<li>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</li>\n<li>可选值: “hash” | “history” | “abstract”</li>\n</ul>\n<p>配置路由模式:</p>\n<ul>\n<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</li>\n<li>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</li>\n<li>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>\n</ul>\n<h6 id=\"路由模式解析\"><a href=\"#路由模式解析\" class=\"headerlink\" title=\"路由模式解析\"></a>路由模式解析</h6><p>对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.</p>\n<p>前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求<br><code>浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。</code></p>\n<p>.</p>\n<ul>\n<li>vue-router: hash</li>\n</ul>\n<p>hash模式中url带有#号，修改成history模式，url中的#自动就去除了。</p>\n<p>hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onhashchange = function(event)&#123;</span><br><span class=\"line\">    console.log(event.oldURL, event.newURL);</span><br><span class=\"line\">    let hash = location.hash.slice(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hash模式下，仅hash符号之前的内容会被包含在请求中,如 <a href=\"http://www.abc.com\" target=\"_blank\" rel=\"noopener\">http://www.abc.com</a>, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.</p>\n<ul>\n<li>vue-router: history<br>随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。<br>　history api可以分为两大部分：切换和修改</li>\n</ul>\n<ol>\n<li>切换历史状态</li>\n</ol>\n<p>包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-2);//后退两次</span><br><span class=\"line\">history.go(2);//前进两次</span><br><span class=\"line\">history.back(); //后退</span><br><span class=\"line\">hsitory.forward(); //前进</span><br></pre></td></tr></table></figure></p>\n<p><code>坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页</code></p>\n<ol start=\"2\">\n<li>修改历史状态<br>包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.pushState(stateObj，title，url)</span><br><span class=\"line\">window.onpopstate = function(event)&#123;</span><br><span class=\"line\">    console.log(event.state)</span><br><span class=\"line\">    if(event.state &amp;&amp; event.state.color === &apos;red&apos;)&#123;</span><br><span class=\"line\">        document.body.style.color = &apos;red&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</code></p>\n<ol start=\"3\">\n<li>popstate实现history路由拦截，监听页面返回事件<br>当活动历史记录条目更改时，将触发popstate事件</li>\n</ol>\n<ul>\n<li><p>如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。</p>\n</li>\n<li><p>需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；</p>\n<p>　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）</p>\n</li>\n<li>vue-router: abstract<br>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</li>\n</ul>\n<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式</p>\n<h2 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h2><p>先贴一个常规回答：<br>`<br>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>\n<p><keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br>`</keep-alive></p>\n<p><code>然后你可以开始骚了：</code></p>\n<ol>\n<li><p><code>&lt;keep-alive&gt;</code>是 Vue 源码中实现的一个全局抽象组件，通过自定义 <code>render</code> 函数并且利用了<code>插槽</code>来实现数据缓存和更新。它的定义在<code>src/core/components/keep-alive.js</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;keep-alive&apos;,</span><br><span class=\"line\">  abstract: true,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">  // abstract 即 `ptions.abstract`</span><br><span class=\"line\">  // while 循环查找第一个非抽象的父组件</span><br><span class=\"line\">  while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">    parent = parent.$parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  parent.$children.push(vm)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。</keep-alive></p>\n<h2 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h2><ul>\n<li>component</li>\n<li>transition</li>\n<li>transition-group</li>\n<li>keep-alive</li>\n<li>slot<h2 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h2>Vue2.6+新的全局API是Vue.observable(),它的使用方式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 准备个文件store.js - /store/store.js</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export const store = Vue.observable(&#123; count: 0 &#125;)  //定义一个变量</span><br><span class=\"line\">export const mutations = &#123;  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值</span><br><span class=\"line\">  setCount (count) &#123;</span><br><span class=\"line\">    store.count = count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>返回的对象可以直接用于<code>渲染函数</code>和<code>计算属性</code>内，并且会在发生改变时触发相应的更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;你点+-，看我能不能根据状态去动态改变&lt;/p&gt;</span><br><span class=\"line\">        &lt;label for=&quot;bookNum&quot;&gt;数量&lt;/label&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count+1)&quot;&gt;+&lt;/button&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count-1)&quot;&gt;-&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; store, mutations &#125; from &apos;../store/store&apos; // Vue2.6新增API Observable</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;Add&apos;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return store.count //用于去渲染之前Observable中定义的变量count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    setCount: mutations.setCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h2><p>参考Vue.js官网介绍响应式原理图，我们进行分析：</p>\n<p>这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。<br>Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。</p>\n<p>Vue在初始化组件数据时，在生命周期的<code>beforeCreate</code>与<code>created</code>钩子函数之间实现了对<code>data、props、computed、methods、events</code>以及<code>watch</code>的处理.</p>\n<ul>\n<li>initData<br>参考源码instance下的state.js文件</li>\n</ul>\n<p>initData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initData (vm: Component) &#123;  </span><br><span class=\"line\">  /*得到data数据*/</span><br><span class=\"line\">  let data = vm.$options.data</span><br><span class=\"line\">  data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; </span><br><span class=\"line\">  /*判断是否是对象*/</span><br><span class=\"line\">  if (!isPlainObject(data)) &#123;</span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(&apos;data functions should return an object:\\n&apos; +&apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm)</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  // proxy data on instance</span><br><span class=\"line\">  /*遍历data对象*/</span><br><span class=\"line\">  const keys = Object.keys(data)</span><br><span class=\"line\">  const props = vm.$options.props</span><br><span class=\"line\">  let i = keys.length</span><br><span class=\"line\">  //遍历data中的数据</span><br><span class=\"line\">  while (i--) &#123;</span><br><span class=\"line\">    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class=\"line\">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(`The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +`Use prop default value instead.`,vm)</span><br><span class=\"line\">    &#125; else if (!isReserved(keys[i])) &#123;</span><br><span class=\"line\">      /*判断是否是保留字段*/</span><br><span class=\"line\">      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/</span><br><span class=\"line\">      proxy(vm, `_data`, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // observe data</span><br><span class=\"line\">  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  </span><br><span class=\"line\">  observe(data, true /* asRootData */)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。</p>\n<ul>\n<li>proxy<br>接下来看一下proxy代理。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*添加代理*/</span><br><span class=\"line\">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class=\"line\">  sharedPropertyDefinition.get = function proxyGetter () &#123;</span><br><span class=\"line\">    return this[sourceKey][key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sharedPropertyDefinition.set = function proxySetter (val) &#123;</span><br><span class=\"line\">    this[sourceKey][key] = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。</p>\n<ul>\n<li>observe<br>参考源码文件在core文件下oberver的index.js文件中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Attempt to create an observer instance for a value,</span><br><span class=\"line\"> * returns the new observer if successfully observed,</span><br><span class=\"line\"> * or the existing observer if the value already has one.</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*</span><br><span class=\"line\"> 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class=\"line\">  /*判断是否是一个对象*/</span><br><span class=\"line\">  if (!isObject(value)) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let ob: Observer | void</span><br><span class=\"line\"></span><br><span class=\"line\">  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/</span><br><span class=\"line\">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; else if (</span><br><span class=\"line\"></span><br><span class=\"line\">    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/</span><br><span class=\"line\">    observerState.shouldConvert &amp;&amp;</span><br><span class=\"line\">    !isServerRendering() &amp;&amp;</span><br><span class=\"line\">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class=\"line\">    Object.isExtensible(value) &amp;&amp;</span><br><span class=\"line\">    !value._isVue</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = new Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/</span><br><span class=\"line\">    ob.vmCount++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vue的响应式数据都会有一个<strong>ob</strong>的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。</p>\n<ul>\n<li>Observer<br>Observer的作用就是遍历对象的所有属性将其进行双向绑定。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Observer class that are attached to each observed</span><br><span class=\"line\"> * object. Once attached, the observer converts target</span><br><span class=\"line\"> * object&apos;s property keys into getter/setters that</span><br><span class=\"line\"> * collect dependencies and dispatches updates.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export class  &#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\">  vmCount: number; // number of vms that has this object as root $data</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (value: any) &#123;</span><br><span class=\"line\">    this.value = value</span><br><span class=\"line\">    this.dep = new Dep()</span><br><span class=\"line\">    this.vmCount = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16</span><br><span class=\"line\">    */</span><br><span class=\"line\">    def(value, &apos;__ob__&apos;, this)</span><br><span class=\"line\">    if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*</span><br><span class=\"line\">          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。</span><br><span class=\"line\">          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。</span><br><span class=\"line\">      */</span><br><span class=\"line\">      const augment = hasProto</span><br><span class=\"line\">        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/</span><br><span class=\"line\">        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是数组则需要遍历数组的每一个成员进行observe*/</span><br><span class=\"line\">      this.observeArray(value)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是对象则直接walk进行绑定*/</span><br><span class=\"line\">      this.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Walk through each property and convert them into</span><br><span class=\"line\">   * getter/setters. This method should only be called when</span><br><span class=\"line\">   * value type is Object.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  walk (obj: Object) &#123;</span><br><span class=\"line\">    const keys = Object.keys(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/</span><br><span class=\"line\">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Observe a list of Array items.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组需要便利每一个成员进行observe*/</span><br><span class=\"line\">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。<br>如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。<br>但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？</p>\n<p>Vue.js提供的方法是重写 <code>push、pop、shift、unshift、splice、sort、reverse</code>这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * not type checking this file because flow doesn&apos;t play well with</span><br><span class=\"line\"> * dynamically accessing methods on Array prototype</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; def &#125; from &apos;../util/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">/*取得原生数组的原型*/</span><br><span class=\"line\">const arrayProto = Array.prototype</span><br><span class=\"line\">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span><br><span class=\"line\">export const arrayMethods = Object.create(arrayProto)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Intercept mutating methods and emit events</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/</span><br><span class=\"line\">;[</span><br><span class=\"line\">  &apos;push&apos;,</span><br><span class=\"line\">  &apos;pop&apos;,</span><br><span class=\"line\">  &apos;shift&apos;,</span><br><span class=\"line\">  &apos;unshift&apos;,</span><br><span class=\"line\">  &apos;splice&apos;,</span><br><span class=\"line\">  &apos;sort&apos;,</span><br><span class=\"line\">  &apos;reverse&apos;</span><br><span class=\"line\">]</span><br><span class=\"line\">.forEach(function (method) &#123;</span><br><span class=\"line\">  // cache original method</span><br><span class=\"line\">  /*将数组的原生方法缓存起来，后面要调用*/</span><br><span class=\"line\">  const original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, function mutator () &#123;</span><br><span class=\"line\">    // avoid leaking arguments:</span><br><span class=\"line\">    // http://jsperf.com/closure-with-arguments</span><br><span class=\"line\">    let i = arguments.length</span><br><span class=\"line\">    const args = new Array(i)</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      args[i] = arguments[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /*调用原生的数组方法*/</span><br><span class=\"line\">    const result = original.apply(this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组新插入的元素需要重新进行observe才能响应式*/</span><br><span class=\"line\">    const ob = this.__ob__</span><br><span class=\"line\">    let inserted</span><br><span class=\"line\">    switch (method) &#123;</span><br><span class=\"line\">      case &apos;push&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;unshift&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;splice&apos;:</span><br><span class=\"line\">        inserted = args.slice(2)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (inserted) ob.observeArray(inserted)</span><br><span class=\"line\">      </span><br><span class=\"line\">    // notify change</span><br><span class=\"line\">    /*dep通知所有注册的观察者进行响应式处理*/</span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    return result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持<strong>proto</strong>这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。</p>\n<p>如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。</p>\n<p>在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。</p>\n<p>但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。</p>\n<ul>\n<li>Watcher</li>\n</ul>\n<p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default class Watcher &#123;</span><br><span class=\"line\">  vm: Component;</span><br><span class=\"line\">  expression: string;</span><br><span class=\"line\">  cb: Function;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  deep: boolean;</span><br><span class=\"line\">  user: boolean;</span><br><span class=\"line\">  lazy: boolean;</span><br><span class=\"line\">  sync: boolean;</span><br><span class=\"line\">  dirty: boolean;</span><br><span class=\"line\">  active: boolean;</span><br><span class=\"line\">  deps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  newDeps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  depIds: ISet;</span><br><span class=\"line\">  newDepIds: ISet;</span><br><span class=\"line\">  getter: Function;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (</span><br><span class=\"line\">    vm: Component,</span><br><span class=\"line\">    expOrFn: string | Function,</span><br><span class=\"line\">    cb: Function,</span><br><span class=\"line\">    options?: Object</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    this.vm = vm</span><br><span class=\"line\">    /*_watchers存放订阅者实例*/</span><br><span class=\"line\">    vm._watchers.push(this)</span><br><span class=\"line\">    // options</span><br><span class=\"line\">    if (options) &#123;</span><br><span class=\"line\">      this.deep = !!options.deep</span><br><span class=\"line\">      this.user = !!options.user</span><br><span class=\"line\">      this.lazy = !!options.lazy</span><br><span class=\"line\">      this.sync = !!options.sync</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.cb = cb</span><br><span class=\"line\">    this.id = ++uid // uid for batching</span><br><span class=\"line\">    this.active = true</span><br><span class=\"line\">    this.dirty = this.lazy // for lazy watchers</span><br><span class=\"line\">    this.deps = []</span><br><span class=\"line\">    this.newDeps = []</span><br><span class=\"line\">    this.depIds = new Set()</span><br><span class=\"line\">    this.newDepIds = new Set()</span><br><span class=\"line\">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class=\"line\">      ? expOrFn.toString()</span><br><span class=\"line\">      : &apos;&apos;</span><br><span class=\"line\">    // parse expression for getter</span><br><span class=\"line\">    /*把表达式expOrFn解析成getter*/</span><br><span class=\"line\">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class=\"line\">      this.getter = expOrFn</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.getter = parsePath(expOrFn)</span><br><span class=\"line\">      if (!this.getter) &#123;</span><br><span class=\"line\">        this.getter = function () &#123;&#125;</span><br><span class=\"line\">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class=\"line\">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class=\"line\">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class=\"line\">          &apos;For full control, use a function instead.&apos;,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.value = this.lazy</span><br><span class=\"line\">      ? undefined</span><br><span class=\"line\">      : this.get()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the getter, and re-collect dependencies.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获得getter的值并且重新进行依赖收集*/</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span><br><span class=\"line\">    pushTarget(this)</span><br><span class=\"line\">    let value</span><br><span class=\"line\">    const vm = this.vm</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。</span><br><span class=\"line\">      在将Dep.target设置为自生观察者实例以后，执行getter操作。</span><br><span class=\"line\">      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，</span><br><span class=\"line\">      那么在执行getter的时候就会触发a跟c两个数据的getter函数，</span><br><span class=\"line\">      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，</span><br><span class=\"line\">      将该观察者对象放入闭包中的Dep的subs中去。</span><br><span class=\"line\">    */</span><br><span class=\"line\">    if (this.user) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        value = this.getter.call(vm, vm)</span><br><span class=\"line\">      &#125; catch (e) &#123;</span><br><span class=\"line\">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      value = this.getter.call(vm, vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // &quot;touch&quot; every property so they are all tracked as</span><br><span class=\"line\">    // dependencies for deep watching</span><br><span class=\"line\">    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span><br><span class=\"line\">    if (this.deep) &#123;</span><br><span class=\"line\">      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span><br><span class=\"line\">      traverse(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*将观察者实例从target栈中取出并设置给Dep.target*/</span><br><span class=\"line\">    popTarget()</span><br><span class=\"line\">    this.cleanupDeps()</span><br><span class=\"line\">    return value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Add a dependency to this directive.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*添加一个依赖关系到Deps集合中*/</span><br><span class=\"line\">  addDep (dep: Dep) &#123;</span><br><span class=\"line\">    const id = dep.id</span><br><span class=\"line\">    if (!this.newDepIds.has(id)) &#123;</span><br><span class=\"line\">      this.newDepIds.add(id)</span><br><span class=\"line\">      this.newDeps.push(dep)</span><br><span class=\"line\">      if (!this.depIds.has(id)) &#123;</span><br><span class=\"line\">        dep.addSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Clean up for dependency collection.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*清理依赖收集*/</span><br><span class=\"line\">  cleanupDeps () &#123;</span><br><span class=\"line\">    /*移除所有观察者对象*/</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      const dep = this.deps[i]</span><br><span class=\"line\">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class=\"line\">        dep.removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let tmp = this.depIds</span><br><span class=\"line\">    this.depIds = this.newDepIds</span><br><span class=\"line\">    this.newDepIds = tmp</span><br><span class=\"line\">    this.newDepIds.clear()</span><br><span class=\"line\">    tmp = this.deps</span><br><span class=\"line\">    this.deps = this.newDeps</span><br><span class=\"line\">    this.newDeps = tmp</span><br><span class=\"line\">    this.newDeps.length = 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Subscriber interface.</span><br><span class=\"line\">   * Will be called when a dependency changes.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class=\"line\">   */</span><br><span class=\"line\">  update () &#123;</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (this.lazy) &#123;</span><br><span class=\"line\">      this.dirty = true</span><br><span class=\"line\">    &#125; else if (this.sync) &#123;</span><br><span class=\"line\">      /*同步则执行run直接渲染视图*/</span><br><span class=\"line\">      this.run()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class=\"line\">      queueWatcher(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Scheduler job interface.</span><br><span class=\"line\">   * Will be called by the scheduler.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者工作接口，将被调度者回调。</span><br><span class=\"line\">    */</span><br><span class=\"line\">  run () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      const value = this.get()</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        value !== this.value ||</span><br><span class=\"line\">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class=\"line\">        // when the value is the same, because the value may</span><br><span class=\"line\">        // have mutated.</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。</span><br><span class=\"line\">        */</span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        this.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // set new value</span><br><span class=\"line\">        const oldValue = this.value</span><br><span class=\"line\">        /*设置新的值*/</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        /*触发回调渲染视图*/</span><br><span class=\"line\">        if (this.user) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the value of the watcher.</span><br><span class=\"line\">   * This only gets called for lazy watchers.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获取观察者的值*/</span><br><span class=\"line\">  evaluate () &#123;</span><br><span class=\"line\">    this.value = this.get()</span><br><span class=\"line\">    this.dirty = false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Depend on all deps collected by this watcher.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*收集该watcher的所有deps依赖*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      this.deps[i].depend()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*将自身从所有依赖收集订阅列表删除*/</span><br><span class=\"line\">  teardown () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      // remove self from vm&apos;s watcher list</span><br><span class=\"line\">      // this is a somewhat expensive operation so we skip it</span><br><span class=\"line\">      // if the vm is being destroyed.</span><br><span class=\"line\">      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/</span><br><span class=\"line\">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class=\"line\">        remove(this.vm._watchers, this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      let i = this.deps.length</span><br><span class=\"line\">      while (i--) &#123;</span><br><span class=\"line\">        this.deps[i].removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.active = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Dep</li>\n</ul>\n<p>来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * A dep is an observable that can have multiple</span><br><span class=\"line\"> * directives subscribing to it.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export default class Dep &#123;</span><br><span class=\"line\">  static target: ?Watcher;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  subs: Array&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.id = uid++</span><br><span class=\"line\">    this.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*添加一个观察者对象*/</span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    this.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*移除一个观察者对象*/</span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(this.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*依赖收集，当存在Dep.target的时候添加观察者对象*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    if (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*通知所有订阅者*/</span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    // stabilize the subscriber list first</span><br><span class=\"line\">    const subs = this.subs.slice()</span><br><span class=\"line\">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// the current target watcher being evaluated.</span><br><span class=\"line\">// this is globally unique because there could be only one</span><br><span class=\"line\">// watcher being evaluated at any time.</span><br><span class=\"line\">Dep.target = null</span><br><span class=\"line\">/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defineReactive</li>\n</ul>\n<p>接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。<br>触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Define a reactive property on an Object.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function defineReactive (</span><br><span class=\"line\">  obj: Object,</span><br><span class=\"line\">  key: string,</span><br><span class=\"line\">  val: any,</span><br><span class=\"line\">  customSetter?: Function</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  /*在闭包中定义一个dep对象*/</span><br><span class=\"line\">  const dep = new Dep()</span><br><span class=\"line\"></span><br><span class=\"line\">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/</span><br><span class=\"line\">  // cater for pre-defined getter/setters</span><br><span class=\"line\">  const getter = property &amp;&amp; property.get</span><br><span class=\"line\">  const setter = property &amp;&amp; property.set</span><br><span class=\"line\"></span><br><span class=\"line\">  /*对象的子对象递归进行observe并返回子节点的Observer对象*/</span><br><span class=\"line\">  let childOb = observe(val)</span><br><span class=\"line\">  Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果原本对象拥有getter方法则执行*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      if (Dep.target) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*进行依赖收集*/</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        if (childOb) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span><br><span class=\"line\">          dependArray(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      /* eslint-disable no-self-compare */</span><br><span class=\"line\">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      /* eslint-enable no-self-compare */</span><br><span class=\"line\">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (setter) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*如果原本对象拥有setter方法则执行setter*/</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*新的值需要重新进行observe，保证数据响应式*/</span><br><span class=\"line\">      childOb = observe(newVal)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*dep对象通知所有的观察者*/</span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>整篇文章主要参考链接：<a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a><br>源码解析参考链接：<a href=\"https://github.com/answershuto/learnVue\" target=\"_blank\" rel=\"noopener\">https://github.com/answershuto/learnVue</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-03 09:47:57</p>\n<h2 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h2><p>new关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是<br><code>/src/core/instance/index.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们跳转追踪至<code>this._init()</code>，即<code>Vue.prototype._init</code>,位于<code>src\\core\\instance\\init.js</code>.<br>在<code>_init()</code>方法的内部有一系列 <code>init*</code> 的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // ...忽略，从第45行看起</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">    // ...忽略</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>统一概述一遍new Vue()时做了什么处理:</p>\n<ul>\n<li><code>initProxy</code>，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)</li>\n<li><code>initLifecycle</code>（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。</li>\n<li><code>initEvents</code>，用来存放除@hook:生命周期钩子名称=”绑定的函数”事件的对象。如:$on、$emit等。</li>\n<li><code>initRender</code>，用于初始化$slots、$attrs、$listeners</li>\n<li><code>initInjections</code>，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。</li>\n<li><code>initState</code>，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。</li>\n<li><code>initProvide</code>，初始化provide。</li>\n<li><code>vm.$mount</code>，挂载实例。</li>\n</ul>\n<h2 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h2><p>这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">// 初始化 inject</span><br><span class=\"line\">// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)</span><br><span class=\"line\">// 初始化 provide</span><br><span class=\"line\">callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">// 挂载实例 vm.$mount(vm.$options.el)</span><br><span class=\"line\">// vue实例的数据对象data有了</span><br></pre></td></tr></table></figure></p>\n<p>所以当面试官问你:</p>\n<ul>\n<li>beforeCreate以及 created 调用时，哪些数据能用与否？</li>\n<li>什么阶段才能访问DOM？</li>\n<li>为什么created之后才挂载实例？</li>\n</ul>\n<h2 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h2><p>生命周期函数解释说明（图片）：<a href=\"https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\" target=\"_blank\" rel=\"noopener\">https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png</a></p>\n<h5 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解:\"></a>理解:</h5><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会</p>\n<h5 id=\"生命周期的几个阶段\"><a href=\"#生命周期的几个阶段\" class=\"headerlink\" title=\"生命周期的几个阶段:\"></a>生命周期的几个阶段:</h5><ol>\n<li>created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁</li>\n</ol>\n<ul>\n<li>beforeCreate &amp; created 看上一题</li>\n<li><p>beforeMount &amp; mounted</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeMount&apos;)</span><br><span class=\"line\">// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，</span><br><span class=\"line\">callHook(vm, &apos;mounted&apos;)</span><br><span class=\"line\">// vue实例挂载完成，data.message成功渲染</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeUpdate &amp; updated</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data变化会触发beforeUpdate和updated方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeDestroy &amp; destroyed</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;destroyed&apos;)</span><br><span class=\"line\">// data的改变不会再触发周期函数</span><br><span class=\"line\">// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>深入理解源码:</p>\n<ol start=\"2\">\n<li>Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10 最新版</span><br><span class=\"line\">var LIFECYCLE_HOOKS = [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;,</span><br><span class=\"line\">    &apos;errorCaptured&apos;,</span><br><span class=\"line\">    // v2.6+ </span><br><span class=\"line\">    &apos;serverPrefetch&apos; //看下一题</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>于是，你可以答多<code>activated &amp; deactivated</code>（keep-alive 组件激活/停用）、<code>errorCaptured</code>（v2.5 以上版本有的一个钩子，用于处理错误）这三个。</p>\n<hr>\n<h2 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h2><p><a href=\"https://www.cnblogs.com/xweizi/p/10572281.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xweizi/p/10572281.html</a></p>\n<hr>\n<p>单独抽出一天来处理</p>\n<h2 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10的变化</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>serverPrefetch</code>前身是<code>ssrPrefetch</code>。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。<br><img src=\"https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>这里我们贴出一段官方例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Item.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;item&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    item () &#123;</span><br><span class=\"line\">      return this.$store.state.items[this.$route.params.id]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  serverPrefetch () &#123;</span><br><span class=\"line\">    return this.fetchItem()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    if (!this.item) &#123;</span><br><span class=\"line\">      this.fetchItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    fetchItem () &#123;</span><br><span class=\"line\">      // return the Promise from the action</span><br><span class=\"line\">      return this.$store.dispatch(&apos;fetchItem&apos;, this.$route.params.id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h2><p>三种 “hash” | “history” | “abstract”，一般人只知道两种”hash” | “history”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码：</span><br><span class=\"line\"></span><br><span class=\"line\">switch (mode) &#123;</span><br><span class=\"line\">  case &apos;history&apos;:</span><br><span class=\"line\">    this.history = new HTML5History(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;hash&apos;:</span><br><span class=\"line\">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;abstract&apos;:</span><br><span class=\"line\">    this.history = new AbstractHistory(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h5><ul>\n<li>类型: string</li>\n<li>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</li>\n<li>可选值: “hash” | “history” | “abstract”</li>\n</ul>\n<p>配置路由模式:</p>\n<ul>\n<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</li>\n<li>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</li>\n<li>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>\n</ul>\n<h6 id=\"路由模式解析\"><a href=\"#路由模式解析\" class=\"headerlink\" title=\"路由模式解析\"></a>路由模式解析</h6><p>对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.</p>\n<p>前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求<br><code>浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。</code></p>\n<p>.</p>\n<ul>\n<li>vue-router: hash</li>\n</ul>\n<p>hash模式中url带有#号，修改成history模式，url中的#自动就去除了。</p>\n<p>hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onhashchange = function(event)&#123;</span><br><span class=\"line\">    console.log(event.oldURL, event.newURL);</span><br><span class=\"line\">    let hash = location.hash.slice(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hash模式下，仅hash符号之前的内容会被包含在请求中,如 <a href=\"http://www.abc.com\" target=\"_blank\" rel=\"noopener\">http://www.abc.com</a>, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.</p>\n<ul>\n<li>vue-router: history<br>随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。<br>　history api可以分为两大部分：切换和修改</li>\n</ul>\n<ol>\n<li>切换历史状态</li>\n</ol>\n<p>包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-2);//后退两次</span><br><span class=\"line\">history.go(2);//前进两次</span><br><span class=\"line\">history.back(); //后退</span><br><span class=\"line\">hsitory.forward(); //前进</span><br></pre></td></tr></table></figure></p>\n<p><code>坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页</code></p>\n<ol start=\"2\">\n<li>修改历史状态<br>包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.pushState(stateObj，title，url)</span><br><span class=\"line\">window.onpopstate = function(event)&#123;</span><br><span class=\"line\">    console.log(event.state)</span><br><span class=\"line\">    if(event.state &amp;&amp; event.state.color === &apos;red&apos;)&#123;</span><br><span class=\"line\">        document.body.style.color = &apos;red&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</code></p>\n<ol start=\"3\">\n<li>popstate实现history路由拦截，监听页面返回事件<br>当活动历史记录条目更改时，将触发popstate事件</li>\n</ol>\n<ul>\n<li><p>如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。</p>\n</li>\n<li><p>需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；</p>\n<p>　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）</p>\n</li>\n<li>vue-router: abstract<br>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</li>\n</ul>\n<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式</p>\n<h2 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h2><p>先贴一个常规回答：<br>`<br>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>\n<p><keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br>`</keep-alive></p>\n<p><code>然后你可以开始骚了：</code></p>\n<ol>\n<li><p><code>&lt;keep-alive&gt;</code>是 Vue 源码中实现的一个全局抽象组件，通过自定义 <code>render</code> 函数并且利用了<code>插槽</code>来实现数据缓存和更新。它的定义在<code>src/core/components/keep-alive.js</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;keep-alive&apos;,</span><br><span class=\"line\">  abstract: true,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">  // abstract 即 `ptions.abstract`</span><br><span class=\"line\">  // while 循环查找第一个非抽象的父组件</span><br><span class=\"line\">  while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">    parent = parent.$parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  parent.$children.push(vm)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。</keep-alive></p>\n<h2 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h2><ul>\n<li>component</li>\n<li>transition</li>\n<li>transition-group</li>\n<li>keep-alive</li>\n<li>slot<h2 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h2>Vue2.6+新的全局API是Vue.observable(),它的使用方式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 准备个文件store.js - /store/store.js</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export const store = Vue.observable(&#123; count: 0 &#125;)  //定义一个变量</span><br><span class=\"line\">export const mutations = &#123;  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值</span><br><span class=\"line\">  setCount (count) &#123;</span><br><span class=\"line\">    store.count = count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>返回的对象可以直接用于<code>渲染函数</code>和<code>计算属性</code>内，并且会在发生改变时触发相应的更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;你点+-，看我能不能根据状态去动态改变&lt;/p&gt;</span><br><span class=\"line\">        &lt;label for=&quot;bookNum&quot;&gt;数量&lt;/label&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count+1)&quot;&gt;+&lt;/button&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count-1)&quot;&gt;-&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; store, mutations &#125; from &apos;../store/store&apos; // Vue2.6新增API Observable</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;Add&apos;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return store.count //用于去渲染之前Observable中定义的变量count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    setCount: mutations.setCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h2><p>参考Vue.js官网介绍响应式原理图，我们进行分析：</p>\n<p>这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。<br>Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。</p>\n<p>Vue在初始化组件数据时，在生命周期的<code>beforeCreate</code>与<code>created</code>钩子函数之间实现了对<code>data、props、computed、methods、events</code>以及<code>watch</code>的处理.</p>\n<ul>\n<li>initData<br>参考源码instance下的state.js文件</li>\n</ul>\n<p>initData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initData (vm: Component) &#123;  </span><br><span class=\"line\">  /*得到data数据*/</span><br><span class=\"line\">  let data = vm.$options.data</span><br><span class=\"line\">  data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; </span><br><span class=\"line\">  /*判断是否是对象*/</span><br><span class=\"line\">  if (!isPlainObject(data)) &#123;</span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(&apos;data functions should return an object:\\n&apos; +&apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm)</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  // proxy data on instance</span><br><span class=\"line\">  /*遍历data对象*/</span><br><span class=\"line\">  const keys = Object.keys(data)</span><br><span class=\"line\">  const props = vm.$options.props</span><br><span class=\"line\">  let i = keys.length</span><br><span class=\"line\">  //遍历data中的数据</span><br><span class=\"line\">  while (i--) &#123;</span><br><span class=\"line\">    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class=\"line\">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(`The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +`Use prop default value instead.`,vm)</span><br><span class=\"line\">    &#125; else if (!isReserved(keys[i])) &#123;</span><br><span class=\"line\">      /*判断是否是保留字段*/</span><br><span class=\"line\">      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/</span><br><span class=\"line\">      proxy(vm, `_data`, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // observe data</span><br><span class=\"line\">  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  </span><br><span class=\"line\">  observe(data, true /* asRootData */)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。</p>\n<ul>\n<li>proxy<br>接下来看一下proxy代理。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*添加代理*/</span><br><span class=\"line\">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class=\"line\">  sharedPropertyDefinition.get = function proxyGetter () &#123;</span><br><span class=\"line\">    return this[sourceKey][key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sharedPropertyDefinition.set = function proxySetter (val) &#123;</span><br><span class=\"line\">    this[sourceKey][key] = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。</p>\n<ul>\n<li>observe<br>参考源码文件在core文件下oberver的index.js文件中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Attempt to create an observer instance for a value,</span><br><span class=\"line\"> * returns the new observer if successfully observed,</span><br><span class=\"line\"> * or the existing observer if the value already has one.</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*</span><br><span class=\"line\"> 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class=\"line\">  /*判断是否是一个对象*/</span><br><span class=\"line\">  if (!isObject(value)) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let ob: Observer | void</span><br><span class=\"line\"></span><br><span class=\"line\">  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/</span><br><span class=\"line\">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; else if (</span><br><span class=\"line\"></span><br><span class=\"line\">    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/</span><br><span class=\"line\">    observerState.shouldConvert &amp;&amp;</span><br><span class=\"line\">    !isServerRendering() &amp;&amp;</span><br><span class=\"line\">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class=\"line\">    Object.isExtensible(value) &amp;&amp;</span><br><span class=\"line\">    !value._isVue</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = new Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/</span><br><span class=\"line\">    ob.vmCount++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vue的响应式数据都会有一个<strong>ob</strong>的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。</p>\n<ul>\n<li>Observer<br>Observer的作用就是遍历对象的所有属性将其进行双向绑定。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Observer class that are attached to each observed</span><br><span class=\"line\"> * object. Once attached, the observer converts target</span><br><span class=\"line\"> * object&apos;s property keys into getter/setters that</span><br><span class=\"line\"> * collect dependencies and dispatches updates.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export class  &#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\">  vmCount: number; // number of vms that has this object as root $data</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (value: any) &#123;</span><br><span class=\"line\">    this.value = value</span><br><span class=\"line\">    this.dep = new Dep()</span><br><span class=\"line\">    this.vmCount = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16</span><br><span class=\"line\">    */</span><br><span class=\"line\">    def(value, &apos;__ob__&apos;, this)</span><br><span class=\"line\">    if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*</span><br><span class=\"line\">          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。</span><br><span class=\"line\">          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。</span><br><span class=\"line\">      */</span><br><span class=\"line\">      const augment = hasProto</span><br><span class=\"line\">        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/</span><br><span class=\"line\">        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是数组则需要遍历数组的每一个成员进行observe*/</span><br><span class=\"line\">      this.observeArray(value)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是对象则直接walk进行绑定*/</span><br><span class=\"line\">      this.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Walk through each property and convert them into</span><br><span class=\"line\">   * getter/setters. This method should only be called when</span><br><span class=\"line\">   * value type is Object.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  walk (obj: Object) &#123;</span><br><span class=\"line\">    const keys = Object.keys(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/</span><br><span class=\"line\">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Observe a list of Array items.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组需要便利每一个成员进行observe*/</span><br><span class=\"line\">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。<br>如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。<br>但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？</p>\n<p>Vue.js提供的方法是重写 <code>push、pop、shift、unshift、splice、sort、reverse</code>这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * not type checking this file because flow doesn&apos;t play well with</span><br><span class=\"line\"> * dynamically accessing methods on Array prototype</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; def &#125; from &apos;../util/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">/*取得原生数组的原型*/</span><br><span class=\"line\">const arrayProto = Array.prototype</span><br><span class=\"line\">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span><br><span class=\"line\">export const arrayMethods = Object.create(arrayProto)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Intercept mutating methods and emit events</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/</span><br><span class=\"line\">;[</span><br><span class=\"line\">  &apos;push&apos;,</span><br><span class=\"line\">  &apos;pop&apos;,</span><br><span class=\"line\">  &apos;shift&apos;,</span><br><span class=\"line\">  &apos;unshift&apos;,</span><br><span class=\"line\">  &apos;splice&apos;,</span><br><span class=\"line\">  &apos;sort&apos;,</span><br><span class=\"line\">  &apos;reverse&apos;</span><br><span class=\"line\">]</span><br><span class=\"line\">.forEach(function (method) &#123;</span><br><span class=\"line\">  // cache original method</span><br><span class=\"line\">  /*将数组的原生方法缓存起来，后面要调用*/</span><br><span class=\"line\">  const original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, function mutator () &#123;</span><br><span class=\"line\">    // avoid leaking arguments:</span><br><span class=\"line\">    // http://jsperf.com/closure-with-arguments</span><br><span class=\"line\">    let i = arguments.length</span><br><span class=\"line\">    const args = new Array(i)</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      args[i] = arguments[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /*调用原生的数组方法*/</span><br><span class=\"line\">    const result = original.apply(this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组新插入的元素需要重新进行observe才能响应式*/</span><br><span class=\"line\">    const ob = this.__ob__</span><br><span class=\"line\">    let inserted</span><br><span class=\"line\">    switch (method) &#123;</span><br><span class=\"line\">      case &apos;push&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;unshift&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;splice&apos;:</span><br><span class=\"line\">        inserted = args.slice(2)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (inserted) ob.observeArray(inserted)</span><br><span class=\"line\">      </span><br><span class=\"line\">    // notify change</span><br><span class=\"line\">    /*dep通知所有注册的观察者进行响应式处理*/</span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    return result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持<strong>proto</strong>这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。</p>\n<p>如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。</p>\n<p>在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。</p>\n<p>但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。</p>\n<ul>\n<li>Watcher</li>\n</ul>\n<p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default class Watcher &#123;</span><br><span class=\"line\">  vm: Component;</span><br><span class=\"line\">  expression: string;</span><br><span class=\"line\">  cb: Function;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  deep: boolean;</span><br><span class=\"line\">  user: boolean;</span><br><span class=\"line\">  lazy: boolean;</span><br><span class=\"line\">  sync: boolean;</span><br><span class=\"line\">  dirty: boolean;</span><br><span class=\"line\">  active: boolean;</span><br><span class=\"line\">  deps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  newDeps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  depIds: ISet;</span><br><span class=\"line\">  newDepIds: ISet;</span><br><span class=\"line\">  getter: Function;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (</span><br><span class=\"line\">    vm: Component,</span><br><span class=\"line\">    expOrFn: string | Function,</span><br><span class=\"line\">    cb: Function,</span><br><span class=\"line\">    options?: Object</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    this.vm = vm</span><br><span class=\"line\">    /*_watchers存放订阅者实例*/</span><br><span class=\"line\">    vm._watchers.push(this)</span><br><span class=\"line\">    // options</span><br><span class=\"line\">    if (options) &#123;</span><br><span class=\"line\">      this.deep = !!options.deep</span><br><span class=\"line\">      this.user = !!options.user</span><br><span class=\"line\">      this.lazy = !!options.lazy</span><br><span class=\"line\">      this.sync = !!options.sync</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.cb = cb</span><br><span class=\"line\">    this.id = ++uid // uid for batching</span><br><span class=\"line\">    this.active = true</span><br><span class=\"line\">    this.dirty = this.lazy // for lazy watchers</span><br><span class=\"line\">    this.deps = []</span><br><span class=\"line\">    this.newDeps = []</span><br><span class=\"line\">    this.depIds = new Set()</span><br><span class=\"line\">    this.newDepIds = new Set()</span><br><span class=\"line\">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class=\"line\">      ? expOrFn.toString()</span><br><span class=\"line\">      : &apos;&apos;</span><br><span class=\"line\">    // parse expression for getter</span><br><span class=\"line\">    /*把表达式expOrFn解析成getter*/</span><br><span class=\"line\">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class=\"line\">      this.getter = expOrFn</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.getter = parsePath(expOrFn)</span><br><span class=\"line\">      if (!this.getter) &#123;</span><br><span class=\"line\">        this.getter = function () &#123;&#125;</span><br><span class=\"line\">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class=\"line\">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class=\"line\">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class=\"line\">          &apos;For full control, use a function instead.&apos;,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.value = this.lazy</span><br><span class=\"line\">      ? undefined</span><br><span class=\"line\">      : this.get()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the getter, and re-collect dependencies.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获得getter的值并且重新进行依赖收集*/</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span><br><span class=\"line\">    pushTarget(this)</span><br><span class=\"line\">    let value</span><br><span class=\"line\">    const vm = this.vm</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。</span><br><span class=\"line\">      在将Dep.target设置为自生观察者实例以后，执行getter操作。</span><br><span class=\"line\">      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，</span><br><span class=\"line\">      那么在执行getter的时候就会触发a跟c两个数据的getter函数，</span><br><span class=\"line\">      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，</span><br><span class=\"line\">      将该观察者对象放入闭包中的Dep的subs中去。</span><br><span class=\"line\">    */</span><br><span class=\"line\">    if (this.user) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        value = this.getter.call(vm, vm)</span><br><span class=\"line\">      &#125; catch (e) &#123;</span><br><span class=\"line\">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      value = this.getter.call(vm, vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // &quot;touch&quot; every property so they are all tracked as</span><br><span class=\"line\">    // dependencies for deep watching</span><br><span class=\"line\">    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span><br><span class=\"line\">    if (this.deep) &#123;</span><br><span class=\"line\">      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span><br><span class=\"line\">      traverse(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*将观察者实例从target栈中取出并设置给Dep.target*/</span><br><span class=\"line\">    popTarget()</span><br><span class=\"line\">    this.cleanupDeps()</span><br><span class=\"line\">    return value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Add a dependency to this directive.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*添加一个依赖关系到Deps集合中*/</span><br><span class=\"line\">  addDep (dep: Dep) &#123;</span><br><span class=\"line\">    const id = dep.id</span><br><span class=\"line\">    if (!this.newDepIds.has(id)) &#123;</span><br><span class=\"line\">      this.newDepIds.add(id)</span><br><span class=\"line\">      this.newDeps.push(dep)</span><br><span class=\"line\">      if (!this.depIds.has(id)) &#123;</span><br><span class=\"line\">        dep.addSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Clean up for dependency collection.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*清理依赖收集*/</span><br><span class=\"line\">  cleanupDeps () &#123;</span><br><span class=\"line\">    /*移除所有观察者对象*/</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      const dep = this.deps[i]</span><br><span class=\"line\">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class=\"line\">        dep.removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let tmp = this.depIds</span><br><span class=\"line\">    this.depIds = this.newDepIds</span><br><span class=\"line\">    this.newDepIds = tmp</span><br><span class=\"line\">    this.newDepIds.clear()</span><br><span class=\"line\">    tmp = this.deps</span><br><span class=\"line\">    this.deps = this.newDeps</span><br><span class=\"line\">    this.newDeps = tmp</span><br><span class=\"line\">    this.newDeps.length = 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Subscriber interface.</span><br><span class=\"line\">   * Will be called when a dependency changes.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class=\"line\">   */</span><br><span class=\"line\">  update () &#123;</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (this.lazy) &#123;</span><br><span class=\"line\">      this.dirty = true</span><br><span class=\"line\">    &#125; else if (this.sync) &#123;</span><br><span class=\"line\">      /*同步则执行run直接渲染视图*/</span><br><span class=\"line\">      this.run()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class=\"line\">      queueWatcher(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Scheduler job interface.</span><br><span class=\"line\">   * Will be called by the scheduler.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者工作接口，将被调度者回调。</span><br><span class=\"line\">    */</span><br><span class=\"line\">  run () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      const value = this.get()</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        value !== this.value ||</span><br><span class=\"line\">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class=\"line\">        // when the value is the same, because the value may</span><br><span class=\"line\">        // have mutated.</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。</span><br><span class=\"line\">        */</span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        this.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // set new value</span><br><span class=\"line\">        const oldValue = this.value</span><br><span class=\"line\">        /*设置新的值*/</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        /*触发回调渲染视图*/</span><br><span class=\"line\">        if (this.user) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the value of the watcher.</span><br><span class=\"line\">   * This only gets called for lazy watchers.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获取观察者的值*/</span><br><span class=\"line\">  evaluate () &#123;</span><br><span class=\"line\">    this.value = this.get()</span><br><span class=\"line\">    this.dirty = false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Depend on all deps collected by this watcher.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*收集该watcher的所有deps依赖*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      this.deps[i].depend()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*将自身从所有依赖收集订阅列表删除*/</span><br><span class=\"line\">  teardown () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      // remove self from vm&apos;s watcher list</span><br><span class=\"line\">      // this is a somewhat expensive operation so we skip it</span><br><span class=\"line\">      // if the vm is being destroyed.</span><br><span class=\"line\">      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/</span><br><span class=\"line\">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class=\"line\">        remove(this.vm._watchers, this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      let i = this.deps.length</span><br><span class=\"line\">      while (i--) &#123;</span><br><span class=\"line\">        this.deps[i].removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.active = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Dep</li>\n</ul>\n<p>来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * A dep is an observable that can have multiple</span><br><span class=\"line\"> * directives subscribing to it.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export default class Dep &#123;</span><br><span class=\"line\">  static target: ?Watcher;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  subs: Array&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.id = uid++</span><br><span class=\"line\">    this.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*添加一个观察者对象*/</span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    this.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*移除一个观察者对象*/</span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(this.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*依赖收集，当存在Dep.target的时候添加观察者对象*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    if (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*通知所有订阅者*/</span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    // stabilize the subscriber list first</span><br><span class=\"line\">    const subs = this.subs.slice()</span><br><span class=\"line\">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// the current target watcher being evaluated.</span><br><span class=\"line\">// this is globally unique because there could be only one</span><br><span class=\"line\">// watcher being evaluated at any time.</span><br><span class=\"line\">Dep.target = null</span><br><span class=\"line\">/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defineReactive</li>\n</ul>\n<p>接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。<br>触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Define a reactive property on an Object.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function defineReactive (</span><br><span class=\"line\">  obj: Object,</span><br><span class=\"line\">  key: string,</span><br><span class=\"line\">  val: any,</span><br><span class=\"line\">  customSetter?: Function</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  /*在闭包中定义一个dep对象*/</span><br><span class=\"line\">  const dep = new Dep()</span><br><span class=\"line\"></span><br><span class=\"line\">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/</span><br><span class=\"line\">  // cater for pre-defined getter/setters</span><br><span class=\"line\">  const getter = property &amp;&amp; property.get</span><br><span class=\"line\">  const setter = property &amp;&amp; property.set</span><br><span class=\"line\"></span><br><span class=\"line\">  /*对象的子对象递归进行observe并返回子节点的Observer对象*/</span><br><span class=\"line\">  let childOb = observe(val)</span><br><span class=\"line\">  Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果原本对象拥有getter方法则执行*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      if (Dep.target) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*进行依赖收集*/</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        if (childOb) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span><br><span class=\"line\">          dependArray(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      /* eslint-disable no-self-compare */</span><br><span class=\"line\">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      /* eslint-enable no-self-compare */</span><br><span class=\"line\">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (setter) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*如果原本对象拥有setter方法则执行setter*/</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*新的值需要重新进行observe，保证数据响应式*/</span><br><span class=\"line\">      childOb = observe(newVal)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*dep对象通知所有的观察者*/</span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>整篇文章主要参考链接：<a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a><br>源码解析参考链接：<a href=\"https://github.com/answershuto/learnVue\" target=\"_blank\" rel=\"noopener\">https://github.com/answershuto/learnVue</a></p>\n"},{"title":"前端面试题整理","date":"2019-09-02T02:42:59.000Z","_content":" \nAuthor: Echo\nTime: 2019-09-02 10:42:59\n\n## 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n\n1.输入域名地址\n2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；\n3.与WEB服务器建立TCP连接；\n4.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）\n5.浏览器跟踪重定向地址\n6.服务器处理请求\n7.服务器返回一个HTTP响应\n8.浏览器显示 HTML\n9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）\n10.浏览器发送异步请求\n\n```\nDNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。\nTCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。\n```\n\n## 浏览器工作原理\n\n1. `用户界面` － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。\n\n2. `浏览器引擎` － 用来查询及操作渲染引擎的接口。\n\n3. `渲染引擎` － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。\n\n4. `网络` － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。\n\n5. `UI后端` － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。\n\n6. `JS解释器` － 用来解释执行JS代码。\n\n7. `数据存储` － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术\n![image](https://pic.xiaohuochai.site/blog/browserRender1.png)\n\n\n参考链接:https://www.cnblogs.com/xiaohuochai/p/9174471.html\n\n## 浏览器内核\n\n主要分成两部分:`渲染引擎`(layout engineer或Rendering Engine)和`JS引擎`。\n\n`渲染引擎`:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\n`JS引擎`:解析和执行javascript来实现网页的动态效果。\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n\n## 常见的浏览器内核有哪些？\n\nTrident内核:IE，360.... (微软开发的一种排版引擎)\nGecko内核:Firefox\nPresto内核:Opera(已经废弃了)\nBlink内核:Opera；\nWebkit内核:Safari，Chrome。\n##  cookies，sessionStorage 和 localStorage 的区别？\n`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。\n`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。\n\n##### 存储大小:\n* cookie数据大小不能超过4k。\n* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。\n##### 存储时间:\n* localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;\n* sessionStorage 数据在当前浏览器窗口关闭后自动删除.\n* cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n```\n// 存储内容类型: \nsessionStorage和localStorage只能存储字符串类型\n// 获取方式:\nlocalStorage:window.localStorage;；sessionStorage:window.sessionStorage;\n// WebStorage提供了一些方法，数据操作比cookie方便；\nsetItem (key, value) ——  保存数据，以键值对的方式储存信息。\ngetItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。\nremoveItem (key) ——  删除单个数据，根据键值移除对应的信息。\nclear () ——  删除所有的数据\nkey (index) —— 获取某个索引的key\n// cookie需要自己封装接口setCookie. getCookit\n```\n\n## 页面访问cookie的限制条件\n跨域问题，设置了HttpOnly\n\n参考链接:https://www.cnblogs.com/hujunzheng/p/5744755.html\n\n## 实现浏览器内多个标签页之间的通信\n\n* localstorge\nlocalstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。\n```\n// a:click\n$(\"#btn\").click(function(){  \n  var name=$(\"#name\").val();  \n  localStorage.setItem(\"name\", name); \n}); \n\n// b:watch\nwindow.addEventListener(\"storage\", function(event){   console.log(event.key + \"=\" + event.newValue);  \n}); \n```\n* cookie+setInterval\n将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息\n\n* websocket协议\n1.首先我们得了解websocket是什么？\n它是一种网络通信协议\n2.为什么会用到websocket?\n因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。\n但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。\n轮询:每隔一段时间，就发出一个询问.\n因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.\n* html5浏览器的新特性SharedWorker\n\n参考链接:https://segmentfault.com/a/1190000018354650\n\n## 页面可见性（Page Visibility API） 可以有哪些用途\n通过 visibilityState 的值检测页面\n* 当前是否可见\n* 打开网页的时间\n* 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等\n##  网页验证码是做什么的，是为了解决什么安全问题\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n##  为什么利用多个域名来存储网站资源\n1、CDN缓存更方便\n\n2、突破浏览器并发限制\n\n3、节约cookie带宽\n\n4、节约主域名的连接数，优化页面响应速度\n\n5、防止不必要的安全问题\n\n```\nCDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源\n// 突破浏览器并发限制\n同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。\n\n```\n\n## 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n\n* 图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n* 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n* 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n* 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n## 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n\n* 语义化html标签\n\n* 合理的title，description,keywords\n\n* 主要html代码放在前面\n\n* 少用iframe，搜索引擎不会抓取iframe中的内容\n\n* 图片加上Alt\n\n参考链接(了解seo): https://blog.csdn.net/jnshu_it/article/details/80029988\n\n## 前端性能优化\n\n###### 一、减少请求资源大小或者次数　\n1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）\n　　原因:主要是为了减少http请求次数以及减少请求资源的大小\n　　打包工具:\n　　webpack\n　　gulp\n　　grunt\n.　　....\n2、尽量所使用的字体图标或者SVG图标来代替传统png图\n　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快\n\n3、采用图片的懒加载（延迟加载）\n　　目的为了，减少页面第一次加载过程中http的请求次数\n　　具体步骤:\n　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图\n　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息\n\n4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。\n　　避免引入第三方大量的库。而自己却只是用里面的一个小功能\n\n5、使用雪碧图或者是说图片精灵\n　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用\n　　图片定位来讲小图展现在页面中（background-position:百分比，数值）\n\n6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie\n\n7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势\n　　目的:是数据处理方便，资源偏小\n\n8、前端与后端协商，合理使用keep-alive\n\n9、前端与服务器协商，使用响应资源的压缩\n\n10、避免使用iframe\n　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源\n\n11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个\n缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据\n时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）\n\n二、代码优化相关\n1、在js中尽量减少闭包的使用\n　　原因:使用闭包后，闭包所在的上下文不会被释放\n\n2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）\n　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）\n\n3、在js中避免嵌套循环和\"死循环\"(一旦遇到死循环，浏览器就会直接卡掉)\n\n4、把css放在body上，把js放在body下面\n　　让其先加载css（注意:这里关于优化没有多大关系）\n\n5、减少css表达式的使用\n\n6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象\n\n7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。\n\n9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上\n\n10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作\n\n11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画\n　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout\n　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间\n　　缩短\n\n12、尽量减少使用递归，避免死递归。\n　　解决:建议使用尾递归\n\n13、基于script标签下载js文件时，可以使用defer或者async来异步加载\n\n14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。\n\n15、减少Flash的使用\n\n三、存储\n\n1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs\n\n2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，\n　　避免向后台请求数据或者说在离线状态下做一些数据展示。\n\n四、其他优化\n\n\n1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢\n　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的\n　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示\n　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数\n\n3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）\n　　解决方法:只需要将音视频的`preload=none`即可。\n　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源\n\n## webSocket如何兼容低浏览器\n\n* 基于长轮询的 XHR\n* Adobe Flash Socket\n* ActiveX HTMLFile (IE)\n* 基于 multipart 编码发送 XHR\n参考链接:https://www.cnblogs.com/pengc/p/8718380.html\n\n## web开发中会话跟踪的方法\n1. 隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。\n2. URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。\n3. Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。\n4. Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话\n5. IP地址\n\n## HTTP method\n一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。\n* GET是最常用的方法，通常用于请求服务器发送某个资源。\n* HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。\n* PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。\n* POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。\n* TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。\n* OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。\n* DELETE 请求服务器删除请求 URL 指定的资源\n\n## HTTP状态码及其含义\n\n| 状态码        | 类别    |  原因短语  |\n| --------   | -----:  | :----: |\n| 1XX        | Information（信息性状态码）      |   接收的请求正在处理    |\n| 2XX        | Success（成功状态码）      |   请求正常处理完毕    |\n| 3XX        | Redirection（重定向状态码）      |   需要进行附加的操作以完成请求    |\n| 4XX        | Client Error（客户端错误状态码）      |   服务器无法处理请求    |\n| 5XX        | Server Error（服务端错误状态码）      |   服务器处理请求出错    |\n\n* 204\t 服务器成功处理，但未返回内容。\n* 304\tNot Modified 未修改。\t所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n* 400\tBad Request\t客户端请求的语法错误，服务器无法理解\n* 403\tForbidden\t服务器理解请求客户端的请求，但是拒绝执行此请求\n* 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n## 什么是同源：协议相同 域名相同 端口相同\n\n同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。\n\n如果非同源，共有三种行为受到限制\n1.Cookie、LocalStorage 和 IndexDB 无法读取。\n2.DOM 无法获得。\n3.AJAX 请求不能发送。\n\n----\n// 下面的还没有看\n关于建站安全防护\n\n要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。\n\nXSS概念:\n\n译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。\nXSS预防:\n\n关键cookie字段设置httpOnly\n输入检查,特殊字符 < > / &等,对其进行转义后存储\nCSRF概念：\n\n本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。\nCSRF 预防：\n\n使用验证码，更高级用图灵测试\nSQL概念：\n\n通常没有任何过滤，直接把参数存放到了SQL语句当中\nSQL预防：\n\n根本上防止SQL注入的方法，就是参数化查询或者做词法分析。\nDDOS概念：\n\n利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。\nDDOS预防：用软硬件结合的方式来防御是最有效的\n25.对前端工程化的理解\n\n1.开发规范\n2.模块化开发\n3.组件化开发\n4.组件仓库\n5.性能优化\n6.项目部署\n7.开发流程\n8.开发工具\n26.AMD和CMD是什么？它们的区别有哪些？\n\nAMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。\n\n27.MVC BFC\n\nmvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。\n\nBFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。\n\n28.你如何对网站的文件和资源进行优化？\n\n期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。\n29.如果网页内容需要支持多语言，你会怎么做？\n\n1.应用字符集的选择，选择UTF-8编码\n2.语言书写习惯&导航结构\n3.数据库驱动型网站\n30.如果设计中使用了非标准的字体，你该如何去实现？\n\n所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。\n方法：\n用图片代替\nweb fonts在线字库，如Google Webfonts，Typekit等等;http://www.chinaz.com/free/20…；\n@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)\n31.如何自学一门新编程语言\n\n(1)了解背景知识：历史、现状、特点、应用领域、发展趋势\n(2)搭建开发环境，编写HelloWorld\n(3)声明变量和常量\n(4)数据类型\n(5)运算符\n(6)逻辑结构\n(7)通用小程序\n(8)函数和对象\n(9)第三方库、组件、框架\n(10)实用项目\n32.什么是哈希表？\n\n散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n\n33.静态网页和动态网页区别：\n\n静态: 网页内容任何人在任何时间访问都是不变的\n\n动态: 网页内容不同人在不同时间访问可能是不同的\n\n34.SQL语句的分类\n\nDDL:数据定义语句 CREATE/DROP/ALTER…\nDCL:数据控制语句 GRANT…\nDML:操作操作语句 INSERT/UPDATE/DELETE\nDQL:查询语句 SELECT\n35.什么是弹性布局？\n\n解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。\n\n设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!\n\ndisplay:flex; 属性align-self 定义子元素的位置。\n\n36.编写响应式？\n\n1.声明viewport元标签\n2.使用流式布局\n3.所有容器使用相对尺寸，不用绝对尺寸\n4.（最重要原则）使用CSS3 Media Query技术\n37.常见的浏览器兼容问题？\n\n1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}\n2.图片默认有间距使用float属性为img布局\n3.居中问题（而FF默认为左对齐）margin: 0 auto;\n4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、\n5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀\n38.H5新特性：\n\n(1)Canvas绘图\n(2)SVG绘图\n(3)地理定位\n(4)Web Worker\nweb worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。\n(5)Web Storage\n1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）\n2.（兼容性差,数据8MB,操作简单）sessionStorage\n3.localStorage\n(6)Web Socket\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n39.C3新特性：\n\n1.复杂的选择器\n2.弹性布局\n3.动画\n40.什么是typescript\n\n1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。\n41.三大框架的区别：\n\nAngular带有比较强的排它性的\nReact主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。\nVue 渐进式的\n42.spa应用\n\n优点：用户体验好 、良好的前后端分离。\n\n缺点：\n1.不利于SEO。\n2.初次加载耗时相对增多。\n3.导航不可用，如果一定要导航需要自行实现前进、后退。\n43.什么是模块化编程？\n\n每个模块内部，module变量代表当前模块。\n\n这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。\n\n44.性能优化？\n\n1.使用 CDN\n2.图片懒加载\n3.使用外部 JavaScript 和 CSS\n4.压缩 JavaScript 、 CSS 、字体、图片等\n5.优化 CSS Sprite\n6.减少 HTTP 请求数\n7.减少 DNS 查询\n8.减少 DOM 元素数量\n9.减少 DOM 操作\n10.把脚本放在页面底部\n可以看看这篇文章 关于前端优化的一些方案\n45.什么是HTTP协议：\n\nHTTP是一个客户端和服务器端请求和应答的标准（TCP）。\nHTTP1.1 和 2.0协议的区别：\nHTTP1.1不支持 header 数据的压缩，而2.0支持","source":"_posts/webTitle.md","raw":"---\ntitle: 前端面试题整理\ndate: 2019-09-02 10:42:59\ntags: web\n---\n \nAuthor: Echo\nTime: 2019-09-02 10:42:59\n\n## 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n\n1.输入域名地址\n2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；\n3.与WEB服务器建立TCP连接；\n4.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）\n5.浏览器跟踪重定向地址\n6.服务器处理请求\n7.服务器返回一个HTTP响应\n8.浏览器显示 HTML\n9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）\n10.浏览器发送异步请求\n\n```\nDNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。\nTCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。\n```\n\n## 浏览器工作原理\n\n1. `用户界面` － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。\n\n2. `浏览器引擎` － 用来查询及操作渲染引擎的接口。\n\n3. `渲染引擎` － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。\n\n4. `网络` － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。\n\n5. `UI后端` － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。\n\n6. `JS解释器` － 用来解释执行JS代码。\n\n7. `数据存储` － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术\n![image](https://pic.xiaohuochai.site/blog/browserRender1.png)\n\n\n参考链接:https://www.cnblogs.com/xiaohuochai/p/9174471.html\n\n## 浏览器内核\n\n主要分成两部分:`渲染引擎`(layout engineer或Rendering Engine)和`JS引擎`。\n\n`渲染引擎`:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\n`JS引擎`:解析和执行javascript来实现网页的动态效果。\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n\n## 常见的浏览器内核有哪些？\n\nTrident内核:IE，360.... (微软开发的一种排版引擎)\nGecko内核:Firefox\nPresto内核:Opera(已经废弃了)\nBlink内核:Opera；\nWebkit内核:Safari，Chrome。\n##  cookies，sessionStorage 和 localStorage 的区别？\n`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。\n`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。\n\n##### 存储大小:\n* cookie数据大小不能超过4k。\n* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。\n##### 存储时间:\n* localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;\n* sessionStorage 数据在当前浏览器窗口关闭后自动删除.\n* cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n```\n// 存储内容类型: \nsessionStorage和localStorage只能存储字符串类型\n// 获取方式:\nlocalStorage:window.localStorage;；sessionStorage:window.sessionStorage;\n// WebStorage提供了一些方法，数据操作比cookie方便；\nsetItem (key, value) ——  保存数据，以键值对的方式储存信息。\ngetItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。\nremoveItem (key) ——  删除单个数据，根据键值移除对应的信息。\nclear () ——  删除所有的数据\nkey (index) —— 获取某个索引的key\n// cookie需要自己封装接口setCookie. getCookit\n```\n\n## 页面访问cookie的限制条件\n跨域问题，设置了HttpOnly\n\n参考链接:https://www.cnblogs.com/hujunzheng/p/5744755.html\n\n## 实现浏览器内多个标签页之间的通信\n\n* localstorge\nlocalstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。\n```\n// a:click\n$(\"#btn\").click(function(){  \n  var name=$(\"#name\").val();  \n  localStorage.setItem(\"name\", name); \n}); \n\n// b:watch\nwindow.addEventListener(\"storage\", function(event){   console.log(event.key + \"=\" + event.newValue);  \n}); \n```\n* cookie+setInterval\n将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息\n\n* websocket协议\n1.首先我们得了解websocket是什么？\n它是一种网络通信协议\n2.为什么会用到websocket?\n因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。\n但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。\n轮询:每隔一段时间，就发出一个询问.\n因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.\n* html5浏览器的新特性SharedWorker\n\n参考链接:https://segmentfault.com/a/1190000018354650\n\n## 页面可见性（Page Visibility API） 可以有哪些用途\n通过 visibilityState 的值检测页面\n* 当前是否可见\n* 打开网页的时间\n* 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等\n##  网页验证码是做什么的，是为了解决什么安全问题\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n##  为什么利用多个域名来存储网站资源\n1、CDN缓存更方便\n\n2、突破浏览器并发限制\n\n3、节约cookie带宽\n\n4、节约主域名的连接数，优化页面响应速度\n\n5、防止不必要的安全问题\n\n```\nCDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源\n// 突破浏览器并发限制\n同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。\n\n```\n\n## 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n\n* 图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n* 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n* 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n* 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n## 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n\n* 语义化html标签\n\n* 合理的title，description,keywords\n\n* 主要html代码放在前面\n\n* 少用iframe，搜索引擎不会抓取iframe中的内容\n\n* 图片加上Alt\n\n参考链接(了解seo): https://blog.csdn.net/jnshu_it/article/details/80029988\n\n## 前端性能优化\n\n###### 一、减少请求资源大小或者次数　\n1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）\n　　原因:主要是为了减少http请求次数以及减少请求资源的大小\n　　打包工具:\n　　webpack\n　　gulp\n　　grunt\n.　　....\n2、尽量所使用的字体图标或者SVG图标来代替传统png图\n　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快\n\n3、采用图片的懒加载（延迟加载）\n　　目的为了，减少页面第一次加载过程中http的请求次数\n　　具体步骤:\n　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图\n　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息\n\n4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。\n　　避免引入第三方大量的库。而自己却只是用里面的一个小功能\n\n5、使用雪碧图或者是说图片精灵\n　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用\n　　图片定位来讲小图展现在页面中（background-position:百分比，数值）\n\n6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie\n\n7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势\n　　目的:是数据处理方便，资源偏小\n\n8、前端与后端协商，合理使用keep-alive\n\n9、前端与服务器协商，使用响应资源的压缩\n\n10、避免使用iframe\n　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源\n\n11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个\n缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据\n时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）\n\n二、代码优化相关\n1、在js中尽量减少闭包的使用\n　　原因:使用闭包后，闭包所在的上下文不会被释放\n\n2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）\n　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）\n\n3、在js中避免嵌套循环和\"死循环\"(一旦遇到死循环，浏览器就会直接卡掉)\n\n4、把css放在body上，把js放在body下面\n　　让其先加载css（注意:这里关于优化没有多大关系）\n\n5、减少css表达式的使用\n\n6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象\n\n7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。\n\n9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上\n\n10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作\n\n11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画\n　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout\n　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间\n　　缩短\n\n12、尽量减少使用递归，避免死递归。\n　　解决:建议使用尾递归\n\n13、基于script标签下载js文件时，可以使用defer或者async来异步加载\n\n14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。\n\n15、减少Flash的使用\n\n三、存储\n\n1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs\n\n2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，\n　　避免向后台请求数据或者说在离线状态下做一些数据展示。\n\n四、其他优化\n\n\n1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢\n　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的\n　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示\n　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数\n\n3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）\n　　解决方法:只需要将音视频的`preload=none`即可。\n　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源\n\n## webSocket如何兼容低浏览器\n\n* 基于长轮询的 XHR\n* Adobe Flash Socket\n* ActiveX HTMLFile (IE)\n* 基于 multipart 编码发送 XHR\n参考链接:https://www.cnblogs.com/pengc/p/8718380.html\n\n## web开发中会话跟踪的方法\n1. 隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。\n2. URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。\n3. Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。\n4. Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话\n5. IP地址\n\n## HTTP method\n一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。\n* GET是最常用的方法，通常用于请求服务器发送某个资源。\n* HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。\n* PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。\n* POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。\n* TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。\n* OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。\n* DELETE 请求服务器删除请求 URL 指定的资源\n\n## HTTP状态码及其含义\n\n| 状态码        | 类别    |  原因短语  |\n| --------   | -----:  | :----: |\n| 1XX        | Information（信息性状态码）      |   接收的请求正在处理    |\n| 2XX        | Success（成功状态码）      |   请求正常处理完毕    |\n| 3XX        | Redirection（重定向状态码）      |   需要进行附加的操作以完成请求    |\n| 4XX        | Client Error（客户端错误状态码）      |   服务器无法处理请求    |\n| 5XX        | Server Error（服务端错误状态码）      |   服务器处理请求出错    |\n\n* 204\t 服务器成功处理，但未返回内容。\n* 304\tNot Modified 未修改。\t所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n* 400\tBad Request\t客户端请求的语法错误，服务器无法理解\n* 403\tForbidden\t服务器理解请求客户端的请求，但是拒绝执行此请求\n* 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n## 什么是同源：协议相同 域名相同 端口相同\n\n同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。\n\n如果非同源，共有三种行为受到限制\n1.Cookie、LocalStorage 和 IndexDB 无法读取。\n2.DOM 无法获得。\n3.AJAX 请求不能发送。\n\n----\n// 下面的还没有看\n关于建站安全防护\n\n要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。\n\nXSS概念:\n\n译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。\nXSS预防:\n\n关键cookie字段设置httpOnly\n输入检查,特殊字符 < > / &等,对其进行转义后存储\nCSRF概念：\n\n本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。\nCSRF 预防：\n\n使用验证码，更高级用图灵测试\nSQL概念：\n\n通常没有任何过滤，直接把参数存放到了SQL语句当中\nSQL预防：\n\n根本上防止SQL注入的方法，就是参数化查询或者做词法分析。\nDDOS概念：\n\n利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。\nDDOS预防：用软硬件结合的方式来防御是最有效的\n25.对前端工程化的理解\n\n1.开发规范\n2.模块化开发\n3.组件化开发\n4.组件仓库\n5.性能优化\n6.项目部署\n7.开发流程\n8.开发工具\n26.AMD和CMD是什么？它们的区别有哪些？\n\nAMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。\n\n27.MVC BFC\n\nmvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。\n\nBFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。\n\n28.你如何对网站的文件和资源进行优化？\n\n期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。\n29.如果网页内容需要支持多语言，你会怎么做？\n\n1.应用字符集的选择，选择UTF-8编码\n2.语言书写习惯&导航结构\n3.数据库驱动型网站\n30.如果设计中使用了非标准的字体，你该如何去实现？\n\n所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。\n方法：\n用图片代替\nweb fonts在线字库，如Google Webfonts，Typekit等等;http://www.chinaz.com/free/20…；\n@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)\n31.如何自学一门新编程语言\n\n(1)了解背景知识：历史、现状、特点、应用领域、发展趋势\n(2)搭建开发环境，编写HelloWorld\n(3)声明变量和常量\n(4)数据类型\n(5)运算符\n(6)逻辑结构\n(7)通用小程序\n(8)函数和对象\n(9)第三方库、组件、框架\n(10)实用项目\n32.什么是哈希表？\n\n散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n\n33.静态网页和动态网页区别：\n\n静态: 网页内容任何人在任何时间访问都是不变的\n\n动态: 网页内容不同人在不同时间访问可能是不同的\n\n34.SQL语句的分类\n\nDDL:数据定义语句 CREATE/DROP/ALTER…\nDCL:数据控制语句 GRANT…\nDML:操作操作语句 INSERT/UPDATE/DELETE\nDQL:查询语句 SELECT\n35.什么是弹性布局？\n\n解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。\n\n设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!\n\ndisplay:flex; 属性align-self 定义子元素的位置。\n\n36.编写响应式？\n\n1.声明viewport元标签\n2.使用流式布局\n3.所有容器使用相对尺寸，不用绝对尺寸\n4.（最重要原则）使用CSS3 Media Query技术\n37.常见的浏览器兼容问题？\n\n1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}\n2.图片默认有间距使用float属性为img布局\n3.居中问题（而FF默认为左对齐）margin: 0 auto;\n4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、\n5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀\n38.H5新特性：\n\n(1)Canvas绘图\n(2)SVG绘图\n(3)地理定位\n(4)Web Worker\nweb worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。\n(5)Web Storage\n1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）\n2.（兼容性差,数据8MB,操作简单）sessionStorage\n3.localStorage\n(6)Web Socket\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n39.C3新特性：\n\n1.复杂的选择器\n2.弹性布局\n3.动画\n40.什么是typescript\n\n1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。\n41.三大框架的区别：\n\nAngular带有比较强的排它性的\nReact主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。\nVue 渐进式的\n42.spa应用\n\n优点：用户体验好 、良好的前后端分离。\n\n缺点：\n1.不利于SEO。\n2.初次加载耗时相对增多。\n3.导航不可用，如果一定要导航需要自行实现前进、后退。\n43.什么是模块化编程？\n\n每个模块内部，module变量代表当前模块。\n\n这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。\n\n44.性能优化？\n\n1.使用 CDN\n2.图片懒加载\n3.使用外部 JavaScript 和 CSS\n4.压缩 JavaScript 、 CSS 、字体、图片等\n5.优化 CSS Sprite\n6.减少 HTTP 请求数\n7.减少 DNS 查询\n8.减少 DOM 元素数量\n9.减少 DOM 操作\n10.把脚本放在页面底部\n可以看看这篇文章 关于前端优化的一些方案\n45.什么是HTTP协议：\n\nHTTP是一个客户端和服务器端请求和应答的标准（TCP）。\nHTTP1.1 和 2.0协议的区别：\nHTTP1.1不支持 header 数据的压缩，而2.0支持","slug":"webTitle","published":1,"updated":"2019-09-19T12:55:01.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck0rxd4ue001rygkcfo1291z2","content":"<p>Author: Echo<br>Time: 2019-09-02 10:42:59</p>\n<h2 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h2><p>1.输入域名地址<br>2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；<br>3.与WEB服务器建立TCP连接；<br>4.服务器的永久重定向响应（从 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 到 <a href=\"http://www.example.com）\" target=\"_blank\" rel=\"noopener\">http://www.example.com）</a><br>5.浏览器跟踪重定向地址<br>6.服务器处理请求<br>7.服务器返回一个HTTP响应<br>8.浏览器显示 HTML<br>9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）<br>10.浏览器发送异步请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。</span><br><span class=\"line\">TCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h2><ol>\n<li><p><code>用户界面</code> － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。</p>\n</li>\n<li><p><code>浏览器引擎</code> － 用来查询及操作渲染引擎的接口。</p>\n</li>\n<li><p><code>渲染引擎</code> － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。</p>\n</li>\n<li><p><code>网络</code> － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。</p>\n</li>\n<li><p><code>UI后端</code> － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p>\n</li>\n<li><p><code>JS解释器</code> － 用来解释执行JS代码。</p>\n</li>\n<li><p><code>数据存储</code> － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术<br><img src=\"https://pic.xiaohuochai.site/blog/browserRender1.png\" alt=\"image\"></p>\n</li>\n</ol>\n<p>参考链接:<a href=\"https://www.cnblogs.com/xiaohuochai/p/9174471.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaohuochai/p/9174471.html</a></p>\n<h2 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h2><p>主要分成两部分:<code>渲染引擎</code>(layout engineer或Rendering Engine)和<code>JS引擎</code>。</p>\n<p><code>渲染引擎</code>:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p><code>JS引擎</code>:解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><p>Trident内核:IE，360…. (微软开发的一种排版引擎)<br>Gecko内核:Firefox<br>Presto内核:Opera(已经废弃了)<br>Blink内核:Opera；<br>Webkit内核:Safari，Chrome。</p>\n<h2 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>\n<h5 id=\"存储大小\"><a href=\"#存储大小\" class=\"headerlink\" title=\"存储大小:\"></a>存储大小:</h5><ul>\n<li>cookie数据大小不能超过4k。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。<h5 id=\"存储时间\"><a href=\"#存储时间\" class=\"headerlink\" title=\"存储时间:\"></a>存储时间:</h5></li>\n<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;</li>\n<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除.</li>\n<li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 存储内容类型: </span><br><span class=\"line\">sessionStorage和localStorage只能存储字符串类型</span><br><span class=\"line\">// 获取方式:</span><br><span class=\"line\">localStorage:window.localStorage;；sessionStorage:window.sessionStorage;</span><br><span class=\"line\">// WebStorage提供了一些方法，数据操作比cookie方便；</span><br><span class=\"line\">setItem (key, value) ——  保存数据，以键值对的方式储存信息。</span><br><span class=\"line\">getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</span><br><span class=\"line\">removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</span><br><span class=\"line\">clear () ——  删除所有的数据</span><br><span class=\"line\">key (index) —— 获取某个索引的key</span><br><span class=\"line\">// cookie需要自己封装接口setCookie. getCookit</span><br></pre></td></tr></table></figure>\n<h2 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h2><p>跨域问题，设置了HttpOnly</p>\n<p>参考链接:<a href=\"https://www.cnblogs.com/hujunzheng/p/5744755.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hujunzheng/p/5744755.html</a></p>\n<h2 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h2><ul>\n<li><p>localstorge<br>localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a:click</span><br><span class=\"line\">$(&quot;#btn&quot;).click(function()&#123;  </span><br><span class=\"line\">  var name=$(&quot;#name&quot;).val();  </span><br><span class=\"line\">  localStorage.setItem(&quot;name&quot;, name); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">// b:watch</span><br><span class=\"line\">window.addEventListener(&quot;storage&quot;, function(event)&#123;   console.log(event.key + &quot;=&quot; + event.newValue);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cookie+setInterval<br>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息</p>\n</li>\n<li><p>websocket协议<br>1.首先我们得了解websocket是什么？<br>它是一种网络通信协议<br>2.为什么会用到websocket?<br>因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。<br>但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。<br>轮询:每隔一段时间，就发出一个询问.<br>因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.</p>\n</li>\n<li>html5浏览器的新特性SharedWorker</li>\n</ul>\n<p>参考链接:<a href=\"https://segmentfault.com/a/1190000018354650\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000018354650</a></p>\n<h2 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h2><p>通过 visibilityState 的值检测页面</p>\n<ul>\n<li>当前是否可见</li>\n<li>打开网页的时间</li>\n<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等<h2 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h2>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试<h2 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h2>1、CDN缓存更方便</li>\n</ul>\n<p>2、突破浏览器并发限制</p>\n<p>3、节约cookie带宽</p>\n<p>4、节约主域名的连接数，优化页面响应速度</p>\n<p>5、防止不必要的安全问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源</span><br><span class=\"line\">// 突破浏览器并发限制</span><br><span class=\"line\">同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h2><ul>\n<li>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>\n<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>\n<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>\n<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>\n</ul>\n<h2 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h2><ul>\n<li><p>语义化html标签</p>\n</li>\n<li><p>合理的title，description,keywords</p>\n</li>\n<li><p>主要html代码放在前面</p>\n</li>\n<li><p>少用iframe，搜索引擎不会抓取iframe中的内容</p>\n</li>\n<li><p>图片加上Alt</p>\n</li>\n</ul>\n<p>参考链接(了解seo): <a href=\"https://blog.csdn.net/jnshu_it/article/details/80029988\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jnshu_it/article/details/80029988</a></p>\n<h2 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h2><h6 id=\"一、减少请求资源大小或者次数\"><a href=\"#一、减少请求资源大小或者次数\" class=\"headerlink\" title=\"一、减少请求资源大小或者次数　\"></a>一、减少请求资源大小或者次数　</h6><p>1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）<br>　　原因:主要是为了减少http请求次数以及减少请求资源的大小<br>　　打包工具:<br>　　webpack<br>　　gulp<br>　　grunt<br>.　　….<br>2、尽量所使用的字体图标或者SVG图标来代替传统png图<br>　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快</p>\n<p>3、采用图片的懒加载（延迟加载）<br>　　目的为了，减少页面第一次加载过程中http的请求次数<br>　　具体步骤:<br>　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图<br>　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息</p>\n<p>4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。<br>　　避免引入第三方大量的库。而自己却只是用里面的一个小功能</p>\n<p>5、使用雪碧图或者是说图片精灵<br>　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用<br>　　图片定位来讲小图展现在页面中（background-position:百分比，数值）</p>\n<p>6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie</p>\n<p>7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势<br>　　目的:是数据处理方便，资源偏小</p>\n<p>8、前端与后端协商，合理使用keep-alive</p>\n<p>9、前端与服务器协商，使用响应资源的压缩</p>\n<p>10、避免使用iframe<br>　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源</p>\n<p>11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个<br>缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据<br>时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）</p>\n<p>二、代码优化相关<br>1、在js中尽量减少闭包的使用<br>　　原因:使用闭包后，闭包所在的上下文不会被释放</p>\n<p>2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）<br>　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）</p>\n<p>3、在js中避免嵌套循环和”死循环”(一旦遇到死循环，浏览器就会直接卡掉)</p>\n<p>4、把css放在body上，把js放在body下面<br>　　让其先加载css（注意:这里关于优化没有多大关系）</p>\n<p>5、减少css表达式的使用</p>\n<p>6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象</p>\n<p>7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。</p>\n<p>9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上</p>\n<p>10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作</p>\n<p>11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画<br>　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout<br>　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间<br>　　缩短</p>\n<p>12、尽量减少使用递归，避免死递归。<br>　　解决:建议使用尾递归</p>\n<p>13、基于script标签下载js文件时，可以使用defer或者async来异步加载</p>\n<p>14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。</p>\n<p>15、减少Flash的使用</p>\n<p>三、存储</p>\n<p>1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs</p>\n<p>2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，<br>　　避免向后台请求数据或者说在离线状态下做一些数据展示。</p>\n<p>四、其他优化</p>\n<p>1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢<br>　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的<br>　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示<br>　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数</p>\n<p>3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）<br>　　解决方法:只需要将音视频的<code>preload=none</code>即可。<br>　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源</p>\n<h2 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h2><ul>\n<li>基于长轮询的 XHR</li>\n<li>Adobe Flash Socket</li>\n<li>ActiveX HTMLFile (IE)</li>\n<li>基于 multipart 编码发送 XHR<br>参考链接:<a href=\"https://www.cnblogs.com/pengc/p/8718380.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/pengc/p/8718380.html</a></li>\n</ul>\n<h2 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h2><ol>\n<li>隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。</li>\n<li>URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。</li>\n<li>Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。</li>\n<li>Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</li>\n<li>IP地址</li>\n</ol>\n<h2 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。</p>\n<ul>\n<li>GET是最常用的方法，通常用于请求服务器发送某个资源。</li>\n<li>HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。</li>\n<li>PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。</li>\n<li>POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li>\n<li>TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li>\n<li>OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>\n<li>DELETE 请求服务器删除请求 URL 指定的资源</li>\n</ul>\n<h2 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h2><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th style=\"text-align:right\">类别</th>\n<th style=\"text-align:center\">原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td style=\"text-align:right\">Information（信息性状态码）</td>\n<td style=\"text-align:center\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td style=\"text-align:right\">Success（成功状态码）</td>\n<td style=\"text-align:center\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td style=\"text-align:right\">Redirection（重定向状态码）</td>\n<td style=\"text-align:center\">需要进行附加的操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td style=\"text-align:right\">Client Error（客户端错误状态码）</td>\n<td style=\"text-align:center\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td style=\"text-align:right\">Server Error（服务端错误状态码）</td>\n<td style=\"text-align:center\">服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>204     服务器成功处理，但未返回内容。</li>\n<li>304    Not Modified 未修改。    所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>\n<li>400    Bad Request    客户端请求的语法错误，服务器无法理解</li>\n<li>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面<h2 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h2></li>\n</ul>\n<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<p>如果非同源，共有三种行为受到限制<br>1.Cookie、LocalStorage 和 IndexDB 无法读取。<br>2.DOM 无法获得。<br>3.AJAX 请求不能发送。</p>\n<hr>\n<p>// 下面的还没有看<br>关于建站安全防护</p>\n<p>要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。</p>\n<p>XSS概念:</p>\n<p>译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。<br>XSS预防:</p>\n<p>关键cookie字段设置httpOnly<br>输入检查,特殊字符 &lt; &gt; / &amp;等,对其进行转义后存储<br>CSRF概念：</p>\n<p>本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。<br>CSRF 预防：</p>\n<p>使用验证码，更高级用图灵测试<br>SQL概念：</p>\n<p>通常没有任何过滤，直接把参数存放到了SQL语句当中<br>SQL预防：</p>\n<p>根本上防止SQL注入的方法，就是参数化查询或者做词法分析。<br>DDOS概念：</p>\n<p>利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。<br>DDOS预防：用软硬件结合的方式来防御是最有效的<br>25.对前端工程化的理解</p>\n<p>1.开发规范<br>2.模块化开发<br>3.组件化开发<br>4.组件仓库<br>5.性能优化<br>6.项目部署<br>7.开发流程<br>8.开发工具<br>26.AMD和CMD是什么？它们的区别有哪些？</p>\n<p>AMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。</p>\n<p>27.MVC BFC</p>\n<p>mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。</p>\n<p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。</p>\n<p>28.你如何对网站的文件和资源进行优化？</p>\n<p>期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。<br>29.如果网页内容需要支持多语言，你会怎么做？</p>\n<p>1.应用字符集的选择，选择UTF-8编码<br>2.语言书写习惯&amp;导航结构<br>3.数据库驱动型网站<br>30.如果设计中使用了非标准的字体，你该如何去实现？</p>\n<p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：<br>用图片代替<br>web fonts在线字库，如Google Webfonts，Typekit等等;<a href=\"http://www.chinaz.com/free/20…；\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/free/20…；</a><br>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)<br>31.如何自学一门新编程语言</p>\n<p>(1)了解背景知识：历史、现状、特点、应用领域、发展趋势<br>(2)搭建开发环境，编写HelloWorld<br>(3)声明变量和常量<br>(4)数据类型<br>(5)运算符<br>(6)逻辑结构<br>(7)通用小程序<br>(8)函数和对象<br>(9)第三方库、组件、框架<br>(10)实用项目<br>32.什么是哈希表？</p>\n<p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>\n<p>33.静态网页和动态网页区别：</p>\n<p>静态: 网页内容任何人在任何时间访问都是不变的</p>\n<p>动态: 网页内容不同人在不同时间访问可能是不同的</p>\n<p>34.SQL语句的分类</p>\n<p>DDL:数据定义语句 CREATE/DROP/ALTER…<br>DCL:数据控制语句 GRANT…<br>DML:操作操作语句 INSERT/UPDATE/DELETE<br>DQL:查询语句 SELECT<br>35.什么是弹性布局？</p>\n<p>解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。</p>\n<p>设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!</p>\n<p>display:flex; 属性align-self 定义子元素的位置。</p>\n<p>36.编写响应式？</p>\n<p>1.声明viewport元标签<br>2.使用流式布局<br>3.所有容器使用相对尺寸，不用绝对尺寸<br>4.（最重要原则）使用CSS3 Media Query技术<br>37.常见的浏览器兼容问题？</p>\n<p>1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}<br>2.图片默认有间距使用float属性为img布局<br>3.居中问题（而FF默认为左对齐）margin: 0 auto;<br>4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、<br>5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀<br>38.H5新特性：</p>\n<p>(1)Canvas绘图<br>(2)SVG绘图<br>(3)地理定位<br>(4)Web Worker<br>web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。<br>(5)Web Storage<br>1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）<br>2.（兼容性差,数据8MB,操作简单）sessionStorage<br>3.localStorage<br>(6)Web Socket<br>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。<br>39.C3新特性：</p>\n<p>1.复杂的选择器<br>2.弹性布局<br>3.动画<br>40.什么是typescript</p>\n<p>1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。<br>41.三大框架的区别：</p>\n<p>Angular带有比较强的排它性的<br>React主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。<br>Vue 渐进式的<br>42.spa应用</p>\n<p>优点：用户体验好 、良好的前后端分离。</p>\n<p>缺点：<br>1.不利于SEO。<br>2.初次加载耗时相对增多。<br>3.导航不可用，如果一定要导航需要自行实现前进、后退。<br>43.什么是模块化编程？</p>\n<p>每个模块内部，module变量代表当前模块。</p>\n<p>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>\n<p>44.性能优化？</p>\n<p>1.使用 CDN<br>2.图片懒加载<br>3.使用外部 JavaScript 和 CSS<br>4.压缩 JavaScript 、 CSS 、字体、图片等<br>5.优化 CSS Sprite<br>6.减少 HTTP 请求数<br>7.减少 DNS 查询<br>8.减少 DOM 元素数量<br>9.减少 DOM 操作<br>10.把脚本放在页面底部<br>可以看看这篇文章 关于前端优化的一些方案<br>45.什么是HTTP协议：</p>\n<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。<br>HTTP1.1 和 2.0协议的区别：<br>HTTP1.1不支持 header 数据的压缩，而2.0支持</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-02 10:42:59</p>\n<h2 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h2><p>1.输入域名地址<br>2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；<br>3.与WEB服务器建立TCP连接；<br>4.服务器的永久重定向响应（从 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 到 <a href=\"http://www.example.com）\" target=\"_blank\" rel=\"noopener\">http://www.example.com）</a><br>5.浏览器跟踪重定向地址<br>6.服务器处理请求<br>7.服务器返回一个HTTP响应<br>8.浏览器显示 HTML<br>9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）<br>10.浏览器发送异步请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。</span><br><span class=\"line\">TCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h2><ol>\n<li><p><code>用户界面</code> － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。</p>\n</li>\n<li><p><code>浏览器引擎</code> － 用来查询及操作渲染引擎的接口。</p>\n</li>\n<li><p><code>渲染引擎</code> － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。</p>\n</li>\n<li><p><code>网络</code> － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。</p>\n</li>\n<li><p><code>UI后端</code> － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p>\n</li>\n<li><p><code>JS解释器</code> － 用来解释执行JS代码。</p>\n</li>\n<li><p><code>数据存储</code> － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术<br><img src=\"https://pic.xiaohuochai.site/blog/browserRender1.png\" alt=\"image\"></p>\n</li>\n</ol>\n<p>参考链接:<a href=\"https://www.cnblogs.com/xiaohuochai/p/9174471.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaohuochai/p/9174471.html</a></p>\n<h2 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h2><p>主要分成两部分:<code>渲染引擎</code>(layout engineer或Rendering Engine)和<code>JS引擎</code>。</p>\n<p><code>渲染引擎</code>:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p><code>JS引擎</code>:解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><p>Trident内核:IE，360…. (微软开发的一种排版引擎)<br>Gecko内核:Firefox<br>Presto内核:Opera(已经废弃了)<br>Blink内核:Opera；<br>Webkit内核:Safari，Chrome。</p>\n<h2 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>\n<h5 id=\"存储大小\"><a href=\"#存储大小\" class=\"headerlink\" title=\"存储大小:\"></a>存储大小:</h5><ul>\n<li>cookie数据大小不能超过4k。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。<h5 id=\"存储时间\"><a href=\"#存储时间\" class=\"headerlink\" title=\"存储时间:\"></a>存储时间:</h5></li>\n<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;</li>\n<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除.</li>\n<li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 存储内容类型: </span><br><span class=\"line\">sessionStorage和localStorage只能存储字符串类型</span><br><span class=\"line\">// 获取方式:</span><br><span class=\"line\">localStorage:window.localStorage;；sessionStorage:window.sessionStorage;</span><br><span class=\"line\">// WebStorage提供了一些方法，数据操作比cookie方便；</span><br><span class=\"line\">setItem (key, value) ——  保存数据，以键值对的方式储存信息。</span><br><span class=\"line\">getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</span><br><span class=\"line\">removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</span><br><span class=\"line\">clear () ——  删除所有的数据</span><br><span class=\"line\">key (index) —— 获取某个索引的key</span><br><span class=\"line\">// cookie需要自己封装接口setCookie. getCookit</span><br></pre></td></tr></table></figure>\n<h2 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h2><p>跨域问题，设置了HttpOnly</p>\n<p>参考链接:<a href=\"https://www.cnblogs.com/hujunzheng/p/5744755.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hujunzheng/p/5744755.html</a></p>\n<h2 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h2><ul>\n<li><p>localstorge<br>localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a:click</span><br><span class=\"line\">$(&quot;#btn&quot;).click(function()&#123;  </span><br><span class=\"line\">  var name=$(&quot;#name&quot;).val();  </span><br><span class=\"line\">  localStorage.setItem(&quot;name&quot;, name); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">// b:watch</span><br><span class=\"line\">window.addEventListener(&quot;storage&quot;, function(event)&#123;   console.log(event.key + &quot;=&quot; + event.newValue);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cookie+setInterval<br>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息</p>\n</li>\n<li><p>websocket协议<br>1.首先我们得了解websocket是什么？<br>它是一种网络通信协议<br>2.为什么会用到websocket?<br>因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。<br>但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。<br>轮询:每隔一段时间，就发出一个询问.<br>因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.</p>\n</li>\n<li>html5浏览器的新特性SharedWorker</li>\n</ul>\n<p>参考链接:<a href=\"https://segmentfault.com/a/1190000018354650\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000018354650</a></p>\n<h2 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h2><p>通过 visibilityState 的值检测页面</p>\n<ul>\n<li>当前是否可见</li>\n<li>打开网页的时间</li>\n<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等<h2 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h2>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试<h2 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h2>1、CDN缓存更方便</li>\n</ul>\n<p>2、突破浏览器并发限制</p>\n<p>3、节约cookie带宽</p>\n<p>4、节约主域名的连接数，优化页面响应速度</p>\n<p>5、防止不必要的安全问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源</span><br><span class=\"line\">// 突破浏览器并发限制</span><br><span class=\"line\">同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h2><ul>\n<li>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>\n<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>\n<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>\n<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>\n</ul>\n<h2 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h2><ul>\n<li><p>语义化html标签</p>\n</li>\n<li><p>合理的title，description,keywords</p>\n</li>\n<li><p>主要html代码放在前面</p>\n</li>\n<li><p>少用iframe，搜索引擎不会抓取iframe中的内容</p>\n</li>\n<li><p>图片加上Alt</p>\n</li>\n</ul>\n<p>参考链接(了解seo): <a href=\"https://blog.csdn.net/jnshu_it/article/details/80029988\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jnshu_it/article/details/80029988</a></p>\n<h2 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h2><h6 id=\"一、减少请求资源大小或者次数\"><a href=\"#一、减少请求资源大小或者次数\" class=\"headerlink\" title=\"一、减少请求资源大小或者次数　\"></a>一、减少请求资源大小或者次数　</h6><p>1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）<br>　　原因:主要是为了减少http请求次数以及减少请求资源的大小<br>　　打包工具:<br>　　webpack<br>　　gulp<br>　　grunt<br>.　　….<br>2、尽量所使用的字体图标或者SVG图标来代替传统png图<br>　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快</p>\n<p>3、采用图片的懒加载（延迟加载）<br>　　目的为了，减少页面第一次加载过程中http的请求次数<br>　　具体步骤:<br>　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图<br>　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息</p>\n<p>4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。<br>　　避免引入第三方大量的库。而自己却只是用里面的一个小功能</p>\n<p>5、使用雪碧图或者是说图片精灵<br>　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用<br>　　图片定位来讲小图展现在页面中（background-position:百分比，数值）</p>\n<p>6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie</p>\n<p>7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势<br>　　目的:是数据处理方便，资源偏小</p>\n<p>8、前端与后端协商，合理使用keep-alive</p>\n<p>9、前端与服务器协商，使用响应资源的压缩</p>\n<p>10、避免使用iframe<br>　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源</p>\n<p>11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个<br>缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据<br>时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）</p>\n<p>二、代码优化相关<br>1、在js中尽量减少闭包的使用<br>　　原因:使用闭包后，闭包所在的上下文不会被释放</p>\n<p>2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）<br>　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）</p>\n<p>3、在js中避免嵌套循环和”死循环”(一旦遇到死循环，浏览器就会直接卡掉)</p>\n<p>4、把css放在body上，把js放在body下面<br>　　让其先加载css（注意:这里关于优化没有多大关系）</p>\n<p>5、减少css表达式的使用</p>\n<p>6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象</p>\n<p>7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。</p>\n<p>9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上</p>\n<p>10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作</p>\n<p>11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画<br>　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout<br>　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间<br>　　缩短</p>\n<p>12、尽量减少使用递归，避免死递归。<br>　　解决:建议使用尾递归</p>\n<p>13、基于script标签下载js文件时，可以使用defer或者async来异步加载</p>\n<p>14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。</p>\n<p>15、减少Flash的使用</p>\n<p>三、存储</p>\n<p>1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs</p>\n<p>2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，<br>　　避免向后台请求数据或者说在离线状态下做一些数据展示。</p>\n<p>四、其他优化</p>\n<p>1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢<br>　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的<br>　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示<br>　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数</p>\n<p>3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）<br>　　解决方法:只需要将音视频的<code>preload=none</code>即可。<br>　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源</p>\n<h2 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h2><ul>\n<li>基于长轮询的 XHR</li>\n<li>Adobe Flash Socket</li>\n<li>ActiveX HTMLFile (IE)</li>\n<li>基于 multipart 编码发送 XHR<br>参考链接:<a href=\"https://www.cnblogs.com/pengc/p/8718380.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/pengc/p/8718380.html</a></li>\n</ul>\n<h2 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h2><ol>\n<li>隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。</li>\n<li>URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。</li>\n<li>Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。</li>\n<li>Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</li>\n<li>IP地址</li>\n</ol>\n<h2 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。</p>\n<ul>\n<li>GET是最常用的方法，通常用于请求服务器发送某个资源。</li>\n<li>HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。</li>\n<li>PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。</li>\n<li>POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li>\n<li>TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li>\n<li>OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>\n<li>DELETE 请求服务器删除请求 URL 指定的资源</li>\n</ul>\n<h2 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h2><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th style=\"text-align:right\">类别</th>\n<th style=\"text-align:center\">原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td style=\"text-align:right\">Information（信息性状态码）</td>\n<td style=\"text-align:center\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td style=\"text-align:right\">Success（成功状态码）</td>\n<td style=\"text-align:center\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td style=\"text-align:right\">Redirection（重定向状态码）</td>\n<td style=\"text-align:center\">需要进行附加的操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td style=\"text-align:right\">Client Error（客户端错误状态码）</td>\n<td style=\"text-align:center\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td style=\"text-align:right\">Server Error（服务端错误状态码）</td>\n<td style=\"text-align:center\">服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>204     服务器成功处理，但未返回内容。</li>\n<li>304    Not Modified 未修改。    所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>\n<li>400    Bad Request    客户端请求的语法错误，服务器无法理解</li>\n<li>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面<h2 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h2></li>\n</ul>\n<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<p>如果非同源，共有三种行为受到限制<br>1.Cookie、LocalStorage 和 IndexDB 无法读取。<br>2.DOM 无法获得。<br>3.AJAX 请求不能发送。</p>\n<hr>\n<p>// 下面的还没有看<br>关于建站安全防护</p>\n<p>要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。</p>\n<p>XSS概念:</p>\n<p>译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。<br>XSS预防:</p>\n<p>关键cookie字段设置httpOnly<br>输入检查,特殊字符 &lt; &gt; / &amp;等,对其进行转义后存储<br>CSRF概念：</p>\n<p>本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。<br>CSRF 预防：</p>\n<p>使用验证码，更高级用图灵测试<br>SQL概念：</p>\n<p>通常没有任何过滤，直接把参数存放到了SQL语句当中<br>SQL预防：</p>\n<p>根本上防止SQL注入的方法，就是参数化查询或者做词法分析。<br>DDOS概念：</p>\n<p>利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。<br>DDOS预防：用软硬件结合的方式来防御是最有效的<br>25.对前端工程化的理解</p>\n<p>1.开发规范<br>2.模块化开发<br>3.组件化开发<br>4.组件仓库<br>5.性能优化<br>6.项目部署<br>7.开发流程<br>8.开发工具<br>26.AMD和CMD是什么？它们的区别有哪些？</p>\n<p>AMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。</p>\n<p>27.MVC BFC</p>\n<p>mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。</p>\n<p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。</p>\n<p>28.你如何对网站的文件和资源进行优化？</p>\n<p>期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。<br>29.如果网页内容需要支持多语言，你会怎么做？</p>\n<p>1.应用字符集的选择，选择UTF-8编码<br>2.语言书写习惯&amp;导航结构<br>3.数据库驱动型网站<br>30.如果设计中使用了非标准的字体，你该如何去实现？</p>\n<p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：<br>用图片代替<br>web fonts在线字库，如Google Webfonts，Typekit等等;<a href=\"http://www.chinaz.com/free/20…；\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/free/20…；</a><br>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)<br>31.如何自学一门新编程语言</p>\n<p>(1)了解背景知识：历史、现状、特点、应用领域、发展趋势<br>(2)搭建开发环境，编写HelloWorld<br>(3)声明变量和常量<br>(4)数据类型<br>(5)运算符<br>(6)逻辑结构<br>(7)通用小程序<br>(8)函数和对象<br>(9)第三方库、组件、框架<br>(10)实用项目<br>32.什么是哈希表？</p>\n<p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>\n<p>33.静态网页和动态网页区别：</p>\n<p>静态: 网页内容任何人在任何时间访问都是不变的</p>\n<p>动态: 网页内容不同人在不同时间访问可能是不同的</p>\n<p>34.SQL语句的分类</p>\n<p>DDL:数据定义语句 CREATE/DROP/ALTER…<br>DCL:数据控制语句 GRANT…<br>DML:操作操作语句 INSERT/UPDATE/DELETE<br>DQL:查询语句 SELECT<br>35.什么是弹性布局？</p>\n<p>解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。</p>\n<p>设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!</p>\n<p>display:flex; 属性align-self 定义子元素的位置。</p>\n<p>36.编写响应式？</p>\n<p>1.声明viewport元标签<br>2.使用流式布局<br>3.所有容器使用相对尺寸，不用绝对尺寸<br>4.（最重要原则）使用CSS3 Media Query技术<br>37.常见的浏览器兼容问题？</p>\n<p>1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}<br>2.图片默认有间距使用float属性为img布局<br>3.居中问题（而FF默认为左对齐）margin: 0 auto;<br>4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、<br>5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀<br>38.H5新特性：</p>\n<p>(1)Canvas绘图<br>(2)SVG绘图<br>(3)地理定位<br>(4)Web Worker<br>web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。<br>(5)Web Storage<br>1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）<br>2.（兼容性差,数据8MB,操作简单）sessionStorage<br>3.localStorage<br>(6)Web Socket<br>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。<br>39.C3新特性：</p>\n<p>1.复杂的选择器<br>2.弹性布局<br>3.动画<br>40.什么是typescript</p>\n<p>1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。<br>41.三大框架的区别：</p>\n<p>Angular带有比较强的排它性的<br>React主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。<br>Vue 渐进式的<br>42.spa应用</p>\n<p>优点：用户体验好 、良好的前后端分离。</p>\n<p>缺点：<br>1.不利于SEO。<br>2.初次加载耗时相对增多。<br>3.导航不可用，如果一定要导航需要自行实现前进、后退。<br>43.什么是模块化编程？</p>\n<p>每个模块内部，module变量代表当前模块。</p>\n<p>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>\n<p>44.性能优化？</p>\n<p>1.使用 CDN<br>2.图片懒加载<br>3.使用外部 JavaScript 和 CSS<br>4.压缩 JavaScript 、 CSS 、字体、图片等<br>5.优化 CSS Sprite<br>6.减少 HTTP 请求数<br>7.减少 DNS 查询<br>8.减少 DOM 元素数量<br>9.减少 DOM 操作<br>10.把脚本放在页面底部<br>可以看看这篇文章 关于前端优化的一些方案<br>45.什么是HTTP协议：</p>\n<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。<br>HTTP1.1 和 2.0协议的区别：<br>HTTP1.1不支持 header 数据的压缩，而2.0支持</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck0rxd4sm0006ygkcey9a8k1l","tag_id":"ck0rxd4sr0008ygkcdg9haaak","_id":"ck0rxd4sy000dygkcu50f5duz"},{"post_id":"ck0rxd4ss0009ygkc7npcpglu","tag_id":"ck0rxd4sx000cygkcwyw53l4g","_id":"ck0rxd4t3000iygkck62qt3gz"},{"post_id":"ck0rxd4t3000hygkctjlyz4mh","tag_id":"ck0rxd4t2000gygkctq8fyki9","_id":"ck0rxd4t6000lygkcsf8fgtj3"},{"post_id":"ck0rxd4su000aygkcqv0y3wr6","tag_id":"ck0rxd4t2000gygkctq8fyki9","_id":"ck0rxd4t7000nygkck566u34o"},{"post_id":"ck0rxd4sv000bygkcw8b8l1xd","tag_id":"ck0rxd4t6000kygkc7d6dqwly","_id":"ck0rxd4ta000rygkc96bq23jp"},{"post_id":"ck0rxd4sy000eygkcu7wswmdc","tag_id":"ck0rxd4t9000pygkcmix990nv","_id":"ck0rxd4tc000uygkcj5sg829k"},{"post_id":"ck0rxd4t0000fygkcdv92a854","tag_id":"ck0rxd4tb000tygkcl8jaijml","_id":"ck0rxd4te000wygkcyv85x9p2"},{"post_id":"ck0rxd4t4000jygkcnqvs8yph","tag_id":"ck0rxd4t9000pygkcmix990nv","_id":"ck0rxd4tf000yygkcyc0brnzv"},{"post_id":"ck0rxd4t6000mygkcq5fyc8bp","tag_id":"ck0rxd4te000xygkc3613r95z","_id":"ck0rxd4tg0010ygkciif6ng3g"},{"post_id":"ck0rxd4t8000oygkcla55vjow","tag_id":"ck0rxd4tg000zygkcpuaedktn","_id":"ck0rxd4th0012ygkcs8zqctn8"},{"post_id":"ck0rxd4t9000qygkcahzesj5f","tag_id":"ck0rxd4t9000pygkcmix990nv","_id":"ck0rxd4tj0014ygkcjpa5w9wj"},{"post_id":"ck0rxd4ta000sygkc81rfw2q3","tag_id":"ck0rxd4tg000zygkcpuaedktn","_id":"ck0rxd4tj0015ygkc2hvyxh2f"},{"post_id":"ck0rxd4to0016ygkc91j54i1s","tag_id":"ck0rxd4t9000pygkcmix990nv","_id":"ck0rxd4tr0018ygkc79q04atm"},{"post_id":"ck0rxd4tq0017ygkct4mzlrpp","tag_id":"ck0rxd4te000xygkc3613r95z","_id":"ck0rxd4ts001aygkcibttrl4e"},{"post_id":"ck0rxd4tu001dygkcjtjb0etr","tag_id":"ck0rxd4tg000zygkcpuaedktn","_id":"ck0rxd4tw001fygkcrjvddtiv"},{"post_id":"ck0rxd4tv001eygkcmbzyp7ij","tag_id":"ck0rxd4tb000tygkcl8jaijml","_id":"ck0rxd4ty001iygkcw9k25ymr"},{"post_id":"ck0rxd4ts0019ygkc9tu9df92","tag_id":"ck0rxd4tu001cygkc38g5771h","_id":"ck0rxd4ty001jygkcyfcfvpyv"},{"post_id":"ck0rxd4tt001bygkc0clgm77i","tag_id":"ck0rxd4tx001hygkct1dvmfht","_id":"ck0rxd4tz001lygkcp8h7ll3b"},{"post_id":"ck0rxd4tw001gygkcnia1xh6z","tag_id":"ck0rxd4tz001kygkcr9grkru1","_id":"ck0rxd4tz001mygkc6yfr0p3g"},{"post_id":"ck0rxd4u5001nygkcv73a4g40","tag_id":"ck0rxd4u8001oygkcrk7ait7z","_id":"ck0rxd4u8001pygkccc9534n7"},{"post_id":"ck0rxd4ud001qygkcjk7aoyc5","tag_id":"ck0rxd4tg000zygkcpuaedktn","_id":"ck0rxd4uf001sygkcuxajoemh"},{"post_id":"ck0rxd4ue001rygkcfo1291z2","tag_id":"ck0rxd4sx000cygkcwyw53l4g","_id":"ck0rxd4ug001tygkct00cpj5p"}],"Tag":[{"name":"proxy","_id":"ck0rxd4sr0008ygkcdg9haaak"},{"name":"web","_id":"ck0rxd4sx000cygkcwyw53l4g"},{"name":"blog-hexo","_id":"ck0rxd4t2000gygkctq8fyki9"},{"name":"git","_id":"ck0rxd4t6000kygkc7d6dqwly"},{"name":"前端面试题","_id":"ck0rxd4t9000pygkcmix990nv"},{"name":"node","_id":"ck0rxd4tb000tygkcl8jaijml"},{"name":"js","_id":"ck0rxd4te000xygkc3613r95z"},{"name":"vue","_id":"ck0rxd4tg000zygkcpuaedktn"},{"name":"es6, vue","_id":"ck0rxd4tu001cygkc38g5771h"},{"name":"css","_id":"ck0rxd4tx001hygkct1dvmfht"},{"name":"npm","_id":"ck0rxd4tz001kygkcr9grkru1"},{"name":"es6","_id":"ck0rxd4u8001oygkcrk7ait7z"}]}}