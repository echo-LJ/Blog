{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/10.png","path":"images/10.png","modified":0,"renderable":0},{"_id":"source/images/2.png","path":"images/2.png","modified":0,"renderable":0},{"_id":"source/images/1.png","path":"images/1.png","modified":0,"renderable":0},{"_id":"source/images/3.png","path":"images/3.png","modified":0,"renderable":0},{"_id":"source/images/4.png","path":"images/4.png","modified":0,"renderable":0},{"_id":"source/images/5.png","path":"images/5.png","modified":0,"renderable":0},{"_id":"source/images/6.png","path":"images/6.png","modified":0,"renderable":0},{"_id":"source/images/7.png","path":"images/7.png","modified":0,"renderable":0},{"_id":"source/images/button.png","path":"images/button.png","modified":0,"renderable":0},{"_id":"source/images/9.png","path":"images/9.png","modified":0,"renderable":0},{"_id":"source/images/vueDiff.jpg","path":"images/vueDiff.jpg","modified":0,"renderable":0},{"_id":"themes/Chic/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"source/images/20200506140521.png","path":"images/20200506140521.png","modified":0,"renderable":0},{"_id":"source/images/react-lifecycle.png","path":"images/react-lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/8.png","path":"images/8.png","modified":0,"renderable":0},{"_id":"themes/Chic/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/font.styl","path":"css/font.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/media.styl","path":"css/media.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/layout.styl","path":"css/layout.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/normalize.styl","path":"css/normalize.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/variable.styl","path":"css/variable.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/image/logo.jpg","path":"image/logo.jpg","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","path":"js/mathjax2.7.5.js","modified":0,"renderable":1},{"_id":"source/images/11.png","path":"images/11.png","modified":0,"renderable":0},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","path":"fonts/iconfont/demo.css","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","path":"fonts/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","path":"fonts/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","path":"fonts/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","path":"fonts/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","path":"fonts/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","path":"fonts/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","path":"fonts/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","path":"fonts/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","path":"fonts/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","path":"fonts/lanting/lanting.woff2","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","path":"fonts/lanting/lanting.woff","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","path":"fonts/lanting/lanting.eot","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","path":"fonts/lanting/lanting.TTF","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","path":"fonts/lanting/lanting.otf","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"71db0e897e892f60366c64183ff1275e82f7a555","modified":1578967803916},{"_id":"themes/Chic/ChangeLogs.md","hash":"82786c20871dd56447d872db9c16bd14b0cf01b8","modified":1607937483488},{"_id":"themes/Chic/LICENSE.md","hash":"9911bdafa287bd65a822f84cc12012980bd10247","modified":1607937483559},{"_id":"themes/Chic/README-CN.md","hash":"5e23397196625e7ceaa82eac4a4a77d523a69f05","modified":1607937483890},{"_id":"themes/Chic/README.md","hash":"5498be18c766225f1125afc2f85db6e1c2f824c3","modified":1607937483795},{"_id":"themes/Chic/_config.yml","hash":"9c8116a5664286097524daea04e677e4bdd9accb","modified":1607937483345},{"_id":"themes/Chic/package.json","hash":"8b4072879307eed0e74ae35390825c5e03b9229c","modified":1607937483708},{"_id":"source/_drafts/React.md","hash":"6db05315c4ac81ce2cba9cbde6db1cea882317fd","modified":1591084451241},{"_id":"source/_drafts/express.md","hash":"7ea80981e86b35d858b24dbc2ad4ec86ad38f7f0","modified":1591267091952},{"_id":"source/_drafts/html.md","hash":"04c9d1165f386fc1d64bb941862ab27849db4ce6","modified":1575463848219},{"_id":"source/_drafts/booknote.md","hash":"c121a9201d2bc7c54141b64c28b969916a72ee8e","modified":1577286275117},{"_id":"source/_drafts/jsTitle.md","hash":"79f1009bc621fcbe41d0da0d69feff7567778f1f","modified":1575463848220},{"_id":"source/_drafts/parseWebpack.md","hash":"113eece63cb49c790736e08f17e35d2c959b84b5","modified":1588930436882},{"_id":"source/_drafts/reactTitle.md","hash":"71da18615c05ccf25c8c05a4edae2d16fcb03a76","modified":1576319395946},{"_id":"source/_drafts/question.md","hash":"4ddcf46075e93904c4f026ef09344de71b464dd0","modified":1606357891762},{"_id":"source/_drafts/skeletons.md","hash":"bb32adb6900588e1496bae23894f7d0c5764899a","modified":1607934893993},{"_id":"source/_drafts/storybook.md","hash":"8cdae0c4d9695543e09817445d940439ca942e37","modified":1575463848220},{"_id":"source/_drafts/studyEnglish.md","hash":"1fae9684a028918bc99224c9e2d82e6fd493e527","modified":1577286275118},{"_id":"source/_drafts/test.md","hash":"630e991d68deebb7294f18003c8fae113e47060d","modified":1576319395947},{"_id":"source/_drafts/title.md","hash":"61cffacce77fac6e8ff47297374f5cb6bbbfff82","modified":1595843775037},{"_id":"source/_drafts/vueCli3-proxy.md","hash":"3eed8657675ac2cb6fe44b591bf6f9d14f38cad8","modified":1575463848220},{"_id":"source/_drafts/vueSourceCoding.md","hash":"ebbd16305fc382cf559367f4e78dcbba14d81c74","modified":1575463848221},{"_id":"source/_posts/ForwardReverseProxy.md","hash":"86a4b753b63d05088ce376337afecd14e0d6ff91","modified":1575463848221},{"_id":"source/_posts/Front-endEngineering.md","hash":"fe099f61932a4733d772852773776917dbbf2023","modified":1590562589033},{"_id":"source/_posts/JS-thread.md","hash":"9163aec37b0497603a0c1dc6d58cc490ef6ff045","modified":1575463848221},{"_id":"source/_posts/Mysql.md","hash":"a163aad755a8d4dec11e17936019e66f6f1080f6","modified":1607942101968},{"_id":"source/_posts/Node.md","hash":"597b995461b1693345daeeddbcd1a12e50fd96d1","modified":1607941827019},{"_id":"source/_posts/Node1.md","hash":"04bab269f58538dd4c4bd96001eabd5787a687de","modified":1607941576124},{"_id":"source/_posts/Node2.md","hash":"938576fa013c90b6f7dd91c92010c5983fe5136f","modified":1595841288346},{"_id":"source/_posts/ReactFragment.md","hash":"9d8a80d558533e46fdc97e8c8dff038c822127f2","modified":1607936648759},{"_id":"source/_posts/Ts1.md","hash":"384418a821818c8fe9a2704421a74195b0f91890","modified":1595841011116},{"_id":"source/_posts/asyncAwit.md","hash":"7dcfcefd6e835a27263d3f62148a1a1e0989b883","modified":1576319395947},{"_id":"source/_posts/axios.md","hash":"931ff186b7ec92592378e6dc87a9f15dc23d9863","modified":1589186562174},{"_id":"source/_posts/axios1.md","hash":"adf3be8818b211e48b487d955beaf6facd4ff670","modified":1607940257197},{"_id":"source/_posts/blogInit.md","hash":"1a930434c3c3fb33dcbad7047cfcdb71ee9e0a5e","modified":1595842020804},{"_id":"source/_posts/commitMessage.md","hash":"d7da46b654d5e0b4aaa31ec7651307647f083e27","modified":1605772611398},{"_id":"source/_posts/css.md","hash":"6e24c2dca6f89b3f7fb373ef7feaddf97c65737d","modified":1576319395947},{"_id":"source/_posts/cssTitle.md","hash":"cdf30a334016a155b4aafff436a9bb43e17d0737","modified":1576319395948},{"_id":"source/_posts/express.md","hash":"2e289d074ba2e0d1c8384445a1caf4b4f73b1fc0","modified":1591267107121},{"_id":"source/_posts/fixProject.md","hash":"b634eba33caad781e3863721ac340b0f7e588695","modified":1607937038637},{"_id":"source/_posts/hexoDeplayBug.md","hash":"6216104cb1d85ff20d410fe265ffe01442f62333","modified":1575463848223},{"_id":"source/_posts/js.md","hash":"c6b9f80c41dd41b0109d3f914d2045e43461765f","modified":1575463848223},{"_id":"source/_posts/message-comp.md","hash":"82645fcacdfabbc0f012165dc94016694efc7347","modified":1575463848224},{"_id":"source/_posts/moduleAlias.md","hash":"fde07db4052dca0fc763c9028446c4bd6a2c519b","modified":1607934660806},{"_id":"source/_posts/nodeBasics.md","hash":"cd5542835d0a8dd126e1895bf0b9d5b477a41a9b","modified":1575463848224},{"_id":"source/_posts/npmBuild.md","hash":"06d2cea5e07f8a15037344090d0a2d9c442f496a","modified":1578971301832},{"_id":"source/_posts/npmReactBuild.md","hash":"c7619193907c5c9d225c1a8cdd2dc098957628f6","modified":1607942542624},{"_id":"source/_posts/optimizaProject.md","hash":"951d853cc941667d9dbf74b62f863581cf10908a","modified":1588922483031},{"_id":"source/_posts/plop.md","hash":"fdbaa3e2a61da2133ccb20249188db27b3314ec3","modified":1607932074223},{"_id":"source/_posts/promise.md","hash":"c7b833c7949b90bd7cda2dd6ca6e5227cd2d60d0","modified":1575463848225},{"_id":"source/_posts/reactCom1.md","hash":"408d44944287908eaf3b8b74da5eaaf290edecc8","modified":1607940801309},{"_id":"source/_posts/reactCom2.md","hash":"10c21e8d2c8c1e818fa1d260e0a6f811bcf8dc08","modified":1607940623050},{"_id":"source/_posts/reactive.md","hash":"e39382f43bcf7d2cde23af78f5a9cb75b30b9762","modified":1588936168463},{"_id":"source/_posts/request.md","hash":"c1c3c88902b7b11639aa438a538974aea7e2ffff","modified":1575463848225},{"_id":"source/_posts/scss1.md","hash":"d291d25bc468c43ce36d03d1ad047fac767ed82f","modified":1607935831862},{"_id":"source/_posts/ssr.md","hash":"8ba7a104628aa5957a007bf18f17544bcb946630","modified":1589858043285},{"_id":"source/_posts/v8.md","hash":"d86eefaa218cdaba6f8373cef543e104d57a54ac","modified":1585557936972},{"_id":"source/_posts/virtualDom.md","hash":"6473ebc252bf31eeb48d899bed8e4d55b3c110eb","modified":1575463848225},{"_id":"source/_posts/vue.md","hash":"63349b8ba07fe44ddb6e141508125f887d50f190","modified":1575463848225},{"_id":"source/_posts/vueCliMd.md","hash":"680e1305241c995a544958679fa1bcacb83b4bd4","modified":1579072290392},{"_id":"source/_posts/vueI18.md","hash":"0f952dcf3a84725a8b5850c82d11796c81f5cc0a","modified":1607936794848},{"_id":"source/_posts/vueMessage.md","hash":"01b0332fa0981eb9f451ed39d818d20da85c64d0","modified":1607941195826},{"_id":"source/_posts/vueRouter.md","hash":"2b9a64adb6bd8567782b163f452e30ae34ddb29f","modified":1589358764383},{"_id":"source/_posts/vueSourceCoding.md","hash":"fabda008eb9b9f3f604bf44d17d38f811cdd00e0","modified":1595405594822},{"_id":"source/_posts/vueTest.md","hash":"1c5384493e161cb7b0751d473f1796d53e0a479c","modified":1588831729015},{"_id":"source/_posts/web.md","hash":"4af8fbe4b9e8d1f3a9996e7690a9013ad34bce4c","modified":1576319395948},{"_id":"source/_posts/vueTitle.md","hash":"3f0b66b28732e4ccbfa3789f27c0d74f006f336e","modified":1575463848226},{"_id":"source/category/index.md","hash":"ca207b6c9e08a5afdd5431f054300aa3ef7a5c60","modified":1607929918978},{"_id":"source/_posts/webTitle.md","hash":"9484a745f57e9948f0c80e95cc3a849cb2013d27","modified":1576319395949},{"_id":"source/images/10.png","hash":"46d39d6622c1b487fdede45e5e5c16daec45389b","modified":1575463848228},{"_id":"source/images/2.png","hash":"226b3d4003e8de1a6986227e5354ff802e2c6957","modified":1575463848230},{"_id":"source/images/1.png","hash":"bb42453a4634ba5efa39724a9e9534d83e628609","modified":1575463848227},{"_id":"source/images/3.png","hash":"487194a77790392b97b7d78d670ece0d51311949","modified":1575463848230},{"_id":"source/images/4.png","hash":"ca862f01f040bb3ea3b96f8336a873b84b6c0811","modified":1575463848230},{"_id":"source/images/5.png","hash":"a15c1fe1536f552659a3954f1e036afee53ed534","modified":1575463848231},{"_id":"source/images/6.png","hash":"82f98a98d4e70602f85533687894b5554df26176","modified":1575463848231},{"_id":"source/images/7.png","hash":"9ba5660654e8de4838df16bfdb314e9790bef507","modified":1575463848232},{"_id":"source/images/button.png","hash":"2bdbc439a3bab740d7340fe9adbca0a89f61ef92","modified":1578967108197},{"_id":"source/images/9.png","hash":"c7e0f6e6f6ff38dc0d45ad7872b66d43e399c2e7","modified":1575463848233},{"_id":"source/images/vueDiff.jpg","hash":"d9da1e7acbdace27c64834411ed947d76b07e468","modified":1575463848234},{"_id":"source/tag/index.md","hash":"8e0f136d2dca6bc1986387dd9d10667222f7c7b2","modified":1607929890731},{"_id":"themes/Chic/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1607927047285},{"_id":"themes/Chic/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1607927047286},{"_id":"themes/Chic/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1607927047286},{"_id":"themes/Chic/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1607927047286},{"_id":"themes/Chic/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1607927047286},{"_id":"themes/Chic/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1607927047286},{"_id":"themes/Chic/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1607927047286},{"_id":"themes/Chic/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1607927047287},{"_id":"themes/Chic/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1607927047287},{"_id":"themes/Chic/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1607927047287},{"_id":"themes/Chic/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1607927047287},{"_id":"themes/Chic/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1607927047287},{"_id":"themes/Chic/layout/archive.ejs","hash":"48cdf67b628eb6a1c24d484ed252f5b0e3f06ddf","modified":1607927047292},{"_id":"themes/Chic/layout/category.ejs","hash":"cae7483c92ff639f74f8efe67959f37c97350800","modified":1607927047292},{"_id":"themes/Chic/layout/index.ejs","hash":"b3344720176ad12dc88745cc5b31d497356ca4fa","modified":1607927047292},{"_id":"themes/Chic/layout/layout.ejs","hash":"f874320edabdefc204f9e17d119a16d16f26c363","modified":1607927047293},{"_id":"themes/Chic/layout/page.ejs","hash":"3179c527694a789760742e1923c7ac5f94b4997c","modified":1607927047293},{"_id":"themes/Chic/layout/post.ejs","hash":"a23f83d6c559ce88588472267468a54488d50e8e","modified":1607927047293},{"_id":"themes/Chic/layout/tag.ejs","hash":"53faf6f7c1b4b46e20bba5d2b3710a780879b3e8","modified":1607937911415},{"_id":"themes/Chic/scripts/imageTag.js","hash":"4b69804c1e4bf638eda7022499c440ce24e28587","modified":1607927047293},{"_id":"themes/Chic/source/.DS_Store","hash":"d941495aa9afd7098782e5cb6608ebbc0298c5ad","modified":1607927245713},{"_id":"themes/Chic/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1607927047315},{"_id":"source/images/20200506140521.png","hash":"235ee474c14c561f938c3216f3af117aecfaa4e9","modified":1588831729016},{"_id":"source/images/react-lifecycle.png","hash":"6191aacdeefb4150e792b47420e71cba10e828a5","modified":1575463848234},{"_id":"source/images/8.png","hash":"39378833bdc6009f6f7e9ebd0ad8cc572adf9e28","modified":1575463848233},{"_id":"themes/Chic/layout/_page/category.ejs","hash":"e8464e11d08a711fe815ea1cd101aa41d7310ebf","modified":1607927047288},{"_id":"themes/Chic/layout/_page/archive.ejs","hash":"464549286c92ea0d6cb057c6936e0f1a5d1c1dd2","modified":1607927047288},{"_id":"themes/Chic/layout/_page/page.ejs","hash":"1d875d59cf4d6b681cc8cf755f19b5355e5d1144","modified":1607927047288},{"_id":"themes/Chic/layout/_page/profile.ejs","hash":"c6d3cf2ef90e5d0fd580e7cff1db47c28fb36037","modified":1607927047289},{"_id":"themes/Chic/layout/_page/post.ejs","hash":"6eb9cd3ee904e99ff78509298ae31a29fdbf49cf","modified":1607927047289},{"_id":"themes/Chic/layout/_page/tag.ejs","hash":"0c20ff00532103f9a59639ca9956fc0bce4aabc2","modified":1607927047290},{"_id":"themes/Chic/layout/_partial/footer.ejs","hash":"e1c332fab0d6cd713e36d46ccc14d0991067ba40","modified":1607927047290},{"_id":"themes/Chic/layout/_partial/header.ejs","hash":"8f1e5272a4de96a3ed94de1db988b05b34515463","modified":1607927047291},{"_id":"themes/Chic/layout/_partial/head.ejs","hash":"8c8a2d95e0858cf0be9bf60d0ddf26876e1d9d35","modified":1607927047291},{"_id":"themes/Chic/layout/_partial/paginator.ejs","hash":"ab59d5db77f2aa64dfe03656e72fd49702c62e23","modified":1607927047291},{"_id":"themes/Chic/layout/_partial/toc.ejs","hash":"10bb9c303c948f5615149981cd85cbbd3e7c781c","modified":1607927047291},{"_id":"themes/Chic/layout/_plugins/mathjax.ejs","hash":"53f088fe44d51c4d9fb61aeac4c23b3cfcc19762","modified":1607927047292},{"_id":"themes/Chic/source/css/base.styl","hash":"7ea2db2c139a719bb7d3f3c5e182dd0e0d59e098","modified":1607927047314},{"_id":"themes/Chic/source/css/custom.styl","hash":"bf8dee1a094b104d87a53b43f6daa7ba43b67574","modified":1607927047314},{"_id":"themes/Chic/source/css/font.styl","hash":"8c1da30e223c0a3d7ef452abc9f0e4cc71dbc140","modified":1607927047314},{"_id":"themes/Chic/source/css/media.styl","hash":"f96c0dbb9653667906a6dc271f637543ac5c7212","modified":1607927047314},{"_id":"themes/Chic/source/css/layout.styl","hash":"9942d05bb2c55cf035d4bf9af325e1e81766a510","modified":1607927047314},{"_id":"themes/Chic/source/css/normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1607927047315},{"_id":"themes/Chic/source/css/style.styl","hash":"a13f2c38070a89b06a2ede599f5ce5fd160e11c9","modified":1607927047315},{"_id":"themes/Chic/source/css/variable.styl","hash":"906faa95457eba70118a0705e13b8f43409e502f","modified":1607927047315},{"_id":"themes/Chic/source/image/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1607927251835},{"_id":"themes/Chic/source/image/logo.jpg","hash":"aa1c5fda78132ee8891c5b62734553a5813c2463","modified":1607916442409},{"_id":"themes/Chic/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1607927047414},{"_id":"themes/Chic/source/js/script.js","hash":"93694e4e16893f83611daa5ba3723b14ecc80abb","modified":1607927047414},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1607927047414},{"_id":"source/images/11.png","hash":"777d5895b1775c05c110b095c9affc90dace9014","modified":1575463848229},{"_id":"themes/Chic/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1607927047294},{"_id":"themes/Chic/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1607927047294},{"_id":"themes/Chic/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1607927047294},{"_id":"themes/Chic/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1607927047294},{"_id":"themes/Chic/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1607927047295},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1607927047295},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1607927047295},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1607927047295},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1607927047295},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1607927047296},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1607927047296},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1607927047296},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1607927047296},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1607927047297},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1607927047297},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1607927047297},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1607927047297},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1607927047297},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1607927047298},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1607927047298},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1607927047298},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1607927047298},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1607927047298},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1607927047299},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1607927047299},{"_id":"themes/Chic/source/css/_highlight/brown-paper.styl","hash":"329b85ae9130a5587a6fb1c6f80396f9cca5ddc1","modified":1607927047299},{"_id":"themes/Chic/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1607927047300},{"_id":"themes/Chic/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1607927047300},{"_id":"themes/Chic/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1607927047300},{"_id":"themes/Chic/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1607927047301},{"_id":"themes/Chic/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1607927047301},{"_id":"themes/Chic/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1607927047301},{"_id":"themes/Chic/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1607927047301},{"_id":"themes/Chic/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1607927047301},{"_id":"themes/Chic/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1607927047302},{"_id":"themes/Chic/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1607927047302},{"_id":"themes/Chic/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1607927047302},{"_id":"themes/Chic/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1607927047302},{"_id":"themes/Chic/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1607927047303},{"_id":"themes/Chic/source/css/_highlight/highlightjs.styl","hash":"65b5981dc3c57cedd1cb668c0e377230987e08d1","modified":1607927047303},{"_id":"themes/Chic/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1607927047303},{"_id":"themes/Chic/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1607927047303},{"_id":"themes/Chic/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1607927047303},{"_id":"themes/Chic/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1607927047304},{"_id":"themes/Chic/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1607927047304},{"_id":"themes/Chic/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1607927047304},{"_id":"themes/Chic/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1607927047305},{"_id":"themes/Chic/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1607927047305},{"_id":"themes/Chic/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1607927047305},{"_id":"themes/Chic/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1607927047305},{"_id":"themes/Chic/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1607927047305},{"_id":"themes/Chic/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1607927047305},{"_id":"themes/Chic/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1607927047306},{"_id":"themes/Chic/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1607927047306},{"_id":"themes/Chic/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1607927047306},{"_id":"themes/Chic/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1607927047306},{"_id":"themes/Chic/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1607927047306},{"_id":"themes/Chic/source/css/_highlight/pojoaque.styl","hash":"2601b4285803a7cea5ccded8d624ca95f80e3d88","modified":1607927047307},{"_id":"themes/Chic/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1607927047307},{"_id":"themes/Chic/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1607927047307},{"_id":"themes/Chic/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1607927047307},{"_id":"themes/Chic/source/css/_highlight/school-book.styl","hash":"beabbbcc7930f8de19159381a01c0ba41dc2291f","modified":1607927047307},{"_id":"themes/Chic/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1607927047308},{"_id":"themes/Chic/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1607927047308},{"_id":"themes/Chic/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1607927047308},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1607927047308},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1607927047309},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1607927047309},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1607927047309},{"_id":"themes/Chic/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1607927047309},{"_id":"themes/Chic/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1607927047309},{"_id":"themes/Chic/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1607927047310},{"_id":"themes/Chic/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1607927047310},{"_id":"themes/Chic/source/css/_page/archive.styl","hash":"71ea842f068b29b4418dd09450db09d27dcf0947","modified":1607927047312},{"_id":"themes/Chic/source/css/_page/category.styl","hash":"cead361269616b7a6ddec3090d9fa34c3c6ac722","modified":1607927047312},{"_id":"themes/Chic/source/css/_page/page.styl","hash":"34e33b52d2e046aa2f5494e81ff4ac2d5ca78058","modified":1607927047312},{"_id":"themes/Chic/source/css/_page/profile.styl","hash":"5ef6d5a06132f26b7aa01b2fbf4bbfb8ee862b7b","modified":1607927047313},{"_id":"themes/Chic/source/css/_page/tag.styl","hash":"55b220cc58011876fb3a470cd1fde8ed87c93079","modified":1607927047313},{"_id":"themes/Chic/source/css/_partial/footer.styl","hash":"4f58e607eaa59cda3b5a9fdb3404ffb75c4d1a03","modified":1607927047313},{"_id":"themes/Chic/source/css/_partial/header.styl","hash":"be70b4ab3bcc977f1055664899742804c716929d","modified":1607927047313},{"_id":"themes/Chic/source/css/_lib/looper.css","hash":"863144dc9af7c1e181670515bc85eaf768f4e287","modified":1607927047310},{"_id":"themes/Chic/source/css/_partial/paginator.styl","hash":"b4f4a5180c4cbc70d186792b8a1fd0f5855bd86a","modified":1607927047313},{"_id":"themes/Chic/source/css/_lib/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1607927047310},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1607927047316},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1607927047316},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1607927047316},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1607927047317},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1607927047317},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","hash":"eae94b803d34035008842855d0bead92d2035281","modified":1607927047317},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1607927047318},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1607927047318},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1607927047318},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1607927047318},{"_id":"themes/Chic/source/css/_page/_post/post_code.styl","hash":"06c3a3524ffd4b27e03e79489001997ea5d727d3","modified":1607927047311},{"_id":"themes/Chic/source/css/_page/_post/post_content.styl","hash":"5e3d63077549d8e2e5ff8c452e809760f5a99c17","modified":1607927047311},{"_id":"themes/Chic/source/css/_page/_post/post_copyright.styl","hash":"64fd9f07ed45f035057d46740af0db70218714aa","modified":1607927047311},{"_id":"themes/Chic/source/css/_page/_post/post_header.styl","hash":"d37b032bc5edca92c84bf62070a28fa40939df55","modified":1607927047311},{"_id":"themes/Chic/source/css/_page/_post/post_nav.styl","hash":"03accaba13c995cbe65a05a88549ff74e992eb3f","modified":1607927047312},{"_id":"themes/Chic/source/css/_page/_post/post_tags.styl","hash":"2ff93677aa4d81da83c659b4dd4e3cb482d9ce7d","modified":1607927047312},{"_id":"themes/Chic/source/css/_page/_post/post_toc.styl","hash":"15e1ec7af93f41184f986aba21991a79923b0a0e","modified":1607927047312},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1607927047412},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1607927047408},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1607927047366},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1607927047344},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1607927047404},{"_id":"public/category/index.html","hash":"ca4717c6b4f57d88458f815fdb93e92f19a9cb4e","modified":1607941167638},{"_id":"public/tag/index.html","hash":"768f7c5a161ce6a1271de6ebb53d7ed17590f912","modified":1607942478330},{"_id":"public/2020/12/14/moduleAlias/index.html","hash":"0a4973a5274f9271fc6b55a794bf020125ac97ed","modified":1607941168244},{"_id":"public/2020/12/14/plop/index.html","hash":"3307e1042b4d1071a3a6888e92bc479236ba7319","modified":1607941168244},{"_id":"public/2020/11/20/scss1/index.html","hash":"9cfd3c05ad96ff5252d7ada9fe0ec292a190666b","modified":1607941168252},{"_id":"public/2020/07/27/ReactFragment/index.html","hash":"c8b0958fd2d3a30c6b767c2ad8709fca4bc1f8cc","modified":1607941168252},{"_id":"public/2020/07/27/Mysql/index.html","hash":"1c5320ea02a08b8e06a0e49ad1d03e688d849c9a","modified":1607942122154},{"_id":"public/2020/03/30/v8/index.html","hash":"5baf2d557817466846396682bf59906e5fed1297","modified":1607948979244},{"_id":"public/2020/01/15/vueCliMd/index.html","hash":"34e99fd04dbed631c33bec581ae478689ad16d43","modified":1607941168252},{"_id":"public/2019/09/20/express/index.html","hash":"aa0270d736d42cb1ace5ad2dcbaef4403aa89ee4","modified":1607941168252},{"_id":"public/2019/09/20/ForwardReverseProxy/index.html","hash":"7d4b495f7d2acb8ab04ad2a3ca79c0eafe1ba6e9","modified":1607941168252},{"_id":"public/2019/09/20/virtualDom/index.html","hash":"c1d4b96d5ea97400101b8801e3767be85d235ae4","modified":1607941168252},{"_id":"public/2020/07/27/vueI18/index.html","hash":"b459820890931b0984831eb8617c8822b17bb1e4","modified":1607941168253},{"_id":"public/2020/07/27/fixProject/index.html","hash":"7c6e69ea0ef36e00f4f4ae9ae1b4ace565c44d76","modified":1607941168253},{"_id":"public/2020/07/27/axios1/index.html","hash":"29a7e03fe16782170e1520f36df185e9941471bf","modified":1607941168253},{"_id":"public/2020/07/27/reactCom2/index.html","hash":"e5fcc6c99dd2690fe8a52d3bdcdb6a95c79d8524","modified":1607941168253},{"_id":"public/2020/07/27/reactCom1/index.html","hash":"28b9fe60869c6f87de39c0a1b3fe6debf8eba75f","modified":1607941168253},{"_id":"public/2020/07/27/vueMessage/index.html","hash":"71167959778e9ebe88899791b8972f0656a29bd7","modified":1607941227874},{"_id":"public/2020/07/27/Node1/index.html","hash":"f26c37e6073d936e89e0a94937f99d0272ddf400","modified":1607941541832},{"_id":"public/2020/07/27/Node/index.html","hash":"c42fa307419053d297bf1ca5abbd6e9c31c7250c","modified":1607941831396},{"_id":"public/2020/06/08/npmReactBuild/index.html","hash":"dd4a2a9a0b81a15341575317c4c9f1c468d164d3","modified":1607948979202},{"_id":"public/2020/05/27/Front-endEngineering/index.html","hash":"d75ed3f714c858baa64e90f240946346b66eae2e","modified":1607941168254},{"_id":"public/2020/05/19/ssr/index.html","hash":"06c08997560570acbceb56eb9ea44c93759b8d96","modified":1607941168254},{"_id":"public/2020/05/13/vueRouter/index.html","hash":"aad4e503c993ee7606b266ac64634333b4bc4b3d","modified":1607941168254},{"_id":"public/2020/05/08/optimizaProject/index.html","hash":"748bcbabc86248cc176c274a2979ccb4f9fc2876","modified":1607941168254},{"_id":"public/2020/05/06/vueTest/index.html","hash":"e073503703714cf1af5203cd82aa37da5de5e1ca","modified":1607941168254},{"_id":"public/2020/03/30/reactive/index.html","hash":"9e814b4c6219020f56ce73a91ba90913828129b3","modified":1607941168254},{"_id":"public/2019/11/04/asyncAwit/index.html","hash":"fcff013179924eb540f1d49c4c9cf626e5300251","modified":1607948979245},{"_id":"public/2019/09/20/commitMessage/index.html","hash":"122f5d735f89e5cb2c8497da201ceed3b0b52df2","modified":1607941168254},{"_id":"public/2019/09/19/web/index.html","hash":"a2a68d67198d9fb59d385eb4fdc9e07267281c32","modified":1607941168261},{"_id":"public/2019/09/19/vue/index.html","hash":"44ebc970d0faf04311630fb7817769820cb1a097","modified":1607941168261},{"_id":"public/2019/09/19/css/index.html","hash":"14fb4b5e57bba9d2a761d263f03e22482f750898","modified":1607941168262},{"_id":"public/2019/09/19/js/index.html","hash":"c1daca8dc253c69e2f9ef5124472bc30df7fc9ed","modified":1607941168262},{"_id":"public/2019/07/24/hexoDeplayBug/index.html","hash":"6e9e2bbcae2be9770b9ae8ee1c2b06076f079471","modified":1607941168262},{"_id":"public/2019/07/24/blogInit/index.html","hash":"8a0139e56fe256524741fe5c3b29cf68f5989ee7","modified":1607941168262},{"_id":"public/archives/index.html","hash":"bd2f7d5f607bef39eb2d4f1d827256d37dbf1dfc","modified":1607941168262},{"_id":"public/archives/page/2/index.html","hash":"c773037b6476e523e57ce4fc58b2954de25e8d28","modified":1607941168262},{"_id":"public/archives/page/3/index.html","hash":"2eb5066567a921e36120a879df73b17823aa467d","modified":1607941168262},{"_id":"public/archives/page/4/index.html","hash":"4ed0f0ca0857d17ded092d4094193a031c2677e9","modified":1607941168262},{"_id":"public/archives/page/5/index.html","hash":"5c434d1d8a6b5dd2d4dce5ab3f62e31c98deea91","modified":1607941168263},{"_id":"public/archives/2019/index.html","hash":"3b9f5a95f826f8f4117f91b2bd96fc89ebf30069","modified":1607941168263},{"_id":"public/archives/2019/page/2/index.html","hash":"a99f9a0892e787a6ca78be0a510235f2ed627bdb","modified":1607941168263},{"_id":"public/archives/2019/page/3/index.html","hash":"e803a00e08e205c0dff478969fcdda88f577b10f","modified":1607941168263},{"_id":"public/archives/2019/07/index.html","hash":"12fd1146a6232229377401972ee0ef40e55d9033","modified":1607941168263},{"_id":"public/archives/2019/08/index.html","hash":"379c43750963843e7581957f0a4a295418f21270","modified":1607941168263},{"_id":"public/2019/09/03/vueTitle/index.html","hash":"bfe1b430a6f063319bb3df177025a61031809d80","modified":1607941168263},{"_id":"public/archives/2019/09/index.html","hash":"001c25d27b958ad7f10226c9913aa40cabc2ae9a","modified":1607941168263},{"_id":"public/archives/2019/11/index.html","hash":"2fc067fbefe934227e61086462f28be3c12b01df","modified":1607948979245},{"_id":"public/archives/2020/index.html","hash":"966e75542e8619423c034c91ad72074f8945cd55","modified":1607941168263},{"_id":"public/archives/2019/09/page/2/index.html","hash":"9999c8091a5a2cf83271fe6f1731fc3de68fe927","modified":1607941168263},{"_id":"public/archives/2020/page/2/index.html","hash":"bc7cd4b268aa376e8c62e40c14cedc477470aaff","modified":1607941168264},{"_id":"public/archives/2020/page/3/index.html","hash":"42eb2d99bd17a53efb569f3b08eb3e32f3d6479c","modified":1607941168264},{"_id":"public/archives/2020/01/index.html","hash":"0dae4d8af407c8bac1d2e599cd1b2e28e8ff40ab","modified":1607941168264},{"_id":"public/archives/2020/03/index.html","hash":"ad0eca5c1340ed5048dde3f0ca2d83f585b3a04f","modified":1607941168264},{"_id":"public/archives/2020/05/index.html","hash":"49fafa4c4a43950cc0dd0dd934e822b7dc6d7868","modified":1607941168264},{"_id":"public/archives/2020/06/index.html","hash":"4199f8e334ea570bcef11a614c5b6404655c02de","modified":1607941168265},{"_id":"public/archives/2020/07/index.html","hash":"2ab1ac5acb088df2af0bc221124ef4f122669c2c","modified":1607941168265},{"_id":"public/archives/2020/11/index.html","hash":"6b50dcc632a6b15f3b61c896c6bf53699e94f414","modified":1607941168265},{"_id":"public/archives/2020/12/index.html","hash":"2a477a7dfc52c5596e1681abd59f0a67aafdba36","modified":1607941168265},{"_id":"public/index.html","hash":"c467fe5831dbaf14ea83e6b7873658aff5f17835","modified":1607941168265},{"_id":"public/page/2/index.html","hash":"c467fe5831dbaf14ea83e6b7873658aff5f17835","modified":1607941168265},{"_id":"public/page/3/index.html","hash":"c467fe5831dbaf14ea83e6b7873658aff5f17835","modified":1607941168265},{"_id":"public/page/4/index.html","hash":"c467fe5831dbaf14ea83e6b7873658aff5f17835","modified":1607941168265},{"_id":"public/page/5/index.html","hash":"c467fe5831dbaf14ea83e6b7873658aff5f17835","modified":1607941168266},{"_id":"public/tags/node/index.html","hash":"31ced24d051403e6c5aee354c4a76fba0051bd12","modified":1607941168266},{"_id":"public/tags/前端面试题/index.html","hash":"9a69e314a4d82f47812b28d4c463c661c900c6c5","modified":1607941168267},{"_id":"public/tags/web/index.html","hash":"69aa094156c1ef7ab60ad82a8a0fb3e2c1acd3e3","modified":1607941168267},{"_id":"public/tags/js/index.html","hash":"18ffd1a8955c4c5e22c1be76d82d88ea44b7649a","modified":1607941168267},{"_id":"public/tags/React/index.html","hash":"8d50595844e9364adb2e10b718248c0cc4b9d93a","modified":1607942478330},{"_id":"public/tags/es6-vue/index.html","hash":"6387153b390f15541d19903062715a81fb252020","modified":1607941168267},{"_id":"public/tags/Axios/index.html","hash":"e4a860fb57e409a1553ed6d073a1b198f467439a","modified":1607941168267},{"_id":"public/tags/blog-hexo/index.html","hash":"e135986467a40d7373ff999111c44c1bfdc96d5f","modified":1607941168267},{"_id":"public/tags/git/index.html","hash":"5801bcf59aa5ecf00b4a8b52b5333eb11b00ad6e","modified":1607941168267},{"_id":"public/tags/css/index.html","hash":"a2a9f8a6b0b0f5e8a086449e242b12316edd0d0f","modified":1607941168267},{"_id":"public/tags/前端工程化/index.html","hash":"88c84e9bb45f7ccc35dbde49557ee58e1af44d12","modified":1607941168267},{"_id":"public/tags/vue/index.html","hash":"ce060d3b216dc7893ee9a3e09f8bf45b9e3e1677","modified":1607941168267},{"_id":"public/tags/npm/index.html","hash":"9bd90b00ed1d2a66cf0963bd26841d3122c0eb03","modified":1607941168267},{"_id":"public/tags/npm-react-typescript/index.html","hash":"898bc82f4412f835954b4e0e4611a7ba1a1a3360","modified":1607941168268},{"_id":"public/tags/es6/index.html","hash":"820f0b3a0fb864ab22e258760f0514df6baa1b03","modified":1607941168268},{"_id":"public/tags/vue-vueRouter/index.html","hash":"443558f1e42b1bd7869cfb691e96c7ecf8bf11f4","modified":1607948979245},{"_id":"public/tags/vue-test/index.html","hash":"3b2fd26728cbcfddc9db887e1a00833ddb7b0d85","modified":1607948979245},{"_id":"public/tags/Vue/index.html","hash":"9228fe277078ce9df1cd95e9684f656223a0c60d","modified":1607941227874},{"_id":"public/2019/09/19/cssTitle/index.html","hash":"1d060e794a5232b14d69066b197b718b44809680","modified":1607941168268},{"_id":"public/2019/09/03/vueSourceCoding/index.html","hash":"931100780ca68befe8896c0679331fce8ae5823b","modified":1607941168270},{"_id":"public/2019/09/02/webTitle/index.html","hash":"51419fee2be4011e5a34e775f642065c6c0ff101","modified":1607941168271},{"_id":"public/2019/08/26/promise/index.html","hash":"da43d469509c7aedf8e2ccddd771af2467d4c61a","modified":1607941168271},{"_id":"public/2019/08/21/JS-thread/index.html","hash":"25d9d853e717711a98b6eca2dc98ddf90c76730d","modified":1607941168271},{"_id":"public/2019/08/19/request/index.html","hash":"bbaa907b43c1be75674a4fc8bd8096fc4e750d21","modified":1607941168271},{"_id":"public/2019/08/15/message-comp/index.html","hash":"c08254758e19516e6e46b583e8e33076906968f3","modified":1607941168271},{"_id":"public/2019/08/14/nodeBasics/index.html","hash":"6e77169f7ac76deb1cccaa6102502ac8c2afa44d","modified":1607941168271},{"_id":"public/2019/07/26/npmBuild/index.html","hash":"06917220fa8406044a2333502bf469bed1786804","modified":1607941168271},{"_id":"public/2019/09/20/axios/index.html","hash":"92c7e27345ea4d4646ed89014c2b4c34ee3130d8","modified":1607941168271},{"_id":"public/tags/Node/index.html","hash":"552750e6bc25cb2a74bb8781be5ca593d5c20144","modified":1607941831403},{"_id":"public/tags/Software/index.html","hash":"99d8d610c938a13ea0b2ed0d1ac1cd7cf6f9c96d","modified":1607942122157},{"_id":"source/_drafts/asyncAwit.md","hash":"7dcfcefd6e835a27263d3f62148a1a1e0989b883","modified":1607948676975},{"_id":"source/_drafts/v8.md","hash":"d86eefaa218cdaba6f8373cef543e104d57a54ac","modified":1607948470114}],"Category":[],"Data":[],"Page":[{"title":"category","layout":"category","_content":"","source":"category/index.md","raw":"---\ntitle: category\nlayout: category\n---\n","date":"2020-12-14T07:11:58.978Z","updated":"2020-12-14T07:11:58.978Z","path":"category/index.html","comments":1,"_id":"ckioehjoz000178p38sgpdcem","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tag","layout":"tag","_content":"","source":"tag/index.md","raw":"---\ntitle: Tag\nlayout: tag\n---\n","date":"2020-12-14T07:11:30.731Z","updated":"2020-12-14T07:11:30.731Z","path":"tag/index.html","comments":1,"_id":"ckioehjpm000378p3uoq1a00f","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"React","_content":"\n### 组件的生命周期\n\n\n#### 组件在初始化时会触发5个钩子函数：\n###### 1、getDefaultProps()\n设置默认的props，也可以用dufaultProps设置组件的默认属性\n###### 2、getInitialState()\n在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。\n###### 3、componentWillMount()\n组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。\n###### 4、render()\nreact最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。\n###### 5、componentDidMount()\n组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。\n\n#### 组件在初始化时会触发5个钩子函数：\n\n###### 1、componentWillReceivePorps(nextProps)\n组件初始化时不调用，组件接受新的props时调用。\n###### 2、shouldComponentUpdate(nextProps, nextState)\nreact性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个`props`和`state`是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用`this.forceUpdate`会跳过此步骤。\n###### 3、componentWillUpdate(nextProps, nextState)\n组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state\n！！修改state不能用this.setState(),该方法会触发另一个componentWillUpdate，会陷入死循环。\n（github issue查询建议使用nextState.test = 1这种写法，没有验证）\n###### 4、render()\n###### 5、componentDidUpdate()\n组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。\n###### 6、componentWillUnmount()\n组件将要卸载时调用，一些事件监听和定时器需要在此时清除。\n### React-Router路由\n### 组件之间的通信\n\n\n* 父子之间通信\n父子级关系，父级可以将一个`回调函数`当作`属性`传递给子级，子级可以直接调用函数从而和父级通信。\n* 组件层级嵌套到比较深\n使用上下文`getChildContext`来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过`this.context`直接访问。\n* 兄弟关系的组件之间\n1. 只能利用同一层的上级作为中转站.\n2. 兄弟组件都是最高层的组件, 利用redux\n\n* 组件之间的信息还可以通过全局事件来传递.\n不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。\n\n### Redux\n* 作用\n\n进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信\n\n* 实现逻辑\n\nreact-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。\n\n值得注意的是`connect，Provider，mapStateToProps,mapDispatchToProps`是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起\n\n* redux主要由三部分组成：store，reducer，action\n\n#### store是一个对象，它有四个主要的方法：\n###### 1、dispatch:\n\n用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。\n###### 2、subscribe：\n监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。 \n```\nlet unsubscribe = store.subscribe(() => {console.log('state发生了变化')})\n```\n\n###### 3、getState：\n获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。\ngetState主要在两个地方需要用到:\n* 一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的.\n\n* 二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。\n###### 4、replaceReducer:\n替换reducer，改变state修改的逻辑。\n\nstore可以通过`createStore()`方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。\n\n#### action:\n\naction是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。\n\n#### reducer:\n\nreducer是一个函数，它接受一个`state`和一个`action`，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。\n\n```\nconst reducer = combineReducers({\n     a: doSomethingWithA,\n     b: processB,\n     c: c\n})\n```\n#### combineReducers:\n\n其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。\n\n> 接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。\n\n> redux的state和react的state两者完全没有关系，除了名字一样。\n\n* `使用流程`\n\n如果只使用redux，那么流程是这样的：\n\ncomponent --> dispatch(action) --> reducer --> subscribe --> getState --> component\n\n用了react-redux之后流程是这样的：\n\ncomponent --> actionCreator(data) --> reducer --> component\n\nstore的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。\n\n\n参考链接：https://github.com/bailicangdu/react-pxq\n\n\n# React\n\n#### 1. 什么时候使用状态管理器？\n参考链接：https://baijiahao.baidu.com/s?id=1590300061305698080&wfr=spider&for=pc\n\n#### 2. render函数中return如果没有使用()会有什么问题？\n在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：\n* Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n解决办法：为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。\n\n#### 3. componentWillUpdate可以直接修改state的值吗？\n`本题参考上面的生命周期函数componentWillUpdate的解释`\nreact 组件在每次需要重新渲染时候都会调用 componentWillUpdate(),\n\n例如，我们调用 this.setState()时候\n\n在这个函数中我们之所以不调用 this.setState()是因为该方法会触发另一个 componentWillUpdate(),如果我们 componentWillUpdate()中触发状态更改,我们将以无限循环.\n\n！！（github issue查询建议使用nextState.test = 1这种写法，没有验证）\n\n#### 4. 什么渲染劫持？\n什么是渲染劫持：渲染劫持的概念是控制组件从另一个组件输出的能力，当然这个概念一般和react中的高阶组件（HOC）放在一起解释比较有明了。\n\n高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。\n\n实际上，在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可以增强由原组件render函数产生的React元素。\n\n实际的操作中 通过 操作 state、props 都可以实现渲染劫\n\n\n#### 4. 对 React Context 的理解以及应用？\n在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。\n使用例子：比如react-redux的<Provider />，就是通过Context提供一个全局态的store，拖拽组件react-dnd，通过Context在组件中分发DOM的Drag和Drop事件，路由组件react-router通过Context管理路由状态\n* 使用Context，可以跨越组件进行数据传递。\n* 如何使用Context\n参考链接：https://www.jianshu.com/p/eba2b76b290b\n\n#### 5. 为什么 React 并不推荐我们优先考虑使用 Context？\n\nContext 目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在 app 中使用 context。\n尽管不建议在 app 中使用 context，但是独有组件而言，由于影响范围小于 app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用 context\n对于组件之间的数据通信或者状态管理，有效使用 props 或者 state 解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑 context。\n\ncontext 的更新需要通过 setState()触发，但是这并不是很可靠的，Context 支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回 false 那么不能保证 Context 的更新一定可以使用 Context 的子组件，因此，Context 的可靠性需要关注。\n\n#### 6. 说说你对windowing的了解-react-window和react-virtualized？\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\n`react-window`和`react-virtualized`都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据.\n\n#### 7. 举例说明 React 的插槽有哪些运用场景？\n对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的\n\n#### 8. 你有用过 React 的插槽(Portals)吗？怎么用？\n* 首先简单的介绍下 react 中的插槽（Portals），通过 ReactDOM.createPortal(child, container)创建，是 ReactDOM 提供的接口，可以实现将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。\n* 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。\n\n* 对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的。\n#### 9. React 的严格模式有什么用处？\n\nreact 的 strictMode 是一个突出显示应用程序中潜在问题的工具，与 Fragment 一样，strictMode 不会渲染任何的可见 UI，它为其后代元素触发额外的检查和警告。\n\n注意：严格模式仅在开发模式下运行，它们不会影响生产构建\n\n可以为程序的任何部分使用严格模式\n\n```\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n```\n在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n\nStrictMode 目前有助于：\n\n* 识别不安全的生命周期\n* 关于使用过时字符串 ref API 的警告\n* 关于使用废弃的 findDOMNode 方法的警告\n* 检测意外的副作用\n* 检测过时的 context API\n\n#### 10.React如何进行代码拆分？拆分的原则是什么？\n\n个人认为react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在react项目中：\n1. 在api层面单独封装，对外暴露http请求的结果。\n2. 数据层面使用react-redux， 异步中间件使用的是react-thunk封装处理异步请求，和业务层逻辑处理。\n3. 视图层，尽量使用redux层传过来的数据，修改逻辑，也是重新触发action更改props.\n4. 静态类型的资源单独放置。\n5. 公共组件、高阶组件、插件单独放置。\n6. 工具类文件单独放置。\n\n#### 10.React组件的构造函数有什么作用？\n\n在react的新的写法中，每一个组件都是一个类，这个很符合es6的语法规范，在es6中想要创建一个对象，就要调用相应的构造函数，react的组件渲染有两种情况，第一种情况是第一次渲染，第二种情况是状态更新时候重新渲染构造函数，在组件的初次渲染时只会运行一次。\n\n构造函数里面进行的操作一般会有三种用途：\n\n* 1. 指定this -->super(props)\n* 2. 设置初始化的状态 --> this.setState({});\n* 3. 为组件上的构造函数绑定this\n\n#### 11.为什么说react中的props是只读的？\n\nreact官方文档中说到：组件无论是使用函数声明还是通过class声明，都不能修改自身的props,props作为组件对外通信的一个接口，为了保证组件像纯函数一样没有响应的副作用，所有的组件都必须像纯函数一样保护他们的props不被修改。\n\n#### 12.`super()`和`super(props)`有什么区别？\n\nreact中的class是基于es6的规范实现的，继承是使用extends关键字实现继承的，字类必须在constructor()中调用super()方法否则新建实力就会报错；\n报错的原因就是：子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super()子类就得不到this对象。\n如果你使用了constructor就必须使用super()，这个是用来初始化this的，可以绑定事件到this上，如果想要在constructor中使用this.props,就必须给super添加参数super(props)；\n注意：无论有没有constructor，在render中的this.props都是可以使用的，这是react自动附带的，如果没有用到constructor是可以不写的，react会默认添加一个空的constroctor.\n\n\n#### 13.怎么动态到导入组件？\n\n* 使用import和async/await实现的异步组件\n* react.lazy\n* 开源库react-loadable/react-lazyload库\n* babel动态导入\n\n\n#### 14.怎样使用Hooks获取服务端数据？\n参考链接： https://zhuanlan.zhihu.com/p/57214270\n\n#### 15.使用Hooks要遵守哪些原则？\n* 只在最顶层使用 Hook\n* 只在 React 函数中调用 Hook\nhttps://react.docschina.org/docs/hooks-rules.html\n\n#### render方法的原理你有了解吗？它返回的数据类型是什么？\n#### 在React项目中你用过哪些动画的包?\n\n#### useEffect和useLayoutEffect的区别?\n在 React hook 中，useEffect 用来取代 componentDidMount 和 componentDidUpdate。主要作用是当页面渲染后，进行一些副作用操作（比如访问 DOM，请求数据）。\n* useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。\n* useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 说说你对React的渲染原理的理解？\n持\n\n#### 4. React Intl是什么原理？\nreact-intl 实现多语言项目国际化处理\n\n\n\n\n","source":"_drafts/React.md","raw":"---\ntitle: React\ntags:\n---\n\n### 组件的生命周期\n\n\n#### 组件在初始化时会触发5个钩子函数：\n###### 1、getDefaultProps()\n设置默认的props，也可以用dufaultProps设置组件的默认属性\n###### 2、getInitialState()\n在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。\n###### 3、componentWillMount()\n组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。\n###### 4、render()\nreact最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。\n###### 5、componentDidMount()\n组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。\n\n#### 组件在初始化时会触发5个钩子函数：\n\n###### 1、componentWillReceivePorps(nextProps)\n组件初始化时不调用，组件接受新的props时调用。\n###### 2、shouldComponentUpdate(nextProps, nextState)\nreact性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个`props`和`state`是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用`this.forceUpdate`会跳过此步骤。\n###### 3、componentWillUpdate(nextProps, nextState)\n组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state\n！！修改state不能用this.setState(),该方法会触发另一个componentWillUpdate，会陷入死循环。\n（github issue查询建议使用nextState.test = 1这种写法，没有验证）\n###### 4、render()\n###### 5、componentDidUpdate()\n组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。\n###### 6、componentWillUnmount()\n组件将要卸载时调用，一些事件监听和定时器需要在此时清除。\n### React-Router路由\n### 组件之间的通信\n\n\n* 父子之间通信\n父子级关系，父级可以将一个`回调函数`当作`属性`传递给子级，子级可以直接调用函数从而和父级通信。\n* 组件层级嵌套到比较深\n使用上下文`getChildContext`来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过`this.context`直接访问。\n* 兄弟关系的组件之间\n1. 只能利用同一层的上级作为中转站.\n2. 兄弟组件都是最高层的组件, 利用redux\n\n* 组件之间的信息还可以通过全局事件来传递.\n不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。\n\n### Redux\n* 作用\n\n进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信\n\n* 实现逻辑\n\nreact-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。\n\n值得注意的是`connect，Provider，mapStateToProps,mapDispatchToProps`是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起\n\n* redux主要由三部分组成：store，reducer，action\n\n#### store是一个对象，它有四个主要的方法：\n###### 1、dispatch:\n\n用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。\n###### 2、subscribe：\n监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。 \n```\nlet unsubscribe = store.subscribe(() => {console.log('state发生了变化')})\n```\n\n###### 3、getState：\n获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。\ngetState主要在两个地方需要用到:\n* 一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的.\n\n* 二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。\n###### 4、replaceReducer:\n替换reducer，改变state修改的逻辑。\n\nstore可以通过`createStore()`方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。\n\n#### action:\n\naction是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。\n\n#### reducer:\n\nreducer是一个函数，它接受一个`state`和一个`action`，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。\n\n```\nconst reducer = combineReducers({\n     a: doSomethingWithA,\n     b: processB,\n     c: c\n})\n```\n#### combineReducers:\n\n其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。\n\n> 接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。\n\n> redux的state和react的state两者完全没有关系，除了名字一样。\n\n* `使用流程`\n\n如果只使用redux，那么流程是这样的：\n\ncomponent --> dispatch(action) --> reducer --> subscribe --> getState --> component\n\n用了react-redux之后流程是这样的：\n\ncomponent --> actionCreator(data) --> reducer --> component\n\nstore的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。\n\n\n参考链接：https://github.com/bailicangdu/react-pxq\n\n\n# React\n\n#### 1. 什么时候使用状态管理器？\n参考链接：https://baijiahao.baidu.com/s?id=1590300061305698080&wfr=spider&for=pc\n\n#### 2. render函数中return如果没有使用()会有什么问题？\n在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：\n* Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.\n解决办法：为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。\n\n#### 3. componentWillUpdate可以直接修改state的值吗？\n`本题参考上面的生命周期函数componentWillUpdate的解释`\nreact 组件在每次需要重新渲染时候都会调用 componentWillUpdate(),\n\n例如，我们调用 this.setState()时候\n\n在这个函数中我们之所以不调用 this.setState()是因为该方法会触发另一个 componentWillUpdate(),如果我们 componentWillUpdate()中触发状态更改,我们将以无限循环.\n\n！！（github issue查询建议使用nextState.test = 1这种写法，没有验证）\n\n#### 4. 什么渲染劫持？\n什么是渲染劫持：渲染劫持的概念是控制组件从另一个组件输出的能力，当然这个概念一般和react中的高阶组件（HOC）放在一起解释比较有明了。\n\n高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。\n\n实际上，在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可以增强由原组件render函数产生的React元素。\n\n实际的操作中 通过 操作 state、props 都可以实现渲染劫\n\n\n#### 4. 对 React Context 的理解以及应用？\n在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。\n使用例子：比如react-redux的<Provider />，就是通过Context提供一个全局态的store，拖拽组件react-dnd，通过Context在组件中分发DOM的Drag和Drop事件，路由组件react-router通过Context管理路由状态\n* 使用Context，可以跨越组件进行数据传递。\n* 如何使用Context\n参考链接：https://www.jianshu.com/p/eba2b76b290b\n\n#### 5. 为什么 React 并不推荐我们优先考虑使用 Context？\n\nContext 目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在 app 中使用 context。\n尽管不建议在 app 中使用 context，但是独有组件而言，由于影响范围小于 app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用 context\n对于组件之间的数据通信或者状态管理，有效使用 props 或者 state 解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑 context。\n\ncontext 的更新需要通过 setState()触发，但是这并不是很可靠的，Context 支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回 false 那么不能保证 Context 的更新一定可以使用 Context 的子组件，因此，Context 的可靠性需要关注。\n\n#### 6. 说说你对windowing的了解-react-window和react-virtualized？\n\n展示长列表\n如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。\n\n`react-window`和`react-virtualized`都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据.\n\n#### 7. 举例说明 React 的插槽有哪些运用场景？\n对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的\n\n#### 8. 你有用过 React 的插槽(Portals)吗？怎么用？\n* 首先简单的介绍下 react 中的插槽（Portals），通过 ReactDOM.createPortal(child, container)创建，是 ReactDOM 提供的接口，可以实现将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。\n* 第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。\n\n* 对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的。\n#### 9. React 的严格模式有什么用处？\n\nreact 的 strictMode 是一个突出显示应用程序中潜在问题的工具，与 Fragment 一样，strictMode 不会渲染任何的可见 UI，它为其后代元素触发额外的检查和警告。\n\n注意：严格模式仅在开发模式下运行，它们不会影响生产构建\n\n可以为程序的任何部分使用严格模式\n\n```\nimport React from 'react';\n\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n```\n在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\n\nStrictMode 目前有助于：\n\n* 识别不安全的生命周期\n* 关于使用过时字符串 ref API 的警告\n* 关于使用废弃的 findDOMNode 方法的警告\n* 检测意外的副作用\n* 检测过时的 context API\n\n#### 10.React如何进行代码拆分？拆分的原则是什么？\n\n个人认为react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。\n\n在react项目中：\n1. 在api层面单独封装，对外暴露http请求的结果。\n2. 数据层面使用react-redux， 异步中间件使用的是react-thunk封装处理异步请求，和业务层逻辑处理。\n3. 视图层，尽量使用redux层传过来的数据，修改逻辑，也是重新触发action更改props.\n4. 静态类型的资源单独放置。\n5. 公共组件、高阶组件、插件单独放置。\n6. 工具类文件单独放置。\n\n#### 10.React组件的构造函数有什么作用？\n\n在react的新的写法中，每一个组件都是一个类，这个很符合es6的语法规范，在es6中想要创建一个对象，就要调用相应的构造函数，react的组件渲染有两种情况，第一种情况是第一次渲染，第二种情况是状态更新时候重新渲染构造函数，在组件的初次渲染时只会运行一次。\n\n构造函数里面进行的操作一般会有三种用途：\n\n* 1. 指定this -->super(props)\n* 2. 设置初始化的状态 --> this.setState({});\n* 3. 为组件上的构造函数绑定this\n\n#### 11.为什么说react中的props是只读的？\n\nreact官方文档中说到：组件无论是使用函数声明还是通过class声明，都不能修改自身的props,props作为组件对外通信的一个接口，为了保证组件像纯函数一样没有响应的副作用，所有的组件都必须像纯函数一样保护他们的props不被修改。\n\n#### 12.`super()`和`super(props)`有什么区别？\n\nreact中的class是基于es6的规范实现的，继承是使用extends关键字实现继承的，字类必须在constructor()中调用super()方法否则新建实力就会报错；\n报错的原因就是：子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super()子类就得不到this对象。\n如果你使用了constructor就必须使用super()，这个是用来初始化this的，可以绑定事件到this上，如果想要在constructor中使用this.props,就必须给super添加参数super(props)；\n注意：无论有没有constructor，在render中的this.props都是可以使用的，这是react自动附带的，如果没有用到constructor是可以不写的，react会默认添加一个空的constroctor.\n\n\n#### 13.怎么动态到导入组件？\n\n* 使用import和async/await实现的异步组件\n* react.lazy\n* 开源库react-loadable/react-lazyload库\n* babel动态导入\n\n\n#### 14.怎样使用Hooks获取服务端数据？\n参考链接： https://zhuanlan.zhihu.com/p/57214270\n\n#### 15.使用Hooks要遵守哪些原则？\n* 只在最顶层使用 Hook\n* 只在 React 函数中调用 Hook\nhttps://react.docschina.org/docs/hooks-rules.html\n\n#### render方法的原理你有了解吗？它返回的数据类型是什么？\n#### 在React项目中你用过哪些动画的包?\n\n#### useEffect和useLayoutEffect的区别?\n在 React hook 中，useEffect 用来取代 componentDidMount 和 componentDidUpdate。主要作用是当页面渲染后，进行一些副作用操作（比如访问 DOM，请求数据）。\n* useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。\n* useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 说说你对React的渲染原理的理解？\n持\n\n#### 4. React Intl是什么原理？\nreact-intl 实现多语言项目国际化处理\n\n\n\n\n","slug":"React","published":0,"date":"2019-12-25T15:04:35.116Z","updated":"2020-06-02T07:54:11.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjov000078p316cbn05a","content":"<h3 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h3><h4 id=\"组件在初始化时会触发5个钩子函数：\"><a href=\"#组件在初始化时会触发5个钩子函数：\" class=\"headerlink\" title=\"组件在初始化时会触发5个钩子函数：\"></a>组件在初始化时会触发5个钩子函数：</h4><h6 id=\"1、getDefaultProps\"><a href=\"#1、getDefaultProps\" class=\"headerlink\" title=\"1、getDefaultProps()\"></a>1、getDefaultProps()</h6><p>设置默认的props，也可以用dufaultProps设置组件的默认属性</p>\n<h6 id=\"2、getInitialState\"><a href=\"#2、getInitialState\" class=\"headerlink\" title=\"2、getInitialState()\"></a>2、getInitialState()</h6><p>在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。</p>\n<h6 id=\"3、componentWillMount\"><a href=\"#3、componentWillMount\" class=\"headerlink\" title=\"3、componentWillMount()\"></a>3、componentWillMount()</h6><p>组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。</p>\n<h6 id=\"4、render\"><a href=\"#4、render\" class=\"headerlink\" title=\"4、render()\"></a>4、render()</h6><p>react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。</p>\n<h6 id=\"5、componentDidMount\"><a href=\"#5、componentDidMount\" class=\"headerlink\" title=\"5、componentDidMount()\"></a>5、componentDidMount()</h6><p>组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。</p>\n<h4 id=\"组件在初始化时会触发5个钩子函数：-1\"><a href=\"#组件在初始化时会触发5个钩子函数：-1\" class=\"headerlink\" title=\"组件在初始化时会触发5个钩子函数：\"></a>组件在初始化时会触发5个钩子函数：</h4><h6 id=\"1、componentWillReceivePorps-nextProps\"><a href=\"#1、componentWillReceivePorps-nextProps\" class=\"headerlink\" title=\"1、componentWillReceivePorps(nextProps)\"></a>1、componentWillReceivePorps(nextProps)</h6><p>组件初始化时不调用，组件接受新的props时调用。</p>\n<h6 id=\"2、shouldComponentUpdate-nextProps-nextState\"><a href=\"#2、shouldComponentUpdate-nextProps-nextState\" class=\"headerlink\" title=\"2、shouldComponentUpdate(nextProps, nextState)\"></a>2、shouldComponentUpdate(nextProps, nextState)</h6><p>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个<code>props</code>和<code>state</code>是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用<code>this.forceUpdate</code>会跳过此步骤。</p>\n<h6 id=\"3、componentWillUpdate-nextProps-nextState\"><a href=\"#3、componentWillUpdate-nextProps-nextState\" class=\"headerlink\" title=\"3、componentWillUpdate(nextProps, nextState)\"></a>3、componentWillUpdate(nextProps, nextState)</h6><p>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state<br>！！修改state不能用this.setState(),该方法会触发另一个componentWillUpdate，会陷入死循环。<br>（github issue查询建议使用nextState.test = 1这种写法，没有验证）</p>\n<h6 id=\"4、render-1\"><a href=\"#4、render-1\" class=\"headerlink\" title=\"4、render()\"></a>4、render()</h6><h6 id=\"5、componentDidUpdate\"><a href=\"#5、componentDidUpdate\" class=\"headerlink\" title=\"5、componentDidUpdate()\"></a>5、componentDidUpdate()</h6><p>组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</p>\n<h6 id=\"6、componentWillUnmount\"><a href=\"#6、componentWillUnmount\" class=\"headerlink\" title=\"6、componentWillUnmount()\"></a>6、componentWillUnmount()</h6><p>组件将要卸载时调用，一些事件监听和定时器需要在此时清除。</p>\n<h3 id=\"React-Router路由\"><a href=\"#React-Router路由\" class=\"headerlink\" title=\"React-Router路由\"></a>React-Router路由</h3><h3 id=\"组件之间的通信\"><a href=\"#组件之间的通信\" class=\"headerlink\" title=\"组件之间的通信\"></a>组件之间的通信</h3><ul>\n<li>父子之间通信<br>父子级关系，父级可以将一个<code>回调函数</code>当作<code>属性</code>传递给子级，子级可以直接调用函数从而和父级通信。</li>\n<li>组件层级嵌套到比较深<br>使用上下文<code>getChildContext</code>来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过<code>this.context</code>直接访问。</li>\n<li>兄弟关系的组件之间</li>\n</ul>\n<ol>\n<li>只能利用同一层的上级作为中转站.</li>\n<li>兄弟组件都是最高层的组件, 利用redux</li>\n</ol>\n<ul>\n<li>组件之间的信息还可以通过全局事件来传递.<br>不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。</li>\n</ul>\n<h3 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h3><ul>\n<li>作用</li>\n</ul>\n<p>进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信</p>\n<ul>\n<li>实现逻辑</li>\n</ul>\n<p>react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。</p>\n<p>值得注意的是<code>connect，Provider，mapStateToProps,mapDispatchToProps</code>是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起</p>\n<ul>\n<li>redux主要由三部分组成：store，reducer，action</li>\n</ul>\n<h4 id=\"store是一个对象，它有四个主要的方法：\"><a href=\"#store是一个对象，它有四个主要的方法：\" class=\"headerlink\" title=\"store是一个对象，它有四个主要的方法：\"></a>store是一个对象，它有四个主要的方法：</h4><h6 id=\"1、dispatch\"><a href=\"#1、dispatch\" class=\"headerlink\" title=\"1、dispatch:\"></a>1、dispatch:</h6><p>用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</p>\n<h6 id=\"2、subscribe：\"><a href=\"#2、subscribe：\" class=\"headerlink\" title=\"2、subscribe：\"></a>2、subscribe：</h6><p>监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let unsubscribe = store.subscribe(() =&gt; &#123;console.log(&apos;state发生了变化&apos;)&#125;)</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"3、getState：\"><a href=\"#3、getState：\" class=\"headerlink\" title=\"3、getState：\"></a>3、getState：</h6><p>获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。<br>getState主要在两个地方需要用到:</p>\n<ul>\n<li><p>一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的.</p>\n</li>\n<li><p>二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</p>\n<h6 id=\"4、replaceReducer\"><a href=\"#4、replaceReducer\" class=\"headerlink\" title=\"4、replaceReducer:\"></a>4、replaceReducer:</h6><p>替换reducer，改变state修改的逻辑。</p>\n</li>\n</ul>\n<p>store可以通过<code>createStore()</code>方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。</p>\n<h4 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action:\"></a>action:</h4><p>action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。</p>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer:\"></a>reducer:</h4><p>reducer是一个函数，它接受一个<code>state</code>和一个<code>action</code>，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reducer = combineReducers(&#123;</span><br><span class=\"line\">     a: doSomethingWithA,</span><br><span class=\"line\">     b: processB,</span><br><span class=\"line\">     c: c</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers:\"></a>combineReducers:</h4><p>其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。</p>\n<blockquote>\n<p>接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。</p>\n</blockquote>\n<blockquote>\n<p>redux的state和react的state两者完全没有关系，除了名字一样。</p>\n</blockquote>\n<ul>\n<li><code>使用流程</code></li>\n</ul>\n<p>如果只使用redux，那么流程是这样的：</p>\n<p>component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component</p>\n<p>用了react-redux之后流程是这样的：</p>\n<p>component –&gt; actionCreator(data) –&gt; reducer –&gt; component</p>\n<p>store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。</p>\n<p>参考链接：<a href=\"https://github.com/bailicangdu/react-pxq\" target=\"_blank\" rel=\"noopener\">https://github.com/bailicangdu/react-pxq</a></p>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><h4 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h4><p>参考链接：<a href=\"https://baijiahao.baidu.com/s?id=1590300061305698080&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1590300061305698080&amp;wfr=spider&amp;for=pc</a></p>\n<h4 id=\"2-render函数中return如果没有使用-会有什么问题？\"><a href=\"#2-render函数中return如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render函数中return如果没有使用()会有什么问题？\"></a>2. render函数中return如果没有使用()会有什么问题？</h4><p>在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<ul>\n<li>Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>解决办法：为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。</li>\n</ul>\n<h4 id=\"3-componentWillUpdate可以直接修改state的值吗？\"><a href=\"#3-componentWillUpdate可以直接修改state的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate可以直接修改state的值吗？\"></a>3. componentWillUpdate可以直接修改state的值吗？</h4><p><code>本题参考上面的生命周期函数componentWillUpdate的解释</code><br>react 组件在每次需要重新渲染时候都会调用 componentWillUpdate(),</p>\n<p>例如，我们调用 this.setState()时候</p>\n<p>在这个函数中我们之所以不调用 this.setState()是因为该方法会触发另一个 componentWillUpdate(),如果我们 componentWillUpdate()中触发状态更改,我们将以无限循环.</p>\n<p>！！（github issue查询建议使用nextState.test = 1这种写法，没有验证）</p>\n<h4 id=\"4-什么渲染劫持？\"><a href=\"#4-什么渲染劫持？\" class=\"headerlink\" title=\"4. 什么渲染劫持？\"></a>4. 什么渲染劫持？</h4><p>什么是渲染劫持：渲染劫持的概念是控制组件从另一个组件输出的能力，当然这个概念一般和react中的高阶组件（HOC）放在一起解释比较有明了。</p>\n<p>高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。</p>\n<p>实际上，在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可以增强由原组件render函数产生的React元素。</p>\n<p>实际的操作中 通过 操作 state、props 都可以实现渲染劫</p>\n<h4 id=\"4-对-React-Context-的理解以及应用？\"><a href=\"#4-对-React-Context-的理解以及应用？\" class=\"headerlink\" title=\"4. 对 React Context 的理解以及应用？\"></a>4. 对 React Context 的理解以及应用？</h4><p>在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。<br>使用例子：比如react-redux的<provider>，就是通过Context提供一个全局态的store，拖拽组件react-dnd，通过Context在组件中分发DOM的Drag和Drop事件，路由组件react-router通过Context管理路由状态</provider></p>\n<ul>\n<li>使用Context，可以跨越组件进行数据传递。</li>\n<li>如何使用Context<br>参考链接：<a href=\"https://www.jianshu.com/p/eba2b76b290b\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/eba2b76b290b</a></li>\n</ul>\n<h4 id=\"5-为什么-React-并不推荐我们优先考虑使用-Context？\"><a href=\"#5-为什么-React-并不推荐我们优先考虑使用-Context？\" class=\"headerlink\" title=\"5. 为什么 React 并不推荐我们优先考虑使用 Context？\"></a>5. 为什么 React 并不推荐我们优先考虑使用 Context？</h4><p>Context 目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在 app 中使用 context。<br>尽管不建议在 app 中使用 context，但是独有组件而言，由于影响范围小于 app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用 context<br>对于组件之间的数据通信或者状态管理，有效使用 props 或者 state 解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑 context。</p>\n<p>context 的更新需要通过 setState()触发，但是这并不是很可靠的，Context 支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回 false 那么不能保证 Context 的更新一定可以使用 Context 的子组件，因此，Context 的可靠性需要关注。</p>\n<h4 id=\"6-说说你对windowing的了解-react-window和react-virtualized？\"><a href=\"#6-说说你对windowing的了解-react-window和react-virtualized？\" class=\"headerlink\" title=\"6. 说说你对windowing的了解-react-window和react-virtualized？\"></a>6. 说说你对windowing的了解-react-window和react-virtualized？</h4><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p><code>react-window</code>和<code>react-virtualized</code>都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据.</p>\n<h4 id=\"7-举例说明-React-的插槽有哪些运用场景？\"><a href=\"#7-举例说明-React-的插槽有哪些运用场景？\" class=\"headerlink\" title=\"7. 举例说明 React 的插槽有哪些运用场景？\"></a>7. 举例说明 React 的插槽有哪些运用场景？</h4><p>对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的</p>\n<h4 id=\"8-你有用过-React-的插槽-Portals-吗？怎么用？\"><a href=\"#8-你有用过-React-的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"8. 你有用过 React 的插槽(Portals)吗？怎么用？\"></a>8. 你有用过 React 的插槽(Portals)吗？怎么用？</h4><ul>\n<li>首先简单的介绍下 react 中的插槽（Portals），通过 ReactDOM.createPortal(child, container)创建，是 ReactDOM 提供的接口，可以实现将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。</li>\n<li><p>第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。</p>\n</li>\n<li><p>对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的。</p>\n<h4 id=\"9-React-的严格模式有什么用处？\"><a href=\"#9-React-的严格模式有什么用处？\" class=\"headerlink\" title=\"9. React 的严格模式有什么用处？\"></a>9. React 的严格模式有什么用处？</h4></li>\n</ul>\n<p>react 的 strictMode 是一个突出显示应用程序中潜在问题的工具，与 Fragment 一样，strictMode 不会渲染任何的可见 UI，它为其后代元素触发额外的检查和警告。</p>\n<p>注意：严格模式仅在开发模式下运行，它们不会影响生产构建</p>\n<p>可以为程序的任何部分使用严格模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">function ExampleApplication() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Header /&gt;</span><br><span class=\"line\">      &lt;React.StrictMode&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;ComponentOne /&gt;</span><br><span class=\"line\">          &lt;ComponentTwo /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/React.StrictMode&gt;</span><br><span class=\"line\">      &lt;Footer /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</p>\n<p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<h4 id=\"10-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#10-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"10.React如何进行代码拆分？拆分的原则是什么？\"></a>10.React如何进行代码拆分？拆分的原则是什么？</h4><p>个人认为react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在react项目中：</p>\n<ol>\n<li>在api层面单独封装，对外暴露http请求的结果。</li>\n<li>数据层面使用react-redux， 异步中间件使用的是react-thunk封装处理异步请求，和业务层逻辑处理。</li>\n<li>视图层，尽量使用redux层传过来的数据，修改逻辑，也是重新触发action更改props.</li>\n<li>静态类型的资源单独放置。</li>\n<li>公共组件、高阶组件、插件单独放置。</li>\n<li>工具类文件单独放置。</li>\n</ol>\n<h4 id=\"10-React组件的构造函数有什么作用？\"><a href=\"#10-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"10.React组件的构造函数有什么作用？\"></a>10.React组件的构造函数有什么作用？</h4><p>在react的新的写法中，每一个组件都是一个类，这个很符合es6的语法规范，在es6中想要创建一个对象，就要调用相应的构造函数，react的组件渲染有两种情况，第一种情况是第一次渲染，第二种情况是状态更新时候重新渲染构造函数，在组件的初次渲染时只会运行一次。</p>\n<p>构造函数里面进行的操作一般会有三种用途：</p>\n<ul>\n<li><ol>\n<li>指定this –&gt;super(props)</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>设置初始化的状态 –&gt; this.setState({});</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>为组件上的构造函数绑定this</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-为什么说react中的props是只读的？\"><a href=\"#11-为什么说react中的props是只读的？\" class=\"headerlink\" title=\"11.为什么说react中的props是只读的？\"></a>11.为什么说react中的props是只读的？</h4><p>react官方文档中说到：组件无论是使用函数声明还是通过class声明，都不能修改自身的props,props作为组件对外通信的一个接口，为了保证组件像纯函数一样没有响应的副作用，所有的组件都必须像纯函数一样保护他们的props不被修改。</p>\n<h4 id=\"12-super-和super-props-有什么区别？\"><a href=\"#12-super-和super-props-有什么区别？\" class=\"headerlink\" title=\"12.super()和super(props)有什么区别？\"></a>12.<code>super()</code>和<code>super(props)</code>有什么区别？</h4><p>react中的class是基于es6的规范实现的，继承是使用extends关键字实现继承的，字类必须在constructor()中调用super()方法否则新建实力就会报错；<br>报错的原因就是：子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super()子类就得不到this对象。<br>如果你使用了constructor就必须使用super()，这个是用来初始化this的，可以绑定事件到this上，如果想要在constructor中使用this.props,就必须给super添加参数super(props)；<br>注意：无论有没有constructor，在render中的this.props都是可以使用的，这是react自动附带的，如果没有用到constructor是可以不写的，react会默认添加一个空的constroctor.</p>\n<h4 id=\"13-怎么动态到导入组件？\"><a href=\"#13-怎么动态到导入组件？\" class=\"headerlink\" title=\"13.怎么动态到导入组件？\"></a>13.怎么动态到导入组件？</h4><ul>\n<li>使用import和async/await实现的异步组件</li>\n<li>react.lazy</li>\n<li>开源库react-loadable/react-lazyload库</li>\n<li>babel动态导入</li>\n</ul>\n<h4 id=\"14-怎样使用Hooks获取服务端数据？\"><a href=\"#14-怎样使用Hooks获取服务端数据？\" class=\"headerlink\" title=\"14.怎样使用Hooks获取服务端数据？\"></a>14.怎样使用Hooks获取服务端数据？</h4><p>参考链接： <a href=\"https://zhuanlan.zhihu.com/p/57214270\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/57214270</a></p>\n<h4 id=\"15-使用Hooks要遵守哪些原则？\"><a href=\"#15-使用Hooks要遵守哪些原则？\" class=\"headerlink\" title=\"15.使用Hooks要遵守哪些原则？\"></a>15.使用Hooks要遵守哪些原则？</h4><ul>\n<li>只在最顶层使用 Hook</li>\n<li>只在 React 函数中调用 Hook<br><a href=\"https://react.docschina.org/docs/hooks-rules.html\" target=\"_blank\" rel=\"noopener\">https://react.docschina.org/docs/hooks-rules.html</a></li>\n</ul>\n<h4 id=\"render方法的原理你有了解吗？它返回的数据类型是什么？\"><a href=\"#render方法的原理你有了解吗？它返回的数据类型是什么？\" class=\"headerlink\" title=\"render方法的原理你有了解吗？它返回的数据类型是什么？\"></a>render方法的原理你有了解吗？它返回的数据类型是什么？</h4><h4 id=\"在React项目中你用过哪些动画的包\"><a href=\"#在React项目中你用过哪些动画的包\" class=\"headerlink\" title=\"在React项目中你用过哪些动画的包?\"></a>在React项目中你用过哪些动画的包?</h4><h4 id=\"useEffect和useLayoutEffect的区别\"><a href=\"#useEffect和useLayoutEffect的区别\" class=\"headerlink\" title=\"useEffect和useLayoutEffect的区别?\"></a>useEffect和useLayoutEffect的区别?</h4><p>在 React hook 中，useEffect 用来取代 componentDidMount 和 componentDidUpdate。主要作用是当页面渲染后，进行一些副作用操作（比如访问 DOM，请求数据）。</p>\n<ul>\n<li>useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。</li>\n<li>useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。</li>\n</ul>\n<h4 id=\"说说你对React的渲染原理的理解？\"><a href=\"#说说你对React的渲染原理的理解？\" class=\"headerlink\" title=\"说说你对React的渲染原理的理解？\"></a>说说你对React的渲染原理的理解？</h4><p>持</p>\n<h4 id=\"4-React-Intl是什么原理？\"><a href=\"#4-React-Intl是什么原理？\" class=\"headerlink\" title=\"4. React Intl是什么原理？\"></a>4. React Intl是什么原理？</h4><p>react-intl 实现多语言项目国际化处理</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h3><h4 id=\"组件在初始化时会触发5个钩子函数：\"><a href=\"#组件在初始化时会触发5个钩子函数：\" class=\"headerlink\" title=\"组件在初始化时会触发5个钩子函数：\"></a>组件在初始化时会触发5个钩子函数：</h4><h6 id=\"1、getDefaultProps\"><a href=\"#1、getDefaultProps\" class=\"headerlink\" title=\"1、getDefaultProps()\"></a>1、getDefaultProps()</h6><p>设置默认的props，也可以用dufaultProps设置组件的默认属性</p>\n<h6 id=\"2、getInitialState\"><a href=\"#2、getInitialState\" class=\"headerlink\" title=\"2、getInitialState()\"></a>2、getInitialState()</h6><p>在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。</p>\n<h6 id=\"3、componentWillMount\"><a href=\"#3、componentWillMount\" class=\"headerlink\" title=\"3、componentWillMount()\"></a>3、componentWillMount()</h6><p>组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。</p>\n<h6 id=\"4、render\"><a href=\"#4、render\" class=\"headerlink\" title=\"4、render()\"></a>4、render()</h6><p>react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。</p>\n<h6 id=\"5、componentDidMount\"><a href=\"#5、componentDidMount\" class=\"headerlink\" title=\"5、componentDidMount()\"></a>5、componentDidMount()</h6><p>组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。</p>\n<h4 id=\"组件在初始化时会触发5个钩子函数：-1\"><a href=\"#组件在初始化时会触发5个钩子函数：-1\" class=\"headerlink\" title=\"组件在初始化时会触发5个钩子函数：\"></a>组件在初始化时会触发5个钩子函数：</h4><h6 id=\"1、componentWillReceivePorps-nextProps\"><a href=\"#1、componentWillReceivePorps-nextProps\" class=\"headerlink\" title=\"1、componentWillReceivePorps(nextProps)\"></a>1、componentWillReceivePorps(nextProps)</h6><p>组件初始化时不调用，组件接受新的props时调用。</p>\n<h6 id=\"2、shouldComponentUpdate-nextProps-nextState\"><a href=\"#2、shouldComponentUpdate-nextProps-nextState\" class=\"headerlink\" title=\"2、shouldComponentUpdate(nextProps, nextState)\"></a>2、shouldComponentUpdate(nextProps, nextState)</h6><p>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个<code>props</code>和<code>state</code>是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用<code>this.forceUpdate</code>会跳过此步骤。</p>\n<h6 id=\"3、componentWillUpdate-nextProps-nextState\"><a href=\"#3、componentWillUpdate-nextProps-nextState\" class=\"headerlink\" title=\"3、componentWillUpdate(nextProps, nextState)\"></a>3、componentWillUpdate(nextProps, nextState)</h6><p>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state<br>！！修改state不能用this.setState(),该方法会触发另一个componentWillUpdate，会陷入死循环。<br>（github issue查询建议使用nextState.test = 1这种写法，没有验证）</p>\n<h6 id=\"4、render-1\"><a href=\"#4、render-1\" class=\"headerlink\" title=\"4、render()\"></a>4、render()</h6><h6 id=\"5、componentDidUpdate\"><a href=\"#5、componentDidUpdate\" class=\"headerlink\" title=\"5、componentDidUpdate()\"></a>5、componentDidUpdate()</h6><p>组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</p>\n<h6 id=\"6、componentWillUnmount\"><a href=\"#6、componentWillUnmount\" class=\"headerlink\" title=\"6、componentWillUnmount()\"></a>6、componentWillUnmount()</h6><p>组件将要卸载时调用，一些事件监听和定时器需要在此时清除。</p>\n<h3 id=\"React-Router路由\"><a href=\"#React-Router路由\" class=\"headerlink\" title=\"React-Router路由\"></a>React-Router路由</h3><h3 id=\"组件之间的通信\"><a href=\"#组件之间的通信\" class=\"headerlink\" title=\"组件之间的通信\"></a>组件之间的通信</h3><ul>\n<li>父子之间通信<br>父子级关系，父级可以将一个<code>回调函数</code>当作<code>属性</code>传递给子级，子级可以直接调用函数从而和父级通信。</li>\n<li>组件层级嵌套到比较深<br>使用上下文<code>getChildContext</code>来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过<code>this.context</code>直接访问。</li>\n<li>兄弟关系的组件之间</li>\n</ul>\n<ol>\n<li>只能利用同一层的上级作为中转站.</li>\n<li>兄弟组件都是最高层的组件, 利用redux</li>\n</ol>\n<ul>\n<li>组件之间的信息还可以通过全局事件来传递.<br>不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。</li>\n</ul>\n<h3 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h3><ul>\n<li>作用</li>\n</ul>\n<p>进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信</p>\n<ul>\n<li>实现逻辑</li>\n</ul>\n<p>react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。</p>\n<p>值得注意的是<code>connect，Provider，mapStateToProps,mapDispatchToProps</code>是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起</p>\n<ul>\n<li>redux主要由三部分组成：store，reducer，action</li>\n</ul>\n<h4 id=\"store是一个对象，它有四个主要的方法：\"><a href=\"#store是一个对象，它有四个主要的方法：\" class=\"headerlink\" title=\"store是一个对象，它有四个主要的方法：\"></a>store是一个对象，它有四个主要的方法：</h4><h6 id=\"1、dispatch\"><a href=\"#1、dispatch\" class=\"headerlink\" title=\"1、dispatch:\"></a>1、dispatch:</h6><p>用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</p>\n<h6 id=\"2、subscribe：\"><a href=\"#2、subscribe：\" class=\"headerlink\" title=\"2、subscribe：\"></a>2、subscribe：</h6><p>监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let unsubscribe = store.subscribe(() =&gt; &#123;console.log(&apos;state发生了变化&apos;)&#125;)</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"3、getState：\"><a href=\"#3、getState：\" class=\"headerlink\" title=\"3、getState：\"></a>3、getState：</h6><p>获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。<br>getState主要在两个地方需要用到:</p>\n<ul>\n<li><p>一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的.</p>\n</li>\n<li><p>二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了。</p>\n<h6 id=\"4、replaceReducer\"><a href=\"#4、replaceReducer\" class=\"headerlink\" title=\"4、replaceReducer:\"></a>4、replaceReducer:</h6><p>替换reducer，改变state修改的逻辑。</p>\n</li>\n</ul>\n<p>store可以通过<code>createStore()</code>方法创建，接受三个参数，经过combineReducers合并的reducer和state的初始状态以及改变dispatch的中间件，后两个参数并不是必须的。store的主要作用是将action和reducer联系起来并改变state。</p>\n<h4 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action:\"></a>action:</h4><p>action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreactor进行创造。dispatch就是把action对象发送出去。</p>\n<h4 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer:\"></a>reducer:</h4><p>reducer是一个函数，它接受一个<code>state</code>和一个<code>action</code>，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const reducer = combineReducers(&#123;</span><br><span class=\"line\">     a: doSomethingWithA,</span><br><span class=\"line\">     b: processB,</span><br><span class=\"line\">     c: c</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers:\"></a>combineReducers:</h4><p>其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。</p>\n<blockquote>\n<p>接下来分析一下整体的流程，首先调用store.dispatch将action作为参数传入，同时用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。</p>\n</blockquote>\n<blockquote>\n<p>redux的state和react的state两者完全没有关系，除了名字一样。</p>\n</blockquote>\n<ul>\n<li><code>使用流程</code></li>\n</ul>\n<p>如果只使用redux，那么流程是这样的：</p>\n<p>component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component</p>\n<p>用了react-redux之后流程是这样的：</p>\n<p>component –&gt; actionCreator(data) –&gt; reducer –&gt; component</p>\n<p>store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。</p>\n<p>参考链接：<a href=\"https://github.com/bailicangdu/react-pxq\" target=\"_blank\" rel=\"noopener\">https://github.com/bailicangdu/react-pxq</a></p>\n<h1 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h1><h4 id=\"1-什么时候使用状态管理器？\"><a href=\"#1-什么时候使用状态管理器？\" class=\"headerlink\" title=\"1. 什么时候使用状态管理器？\"></a>1. 什么时候使用状态管理器？</h4><p>参考链接：<a href=\"https://baijiahao.baidu.com/s?id=1590300061305698080&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1590300061305698080&amp;wfr=spider&amp;for=pc</a></p>\n<h4 id=\"2-render函数中return如果没有使用-会有什么问题？\"><a href=\"#2-render函数中return如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"2. render函数中return如果没有使用()会有什么问题？\"></a>2. render函数中return如果没有使用()会有什么问题？</h4><p>在使用JSX语法书写react代码时，babel会将JSX语法编译成js，同时会在每行自动添加分号（；），如果return后换行了，那么就会变成 return； 一般情况下会报错：</p>\n<ul>\n<li>Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.<br>解决办法：为了代码可读性我们一般会在return后面添加括号这样代码可以折行书写，否则就在return 后面紧跟着语句，这样也是可以的。</li>\n</ul>\n<h4 id=\"3-componentWillUpdate可以直接修改state的值吗？\"><a href=\"#3-componentWillUpdate可以直接修改state的值吗？\" class=\"headerlink\" title=\"3. componentWillUpdate可以直接修改state的值吗？\"></a>3. componentWillUpdate可以直接修改state的值吗？</h4><p><code>本题参考上面的生命周期函数componentWillUpdate的解释</code><br>react 组件在每次需要重新渲染时候都会调用 componentWillUpdate(),</p>\n<p>例如，我们调用 this.setState()时候</p>\n<p>在这个函数中我们之所以不调用 this.setState()是因为该方法会触发另一个 componentWillUpdate(),如果我们 componentWillUpdate()中触发状态更改,我们将以无限循环.</p>\n<p>！！（github issue查询建议使用nextState.test = 1这种写法，没有验证）</p>\n<h4 id=\"4-什么渲染劫持？\"><a href=\"#4-什么渲染劫持？\" class=\"headerlink\" title=\"4. 什么渲染劫持？\"></a>4. 什么渲染劫持？</h4><p>什么是渲染劫持：渲染劫持的概念是控制组件从另一个组件输出的能力，当然这个概念一般和react中的高阶组件（HOC）放在一起解释比较有明了。</p>\n<p>高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出，只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。</p>\n<p>实际上，在高阶组件中，组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可以增强由原组件render函数产生的React元素。</p>\n<p>实际的操作中 通过 操作 state、props 都可以实现渲染劫</p>\n<h4 id=\"4-对-React-Context-的理解以及应用？\"><a href=\"#4-对-React-Context-的理解以及应用？\" class=\"headerlink\" title=\"4. 对 React Context 的理解以及应用？\"></a>4. 对 React Context 的理解以及应用？</h4><p>在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。<br>使用例子：比如react-redux的<provider>，就是通过Context提供一个全局态的store，拖拽组件react-dnd，通过Context在组件中分发DOM的Drag和Drop事件，路由组件react-router通过Context管理路由状态</provider></p>\n<ul>\n<li>使用Context，可以跨越组件进行数据传递。</li>\n<li>如何使用Context<br>参考链接：<a href=\"https://www.jianshu.com/p/eba2b76b290b\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/eba2b76b290b</a></li>\n</ul>\n<h4 id=\"5-为什么-React-并不推荐我们优先考虑使用-Context？\"><a href=\"#5-为什么-React-并不推荐我们优先考虑使用-Context？\" class=\"headerlink\" title=\"5. 为什么 React 并不推荐我们优先考虑使用 Context？\"></a>5. 为什么 React 并不推荐我们优先考虑使用 Context？</h4><p>Context 目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在 app 中使用 context。<br>尽管不建议在 app 中使用 context，但是独有组件而言，由于影响范围小于 app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用 context<br>对于组件之间的数据通信或者状态管理，有效使用 props 或者 state 解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑 context。</p>\n<p>context 的更新需要通过 setState()触发，但是这并不是很可靠的，Context 支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回 false 那么不能保证 Context 的更新一定可以使用 Context 的子组件，因此，Context 的可靠性需要关注。</p>\n<h4 id=\"6-说说你对windowing的了解-react-window和react-virtualized？\"><a href=\"#6-说说你对windowing的了解-react-window和react-virtualized？\" class=\"headerlink\" title=\"6. 说说你对windowing的了解-react-window和react-virtualized？\"></a>6. 说说你对windowing的了解-react-window和react-virtualized？</h4><p>展示长列表<br>如果你的应用会渲染大量的列表数据，我们建议使用一种称为‘windowing’的技术，这种技术下在任何给定的时间内只会渲染一小部分数据列表，并可以减少列表项的重复渲染（即再次渲染已经渲染过的数据）。</p>\n<p><code>react-window</code>和<code>react-virtualized</code>都是流行的使用windowing技术的库，他们都提供了一系列可重用的组件，这些组件能够帮助你以最好的性能展示列表以及表格数据.</p>\n<h4 id=\"7-举例说明-React-的插槽有哪些运用场景？\"><a href=\"#7-举例说明-React-的插槽有哪些运用场景？\" class=\"headerlink\" title=\"7. 举例说明 React 的插槽有哪些运用场景？\"></a>7. 举例说明 React 的插槽有哪些运用场景？</h4><p>对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的</p>\n<h4 id=\"8-你有用过-React-的插槽-Portals-吗？怎么用？\"><a href=\"#8-你有用过-React-的插槽-Portals-吗？怎么用？\" class=\"headerlink\" title=\"8. 你有用过 React 的插槽(Portals)吗？怎么用？\"></a>8. 你有用过 React 的插槽(Portals)吗？怎么用？</h4><ul>\n<li>首先简单的介绍下 react 中的插槽（Portals），通过 ReactDOM.createPortal(child, container)创建，是 ReactDOM 提供的接口，可以实现将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。</li>\n<li><p>第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。</p>\n</li>\n<li><p>对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。例如，对话框、hovercards 以及提示框。所以一般 react 组件里的模态框，就是这样实现的。</p>\n<h4 id=\"9-React-的严格模式有什么用处？\"><a href=\"#9-React-的严格模式有什么用处？\" class=\"headerlink\" title=\"9. React 的严格模式有什么用处？\"></a>9. React 的严格模式有什么用处？</h4></li>\n</ul>\n<p>react 的 strictMode 是一个突出显示应用程序中潜在问题的工具，与 Fragment 一样，strictMode 不会渲染任何的可见 UI，它为其后代元素触发额外的检查和警告。</p>\n<p>注意：严格模式仅在开发模式下运行，它们不会影响生产构建</p>\n<p>可以为程序的任何部分使用严格模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">function ExampleApplication() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;Header /&gt;</span><br><span class=\"line\">      &lt;React.StrictMode&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;ComponentOne /&gt;</span><br><span class=\"line\">          &lt;ComponentTwo /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/React.StrictMode&gt;</span><br><span class=\"line\">      &lt;Footer /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。</p>\n<p>StrictMode 目前有助于：</p>\n<ul>\n<li>识别不安全的生命周期</li>\n<li>关于使用过时字符串 ref API 的警告</li>\n<li>关于使用废弃的 findDOMNode 方法的警告</li>\n<li>检测意外的副作用</li>\n<li>检测过时的 context API</li>\n</ul>\n<h4 id=\"10-React如何进行代码拆分？拆分的原则是什么？\"><a href=\"#10-React如何进行代码拆分？拆分的原则是什么？\" class=\"headerlink\" title=\"10.React如何进行代码拆分？拆分的原则是什么？\"></a>10.React如何进行代码拆分？拆分的原则是什么？</h4><p>个人认为react的拆分前提是代码目录设计规范，模块定义规范，代码设计规范，符合程序设计的一般原则，例如高内聚、低耦合等等。</p>\n<p>在react项目中：</p>\n<ol>\n<li>在api层面单独封装，对外暴露http请求的结果。</li>\n<li>数据层面使用react-redux， 异步中间件使用的是react-thunk封装处理异步请求，和业务层逻辑处理。</li>\n<li>视图层，尽量使用redux层传过来的数据，修改逻辑，也是重新触发action更改props.</li>\n<li>静态类型的资源单独放置。</li>\n<li>公共组件、高阶组件、插件单独放置。</li>\n<li>工具类文件单独放置。</li>\n</ol>\n<h4 id=\"10-React组件的构造函数有什么作用？\"><a href=\"#10-React组件的构造函数有什么作用？\" class=\"headerlink\" title=\"10.React组件的构造函数有什么作用？\"></a>10.React组件的构造函数有什么作用？</h4><p>在react的新的写法中，每一个组件都是一个类，这个很符合es6的语法规范，在es6中想要创建一个对象，就要调用相应的构造函数，react的组件渲染有两种情况，第一种情况是第一次渲染，第二种情况是状态更新时候重新渲染构造函数，在组件的初次渲染时只会运行一次。</p>\n<p>构造函数里面进行的操作一般会有三种用途：</p>\n<ul>\n<li><ol>\n<li>指定this –&gt;super(props)</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>设置初始化的状态 –&gt; this.setState({});</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>为组件上的构造函数绑定this</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"11-为什么说react中的props是只读的？\"><a href=\"#11-为什么说react中的props是只读的？\" class=\"headerlink\" title=\"11.为什么说react中的props是只读的？\"></a>11.为什么说react中的props是只读的？</h4><p>react官方文档中说到：组件无论是使用函数声明还是通过class声明，都不能修改自身的props,props作为组件对外通信的一个接口，为了保证组件像纯函数一样没有响应的副作用，所有的组件都必须像纯函数一样保护他们的props不被修改。</p>\n<h4 id=\"12-super-和super-props-有什么区别？\"><a href=\"#12-super-和super-props-有什么区别？\" class=\"headerlink\" title=\"12.super()和super(props)有什么区别？\"></a>12.<code>super()</code>和<code>super(props)</code>有什么区别？</h4><p>react中的class是基于es6的规范实现的，继承是使用extends关键字实现继承的，字类必须在constructor()中调用super()方法否则新建实力就会报错；<br>报错的原因就是：子类是没有自己的this对象的，它只能继承父类的this对象，然后对其进行加工，而super()就是将父类中的this对象继承给子类的，没有super()子类就得不到this对象。<br>如果你使用了constructor就必须使用super()，这个是用来初始化this的，可以绑定事件到this上，如果想要在constructor中使用this.props,就必须给super添加参数super(props)；<br>注意：无论有没有constructor，在render中的this.props都是可以使用的，这是react自动附带的，如果没有用到constructor是可以不写的，react会默认添加一个空的constroctor.</p>\n<h4 id=\"13-怎么动态到导入组件？\"><a href=\"#13-怎么动态到导入组件？\" class=\"headerlink\" title=\"13.怎么动态到导入组件？\"></a>13.怎么动态到导入组件？</h4><ul>\n<li>使用import和async/await实现的异步组件</li>\n<li>react.lazy</li>\n<li>开源库react-loadable/react-lazyload库</li>\n<li>babel动态导入</li>\n</ul>\n<h4 id=\"14-怎样使用Hooks获取服务端数据？\"><a href=\"#14-怎样使用Hooks获取服务端数据？\" class=\"headerlink\" title=\"14.怎样使用Hooks获取服务端数据？\"></a>14.怎样使用Hooks获取服务端数据？</h4><p>参考链接： <a href=\"https://zhuanlan.zhihu.com/p/57214270\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/57214270</a></p>\n<h4 id=\"15-使用Hooks要遵守哪些原则？\"><a href=\"#15-使用Hooks要遵守哪些原则？\" class=\"headerlink\" title=\"15.使用Hooks要遵守哪些原则？\"></a>15.使用Hooks要遵守哪些原则？</h4><ul>\n<li>只在最顶层使用 Hook</li>\n<li>只在 React 函数中调用 Hook<br><a href=\"https://react.docschina.org/docs/hooks-rules.html\" target=\"_blank\" rel=\"noopener\">https://react.docschina.org/docs/hooks-rules.html</a></li>\n</ul>\n<h4 id=\"render方法的原理你有了解吗？它返回的数据类型是什么？\"><a href=\"#render方法的原理你有了解吗？它返回的数据类型是什么？\" class=\"headerlink\" title=\"render方法的原理你有了解吗？它返回的数据类型是什么？\"></a>render方法的原理你有了解吗？它返回的数据类型是什么？</h4><h4 id=\"在React项目中你用过哪些动画的包\"><a href=\"#在React项目中你用过哪些动画的包\" class=\"headerlink\" title=\"在React项目中你用过哪些动画的包?\"></a>在React项目中你用过哪些动画的包?</h4><h4 id=\"useEffect和useLayoutEffect的区别\"><a href=\"#useEffect和useLayoutEffect的区别\" class=\"headerlink\" title=\"useEffect和useLayoutEffect的区别?\"></a>useEffect和useLayoutEffect的区别?</h4><p>在 React hook 中，useEffect 用来取代 componentDidMount 和 componentDidUpdate。主要作用是当页面渲染后，进行一些副作用操作（比如访问 DOM，请求数据）。</p>\n<ul>\n<li>useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。</li>\n<li>useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用。</li>\n</ul>\n<h4 id=\"说说你对React的渲染原理的理解？\"><a href=\"#说说你对React的渲染原理的理解？\" class=\"headerlink\" title=\"说说你对React的渲染原理的理解？\"></a>说说你对React的渲染原理的理解？</h4><p>持</p>\n<h4 id=\"4-React-Intl是什么原理？\"><a href=\"#4-React-Intl是什么原理？\" class=\"headerlink\" title=\"4. React Intl是什么原理？\"></a>4. React Intl是什么原理？</h4><p>react-intl 实现多语言项目国际化处理</p>\n"},{"title":"express： 实现本地代码+本地mock+环境接口数据","date":"2019-09-20T09:29:05.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 17:29:05\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```\n\n其他补充文件\n```\n// const config = require(\"../vue.config\");\n\n'use strict'\n// Template version: 1.3.1\n// see http://vuejs-templates.github.io/webpack for documentation.\n\nconst path = require('path')\nvar package_name = \"visit\"\nvar proxyConfig = require('./proxyConfig')\nmodule.exports = {\n    dev: {\n\n        // Paths\n        assetsSubDirectory: 'static',\n        assetsPublicPath: '/',\n        proxyTable: proxyConfig.proxy,\n\n        // Various Dev Server settings\n        // host: 'local.console.jdcloud.com', // can be overwritten by process.env.HOST\n        host: 'ccs-operation.jdcloud.com', // can be overwritten by process.env.HOST\n        port: 8084, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined\n        autoOpenBrowser: false,\n        errorOverlay: true,\n        notifyOnErrors: true,\n        poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-\n\n\n        /**\n         * Source Maps\n         */\n\n        // https://webpack.js.org/configuration/devtool/#development\n        devtool: 'cheap-module-eval-source-map',\n\n        // If you have problems debugging vue-files in devtools,\n        // set this to false - it *may* help\n        // https://vue-loader.vuejs.org/en/options.html#cachebusting\n        cacheBusting: true,\n\n        cssSourceMap: true\n    },\n\n    build: {\n        // Template for index.html\n        index: path.resolve(__dirname, '../' + package_name + '/index.html'),\n\n        // Paths\n        assetsRoot: path.resolve(__dirname, '../' + package_name),\n        assetsSubDirectory: 'static',\n        assetsPublicPath: '/',\n\n        /**\n         * Source Maps\n         */\n\n        productionSourceMap: true,\n        // https://webpack.js.org/configuration/devtool/#production\n        devtool: '#source-map',\n\n        // Gzip off by default as many popular static hosts such as\n        // Surge or Netlify already gzip all static assets for you.\n        // Before setting to `true`, make sure to:\n        // npm install --save-dev compression-webpack-plugin\n        productionGzip: false,\n        productionGzipExtensions: ['js', 'css'],\n\n        // Run the build command with an extra argument to\n        // View the bundle analyzer report after build finishes:\n        // `npm run build --report`\n        // Set to `true` or `false` to always turn it on or off\n        bundleAnalyzerReport: process.env.npm_config_report\n    }\n}\n\n```\n\n```\nconst origin_proxy_url = 'http://ccs-operation-api.jdcloud.com';\nconst local_proxy_port = 3002;\nconst local_proxy_url = `http://localhost:${local_proxy_port}`;\n\nconst { original } = JSON.parse(process.env.npm_config_argv);\nconst use_local = ~original.indexOf('--local');\nconst proxy_url = use_local\n    ? local_proxy_url\n    : origin_proxy_url;\n\nvar renewal_url = 'http://renewal-console.jcloud.com';\n\nmodule.exports = {\n    origin_proxy_url,\n    local_proxy_port,\n    local_proxy_url,\n    proxy: {\n        '/ccs-api': {\n            target: proxy_url, // 接口域名\n            changeOrigin: true, //是否跨域\n            pathRewrite: {\n                '^/ccs-api': '' //需要rewrite的,\n            }\n        },\n        '/renewal': {\n            target: renewal_url, // 接口域名\n            changeOrigin: true, //是否跨域\n            pathRewrite: {\n                '^/renewal': renewal_url //需要rewrite的,\n            }\n        }\n    }\n}\n\n```","source":"_drafts/express.md","raw":"---\ntitle: express： 实现本地代码+本地mock+环境接口数据\ndate: 2019-09-20 17:29:05\ntags: node\n---\n\nAuthor: Echo\nTime: 2019-09-20 17:29:05\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```\n\n其他补充文件\n```\n// const config = require(\"../vue.config\");\n\n'use strict'\n// Template version: 1.3.1\n// see http://vuejs-templates.github.io/webpack for documentation.\n\nconst path = require('path')\nvar package_name = \"visit\"\nvar proxyConfig = require('./proxyConfig')\nmodule.exports = {\n    dev: {\n\n        // Paths\n        assetsSubDirectory: 'static',\n        assetsPublicPath: '/',\n        proxyTable: proxyConfig.proxy,\n\n        // Various Dev Server settings\n        // host: 'local.console.jdcloud.com', // can be overwritten by process.env.HOST\n        host: 'ccs-operation.jdcloud.com', // can be overwritten by process.env.HOST\n        port: 8084, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined\n        autoOpenBrowser: false,\n        errorOverlay: true,\n        notifyOnErrors: true,\n        poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-\n\n\n        /**\n         * Source Maps\n         */\n\n        // https://webpack.js.org/configuration/devtool/#development\n        devtool: 'cheap-module-eval-source-map',\n\n        // If you have problems debugging vue-files in devtools,\n        // set this to false - it *may* help\n        // https://vue-loader.vuejs.org/en/options.html#cachebusting\n        cacheBusting: true,\n\n        cssSourceMap: true\n    },\n\n    build: {\n        // Template for index.html\n        index: path.resolve(__dirname, '../' + package_name + '/index.html'),\n\n        // Paths\n        assetsRoot: path.resolve(__dirname, '../' + package_name),\n        assetsSubDirectory: 'static',\n        assetsPublicPath: '/',\n\n        /**\n         * Source Maps\n         */\n\n        productionSourceMap: true,\n        // https://webpack.js.org/configuration/devtool/#production\n        devtool: '#source-map',\n\n        // Gzip off by default as many popular static hosts such as\n        // Surge or Netlify already gzip all static assets for you.\n        // Before setting to `true`, make sure to:\n        // npm install --save-dev compression-webpack-plugin\n        productionGzip: false,\n        productionGzipExtensions: ['js', 'css'],\n\n        // Run the build command with an extra argument to\n        // View the bundle analyzer report after build finishes:\n        // `npm run build --report`\n        // Set to `true` or `false` to always turn it on or off\n        bundleAnalyzerReport: process.env.npm_config_report\n    }\n}\n\n```\n\n```\nconst origin_proxy_url = 'http://ccs-operation-api.jdcloud.com';\nconst local_proxy_port = 3002;\nconst local_proxy_url = `http://localhost:${local_proxy_port}`;\n\nconst { original } = JSON.parse(process.env.npm_config_argv);\nconst use_local = ~original.indexOf('--local');\nconst proxy_url = use_local\n    ? local_proxy_url\n    : origin_proxy_url;\n\nvar renewal_url = 'http://renewal-console.jcloud.com';\n\nmodule.exports = {\n    origin_proxy_url,\n    local_proxy_port,\n    local_proxy_url,\n    proxy: {\n        '/ccs-api': {\n            target: proxy_url, // 接口域名\n            changeOrigin: true, //是否跨域\n            pathRewrite: {\n                '^/ccs-api': '' //需要rewrite的,\n            }\n        },\n        '/renewal': {\n            target: renewal_url, // 接口域名\n            changeOrigin: true, //是否跨域\n            pathRewrite: {\n                '^/renewal': renewal_url //需要rewrite的,\n            }\n        }\n    }\n}\n\n```","slug":"express","published":0,"updated":"2020-06-04T10:38:11.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjp8000278p3kank4rrn","content":"<p>Author: Echo<br>Time: 2019-09-20 17:29:05</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>\n<p>其他补充文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;use strict&apos;</span><br><span class=\"line\">// Template version: 1.3.1</span><br><span class=\"line\">// see http://vuejs-templates.github.io/webpack for documentation.</span><br><span class=\"line\"></span><br><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">var package_name = &quot;visit&quot;</span><br><span class=\"line\">var proxyConfig = require(&apos;./proxyConfig&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    dev: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Paths</span><br><span class=\"line\">        assetsSubDirectory: &apos;static&apos;,</span><br><span class=\"line\">        assetsPublicPath: &apos;/&apos;,</span><br><span class=\"line\">        proxyTable: proxyConfig.proxy,</span><br><span class=\"line\"></span><br><span class=\"line\">        // Various Dev Server settings</span><br><span class=\"line\">        // host: &apos;local.console.jdcloud.com&apos;, // can be overwritten by process.env.HOST</span><br><span class=\"line\">        host: &apos;ccs-operation.jdcloud.com&apos;, // can be overwritten by process.env.HOST</span><br><span class=\"line\">        port: 8084, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span><br><span class=\"line\">        autoOpenBrowser: false,</span><br><span class=\"line\">        errorOverlay: true,</span><br><span class=\"line\">        notifyOnErrors: true,</span><br><span class=\"line\">        poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Source Maps</span><br><span class=\"line\">         */</span><br><span class=\"line\"></span><br><span class=\"line\">        // https://webpack.js.org/configuration/devtool/#development</span><br><span class=\"line\">        devtool: &apos;cheap-module-eval-source-map&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // If you have problems debugging vue-files in devtools,</span><br><span class=\"line\">        // set this to false - it *may* help</span><br><span class=\"line\">        // https://vue-loader.vuejs.org/en/options.html#cachebusting</span><br><span class=\"line\">        cacheBusting: true,</span><br><span class=\"line\"></span><br><span class=\"line\">        cssSourceMap: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    build: &#123;</span><br><span class=\"line\">        // Template for index.html</span><br><span class=\"line\">        index: path.resolve(__dirname, &apos;../&apos; + package_name + &apos;/index.html&apos;),</span><br><span class=\"line\"></span><br><span class=\"line\">        // Paths</span><br><span class=\"line\">        assetsRoot: path.resolve(__dirname, &apos;../&apos; + package_name),</span><br><span class=\"line\">        assetsSubDirectory: &apos;static&apos;,</span><br><span class=\"line\">        assetsPublicPath: &apos;/&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Source Maps</span><br><span class=\"line\">         */</span><br><span class=\"line\"></span><br><span class=\"line\">        productionSourceMap: true,</span><br><span class=\"line\">        // https://webpack.js.org/configuration/devtool/#production</span><br><span class=\"line\">        devtool: &apos;#source-map&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // Gzip off by default as many popular static hosts such as</span><br><span class=\"line\">        // Surge or Netlify already gzip all static assets for you.</span><br><span class=\"line\">        // Before setting to `true`, make sure to:</span><br><span class=\"line\">        // npm install --save-dev compression-webpack-plugin</span><br><span class=\"line\">        productionGzip: false,</span><br><span class=\"line\">        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],</span><br><span class=\"line\"></span><br><span class=\"line\">        // Run the build command with an extra argument to</span><br><span class=\"line\">        // View the bundle analyzer report after build finishes:</span><br><span class=\"line\">        // `npm run build --report`</span><br><span class=\"line\">        // Set to `true` or `false` to always turn it on or off</span><br><span class=\"line\">        bundleAnalyzerReport: process.env.npm_config_report</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const origin_proxy_url = &apos;http://ccs-operation-api.jdcloud.com&apos;;</span><br><span class=\"line\">const local_proxy_port = 3002;</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; original &#125; = JSON.parse(process.env.npm_config_argv);</span><br><span class=\"line\">const use_local = ~original.indexOf(&apos;--local&apos;);</span><br><span class=\"line\">const proxy_url = use_local</span><br><span class=\"line\">    ? local_proxy_url</span><br><span class=\"line\">    : origin_proxy_url;</span><br><span class=\"line\"></span><br><span class=\"line\">var renewal_url = &apos;http://renewal-console.jcloud.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    origin_proxy_url,</span><br><span class=\"line\">    local_proxy_port,</span><br><span class=\"line\">    local_proxy_url,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">        &apos;/ccs-api&apos;: &#123;</span><br><span class=\"line\">            target: proxy_url, // 接口域名</span><br><span class=\"line\">            changeOrigin: true, //是否跨域</span><br><span class=\"line\">            pathRewrite: &#123;</span><br><span class=\"line\">                &apos;^/ccs-api&apos;: &apos;&apos; //需要rewrite的,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &apos;/renewal&apos;: &#123;</span><br><span class=\"line\">            target: renewal_url, // 接口域名</span><br><span class=\"line\">            changeOrigin: true, //是否跨域</span><br><span class=\"line\">            pathRewrite: &#123;</span><br><span class=\"line\">                &apos;^/renewal&apos;: renewal_url //需要rewrite的,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 17:29:05</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>\n<p>其他补充文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;use strict&apos;</span><br><span class=\"line\">// Template version: 1.3.1</span><br><span class=\"line\">// see http://vuejs-templates.github.io/webpack for documentation.</span><br><span class=\"line\"></span><br><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">var package_name = &quot;visit&quot;</span><br><span class=\"line\">var proxyConfig = require(&apos;./proxyConfig&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    dev: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Paths</span><br><span class=\"line\">        assetsSubDirectory: &apos;static&apos;,</span><br><span class=\"line\">        assetsPublicPath: &apos;/&apos;,</span><br><span class=\"line\">        proxyTable: proxyConfig.proxy,</span><br><span class=\"line\"></span><br><span class=\"line\">        // Various Dev Server settings</span><br><span class=\"line\">        // host: &apos;local.console.jdcloud.com&apos;, // can be overwritten by process.env.HOST</span><br><span class=\"line\">        host: &apos;ccs-operation.jdcloud.com&apos;, // can be overwritten by process.env.HOST</span><br><span class=\"line\">        port: 8084, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined</span><br><span class=\"line\">        autoOpenBrowser: false,</span><br><span class=\"line\">        errorOverlay: true,</span><br><span class=\"line\">        notifyOnErrors: true,</span><br><span class=\"line\">        poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Source Maps</span><br><span class=\"line\">         */</span><br><span class=\"line\"></span><br><span class=\"line\">        // https://webpack.js.org/configuration/devtool/#development</span><br><span class=\"line\">        devtool: &apos;cheap-module-eval-source-map&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // If you have problems debugging vue-files in devtools,</span><br><span class=\"line\">        // set this to false - it *may* help</span><br><span class=\"line\">        // https://vue-loader.vuejs.org/en/options.html#cachebusting</span><br><span class=\"line\">        cacheBusting: true,</span><br><span class=\"line\"></span><br><span class=\"line\">        cssSourceMap: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    build: &#123;</span><br><span class=\"line\">        // Template for index.html</span><br><span class=\"line\">        index: path.resolve(__dirname, &apos;../&apos; + package_name + &apos;/index.html&apos;),</span><br><span class=\"line\"></span><br><span class=\"line\">        // Paths</span><br><span class=\"line\">        assetsRoot: path.resolve(__dirname, &apos;../&apos; + package_name),</span><br><span class=\"line\">        assetsSubDirectory: &apos;static&apos;,</span><br><span class=\"line\">        assetsPublicPath: &apos;/&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * Source Maps</span><br><span class=\"line\">         */</span><br><span class=\"line\"></span><br><span class=\"line\">        productionSourceMap: true,</span><br><span class=\"line\">        // https://webpack.js.org/configuration/devtool/#production</span><br><span class=\"line\">        devtool: &apos;#source-map&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">        // Gzip off by default as many popular static hosts such as</span><br><span class=\"line\">        // Surge or Netlify already gzip all static assets for you.</span><br><span class=\"line\">        // Before setting to `true`, make sure to:</span><br><span class=\"line\">        // npm install --save-dev compression-webpack-plugin</span><br><span class=\"line\">        productionGzip: false,</span><br><span class=\"line\">        productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],</span><br><span class=\"line\"></span><br><span class=\"line\">        // Run the build command with an extra argument to</span><br><span class=\"line\">        // View the bundle analyzer report after build finishes:</span><br><span class=\"line\">        // `npm run build --report`</span><br><span class=\"line\">        // Set to `true` or `false` to always turn it on or off</span><br><span class=\"line\">        bundleAnalyzerReport: process.env.npm_config_report</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const origin_proxy_url = &apos;http://ccs-operation-api.jdcloud.com&apos;;</span><br><span class=\"line\">const local_proxy_port = 3002;</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; original &#125; = JSON.parse(process.env.npm_config_argv);</span><br><span class=\"line\">const use_local = ~original.indexOf(&apos;--local&apos;);</span><br><span class=\"line\">const proxy_url = use_local</span><br><span class=\"line\">    ? local_proxy_url</span><br><span class=\"line\">    : origin_proxy_url;</span><br><span class=\"line\"></span><br><span class=\"line\">var renewal_url = &apos;http://renewal-console.jcloud.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    origin_proxy_url,</span><br><span class=\"line\">    local_proxy_port,</span><br><span class=\"line\">    local_proxy_url,</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">        &apos;/ccs-api&apos;: &#123;</span><br><span class=\"line\">            target: proxy_url, // 接口域名</span><br><span class=\"line\">            changeOrigin: true, //是否跨域</span><br><span class=\"line\">            pathRewrite: &#123;</span><br><span class=\"line\">                &apos;^/ccs-api&apos;: &apos;&apos; //需要rewrite的,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &apos;/renewal&apos;: &#123;</span><br><span class=\"line\">            target: renewal_url, // 接口域名</span><br><span class=\"line\">            changeOrigin: true, //是否跨域</span><br><span class=\"line\">            pathRewrite: &#123;</span><br><span class=\"line\">                &apos;^/renewal&apos;: renewal_url //需要rewrite的,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"html","_content":"\n\n* htML\n#### 你有用过bdo标签吗？举例说明它的作用是什么？\n```\n// bi-diretion-override\n```\n* 含义：覆盖标签内文本的显示方向\n* 是一个行内元素\n* 有一个属性dir，两个值：\n** rtl: right to left（默认）\n** ltr: left to right\n\n* css\n\n#### 外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\n1. 外边距重叠是什么？\n外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。\n2. 重叠的结果是什么？\n举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。\n3. 怎么防止外边距重叠？\n* 浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）\n* 外层元素padding代替\n* 内层元素透明边框 border:1px solid transparent;\n* 用同一方向的margin，都设置为top或者bottom。\n\n\n* js\n\n#### 举例说明js拖拽用到的事件有哪些？\n使用html的新特性dragable\n* dragstart:拖拽开始时在被拖拽元素上触发此事件. \n  此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件\n* dragover:拖拽时鼠标在目标元素上移动时触发.\n  此时监听器通过阻止浏览器默认行为设置元素为可拖放元素\n* dragleave:拖拽时鼠标移出目标元素时在目标元素上触发\n  此时监听器可以取消掉前面设置的视觉效果.\n* drag:拖拽期间在被拖拽元素上连续触发\n* drop:鼠标在拖放目标上释放时,在拖放目标上触发.\n  此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.\n* dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.\n  将元素从浏览器拖放到操作系统时不会触发此事件.\n\n* web\n#### 项目上线流程是怎样的？\n\n","source":"_drafts/html.md","raw":"---\ntitle: html\ntags:\n---\n\n\n* htML\n#### 你有用过bdo标签吗？举例说明它的作用是什么？\n```\n// bi-diretion-override\n```\n* 含义：覆盖标签内文本的显示方向\n* 是一个行内元素\n* 有一个属性dir，两个值：\n** rtl: right to left（默认）\n** ltr: left to right\n\n* css\n\n#### 外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\n1. 外边距重叠是什么？\n外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。\n2. 重叠的结果是什么？\n举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。\n举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。\n3. 怎么防止外边距重叠？\n* 浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）\n* 外层元素padding代替\n* 内层元素透明边框 border:1px solid transparent;\n* 用同一方向的margin，都设置为top或者bottom。\n\n\n* js\n\n#### 举例说明js拖拽用到的事件有哪些？\n使用html的新特性dragable\n* dragstart:拖拽开始时在被拖拽元素上触发此事件. \n  此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件\n* dragover:拖拽时鼠标在目标元素上移动时触发.\n  此时监听器通过阻止浏览器默认行为设置元素为可拖放元素\n* dragleave:拖拽时鼠标移出目标元素时在目标元素上触发\n  此时监听器可以取消掉前面设置的视觉效果.\n* drag:拖拽期间在被拖拽元素上连续触发\n* drop:鼠标在拖放目标上释放时,在拖放目标上触发.\n  此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.\n* dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.\n  将元素从浏览器拖放到操作系统时不会触发此事件.\n\n* web\n#### 项目上线流程是怎样的？\n\n","slug":"html","published":0,"date":"2019-12-04T12:50:48.219Z","updated":"2019-12-04T12:50:48.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjpo000478p375itisrc","content":"<ul>\n<li><p>htML</p>\n<h4 id=\"你有用过bdo标签吗？举例说明它的作用是什么？\"><a href=\"#你有用过bdo标签吗？举例说明它的作用是什么？\" class=\"headerlink\" title=\"你有用过bdo标签吗？举例说明它的作用是什么？\"></a>你有用过bdo标签吗？举例说明它的作用是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bi-diretion-override</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>含义：覆盖标签内文本的显示方向</p>\n</li>\n<li>是一个行内元素</li>\n<li><p>有一个属性dir，两个值：<br><strong> rtl: right to left（默认）\n</strong> ltr: left to right</p>\n</li>\n<li><p>css</p>\n</li>\n</ul>\n<h4 id=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"><a href=\"#外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\" class=\"headerlink\" title=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"></a>外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？</h4><ol>\n<li>外边距重叠是什么？<br>外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。</li>\n<li>重叠的结果是什么？<br>举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。</li>\n<li>怎么防止外边距重叠？</li>\n</ol>\n<ul>\n<li>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）</li>\n<li>外层元素padding代替</li>\n<li>内层元素透明边框 border:1px solid transparent;</li>\n<li>用同一方向的margin，都设置为top或者bottom。</li>\n</ul>\n<ul>\n<li>js</li>\n</ul>\n<h4 id=\"举例说明js拖拽用到的事件有哪些？\"><a href=\"#举例说明js拖拽用到的事件有哪些？\" class=\"headerlink\" title=\"举例说明js拖拽用到的事件有哪些？\"></a>举例说明js拖拽用到的事件有哪些？</h4><p>使用html的新特性dragable</p>\n<ul>\n<li>dragstart:拖拽开始时在被拖拽元素上触发此事件.<br>此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件</li>\n<li>dragover:拖拽时鼠标在目标元素上移动时触发.<br>此时监听器通过阻止浏览器默认行为设置元素为可拖放元素</li>\n<li>dragleave:拖拽时鼠标移出目标元素时在目标元素上触发<br>此时监听器可以取消掉前面设置的视觉效果.</li>\n<li>drag:拖拽期间在被拖拽元素上连续触发</li>\n<li>drop:鼠标在拖放目标上释放时,在拖放目标上触发.<br>此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.</li>\n<li><p>dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.<br>将元素从浏览器拖放到操作系统时不会触发此事件.</p>\n</li>\n<li><p>web</p>\n<h4 id=\"项目上线流程是怎样的？\"><a href=\"#项目上线流程是怎样的？\" class=\"headerlink\" title=\"项目上线流程是怎样的？\"></a>项目上线流程是怎样的？</h4></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>htML</p>\n<h4 id=\"你有用过bdo标签吗？举例说明它的作用是什么？\"><a href=\"#你有用过bdo标签吗？举例说明它的作用是什么？\" class=\"headerlink\" title=\"你有用过bdo标签吗？举例说明它的作用是什么？\"></a>你有用过bdo标签吗？举例说明它的作用是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bi-diretion-override</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>含义：覆盖标签内文本的显示方向</p>\n</li>\n<li>是一个行内元素</li>\n<li><p>有一个属性dir，两个值：<br><strong> rtl: right to left（默认）\n</strong> ltr: left to right</p>\n</li>\n<li><p>css</p>\n</li>\n</ul>\n<h4 id=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"><a href=\"#外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\" class=\"headerlink\" title=\"外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？\"></a>外边距重叠是什么？重叠的结果是什么？怎么防止外边距重叠？</h4><ol>\n<li>外边距重叠是什么？<br>外边距重叠指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>发生的条件：属于同一个BFC的两个相邻元素上下margin会重叠。</li>\n<li>重叠的结果是什么？<br>举例1：当一个元素出现在另一个元素上面时，重叠后的外边距的高度等于两个发生重叠的外边距的高度中的较大者。<br>举例2： 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生重叠。如果这个外边距遇到另一个元素的外边距，它还会发生重叠。</li>\n<li>怎么防止外边距重叠？</li>\n</ol>\n<ul>\n<li>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（注意这里指的是上下相邻的元素）</li>\n<li>外层元素padding代替</li>\n<li>内层元素透明边框 border:1px solid transparent;</li>\n<li>用同一方向的margin，都设置为top或者bottom。</li>\n</ul>\n<ul>\n<li>js</li>\n</ul>\n<h4 id=\"举例说明js拖拽用到的事件有哪些？\"><a href=\"#举例说明js拖拽用到的事件有哪些？\" class=\"headerlink\" title=\"举例说明js拖拽用到的事件有哪些？\"></a>举例说明js拖拽用到的事件有哪些？</h4><p>使用html的新特性dragable</p>\n<ul>\n<li>dragstart:拖拽开始时在被拖拽元素上触发此事件.<br>此时监听器需要设置拖拽所需数据,从操作系统拖拽文件到浏览器时不触发此事件</li>\n<li>dragover:拖拽时鼠标在目标元素上移动时触发.<br>此时监听器通过阻止浏览器默认行为设置元素为可拖放元素</li>\n<li>dragleave:拖拽时鼠标移出目标元素时在目标元素上触发<br>此时监听器可以取消掉前面设置的视觉效果.</li>\n<li>drag:拖拽期间在被拖拽元素上连续触发</li>\n<li>drop:鼠标在拖放目标上释放时,在拖放目标上触发.<br>此时监听器需要收集数据并且执行所需操作.如果是从操作系统拖放文件到浏览器,需要取消浏览器默认行为.</li>\n<li><p>dragend:鼠标在拖放目标上释放时,在拖拽元素上触发.<br>将元素从浏览器拖放到操作系统时不会触发此事件.</p>\n</li>\n<li><p>web</p>\n<h4 id=\"项目上线流程是怎样的？\"><a href=\"#项目上线流程是怎样的？\" class=\"headerlink\" title=\"项目上线流程是怎样的？\"></a>项目上线流程是怎样的？</h4></li>\n</ul>\n"},{"title":"booknote","_content":"\n《活着》\n* 生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的感受。 —————— 余华\n* 时间创造了诞生和死亡，创造了幸福和痛苦，创造了平静和动荡，创造了记忆和感受，创造了理解和想象，创造了故事和神奇。 —————— 余华\n* 生活是属于每个人自己的感受，不属于任何别人的看法。—————— 余华\n* 人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。—————— 余华\n* 在《活着》这本书中，人去世叫'熟了'。\n人死像熟透的梨，离树而落，梨者，离也。\n\n《游戏人间》\n* 父亲对贾平凹说：\"没事咱不寻事，出了事但不要怕事。\"\n不要被一时得所迷惑，不要被一时的失所迷惘。—————— 贾平凹\n* 人生求缺不求满\n 人是从泥土里来的，终究又变为泥土。—————— 贾平凹\n * 读书本是无用事\n  不要论他人短长是非，也不必计较自己的短长是非让人去论。\n  不热羡，不怨恨，以自己的生命体验着走。\n  这就是性格和命运，命运教导我们心理平衡。—————— 贾平凹\n  * 我在这里看人间\n 为什么活着，怎样去活，\n 大多数人并不知道，也不去理会。\n 但日子就是这样有秩或无秩地过着。\n 如草一样，逢春生绿，东来变黄。—————— 贾平凹\n\n 《许三观卖血记》\n * 海涅：死亡是凉爽的夜晚，生活是痛苦的白天。\n * 一盘爆炒猪肝，二两黄酒。\n  黄酒温一温。—————— 余华\n  \n* 做人要多行善事，不行恶事。做了恶事的话，若不马上改正过来，会糟了老天爷的罚，\n老天爷罚起人来可是一点不留情面，都是把人往死里罚。—————— 余华\n* 屌毛出的比眉毛晚，长得倒是比眉毛长。—————— 余华\n\n《黄金时代》\n\n* 那天我二十一岁，在我一生的黄金时代，我有好的奢望，我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去。奢望也一天天消失，最后像受了槌的牛一样。—————— 王小波\n* 当我沿着一条路走下去的时候，心里总想着另一条路上的事，这种时候我心里很乱。—————— 王小波\n* 人生是一条寂寞的路，要有一本有趣的书来消磨旅途。—————— 王小波\n* 海涅的悲歌：\n 在我的记忆之中，\n 有一朵紫罗兰熠熠生辉，\n 这轻狂的姑娘，我竟未染指！\n 妈的，我好不后悔！！—————— 王小波\n","source":"_drafts/booknote.md","raw":"---\ntitle: booknote\ntags:\n---\n\n《活着》\n* 生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的感受。 —————— 余华\n* 时间创造了诞生和死亡，创造了幸福和痛苦，创造了平静和动荡，创造了记忆和感受，创造了理解和想象，创造了故事和神奇。 —————— 余华\n* 生活是属于每个人自己的感受，不属于任何别人的看法。—————— 余华\n* 人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。—————— 余华\n* 在《活着》这本书中，人去世叫'熟了'。\n人死像熟透的梨，离树而落，梨者，离也。\n\n《游戏人间》\n* 父亲对贾平凹说：\"没事咱不寻事，出了事但不要怕事。\"\n不要被一时得所迷惑，不要被一时的失所迷惘。—————— 贾平凹\n* 人生求缺不求满\n 人是从泥土里来的，终究又变为泥土。—————— 贾平凹\n * 读书本是无用事\n  不要论他人短长是非，也不必计较自己的短长是非让人去论。\n  不热羡，不怨恨，以自己的生命体验着走。\n  这就是性格和命运，命运教导我们心理平衡。—————— 贾平凹\n  * 我在这里看人间\n 为什么活着，怎样去活，\n 大多数人并不知道，也不去理会。\n 但日子就是这样有秩或无秩地过着。\n 如草一样，逢春生绿，东来变黄。—————— 贾平凹\n\n 《许三观卖血记》\n * 海涅：死亡是凉爽的夜晚，生活是痛苦的白天。\n * 一盘爆炒猪肝，二两黄酒。\n  黄酒温一温。—————— 余华\n  \n* 做人要多行善事，不行恶事。做了恶事的话，若不马上改正过来，会糟了老天爷的罚，\n老天爷罚起人来可是一点不留情面，都是把人往死里罚。—————— 余华\n* 屌毛出的比眉毛晚，长得倒是比眉毛长。—————— 余华\n\n《黄金时代》\n\n* 那天我二十一岁，在我一生的黄金时代，我有好的奢望，我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去。奢望也一天天消失，最后像受了槌的牛一样。—————— 王小波\n* 当我沿着一条路走下去的时候，心里总想着另一条路上的事，这种时候我心里很乱。—————— 王小波\n* 人生是一条寂寞的路，要有一本有趣的书来消磨旅途。—————— 王小波\n* 海涅的悲歌：\n 在我的记忆之中，\n 有一朵紫罗兰熠熠生辉，\n 这轻狂的姑娘，我竟未染指！\n 妈的，我好不后悔！！—————— 王小波\n","slug":"booknote","published":0,"date":"2019-12-25T15:04:35.117Z","updated":"2019-12-25T15:04:35.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjps000678p31spo9o3t","content":"<p>《活着》</p>\n<ul>\n<li>生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的感受。 —————— 余华</li>\n<li>时间创造了诞生和死亡，创造了幸福和痛苦，创造了平静和动荡，创造了记忆和感受，创造了理解和想象，创造了故事和神奇。 —————— 余华</li>\n<li>生活是属于每个人自己的感受，不属于任何别人的看法。—————— 余华</li>\n<li>人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。—————— 余华</li>\n<li>在《活着》这本书中，人去世叫’熟了’。<br>人死像熟透的梨，离树而落，梨者，离也。</li>\n</ul>\n<p>《游戏人间》</p>\n<ul>\n<li>父亲对贾平凹说：”没事咱不寻事，出了事但不要怕事。”<br>不要被一时得所迷惑，不要被一时的失所迷惘。—————— 贾平凹</li>\n<li><p>人生求缺不求满<br>人是从泥土里来的，终究又变为泥土。—————— 贾平凹</p>\n<ul>\n<li>读书本是无用事<br>不要论他人短长是非，也不必计较自己的短长是非让人去论。<br>不热羡，不怨恨，以自己的生命体验着走。<br>这就是性格和命运，命运教导我们心理平衡。—————— 贾平凹</li>\n<li>我在这里看人间<br>为什么活着，怎样去活，<br>大多数人并不知道，也不去理会。<br>但日子就是这样有秩或无秩地过着。<br>如草一样，逢春生绿，东来变黄。—————— 贾平凹</li>\n</ul>\n<p>《许三观卖血记》</p>\n<ul>\n<li>海涅：死亡是凉爽的夜晚，生活是痛苦的白天。</li>\n<li>一盘爆炒猪肝，二两黄酒。<br>黄酒温一温。—————— 余华</li>\n</ul>\n</li>\n<li><p>做人要多行善事，不行恶事。做了恶事的话，若不马上改正过来，会糟了老天爷的罚，<br>老天爷罚起人来可是一点不留情面，都是把人往死里罚。—————— 余华</p>\n</li>\n<li>屌毛出的比眉毛晚，长得倒是比眉毛长。—————— 余华</li>\n</ul>\n<p>《黄金时代》</p>\n<ul>\n<li>那天我二十一岁，在我一生的黄金时代，我有好的奢望，我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去。奢望也一天天消失，最后像受了槌的牛一样。—————— 王小波</li>\n<li>当我沿着一条路走下去的时候，心里总想着另一条路上的事，这种时候我心里很乱。—————— 王小波</li>\n<li>人生是一条寂寞的路，要有一本有趣的书来消磨旅途。—————— 王小波</li>\n<li>海涅的悲歌：<br>在我的记忆之中，<br>有一朵紫罗兰熠熠生辉，<br>这轻狂的姑娘，我竟未染指！<br>妈的，我好不后悔！！—————— 王小波</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>《活着》</p>\n<ul>\n<li>生活是一个人对自己经历的感受，而幸存往往是旁观者对别人经历的感受。 —————— 余华</li>\n<li>时间创造了诞生和死亡，创造了幸福和痛苦，创造了平静和动荡，创造了记忆和感受，创造了理解和想象，创造了故事和神奇。 —————— 余华</li>\n<li>生活是属于每个人自己的感受，不属于任何别人的看法。—————— 余华</li>\n<li>人是为活着本身而活着的，而不是为了活着之外的任何事物所活着。—————— 余华</li>\n<li>在《活着》这本书中，人去世叫’熟了’。<br>人死像熟透的梨，离树而落，梨者，离也。</li>\n</ul>\n<p>《游戏人间》</p>\n<ul>\n<li>父亲对贾平凹说：”没事咱不寻事，出了事但不要怕事。”<br>不要被一时得所迷惑，不要被一时的失所迷惘。—————— 贾平凹</li>\n<li><p>人生求缺不求满<br>人是从泥土里来的，终究又变为泥土。—————— 贾平凹</p>\n<ul>\n<li>读书本是无用事<br>不要论他人短长是非，也不必计较自己的短长是非让人去论。<br>不热羡，不怨恨，以自己的生命体验着走。<br>这就是性格和命运，命运教导我们心理平衡。—————— 贾平凹</li>\n<li>我在这里看人间<br>为什么活着，怎样去活，<br>大多数人并不知道，也不去理会。<br>但日子就是这样有秩或无秩地过着。<br>如草一样，逢春生绿，东来变黄。—————— 贾平凹</li>\n</ul>\n<p>《许三观卖血记》</p>\n<ul>\n<li>海涅：死亡是凉爽的夜晚，生活是痛苦的白天。</li>\n<li>一盘爆炒猪肝，二两黄酒。<br>黄酒温一温。—————— 余华</li>\n</ul>\n</li>\n<li><p>做人要多行善事，不行恶事。做了恶事的话，若不马上改正过来，会糟了老天爷的罚，<br>老天爷罚起人来可是一点不留情面，都是把人往死里罚。—————— 余华</p>\n</li>\n<li>屌毛出的比眉毛晚，长得倒是比眉毛长。—————— 余华</li>\n</ul>\n<p>《黄金时代》</p>\n<ul>\n<li>那天我二十一岁，在我一生的黄金时代，我有好的奢望，我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去。奢望也一天天消失，最后像受了槌的牛一样。—————— 王小波</li>\n<li>当我沿着一条路走下去的时候，心里总想着另一条路上的事，这种时候我心里很乱。—————— 王小波</li>\n<li>人生是一条寂寞的路，要有一本有趣的书来消磨旅途。—————— 王小波</li>\n<li>海涅的悲歌：<br>在我的记忆之中，<br>有一朵紫罗兰熠熠生辉，<br>这轻狂的姑娘，我竟未染指！<br>妈的，我好不后悔！！—————— 王小波</li>\n</ul>\n"},{"title":"jsTitle","_content":"promise.md\n#### promise\n\njsTitle\n#### 宏任务、微任务\n\n\n\n\n\n\n\n\n\n\n\n\n#### 用原生JS封装插件的方式有哪些？-156\n\n问题参考链接： https://github.com/haizlin/fe-interview/issues/1223\n\n#### HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\n\n#### 如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\n\n\n## window.load 和$(document).ready() 区别\n\n* 执行时间\n\nwindow.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n* 执行的次数不同\n\nwindow.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n$(document).ready()可以同时编写多个，并且都可以得到执行 \n\n* 简化写法 \n\nwindow.onload没有简化写法 \n\n$(document).ready(function(){})可以简写成$(function(){});","source":"_drafts/jsTitle.md","raw":"---\ntitle: jsTitle\ntags:\n---\npromise.md\n#### promise\n\njsTitle\n#### 宏任务、微任务\n\n\n\n\n\n\n\n\n\n\n\n\n#### 用原生JS封装插件的方式有哪些？-156\n\n问题参考链接： https://github.com/haizlin/fe-interview/issues/1223\n\n#### HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\n\n#### 如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\n\n\n## window.load 和$(document).ready() 区别\n\n* 执行时间\n\nwindow.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n* 执行的次数不同\n\nwindow.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n$(document).ready()可以同时编写多个，并且都可以得到执行 \n\n* 简化写法 \n\nwindow.onload没有简化写法 \n\n$(document).ready(function(){})可以简写成$(function(){});","slug":"jsTitle","published":0,"date":"2019-12-04T12:50:48.219Z","updated":"2019-12-04T12:50:48.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjpu000778p3drv34uiq","content":"<p>promise.md</p>\n<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>jsTitle</p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><h4 id=\"用原生JS封装插件的方式有哪些？-156\"><a href=\"#用原生JS封装插件的方式有哪些？-156\" class=\"headerlink\" title=\"用原生JS封装插件的方式有哪些？-156\"></a>用原生JS封装插件的方式有哪些？-156</h4><p>问题参考链接： <a href=\"https://github.com/haizlin/fe-interview/issues/1223\" target=\"_blank\" rel=\"noopener\">https://github.com/haizlin/fe-interview/issues/1223</a></p>\n<h4 id=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"><a href=\"#HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\" class=\"headerlink\" title=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"></a>HTML5的video在有的移动端设备无法自动播放？怎么解决？-156</h4><h4 id=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"><a href=\"#如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\" class=\"headerlink\" title=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"></a>如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156</h4><h2 id=\"window-load-和-document-ready-区别\"><a href=\"#window-load-和-document-ready-区别\" class=\"headerlink\" title=\"window.load 和$(document).ready() 区别\"></a>window.load 和$(document).ready() 区别</h2><ul>\n<li>执行时间</li>\n</ul>\n<p>window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 </p>\n<p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</p>\n<ul>\n<li>执行的次数不同</li>\n</ul>\n<p>window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。</p>\n<p>$(document).ready()可以同时编写多个，并且都可以得到执行 </p>\n<ul>\n<li>简化写法 </li>\n</ul>\n<p>window.onload没有简化写法 </p>\n<p>$(document).ready(function(){})可以简写成$(function(){});</p>\n","site":{"data":{}},"excerpt":"","more":"<p>promise.md</p>\n<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>jsTitle</p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><h4 id=\"用原生JS封装插件的方式有哪些？-156\"><a href=\"#用原生JS封装插件的方式有哪些？-156\" class=\"headerlink\" title=\"用原生JS封装插件的方式有哪些？-156\"></a>用原生JS封装插件的方式有哪些？-156</h4><p>问题参考链接： <a href=\"https://github.com/haizlin/fe-interview/issues/1223\" target=\"_blank\" rel=\"noopener\">https://github.com/haizlin/fe-interview/issues/1223</a></p>\n<h4 id=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"><a href=\"#HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\" class=\"headerlink\" title=\"HTML5的video在有的移动端设备无法自动播放？怎么解决？-156\"></a>HTML5的video在有的移动端设备无法自动播放？怎么解决？-156</h4><h4 id=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"><a href=\"#如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\" class=\"headerlink\" title=\"如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156\"></a>如何让你做一个文件无刷新上传的功能，你有哪些方法可以做到？-156</h4><h2 id=\"window-load-和-document-ready-区别\"><a href=\"#window-load-和-document-ready-区别\" class=\"headerlink\" title=\"window.load 和$(document).ready() 区别\"></a>window.load 和$(document).ready() 区别</h2><ul>\n<li>执行时间</li>\n</ul>\n<p>window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 </p>\n<p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</p>\n<ul>\n<li>执行的次数不同</li>\n</ul>\n<p>window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。</p>\n<p>$(document).ready()可以同时编写多个，并且都可以得到执行 </p>\n<ul>\n<li>简化写法 </li>\n</ul>\n<p>window.onload没有简化写法 </p>\n<p>$(document).ready(function(){})可以简写成$(function(){});</p>\n"},{"title":"webpack","_content":"\n\n\n\n## 深度解析日常写的webpack配置\n\n#### 代码分割到底是在分割啥\nvue-cli2时打包会生成`app.js` `vendor.js` `manifest.js`\n###### 代码分割的目的\n* 多页面应用\n   提取公共依赖：把几个页面中用到的依赖打包成一个单独的文件。\n* 单页面应用\n  减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。\n* 为了业务代码的纯净\n  不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。\n###### 代码分割的方法\n* 多页面应用\n  zu：把几个页面中用到的依赖打包成一个单独的文件。\n* 单页面应用\n  减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。\n* 为了业务代码的纯净\n  不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。\n\n\n#### 开发模式怎么手动搭建\n#### 插件和loder的本质是啥\n\n## 如何从api曾入手，让项目做的更快更好\n\n#### 如何管理自己项目的api层\n#### axios拦截思路\n#### 如何二次封装请求库\n\n\n","source":"_drafts/parseWebpack.md","raw":"---\ntitle: webpack\ntags:\n---\n\n\n\n\n## 深度解析日常写的webpack配置\n\n#### 代码分割到底是在分割啥\nvue-cli2时打包会生成`app.js` `vendor.js` `manifest.js`\n###### 代码分割的目的\n* 多页面应用\n   提取公共依赖：把几个页面中用到的依赖打包成一个单独的文件。\n* 单页面应用\n  减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。\n* 为了业务代码的纯净\n  不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。\n###### 代码分割的方法\n* 多页面应用\n  zu：把几个页面中用到的依赖打包成一个单独的文件。\n* 单页面应用\n  减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。\n* 为了业务代码的纯净\n  不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。\n\n\n#### 开发模式怎么手动搭建\n#### 插件和loder的本质是啥\n\n## 如何从api曾入手，让项目做的更快更好\n\n#### 如何管理自己项目的api层\n#### axios拦截思路\n#### 如何二次封装请求库\n\n\n","slug":"parseWebpack","published":0,"date":"2020-05-07T06:13:19.803Z","updated":"2020-05-08T09:33:56.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjpv000878p3xzj5g5r3","content":"<h2 id=\"深度解析日常写的webpack配置\"><a href=\"#深度解析日常写的webpack配置\" class=\"headerlink\" title=\"深度解析日常写的webpack配置\"></a>深度解析日常写的webpack配置</h2><h4 id=\"代码分割到底是在分割啥\"><a href=\"#代码分割到底是在分割啥\" class=\"headerlink\" title=\"代码分割到底是在分割啥\"></a>代码分割到底是在分割啥</h4><p>vue-cli2时打包会生成<code>app.js</code> <code>vendor.js</code> <code>manifest.js</code></p>\n<h6 id=\"代码分割的目的\"><a href=\"#代码分割的目的\" class=\"headerlink\" title=\"代码分割的目的\"></a>代码分割的目的</h6><ul>\n<li>多页面应用<br> 提取公共依赖：把几个页面中用到的依赖打包成一个单独的文件。</li>\n<li>单页面应用<br>减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。</li>\n<li>为了业务代码的纯净<br>不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。<h6 id=\"代码分割的方法\"><a href=\"#代码分割的方法\" class=\"headerlink\" title=\"代码分割的方法\"></a>代码分割的方法</h6></li>\n<li>多页面应用<br>zu：把几个页面中用到的依赖打包成一个单独的文件。</li>\n<li>单页面应用<br>减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。</li>\n<li>为了业务代码的纯净<br>不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。</li>\n</ul>\n<h4 id=\"开发模式怎么手动搭建\"><a href=\"#开发模式怎么手动搭建\" class=\"headerlink\" title=\"开发模式怎么手动搭建\"></a>开发模式怎么手动搭建</h4><h4 id=\"插件和loder的本质是啥\"><a href=\"#插件和loder的本质是啥\" class=\"headerlink\" title=\"插件和loder的本质是啥\"></a>插件和loder的本质是啥</h4><h2 id=\"如何从api曾入手，让项目做的更快更好\"><a href=\"#如何从api曾入手，让项目做的更快更好\" class=\"headerlink\" title=\"如何从api曾入手，让项目做的更快更好\"></a>如何从api曾入手，让项目做的更快更好</h2><h4 id=\"如何管理自己项目的api层\"><a href=\"#如何管理自己项目的api层\" class=\"headerlink\" title=\"如何管理自己项目的api层\"></a>如何管理自己项目的api层</h4><h4 id=\"axios拦截思路\"><a href=\"#axios拦截思路\" class=\"headerlink\" title=\"axios拦截思路\"></a>axios拦截思路</h4><h4 id=\"如何二次封装请求库\"><a href=\"#如何二次封装请求库\" class=\"headerlink\" title=\"如何二次封装请求库\"></a>如何二次封装请求库</h4>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"深度解析日常写的webpack配置\"><a href=\"#深度解析日常写的webpack配置\" class=\"headerlink\" title=\"深度解析日常写的webpack配置\"></a>深度解析日常写的webpack配置</h2><h4 id=\"代码分割到底是在分割啥\"><a href=\"#代码分割到底是在分割啥\" class=\"headerlink\" title=\"代码分割到底是在分割啥\"></a>代码分割到底是在分割啥</h4><p>vue-cli2时打包会生成<code>app.js</code> <code>vendor.js</code> <code>manifest.js</code></p>\n<h6 id=\"代码分割的目的\"><a href=\"#代码分割的目的\" class=\"headerlink\" title=\"代码分割的目的\"></a>代码分割的目的</h6><ul>\n<li>多页面应用<br> 提取公共依赖：把几个页面中用到的依赖打包成一个单独的文件。</li>\n<li>单页面应用<br>减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。</li>\n<li>为了业务代码的纯净<br>不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。<h6 id=\"代码分割的方法\"><a href=\"#代码分割的方法\" class=\"headerlink\" title=\"代码分割的方法\"></a>代码分割的方法</h6></li>\n<li>多页面应用<br>zu：把几个页面中用到的依赖打包成一个单独的文件。</li>\n<li>单页面应用<br>减少文件提及，拆分应用： 把需要异步加载的内容改成异步加载。</li>\n<li>为了业务代码的纯净<br>不希望业务代码中混入第三方代码或webpack配置代码：把第三方代码或webpack配置代码拆分为单独的文件。</li>\n</ul>\n<h4 id=\"开发模式怎么手动搭建\"><a href=\"#开发模式怎么手动搭建\" class=\"headerlink\" title=\"开发模式怎么手动搭建\"></a>开发模式怎么手动搭建</h4><h4 id=\"插件和loder的本质是啥\"><a href=\"#插件和loder的本质是啥\" class=\"headerlink\" title=\"插件和loder的本质是啥\"></a>插件和loder的本质是啥</h4><h2 id=\"如何从api曾入手，让项目做的更快更好\"><a href=\"#如何从api曾入手，让项目做的更快更好\" class=\"headerlink\" title=\"如何从api曾入手，让项目做的更快更好\"></a>如何从api曾入手，让项目做的更快更好</h2><h4 id=\"如何管理自己项目的api层\"><a href=\"#如何管理自己项目的api层\" class=\"headerlink\" title=\"如何管理自己项目的api层\"></a>如何管理自己项目的api层</h4><h4 id=\"axios拦截思路\"><a href=\"#axios拦截思路\" class=\"headerlink\" title=\"axios拦截思路\"></a>axios拦截思路</h4><h4 id=\"如何二次封装请求库\"><a href=\"#如何二次封装请求库\" class=\"headerlink\" title=\"如何二次封装请求库\"></a>如何二次封装请求库</h4>"},{"title":"react相关面试题汇总","_content":"\n\n* relay框架：基于react的数据驱动框架。\n* formik库： 表单库：https://jaredpalmer.com/formik/docs/api/formik#props\n            https://www.jianshu.com/p/fdb7623487a0\n\n\n##### 组件的生命周期\n##### 组件通信\n\n##### Redux & react-redux\n\n##### 什么时候使用状态管理器？\n##### render函数中return如果没有使用()会有什么问题？\n##### componentWillUpdate可以直接修改state的值吗？\n##### 组件通信？\n##### 组件的生命周期？\n##### 对 React Context 的理解以及应用？\n##### 说说你对windowing的了解-react-window和react-virtualized？\n\n\n\n\n##### React Intl是什么原理？\n","source":"_drafts/reactTitle.md","raw":"---\ntitle: react相关面试题汇总\ntags: 前端面试题\n---\n\n\n* relay框架：基于react的数据驱动框架。\n* formik库： 表单库：https://jaredpalmer.com/formik/docs/api/formik#props\n            https://www.jianshu.com/p/fdb7623487a0\n\n\n##### 组件的生命周期\n##### 组件通信\n\n##### Redux & react-redux\n\n##### 什么时候使用状态管理器？\n##### render函数中return如果没有使用()会有什么问题？\n##### componentWillUpdate可以直接修改state的值吗？\n##### 组件通信？\n##### 组件的生命周期？\n##### 对 React Context 的理解以及应用？\n##### 说说你对windowing的了解-react-window和react-virtualized？\n\n\n\n\n##### React Intl是什么原理？\n","slug":"reactTitle","published":0,"date":"2019-12-14T10:29:55.946Z","updated":"2019-12-14T10:29:55.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjpw000a78p3x55hdanh","content":"<ul>\n<li>relay框架：基于react的数据驱动框架。</li>\n<li>formik库： 表单库：<a href=\"https://jaredpalmer.com/formik/docs/api/formik#props\" target=\"_blank\" rel=\"noopener\">https://jaredpalmer.com/formik/docs/api/formik#props</a><pre><code>https://www.jianshu.com/p/fdb7623487a0\n</code></pre></li>\n</ul>\n<h5 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h5><h5 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h5><h5 id=\"Redux-amp-react-redux\"><a href=\"#Redux-amp-react-redux\" class=\"headerlink\" title=\"Redux &amp; react-redux\"></a>Redux &amp; react-redux</h5><h5 id=\"什么时候使用状态管理器？\"><a href=\"#什么时候使用状态管理器？\" class=\"headerlink\" title=\"什么时候使用状态管理器？\"></a>什么时候使用状态管理器？</h5><h5 id=\"render函数中return如果没有使用-会有什么问题？\"><a href=\"#render函数中return如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"render函数中return如果没有使用()会有什么问题？\"></a>render函数中return如果没有使用()会有什么问题？</h5><h5 id=\"componentWillUpdate可以直接修改state的值吗？\"><a href=\"#componentWillUpdate可以直接修改state的值吗？\" class=\"headerlink\" title=\"componentWillUpdate可以直接修改state的值吗？\"></a>componentWillUpdate可以直接修改state的值吗？</h5><h5 id=\"组件通信？\"><a href=\"#组件通信？\" class=\"headerlink\" title=\"组件通信？\"></a>组件通信？</h5><h5 id=\"组件的生命周期？\"><a href=\"#组件的生命周期？\" class=\"headerlink\" title=\"组件的生命周期？\"></a>组件的生命周期？</h5><h5 id=\"对-React-Context-的理解以及应用？\"><a href=\"#对-React-Context-的理解以及应用？\" class=\"headerlink\" title=\"对 React Context 的理解以及应用？\"></a>对 React Context 的理解以及应用？</h5><h5 id=\"说说你对windowing的了解-react-window和react-virtualized？\"><a href=\"#说说你对windowing的了解-react-window和react-virtualized？\" class=\"headerlink\" title=\"说说你对windowing的了解-react-window和react-virtualized？\"></a>说说你对windowing的了解-react-window和react-virtualized？</h5><h5 id=\"React-Intl是什么原理？\"><a href=\"#React-Intl是什么原理？\" class=\"headerlink\" title=\"React Intl是什么原理？\"></a>React Intl是什么原理？</h5>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>relay框架：基于react的数据驱动框架。</li>\n<li>formik库： 表单库：<a href=\"https://jaredpalmer.com/formik/docs/api/formik#props\" target=\"_blank\" rel=\"noopener\">https://jaredpalmer.com/formik/docs/api/formik#props</a><pre><code>https://www.jianshu.com/p/fdb7623487a0\n</code></pre></li>\n</ul>\n<h5 id=\"组件的生命周期\"><a href=\"#组件的生命周期\" class=\"headerlink\" title=\"组件的生命周期\"></a>组件的生命周期</h5><h5 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h5><h5 id=\"Redux-amp-react-redux\"><a href=\"#Redux-amp-react-redux\" class=\"headerlink\" title=\"Redux &amp; react-redux\"></a>Redux &amp; react-redux</h5><h5 id=\"什么时候使用状态管理器？\"><a href=\"#什么时候使用状态管理器？\" class=\"headerlink\" title=\"什么时候使用状态管理器？\"></a>什么时候使用状态管理器？</h5><h5 id=\"render函数中return如果没有使用-会有什么问题？\"><a href=\"#render函数中return如果没有使用-会有什么问题？\" class=\"headerlink\" title=\"render函数中return如果没有使用()会有什么问题？\"></a>render函数中return如果没有使用()会有什么问题？</h5><h5 id=\"componentWillUpdate可以直接修改state的值吗？\"><a href=\"#componentWillUpdate可以直接修改state的值吗？\" class=\"headerlink\" title=\"componentWillUpdate可以直接修改state的值吗？\"></a>componentWillUpdate可以直接修改state的值吗？</h5><h5 id=\"组件通信？\"><a href=\"#组件通信？\" class=\"headerlink\" title=\"组件通信？\"></a>组件通信？</h5><h5 id=\"组件的生命周期？\"><a href=\"#组件的生命周期？\" class=\"headerlink\" title=\"组件的生命周期？\"></a>组件的生命周期？</h5><h5 id=\"对-React-Context-的理解以及应用？\"><a href=\"#对-React-Context-的理解以及应用？\" class=\"headerlink\" title=\"对 React Context 的理解以及应用？\"></a>对 React Context 的理解以及应用？</h5><h5 id=\"说说你对windowing的了解-react-window和react-virtualized？\"><a href=\"#说说你对windowing的了解-react-window和react-virtualized？\" class=\"headerlink\" title=\"说说你对windowing的了解-react-window和react-virtualized？\"></a>说说你对windowing的了解-react-window和react-virtualized？</h5><h5 id=\"React-Intl是什么原理？\"><a href=\"#React-Intl是什么原理？\" class=\"headerlink\" title=\"React Intl是什么原理？\"></a>React Intl是什么原理？</h5>"},{"title":"question","_content":"## 安装全局包报没权限\n解决方法，运行：sudo npm install -g @vue/cli\n## 打开/usr/local\n1.Mac下/usr/local目录默认是对于Finder是隐藏,如果需要到/usr/local下去,打开Finder,然后使用command+shift+G,在弹出的目录中填写/usr/local就可以了。\n## 关联本地文件夹到github项目\n```\ngit init\ngit remote add origin https://自己的仓库url地址\ngit status\ngit add .\ngit commit -m '[提交内容的描述]'\n先 push，以后才能 pull：git push --set-upstream origin master\n再 git pull\n撤销 git init 命令：\nrm -rf .git\n\n撤销 git add . 命令：\ngit rm -rf --cached .\n\n\n\n回退到某个commit\n第一步： git clone [git-url] -b [branch-name]\n\n第二步：git reset --hard [commit-number]\n```\n* `webTitle`: 浏览器解析过程?\n* `webTitle`: HTTP response报文结构是怎样的\n* `vueSourceCoding`:看一下这个https://www.cnblogs.com/zhuzhenwei918/p/9266407.html 百度搜索一下`vue serverPrefetch`& https://zhuanlan.zhihu.com/p/25936718\n\n#### 在jd的电脑提交代码到github上需要重定向密钥：\n\neval $(ssh-agent -s)\nwindows:ssh-add ~/.ssh/lujing163\nmac: ssh-add ~/.ssh/github\nwx8e506d9ea5a0a3de\nhttps://ssr.vuejs.org/zh/\nhttps://cn.vuejs.org/v2/guide/ssr.html\n* 看一下process.env.NODE_ENV是怎么回事 https://www.jb51.net/article/126838.htm\n\n\n* mac:总结一下github中怎么发布的doc和myzone这两个项目\n* mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&发布组件到npm上\n\n\n\n* 看一下前端工程化（媛媛之前分享）\n* 了解骨架屏\n* 了解一下typeScript\n* 了解一下webpack\n* 了解一下node\n* 了解一下deep,样式穿透。\n* 了解一下github中的vue+express&写一下思路。\n* 看一下redux 中dispatch怎么实现换执行触发reducer\n* 看一下redux 中connect\n* 熟悉一下async await ,什么时候会用到\n* 单页面和多页面应用的区别。\n* 一个项目怎么支持多入口\n\n\n* React Intl是什么原理？  在react项目中实现国际化\n参考链接：https://www.jianshu.com/p/c57e000c2bbf\n\n\n\n\nreact 生命周期函数图片\n<!-- ![react.png](https://github.com/bailicangdu/pxq/raw/master/screenshot/react-lifecycle.png)\n![REDUX.png](值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起) -->\n\n\nreact https://www.ru23.com/note/55bd244d.html 看一下\nhttps://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html： 汤姆大叔\nhttps://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#summaryview fiddler  /charles\n\n\n\n# 项目中遇到的问题\n* 安全工单报高级警告：一般是项目中依赖包版本过低。需要更新到指定版本以上。\n解决办法：正常情况下是直接更新packjson中对应的依赖包就可以啦，但是有些工单所警告的依赖包是其他顶层依赖的深层依赖，在packjson 中搜索不到，处理办法是在packjson-lock中搜索警告的依赖包名称，因为这个底层依赖包可能 有很多 顶层依赖引用，所以需要针对报错的依赖进行更新，只能更新对应的顶层依赖，我当时是先更新到npm上介绍的最新版本，后来发现打包的时候报错。然后我将当前依赖包更新到当前版本的最新版本，解决了这个问题。\n\n## 请问你在项目中做了什么？\n这个项目为了seo和加快首屏加载速度，进行了一个ssr渲染，\n* 然后用了很多性能优化实例：\n1. 懒加载\n2. 多平台适配方案\n3. 中间层\n\n* 有难度的任务\n1. 进行了技术攻坚\n2. 打包速度过慢，优化打包操作，加快打包速度\n\n* 基础设施建设\n1. 对项目做了初始化模版\n2. 封装了组件库\n3. express + mock\n4. 二次封装了axios\n5. 针对路由进行了菜单和权限配置\n6. 实现了动态路由\n7. 定义前端规范md\n\n...\n\ngithub中vue-demo项目视频地址：https://www.youtube.com/watch?v=Fa4cRMaTDUI\n\n\n* react组件库基础搭建参考地址：https://github.com/c10342/lin-ui\n\n* ssr : nuxt框架","source":"_drafts/question.md","raw":"---\ntitle: question\ntags:\n---\n## 安装全局包报没权限\n解决方法，运行：sudo npm install -g @vue/cli\n## 打开/usr/local\n1.Mac下/usr/local目录默认是对于Finder是隐藏,如果需要到/usr/local下去,打开Finder,然后使用command+shift+G,在弹出的目录中填写/usr/local就可以了。\n## 关联本地文件夹到github项目\n```\ngit init\ngit remote add origin https://自己的仓库url地址\ngit status\ngit add .\ngit commit -m '[提交内容的描述]'\n先 push，以后才能 pull：git push --set-upstream origin master\n再 git pull\n撤销 git init 命令：\nrm -rf .git\n\n撤销 git add . 命令：\ngit rm -rf --cached .\n\n\n\n回退到某个commit\n第一步： git clone [git-url] -b [branch-name]\n\n第二步：git reset --hard [commit-number]\n```\n* `webTitle`: 浏览器解析过程?\n* `webTitle`: HTTP response报文结构是怎样的\n* `vueSourceCoding`:看一下这个https://www.cnblogs.com/zhuzhenwei918/p/9266407.html 百度搜索一下`vue serverPrefetch`& https://zhuanlan.zhihu.com/p/25936718\n\n#### 在jd的电脑提交代码到github上需要重定向密钥：\n\neval $(ssh-agent -s)\nwindows:ssh-add ~/.ssh/lujing163\nmac: ssh-add ~/.ssh/github\nwx8e506d9ea5a0a3de\nhttps://ssr.vuejs.org/zh/\nhttps://cn.vuejs.org/v2/guide/ssr.html\n* 看一下process.env.NODE_ENV是怎么回事 https://www.jb51.net/article/126838.htm\n\n\n* mac:总结一下github中怎么发布的doc和myzone这两个项目\n* mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&发布组件到npm上\n\n\n\n* 看一下前端工程化（媛媛之前分享）\n* 了解骨架屏\n* 了解一下typeScript\n* 了解一下webpack\n* 了解一下node\n* 了解一下deep,样式穿透。\n* 了解一下github中的vue+express&写一下思路。\n* 看一下redux 中dispatch怎么实现换执行触发reducer\n* 看一下redux 中connect\n* 熟悉一下async await ,什么时候会用到\n* 单页面和多页面应用的区别。\n* 一个项目怎么支持多入口\n\n\n* React Intl是什么原理？  在react项目中实现国际化\n参考链接：https://www.jianshu.com/p/c57e000c2bbf\n\n\n\n\nreact 生命周期函数图片\n<!-- ![react.png](https://github.com/bailicangdu/pxq/raw/master/screenshot/react-lifecycle.png)\n![REDUX.png](值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起) -->\n\n\nreact https://www.ru23.com/note/55bd244d.html 看一下\nhttps://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html： 汤姆大叔\nhttps://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#summaryview fiddler  /charles\n\n\n\n# 项目中遇到的问题\n* 安全工单报高级警告：一般是项目中依赖包版本过低。需要更新到指定版本以上。\n解决办法：正常情况下是直接更新packjson中对应的依赖包就可以啦，但是有些工单所警告的依赖包是其他顶层依赖的深层依赖，在packjson 中搜索不到，处理办法是在packjson-lock中搜索警告的依赖包名称，因为这个底层依赖包可能 有很多 顶层依赖引用，所以需要针对报错的依赖进行更新，只能更新对应的顶层依赖，我当时是先更新到npm上介绍的最新版本，后来发现打包的时候报错。然后我将当前依赖包更新到当前版本的最新版本，解决了这个问题。\n\n## 请问你在项目中做了什么？\n这个项目为了seo和加快首屏加载速度，进行了一个ssr渲染，\n* 然后用了很多性能优化实例：\n1. 懒加载\n2. 多平台适配方案\n3. 中间层\n\n* 有难度的任务\n1. 进行了技术攻坚\n2. 打包速度过慢，优化打包操作，加快打包速度\n\n* 基础设施建设\n1. 对项目做了初始化模版\n2. 封装了组件库\n3. express + mock\n4. 二次封装了axios\n5. 针对路由进行了菜单和权限配置\n6. 实现了动态路由\n7. 定义前端规范md\n\n...\n\ngithub中vue-demo项目视频地址：https://www.youtube.com/watch?v=Fa4cRMaTDUI\n\n\n* react组件库基础搭建参考地址：https://github.com/c10342/lin-ui\n\n* ssr : nuxt框架","slug":"question","published":0,"date":"2019-12-25T15:04:35.118Z","updated":"2020-11-26T02:31:31.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjpz000b78p3tzcea1xo","content":"<h2 id=\"安装全局包报没权限\"><a href=\"#安装全局包报没权限\" class=\"headerlink\" title=\"安装全局包报没权限\"></a>安装全局包报没权限</h2><p>解决方法，运行：sudo npm install -g @vue/cli</p>\n<h2 id=\"打开-usr-local\"><a href=\"#打开-usr-local\" class=\"headerlink\" title=\"打开/usr/local\"></a>打开/usr/local</h2><p>1.Mac下/usr/local目录默认是对于Finder是隐藏,如果需要到/usr/local下去,打开Finder,然后使用command+shift+G,在弹出的目录中填写/usr/local就可以了。</p>\n<h2 id=\"关联本地文件夹到github项目\"><a href=\"#关联本地文件夹到github项目\" class=\"headerlink\" title=\"关联本地文件夹到github项目\"></a>关联本地文件夹到github项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin https://自己的仓库url地址</span><br><span class=\"line\">git status</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &apos;[提交内容的描述]&apos;</span><br><span class=\"line\">先 push，以后才能 pull：git push --set-upstream origin master</span><br><span class=\"line\">再 git pull</span><br><span class=\"line\">撤销 git init 命令：</span><br><span class=\"line\">rm -rf .git</span><br><span class=\"line\"></span><br><span class=\"line\">撤销 git add . 命令：</span><br><span class=\"line\">git rm -rf --cached .</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回退到某个commit</span><br><span class=\"line\">第一步： git clone [git-url] -b [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\">第二步：git reset --hard [commit-number]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>webTitle</code>: 浏览器解析过程?</li>\n<li><code>webTitle</code>: HTTP response报文结构是怎样的</li>\n<li><code>vueSourceCoding</code>:看一下这个<a href=\"https://www.cnblogs.com/zhuzhenwei918/p/9266407.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhuzhenwei918/p/9266407.html</a> 百度搜索一下<code>vue serverPrefetch</code>&amp; <a href=\"https://zhuanlan.zhihu.com/p/25936718\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25936718</a></li>\n</ul>\n<h4 id=\"在jd的电脑提交代码到github上需要重定向密钥：\"><a href=\"#在jd的电脑提交代码到github上需要重定向密钥：\" class=\"headerlink\" title=\"在jd的电脑提交代码到github上需要重定向密钥：\"></a>在jd的电脑提交代码到github上需要重定向密钥：</h4><p>eval $(ssh-agent -s)<br>windows:ssh-add ~/.ssh/lujing163<br>mac: ssh-add ~/.ssh/github<br>wx8e506d9ea5a0a3de<br><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">https://ssr.vuejs.org/zh/</a><br><a href=\"https://cn.vuejs.org/v2/guide/ssr.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/ssr.html</a></p>\n<ul>\n<li>看一下process.env.NODE_ENV是怎么回事 <a href=\"https://www.jb51.net/article/126838.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/126838.htm</a></li>\n</ul>\n<ul>\n<li>mac:总结一下github中怎么发布的doc和myzone这两个项目</li>\n<li>mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&amp;发布组件到npm上</li>\n</ul>\n<ul>\n<li>看一下前端工程化（媛媛之前分享）</li>\n<li>了解骨架屏</li>\n<li>了解一下typeScript</li>\n<li>了解一下webpack</li>\n<li>了解一下node</li>\n<li>了解一下deep,样式穿透。</li>\n<li>了解一下github中的vue+express&amp;写一下思路。</li>\n<li>看一下redux 中dispatch怎么实现换执行触发reducer</li>\n<li>看一下redux 中connect</li>\n<li>熟悉一下async await ,什么时候会用到</li>\n<li>单页面和多页面应用的区别。</li>\n<li>一个项目怎么支持多入口</li>\n</ul>\n<ul>\n<li>React Intl是什么原理？  在react项目中实现国际化<br>参考链接：<a href=\"https://www.jianshu.com/p/c57e000c2bbf\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c57e000c2bbf</a></li>\n</ul>\n<p>react 生命周期函数图片<br><!-- ![react.png](https://github.com/bailicangdu/pxq/raw/master/screenshot/react-lifecycle.png)\n![REDUX.png](值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起) --></p>\n<p>react <a href=\"https://www.ru23.com/note/55bd244d.html\" target=\"_blank\" rel=\"noopener\">https://www.ru23.com/note/55bd244d.html</a> 看一下<br><a href=\"https://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html：\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html：</a> 汤姆大叔<br><a href=\"https://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#summaryview\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#summaryview</a> fiddler  /charles</p>\n<h1 id=\"项目中遇到的问题\"><a href=\"#项目中遇到的问题\" class=\"headerlink\" title=\"项目中遇到的问题\"></a>项目中遇到的问题</h1><ul>\n<li>安全工单报高级警告：一般是项目中依赖包版本过低。需要更新到指定版本以上。<br>解决办法：正常情况下是直接更新packjson中对应的依赖包就可以啦，但是有些工单所警告的依赖包是其他顶层依赖的深层依赖，在packjson 中搜索不到，处理办法是在packjson-lock中搜索警告的依赖包名称，因为这个底层依赖包可能 有很多 顶层依赖引用，所以需要针对报错的依赖进行更新，只能更新对应的顶层依赖，我当时是先更新到npm上介绍的最新版本，后来发现打包的时候报错。然后我将当前依赖包更新到当前版本的最新版本，解决了这个问题。</li>\n</ul>\n<h2 id=\"请问你在项目中做了什么？\"><a href=\"#请问你在项目中做了什么？\" class=\"headerlink\" title=\"请问你在项目中做了什么？\"></a>请问你在项目中做了什么？</h2><p>这个项目为了seo和加快首屏加载速度，进行了一个ssr渲染，</p>\n<ul>\n<li>然后用了很多性能优化实例：</li>\n</ul>\n<ol>\n<li>懒加载</li>\n<li>多平台适配方案</li>\n<li>中间层</li>\n</ol>\n<ul>\n<li>有难度的任务</li>\n</ul>\n<ol>\n<li>进行了技术攻坚</li>\n<li>打包速度过慢，优化打包操作，加快打包速度</li>\n</ol>\n<ul>\n<li>基础设施建设</li>\n</ul>\n<ol>\n<li>对项目做了初始化模版</li>\n<li>封装了组件库</li>\n<li>express + mock</li>\n<li>二次封装了axios</li>\n<li>针对路由进行了菜单和权限配置</li>\n<li>实现了动态路由</li>\n<li>定义前端规范md</li>\n</ol>\n<p>…</p>\n<p>github中vue-demo项目视频地址：<a href=\"https://www.youtube.com/watch?v=Fa4cRMaTDUI\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Fa4cRMaTDUI</a></p>\n<ul>\n<li><p>react组件库基础搭建参考地址：<a href=\"https://github.com/c10342/lin-ui\" target=\"_blank\" rel=\"noopener\">https://github.com/c10342/lin-ui</a></p>\n</li>\n<li><p>ssr : nuxt框架</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装全局包报没权限\"><a href=\"#安装全局包报没权限\" class=\"headerlink\" title=\"安装全局包报没权限\"></a>安装全局包报没权限</h2><p>解决方法，运行：sudo npm install -g @vue/cli</p>\n<h2 id=\"打开-usr-local\"><a href=\"#打开-usr-local\" class=\"headerlink\" title=\"打开/usr/local\"></a>打开/usr/local</h2><p>1.Mac下/usr/local目录默认是对于Finder是隐藏,如果需要到/usr/local下去,打开Finder,然后使用command+shift+G,在弹出的目录中填写/usr/local就可以了。</p>\n<h2 id=\"关联本地文件夹到github项目\"><a href=\"#关联本地文件夹到github项目\" class=\"headerlink\" title=\"关联本地文件夹到github项目\"></a>关联本地文件夹到github项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin https://自己的仓库url地址</span><br><span class=\"line\">git status</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &apos;[提交内容的描述]&apos;</span><br><span class=\"line\">先 push，以后才能 pull：git push --set-upstream origin master</span><br><span class=\"line\">再 git pull</span><br><span class=\"line\">撤销 git init 命令：</span><br><span class=\"line\">rm -rf .git</span><br><span class=\"line\"></span><br><span class=\"line\">撤销 git add . 命令：</span><br><span class=\"line\">git rm -rf --cached .</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回退到某个commit</span><br><span class=\"line\">第一步： git clone [git-url] -b [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\">第二步：git reset --hard [commit-number]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>webTitle</code>: 浏览器解析过程?</li>\n<li><code>webTitle</code>: HTTP response报文结构是怎样的</li>\n<li><code>vueSourceCoding</code>:看一下这个<a href=\"https://www.cnblogs.com/zhuzhenwei918/p/9266407.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhuzhenwei918/p/9266407.html</a> 百度搜索一下<code>vue serverPrefetch</code>&amp; <a href=\"https://zhuanlan.zhihu.com/p/25936718\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25936718</a></li>\n</ul>\n<h4 id=\"在jd的电脑提交代码到github上需要重定向密钥：\"><a href=\"#在jd的电脑提交代码到github上需要重定向密钥：\" class=\"headerlink\" title=\"在jd的电脑提交代码到github上需要重定向密钥：\"></a>在jd的电脑提交代码到github上需要重定向密钥：</h4><p>eval $(ssh-agent -s)<br>windows:ssh-add ~/.ssh/lujing163<br>mac: ssh-add ~/.ssh/github<br>wx8e506d9ea5a0a3de<br><a href=\"https://ssr.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">https://ssr.vuejs.org/zh/</a><br><a href=\"https://cn.vuejs.org/v2/guide/ssr.html\" target=\"_blank\" rel=\"noopener\">https://cn.vuejs.org/v2/guide/ssr.html</a></p>\n<ul>\n<li>看一下process.env.NODE_ENV是怎么回事 <a href=\"https://www.jb51.net/article/126838.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/126838.htm</a></li>\n</ul>\n<ul>\n<li>mac:总结一下github中怎么发布的doc和myzone这两个项目</li>\n<li>mac:将华清的组件库和可视化大屏整理成组件库和项目汇总&amp;发布组件到npm上</li>\n</ul>\n<ul>\n<li>看一下前端工程化（媛媛之前分享）</li>\n<li>了解骨架屏</li>\n<li>了解一下typeScript</li>\n<li>了解一下webpack</li>\n<li>了解一下node</li>\n<li>了解一下deep,样式穿透。</li>\n<li>了解一下github中的vue+express&amp;写一下思路。</li>\n<li>看一下redux 中dispatch怎么实现换执行触发reducer</li>\n<li>看一下redux 中connect</li>\n<li>熟悉一下async await ,什么时候会用到</li>\n<li>单页面和多页面应用的区别。</li>\n<li>一个项目怎么支持多入口</li>\n</ul>\n<ul>\n<li>React Intl是什么原理？  在react项目中实现国际化<br>参考链接：<a href=\"https://www.jianshu.com/p/c57e000c2bbf\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c57e000c2bbf</a></li>\n</ul>\n<p>react 生命周期函数图片<br><!-- ![react.png](https://github.com/bailicangdu/pxq/raw/master/screenshot/react-lifecycle.png)\n![REDUX.png](值得注意的是connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起) --></p>\n<p>react <a href=\"https://www.ru23.com/note/55bd244d.html\" target=\"_blank\" rel=\"noopener\">https://www.ru23.com/note/55bd244d.html</a> 看一下<br><a href=\"https://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html：\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html：</a> 汤姆大叔<br><a href=\"https://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#summaryview\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#summaryview</a> fiddler  /charles</p>\n<h1 id=\"项目中遇到的问题\"><a href=\"#项目中遇到的问题\" class=\"headerlink\" title=\"项目中遇到的问题\"></a>项目中遇到的问题</h1><ul>\n<li>安全工单报高级警告：一般是项目中依赖包版本过低。需要更新到指定版本以上。<br>解决办法：正常情况下是直接更新packjson中对应的依赖包就可以啦，但是有些工单所警告的依赖包是其他顶层依赖的深层依赖，在packjson 中搜索不到，处理办法是在packjson-lock中搜索警告的依赖包名称，因为这个底层依赖包可能 有很多 顶层依赖引用，所以需要针对报错的依赖进行更新，只能更新对应的顶层依赖，我当时是先更新到npm上介绍的最新版本，后来发现打包的时候报错。然后我将当前依赖包更新到当前版本的最新版本，解决了这个问题。</li>\n</ul>\n<h2 id=\"请问你在项目中做了什么？\"><a href=\"#请问你在项目中做了什么？\" class=\"headerlink\" title=\"请问你在项目中做了什么？\"></a>请问你在项目中做了什么？</h2><p>这个项目为了seo和加快首屏加载速度，进行了一个ssr渲染，</p>\n<ul>\n<li>然后用了很多性能优化实例：</li>\n</ul>\n<ol>\n<li>懒加载</li>\n<li>多平台适配方案</li>\n<li>中间层</li>\n</ol>\n<ul>\n<li>有难度的任务</li>\n</ul>\n<ol>\n<li>进行了技术攻坚</li>\n<li>打包速度过慢，优化打包操作，加快打包速度</li>\n</ol>\n<ul>\n<li>基础设施建设</li>\n</ul>\n<ol>\n<li>对项目做了初始化模版</li>\n<li>封装了组件库</li>\n<li>express + mock</li>\n<li>二次封装了axios</li>\n<li>针对路由进行了菜单和权限配置</li>\n<li>实现了动态路由</li>\n<li>定义前端规范md</li>\n</ol>\n<p>…</p>\n<p>github中vue-demo项目视频地址：<a href=\"https://www.youtube.com/watch?v=Fa4cRMaTDUI\" target=\"_blank\" rel=\"noopener\">https://www.youtube.com/watch?v=Fa4cRMaTDUI</a></p>\n<ul>\n<li><p>react组件库基础搭建参考地址：<a href=\"https://github.com/c10342/lin-ui\" target=\"_blank\" rel=\"noopener\">https://github.com/c10342/lin-ui</a></p>\n</li>\n<li><p>ssr : nuxt框架</p>\n</li>\n</ul>\n"},{"title":"skeletons","date":"2020-11-26T02:22:20.000Z","_content":"\n### 前端项目模版-开发流程\n\n##### 1、初始化项目\n```\n$ npm init \n// 生成package.json\n$ commitizen init cz-conventional-changelog --save --save-exact \n// 添加changelog依赖包\n```\n* 安装生成 Change log 的工具\n\n```\n$ npm install -g conventional-changelog-cli\n```\n配置脚本+执行`npm run changelog`生成changelog文件\n\n```\n\"scripts\": {\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 0\"\n  },\n```\n* 配置`eslint`+`prettier`\n```\n$ npm install --save-dev prettier eslint-plugin-prettier\n```\n添加`.eslintrc.js`文件\n```\n\"lint-staged\": {\n    \"*.{js,vue}\": [\n      \"npm run lint:es\",\n      \"git add\"\n    ],\n    \"*.ts\": [\n      \"npm run lint:ts\",\n      \"git add\"\n    ]\n  }`\n  ```\n添加`.eslintignore`文件\n```\n// 配置语法检查忽略的文件\n```\n配置eslint 执行脚本\n```\n\"lint:ts\": \"cd server && npm run lint\",\n    \"lint:es\": \"cd client && npm run lint\",\n```\n\n* 添加`.gitignore`文件\n\n* 配置git提交规范\n\n参考文章：https://www.jianshu.com/p/cdd749c624d9\n参考文章：https://www.cnblogs.com/daysme/p/7722474.html\n// 参考文章：https://segmentfault.com/a/1190000017790694\n```\n$ npm i --save-dev husky lint-staged\n```\n添加 hook 函数\n```\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"lint-staged\",\n    // git commit 执行这个命令，这个命令在调起 lint-staged\n    // \"commit-msg\": \"node scripts/verify-commit-msg.js\"\n    // 暂时不用，因为项目中使用changelog依赖\n  }\n}\n// validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。\n```\n配置`lint-staged`\n```\n\"lint-staged\": {\n    \"*.{js,vue}\": [\n      \"npm run lint:es\",\n      \"git add\"\n    ],\n    \"*.ts\": [\n      \"npm run lint:ts\",\n      \"git add\"\n    ]\n  }\n```\n\n## 创建serve项目\n通过egg+ts框架\n参考文档：https://eggjs.org/zh-cn/intro/quickstart.html\n\n```\n$ mkdir server\n$ cd server\n$ npm init egg --type=ts\n$ npm i \n$\n```\n* server项目中使用typescript\n```\n$ npm install --save-dev typescript tslint\n```\n\n\n","source":"_drafts/skeletons.md","raw":"---\ntitle: skeletons\ndate: 2020-11-26 10:22:20\ntags:\n---\n\n### 前端项目模版-开发流程\n\n##### 1、初始化项目\n```\n$ npm init \n// 生成package.json\n$ commitizen init cz-conventional-changelog --save --save-exact \n// 添加changelog依赖包\n```\n* 安装生成 Change log 的工具\n\n```\n$ npm install -g conventional-changelog-cli\n```\n配置脚本+执行`npm run changelog`生成changelog文件\n\n```\n\"scripts\": {\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 0\"\n  },\n```\n* 配置`eslint`+`prettier`\n```\n$ npm install --save-dev prettier eslint-plugin-prettier\n```\n添加`.eslintrc.js`文件\n```\n\"lint-staged\": {\n    \"*.{js,vue}\": [\n      \"npm run lint:es\",\n      \"git add\"\n    ],\n    \"*.ts\": [\n      \"npm run lint:ts\",\n      \"git add\"\n    ]\n  }`\n  ```\n添加`.eslintignore`文件\n```\n// 配置语法检查忽略的文件\n```\n配置eslint 执行脚本\n```\n\"lint:ts\": \"cd server && npm run lint\",\n    \"lint:es\": \"cd client && npm run lint\",\n```\n\n* 添加`.gitignore`文件\n\n* 配置git提交规范\n\n参考文章：https://www.jianshu.com/p/cdd749c624d9\n参考文章：https://www.cnblogs.com/daysme/p/7722474.html\n// 参考文章：https://segmentfault.com/a/1190000017790694\n```\n$ npm i --save-dev husky lint-staged\n```\n添加 hook 函数\n```\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"lint-staged\",\n    // git commit 执行这个命令，这个命令在调起 lint-staged\n    // \"commit-msg\": \"node scripts/verify-commit-msg.js\"\n    // 暂时不用，因为项目中使用changelog依赖\n  }\n}\n// validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。\n```\n配置`lint-staged`\n```\n\"lint-staged\": {\n    \"*.{js,vue}\": [\n      \"npm run lint:es\",\n      \"git add\"\n    ],\n    \"*.ts\": [\n      \"npm run lint:ts\",\n      \"git add\"\n    ]\n  }\n```\n\n## 创建serve项目\n通过egg+ts框架\n参考文档：https://eggjs.org/zh-cn/intro/quickstart.html\n\n```\n$ mkdir server\n$ cd server\n$ npm init egg --type=ts\n$ npm i \n$\n```\n* server项目中使用typescript\n```\n$ npm install --save-dev typescript tslint\n```\n\n\n","slug":"skeletons","published":0,"updated":"2020-12-14T08:34:53.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjq2000d78p3awftif3t","content":"<h3 id=\"前端项目模版-开发流程\"><a href=\"#前端项目模版-开发流程\" class=\"headerlink\" title=\"前端项目模版-开发流程\"></a>前端项目模版-开发流程</h3><h5 id=\"1、初始化项目\"><a href=\"#1、初始化项目\" class=\"headerlink\" title=\"1、初始化项目\"></a>1、初始化项目</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init </span><br><span class=\"line\">// 生成package.json</span><br><span class=\"line\">$ commitizen init cz-conventional-changelog --save --save-exact </span><br><span class=\"line\">// 添加changelog依赖包</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装生成 Change log 的工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure>\n<p>配置脚本+执行<code>npm run changelog</code>生成changelog文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>配置<code>eslint</code>+<code>prettier</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev prettier eslint-plugin-prettier</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加<code>.eslintrc.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;*.&#123;js,vue&#125;&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:es&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;*.ts&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:ts&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;`</span><br></pre></td></tr></table></figure></p>\n<p>添加<code>.eslintignore</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 配置语法检查忽略的文件</span><br></pre></td></tr></table></figure></p>\n<p>配置eslint 执行脚本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;lint:ts&quot;: &quot;cd server &amp;&amp; npm run lint&quot;,</span><br><span class=\"line\">    &quot;lint:es&quot;: &quot;cd client &amp;&amp; npm run lint&quot;,</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>添加<code>.gitignore</code>文件</p>\n</li>\n<li><p>配置git提交规范</p>\n</li>\n</ul>\n<p>参考文章：<a href=\"https://www.jianshu.com/p/cdd749c624d9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/cdd749c624d9</a><br>参考文章：<a href=\"https://www.cnblogs.com/daysme/p/7722474.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/daysme/p/7722474.html</a><br>// 参考文章：<a href=\"https://segmentfault.com/a/1190000017790694\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017790694</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i --save-dev husky lint-staged</span><br></pre></td></tr></table></figure></p>\n<p>添加 hook 函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;lint-staged&quot;,</span><br><span class=\"line\">    // git commit 执行这个命令，这个命令在调起 lint-staged</span><br><span class=\"line\">    // &quot;commit-msg&quot;: &quot;node scripts/verify-commit-msg.js&quot;</span><br><span class=\"line\">    // 暂时不用，因为项目中使用changelog依赖</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。</span><br></pre></td></tr></table></figure></p>\n<p>配置<code>lint-staged</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;*.&#123;js,vue&#125;&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:es&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;*.ts&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:ts&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建serve项目\"><a href=\"#创建serve项目\" class=\"headerlink\" title=\"创建serve项目\"></a>创建serve项目</h2><p>通过egg+ts框架<br>参考文档：<a href=\"https://eggjs.org/zh-cn/intro/quickstart.html\" target=\"_blank\" rel=\"noopener\">https://eggjs.org/zh-cn/intro/quickstart.html</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir server</span><br><span class=\"line\">$ cd server</span><br><span class=\"line\">$ npm init egg --type=ts</span><br><span class=\"line\">$ npm i </span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n<ul>\n<li>server项目中使用typescript<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev typescript tslint</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前端项目模版-开发流程\"><a href=\"#前端项目模版-开发流程\" class=\"headerlink\" title=\"前端项目模版-开发流程\"></a>前端项目模版-开发流程</h3><h5 id=\"1、初始化项目\"><a href=\"#1、初始化项目\" class=\"headerlink\" title=\"1、初始化项目\"></a>1、初始化项目</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm init </span><br><span class=\"line\">// 生成package.json</span><br><span class=\"line\">$ commitizen init cz-conventional-changelog --save --save-exact </span><br><span class=\"line\">// 添加changelog依赖包</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装生成 Change log 的工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure>\n<p>配置脚本+执行<code>npm run changelog</code>生成changelog文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>配置<code>eslint</code>+<code>prettier</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev prettier eslint-plugin-prettier</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加<code>.eslintrc.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;*.&#123;js,vue&#125;&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:es&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;*.ts&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:ts&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;`</span><br></pre></td></tr></table></figure></p>\n<p>添加<code>.eslintignore</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 配置语法检查忽略的文件</span><br></pre></td></tr></table></figure></p>\n<p>配置eslint 执行脚本<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;lint:ts&quot;: &quot;cd server &amp;&amp; npm run lint&quot;,</span><br><span class=\"line\">    &quot;lint:es&quot;: &quot;cd client &amp;&amp; npm run lint&quot;,</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>添加<code>.gitignore</code>文件</p>\n</li>\n<li><p>配置git提交规范</p>\n</li>\n</ul>\n<p>参考文章：<a href=\"https://www.jianshu.com/p/cdd749c624d9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/cdd749c624d9</a><br>参考文章：<a href=\"https://www.cnblogs.com/daysme/p/7722474.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/daysme/p/7722474.html</a><br>// 参考文章：<a href=\"https://segmentfault.com/a/1190000017790694\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017790694</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm i --save-dev husky lint-staged</span><br></pre></td></tr></table></figure></p>\n<p>添加 hook 函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;lint-staged&quot;,</span><br><span class=\"line\">    // git commit 执行这个命令，这个命令在调起 lint-staged</span><br><span class=\"line\">    // &quot;commit-msg&quot;: &quot;node scripts/verify-commit-msg.js&quot;</span><br><span class=\"line\">    // 暂时不用，因为项目中使用changelog依赖</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// validate-commit-msg 用于检查 Node 项目的 Commit message 是否符合格式。</span><br></pre></td></tr></table></figure></p>\n<p>配置<code>lint-staged</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;lint-staged&quot;: &#123;</span><br><span class=\"line\">    &quot;*.&#123;js,vue&#125;&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:es&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;*.ts&quot;: [</span><br><span class=\"line\">      &quot;npm run lint:ts&quot;,</span><br><span class=\"line\">      &quot;git add&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建serve项目\"><a href=\"#创建serve项目\" class=\"headerlink\" title=\"创建serve项目\"></a>创建serve项目</h2><p>通过egg+ts框架<br>参考文档：<a href=\"https://eggjs.org/zh-cn/intro/quickstart.html\" target=\"_blank\" rel=\"noopener\">https://eggjs.org/zh-cn/intro/quickstart.html</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir server</span><br><span class=\"line\">$ cd server</span><br><span class=\"line\">$ npm init egg --type=ts</span><br><span class=\"line\">$ npm i </span><br><span class=\"line\">$</span><br></pre></td></tr></table></figure>\n<ul>\n<li>server项目中使用typescript<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save-dev typescript tslint</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"storybook","_content":"\n# 关于storyBook\n\n在现有的vue项目上 自动搭建 storybook\n\n```\n自动搭建\nnpx -p @storybook/cli sb init --type vue\n\n```\n\n### 调试\nnpm run storybook\n\n### 打包\nnpm run build-storybook","source":"_drafts/storybook.md","raw":"---\ntitle: storybook\ntags:\n---\n\n# 关于storyBook\n\n在现有的vue项目上 自动搭建 storybook\n\n```\n自动搭建\nnpx -p @storybook/cli sb init --type vue\n\n```\n\n### 调试\nnpm run storybook\n\n### 打包\nnpm run build-storybook","slug":"storybook","published":0,"date":"2019-12-04T12:50:48.220Z","updated":"2019-12-04T12:50:48.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjq4000e78p3072j6ajw","content":"<h1 id=\"关于storyBook\"><a href=\"#关于storyBook\" class=\"headerlink\" title=\"关于storyBook\"></a>关于storyBook</h1><p>在现有的vue项目上 自动搭建 storybook</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动搭建</span><br><span class=\"line\">npx -p @storybook/cli sb init --type vue</span><br></pre></td></tr></table></figure>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>npm run storybook</p>\n<h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><p>npm run build-storybook</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于storyBook\"><a href=\"#关于storyBook\" class=\"headerlink\" title=\"关于storyBook\"></a>关于storyBook</h1><p>在现有的vue项目上 自动搭建 storybook</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">自动搭建</span><br><span class=\"line\">npx -p @storybook/cli sb init --type vue</span><br></pre></td></tr></table></figure>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>npm run storybook</p>\n<h3 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h3><p>npm run build-storybook</p>\n"},{"title":"studyEnglish","_content":"\n\n* online: https://dictionary.cambridge.org/\n\n* book: English Grammar In Use\n\n* movie: friends\n\ngonna: /ˈɡɑː.nə/--(going to)\n      What are you gonna say ?\nwanna: /ˈwɑː.nə/--(short form of \"want to\" or \"want a\")\n\n      Do you wanna go now?\n      I wanna hamburger, Mom.\n\nguy: /ɡaɪ/--(a man)\n      \n      He's a really nice guy\n      Do you mean the guy with the blonde hair and glasses?\nguy: --(used to address a group of people of either sex)大家，伙计们\n      Come on, you guys, let's go.\n\nThis guy says hello, I wanna kill myself.\n\naura: /ˈɔːr.ə/--(气氛、氛围、气息)\n      The woods have an aura of mystery.\n      There's an aura of sadness about him.\n\npants: /pænts/--(裤子)\n      a pair of pants\n      Echo needs some new pants and vests/vest/.\n\nmetaphor: /ˈmet̬.ə.fɔːr/--(比喻)\n      Is's a metaphor.\nidiot: /ˈɪd.i.ət/--(白痴、笨蛋)\n      I'am such an idiot\n\ngotta: /ˈɡɑː.t̬ə/--(have got to)\n      I gotta go home\n      he's gotta be kidding\n\npregnant: /ˈpreɡ.nənt/--(怀孕)\n      She's five and a half months pregnant\n\ncalm： /kɑːm/--(冷静、平静)\n      He has a very calm manner\n\ninvolved： /ɪnˈvɑːlvd/--(卷入、参与、牵连、影响)\n\nbasically：  /ˈbeɪ.sɪ.kəl.i/\n            Yes, that's basically correct\n\nimplicate： /ˈɪm.plə.keɪt/--(牵涉，涉及)      \n      Don't implicate the innocent别牵连好人，别咬好人/ˈɪn.ə.sənt/（无罪的）\nridiculous: /rɪˈdɪk.jə.ləs/--(愚蠢的；荒唐的；可笑的)  \n      Don't be so ridiculous! \nreward: /rɪˈwɔːrd/--(報答；報償；酬謝；獎賞)  \n      There's a reward for whoever finishes first\nflaw /flɑː/ 錯誤；缺點；缺陷，瑕疵\n            a character flaw  /ˈker.ək.tɚ/\ncigarette /ˈsɪɡ.ə.ret/\n      She lit a cigarette.\n      a packet of cigarettes packet","source":"_drafts/studyEnglish.md","raw":"---\ntitle: studyEnglish\ntags:\n---\n\n\n* online: https://dictionary.cambridge.org/\n\n* book: English Grammar In Use\n\n* movie: friends\n\ngonna: /ˈɡɑː.nə/--(going to)\n      What are you gonna say ?\nwanna: /ˈwɑː.nə/--(short form of \"want to\" or \"want a\")\n\n      Do you wanna go now?\n      I wanna hamburger, Mom.\n\nguy: /ɡaɪ/--(a man)\n      \n      He's a really nice guy\n      Do you mean the guy with the blonde hair and glasses?\nguy: --(used to address a group of people of either sex)大家，伙计们\n      Come on, you guys, let's go.\n\nThis guy says hello, I wanna kill myself.\n\naura: /ˈɔːr.ə/--(气氛、氛围、气息)\n      The woods have an aura of mystery.\n      There's an aura of sadness about him.\n\npants: /pænts/--(裤子)\n      a pair of pants\n      Echo needs some new pants and vests/vest/.\n\nmetaphor: /ˈmet̬.ə.fɔːr/--(比喻)\n      Is's a metaphor.\nidiot: /ˈɪd.i.ət/--(白痴、笨蛋)\n      I'am such an idiot\n\ngotta: /ˈɡɑː.t̬ə/--(have got to)\n      I gotta go home\n      he's gotta be kidding\n\npregnant: /ˈpreɡ.nənt/--(怀孕)\n      She's five and a half months pregnant\n\ncalm： /kɑːm/--(冷静、平静)\n      He has a very calm manner\n\ninvolved： /ɪnˈvɑːlvd/--(卷入、参与、牵连、影响)\n\nbasically：  /ˈbeɪ.sɪ.kəl.i/\n            Yes, that's basically correct\n\nimplicate： /ˈɪm.plə.keɪt/--(牵涉，涉及)      \n      Don't implicate the innocent别牵连好人，别咬好人/ˈɪn.ə.sənt/（无罪的）\nridiculous: /rɪˈdɪk.jə.ləs/--(愚蠢的；荒唐的；可笑的)  \n      Don't be so ridiculous! \nreward: /rɪˈwɔːrd/--(報答；報償；酬謝；獎賞)  \n      There's a reward for whoever finishes first\nflaw /flɑː/ 錯誤；缺點；缺陷，瑕疵\n            a character flaw  /ˈker.ək.tɚ/\ncigarette /ˈsɪɡ.ə.ret/\n      She lit a cigarette.\n      a packet of cigarettes packet","slug":"studyEnglish","published":0,"date":"2019-12-25T15:04:35.118Z","updated":"2019-12-25T15:04:35.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjq6000f78p3wpbqmhyq","content":"<ul>\n<li><p>online: <a href=\"https://dictionary.cambridge.org/\" target=\"_blank\" rel=\"noopener\">https://dictionary.cambridge.org/</a></p>\n</li>\n<li><p>book: English Grammar In Use</p>\n</li>\n<li><p>movie: friends</p>\n</li>\n</ul>\n<p>gonna: /ˈɡɑː.nə/–(going to)<br>      What are you gonna say ?<br>wanna: /ˈwɑː.nə/–(short form of “want to” or “want a”)</p>\n<pre><code>Do you wanna go now?\nI wanna hamburger, Mom.\n</code></pre><p>guy: /ɡaɪ/–(a man)</p>\n<pre><code>He&apos;s a really nice guy\nDo you mean the guy with the blonde hair and glasses?\n</code></pre><p>guy: –(used to address a group of people of either sex)大家，伙计们<br>      Come on, you guys, let’s go.</p>\n<p>This guy says hello, I wanna kill myself.</p>\n<p>aura: /ˈɔːr.ə/–(气氛、氛围、气息)<br>      The woods have an aura of mystery.<br>      There’s an aura of sadness about him.</p>\n<p>pants: /pænts/–(裤子)<br>      a pair of pants<br>      Echo needs some new pants and vests/vest/.</p>\n<p>metaphor: /ˈmet̬.ə.fɔːr/–(比喻)<br>      Is’s a metaphor.<br>idiot: /ˈɪd.i.ət/–(白痴、笨蛋)<br>      I’am such an idiot</p>\n<p>gotta: /ˈɡɑː.t̬ə/–(have got to)<br>      I gotta go home<br>      he’s gotta be kidding</p>\n<p>pregnant: /ˈpreɡ.nənt/–(怀孕)<br>      She’s five and a half months pregnant</p>\n<p>calm： /kɑːm/–(冷静、平静)<br>      He has a very calm manner</p>\n<p>involved： /ɪnˈvɑːlvd/–(卷入、参与、牵连、影响)</p>\n<p>basically：  /ˈbeɪ.sɪ.kəl.i/<br>            Yes, that’s basically correct</p>\n<p>implicate： /ˈɪm.plə.keɪt/–(牵涉，涉及)<br>      Don’t implicate the innocent别牵连好人，别咬好人/ˈɪn.ə.sənt/（无罪的）<br>ridiculous: /rɪˈdɪk.jə.ləs/–(愚蠢的；荒唐的；可笑的)<br>      Don’t be so ridiculous!<br>reward: /rɪˈwɔːrd/–(報答；報償；酬謝；獎賞)<br>      There’s a reward for whoever finishes first<br>flaw /flɑː/ 錯誤；缺點；缺陷，瑕疵<br>            a character flaw  /ˈker.ək.tɚ/<br>cigarette /ˈsɪɡ.ə.ret/<br>      She lit a cigarette.<br>      a packet of cigarettes packet</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>online: <a href=\"https://dictionary.cambridge.org/\" target=\"_blank\" rel=\"noopener\">https://dictionary.cambridge.org/</a></p>\n</li>\n<li><p>book: English Grammar In Use</p>\n</li>\n<li><p>movie: friends</p>\n</li>\n</ul>\n<p>gonna: /ˈɡɑː.nə/–(going to)<br>      What are you gonna say ?<br>wanna: /ˈwɑː.nə/–(short form of “want to” or “want a”)</p>\n<pre><code>Do you wanna go now?\nI wanna hamburger, Mom.\n</code></pre><p>guy: /ɡaɪ/–(a man)</p>\n<pre><code>He&apos;s a really nice guy\nDo you mean the guy with the blonde hair and glasses?\n</code></pre><p>guy: –(used to address a group of people of either sex)大家，伙计们<br>      Come on, you guys, let’s go.</p>\n<p>This guy says hello, I wanna kill myself.</p>\n<p>aura: /ˈɔːr.ə/–(气氛、氛围、气息)<br>      The woods have an aura of mystery.<br>      There’s an aura of sadness about him.</p>\n<p>pants: /pænts/–(裤子)<br>      a pair of pants<br>      Echo needs some new pants and vests/vest/.</p>\n<p>metaphor: /ˈmet̬.ə.fɔːr/–(比喻)<br>      Is’s a metaphor.<br>idiot: /ˈɪd.i.ət/–(白痴、笨蛋)<br>      I’am such an idiot</p>\n<p>gotta: /ˈɡɑː.t̬ə/–(have got to)<br>      I gotta go home<br>      he’s gotta be kidding</p>\n<p>pregnant: /ˈpreɡ.nənt/–(怀孕)<br>      She’s five and a half months pregnant</p>\n<p>calm： /kɑːm/–(冷静、平静)<br>      He has a very calm manner</p>\n<p>involved： /ɪnˈvɑːlvd/–(卷入、参与、牵连、影响)</p>\n<p>basically：  /ˈbeɪ.sɪ.kəl.i/<br>            Yes, that’s basically correct</p>\n<p>implicate： /ˈɪm.plə.keɪt/–(牵涉，涉及)<br>      Don’t implicate the innocent别牵连好人，别咬好人/ˈɪn.ə.sənt/（无罪的）<br>ridiculous: /rɪˈdɪk.jə.ləs/–(愚蠢的；荒唐的；可笑的)<br>      Don’t be so ridiculous!<br>reward: /rɪˈwɔːrd/–(報答；報償；酬謝；獎賞)<br>      There’s a reward for whoever finishes first<br>flaw /flɑː/ 錯誤；缺點；缺陷，瑕疵<br>            a character flaw  /ˈker.ək.tɚ/<br>cigarette /ˈsɪɡ.ə.ret/<br>      She lit a cigarette.<br>      a packet of cigarettes packet</p>\n"},{"title":"test","_content":"\n\n## 一个密码生成器，并同时写一个密码强度校验的方法 \n\n```\n/**\n/*方法说明\n *@createPassword 密码范围 {0-9，A-Z, a-z}\n *@param\n * num {num} 生成密码长度\n *  b {num} 密码生成类型，1: 数字， 2:数字+小写，3.数字+大小写\n *@return {str} \n*/\n**/\nlet createPassword = function (num, b) {\n    let n = 0 //循环次数\n    let arr = new Array // 随机数保存\n    let Capitalization = () => Math.floor(Math.random() * b)// 随机取数0-2/0-1\n    let randomNumber = [() => Math.floor(Math.random() * (57 - 48 + 1) + 48), () => Math.floor(Math.random() * (122 - 97 + 1) + 97), () => Math.floor(Math.random() * (90 - 65 + 1) + 65)] // 去随机值\n    for (let i = 0; i < num; i++) {\n        arr.push(randomNumber[Capitalization()]())\n    }\n    return arr.map(e => String.fromCharCode(e)).join('')\n}\n\n/*方法说明\n *@method passwordStrength 密码强度校验\n *@for 所属类名\n *@param \n *        num{str} 密码\n *        len {num} 密码长度\n *@return {str} 返回密码等级\n\n      str    ASCII\n      0-9    48-57\n      A-Z    65-90\n      a-z    97-122\n\n */\nlet passwordStrength = function (num, len) {\n    if(num.length<len) return '密码长度不够'\n    let passwordLevel = ['弱', '普通', '较强', '强']\n    let arr = new Array(4) // 记录密码等级\n    num.split('').map(e => e.charCodeAt()).forEach(e => {\n        if (e >= 48 && e <= 57) { arr[0] = 1 }\n        else if (e >= 65 && e <= 90) { arr[1] = 1 }\n        else if (e >= 91 && e <= 122) { arr[2] = 1 }\n        else { arr[3] = 1 }\n    })\n    return passwordLevel[arr.reduce((a, b) => a + b) - 1]\n}\n\n```","source":"_drafts/test.md","raw":"---\ntitle: test\ntags:\n---\n\n\n## 一个密码生成器，并同时写一个密码强度校验的方法 \n\n```\n/**\n/*方法说明\n *@createPassword 密码范围 {0-9，A-Z, a-z}\n *@param\n * num {num} 生成密码长度\n *  b {num} 密码生成类型，1: 数字， 2:数字+小写，3.数字+大小写\n *@return {str} \n*/\n**/\nlet createPassword = function (num, b) {\n    let n = 0 //循环次数\n    let arr = new Array // 随机数保存\n    let Capitalization = () => Math.floor(Math.random() * b)// 随机取数0-2/0-1\n    let randomNumber = [() => Math.floor(Math.random() * (57 - 48 + 1) + 48), () => Math.floor(Math.random() * (122 - 97 + 1) + 97), () => Math.floor(Math.random() * (90 - 65 + 1) + 65)] // 去随机值\n    for (let i = 0; i < num; i++) {\n        arr.push(randomNumber[Capitalization()]())\n    }\n    return arr.map(e => String.fromCharCode(e)).join('')\n}\n\n/*方法说明\n *@method passwordStrength 密码强度校验\n *@for 所属类名\n *@param \n *        num{str} 密码\n *        len {num} 密码长度\n *@return {str} 返回密码等级\n\n      str    ASCII\n      0-9    48-57\n      A-Z    65-90\n      a-z    97-122\n\n */\nlet passwordStrength = function (num, len) {\n    if(num.length<len) return '密码长度不够'\n    let passwordLevel = ['弱', '普通', '较强', '强']\n    let arr = new Array(4) // 记录密码等级\n    num.split('').map(e => e.charCodeAt()).forEach(e => {\n        if (e >= 48 && e <= 57) { arr[0] = 1 }\n        else if (e >= 65 && e <= 90) { arr[1] = 1 }\n        else if (e >= 91 && e <= 122) { arr[2] = 1 }\n        else { arr[3] = 1 }\n    })\n    return passwordLevel[arr.reduce((a, b) => a + b) - 1]\n}\n\n```","slug":"test","published":0,"date":"2019-12-14T10:29:55.946Z","updated":"2019-12-14T10:29:55.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqb000h78p3a9l6gwzs","content":"<h2 id=\"一个密码生成器，并同时写一个密码强度校验的方法\"><a href=\"#一个密码生成器，并同时写一个密码强度校验的方法\" class=\"headerlink\" title=\"一个密码生成器，并同时写一个密码强度校验的方法\"></a>一个密码生成器，并同时写一个密码强度校验的方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">/*方法说明</span><br><span class=\"line\"> *@createPassword 密码范围 &#123;0-9，A-Z, a-z&#125;</span><br><span class=\"line\"> *@param</span><br><span class=\"line\"> * num &#123;num&#125; 生成密码长度</span><br><span class=\"line\"> *  b &#123;num&#125; 密码生成类型，1: 数字， 2:数字+小写，3.数字+大小写</span><br><span class=\"line\"> *@return &#123;str&#125; </span><br><span class=\"line\">*/</span><br><span class=\"line\">**/</span><br><span class=\"line\">let createPassword = function (num, b) &#123;</span><br><span class=\"line\">    let n = 0 //循环次数</span><br><span class=\"line\">    let arr = new Array // 随机数保存</span><br><span class=\"line\">    let Capitalization = () =&gt; Math.floor(Math.random() * b)// 随机取数0-2/0-1</span><br><span class=\"line\">    let randomNumber = [() =&gt; Math.floor(Math.random() * (57 - 48 + 1) + 48), () =&gt; Math.floor(Math.random() * (122 - 97 + 1) + 97), () =&gt; Math.floor(Math.random() * (90 - 65 + 1) + 65)] // 去随机值</span><br><span class=\"line\">    for (let i = 0; i &lt; num; i++) &#123;</span><br><span class=\"line\">        arr.push(randomNumber[Capitalization()]())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr.map(e =&gt; String.fromCharCode(e)).join(&apos;&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*方法说明</span><br><span class=\"line\"> *@method passwordStrength 密码强度校验</span><br><span class=\"line\"> *@for 所属类名</span><br><span class=\"line\"> *@param </span><br><span class=\"line\"> *        num&#123;str&#125; 密码</span><br><span class=\"line\"> *        len &#123;num&#125; 密码长度</span><br><span class=\"line\"> *@return &#123;str&#125; 返回密码等级</span><br><span class=\"line\"></span><br><span class=\"line\">      str    ASCII</span><br><span class=\"line\">      0-9    48-57</span><br><span class=\"line\">      A-Z    65-90</span><br><span class=\"line\">      a-z    97-122</span><br><span class=\"line\"></span><br><span class=\"line\"> */</span><br><span class=\"line\">let passwordStrength = function (num, len) &#123;</span><br><span class=\"line\">    if(num.length&lt;len) return &apos;密码长度不够&apos;</span><br><span class=\"line\">    let passwordLevel = [&apos;弱&apos;, &apos;普通&apos;, &apos;较强&apos;, &apos;强&apos;]</span><br><span class=\"line\">    let arr = new Array(4) // 记录密码等级</span><br><span class=\"line\">    num.split(&apos;&apos;).map(e =&gt; e.charCodeAt()).forEach(e =&gt; &#123;</span><br><span class=\"line\">        if (e &gt;= 48 &amp;&amp; e &lt;= 57) &#123; arr[0] = 1 &#125;</span><br><span class=\"line\">        else if (e &gt;= 65 &amp;&amp; e &lt;= 90) &#123; arr[1] = 1 &#125;</span><br><span class=\"line\">        else if (e &gt;= 91 &amp;&amp; e &lt;= 122) &#123; arr[2] = 1 &#125;</span><br><span class=\"line\">        else &#123; arr[3] = 1 &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return passwordLevel[arr.reduce((a, b) =&gt; a + b) - 1]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一个密码生成器，并同时写一个密码强度校验的方法\"><a href=\"#一个密码生成器，并同时写一个密码强度校验的方法\" class=\"headerlink\" title=\"一个密码生成器，并同时写一个密码强度校验的方法\"></a>一个密码生成器，并同时写一个密码强度校验的方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">/*方法说明</span><br><span class=\"line\"> *@createPassword 密码范围 &#123;0-9，A-Z, a-z&#125;</span><br><span class=\"line\"> *@param</span><br><span class=\"line\"> * num &#123;num&#125; 生成密码长度</span><br><span class=\"line\"> *  b &#123;num&#125; 密码生成类型，1: 数字， 2:数字+小写，3.数字+大小写</span><br><span class=\"line\"> *@return &#123;str&#125; </span><br><span class=\"line\">*/</span><br><span class=\"line\">**/</span><br><span class=\"line\">let createPassword = function (num, b) &#123;</span><br><span class=\"line\">    let n = 0 //循环次数</span><br><span class=\"line\">    let arr = new Array // 随机数保存</span><br><span class=\"line\">    let Capitalization = () =&gt; Math.floor(Math.random() * b)// 随机取数0-2/0-1</span><br><span class=\"line\">    let randomNumber = [() =&gt; Math.floor(Math.random() * (57 - 48 + 1) + 48), () =&gt; Math.floor(Math.random() * (122 - 97 + 1) + 97), () =&gt; Math.floor(Math.random() * (90 - 65 + 1) + 65)] // 去随机值</span><br><span class=\"line\">    for (let i = 0; i &lt; num; i++) &#123;</span><br><span class=\"line\">        arr.push(randomNumber[Capitalization()]())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return arr.map(e =&gt; String.fromCharCode(e)).join(&apos;&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*方法说明</span><br><span class=\"line\"> *@method passwordStrength 密码强度校验</span><br><span class=\"line\"> *@for 所属类名</span><br><span class=\"line\"> *@param </span><br><span class=\"line\"> *        num&#123;str&#125; 密码</span><br><span class=\"line\"> *        len &#123;num&#125; 密码长度</span><br><span class=\"line\"> *@return &#123;str&#125; 返回密码等级</span><br><span class=\"line\"></span><br><span class=\"line\">      str    ASCII</span><br><span class=\"line\">      0-9    48-57</span><br><span class=\"line\">      A-Z    65-90</span><br><span class=\"line\">      a-z    97-122</span><br><span class=\"line\"></span><br><span class=\"line\"> */</span><br><span class=\"line\">let passwordStrength = function (num, len) &#123;</span><br><span class=\"line\">    if(num.length&lt;len) return &apos;密码长度不够&apos;</span><br><span class=\"line\">    let passwordLevel = [&apos;弱&apos;, &apos;普通&apos;, &apos;较强&apos;, &apos;强&apos;]</span><br><span class=\"line\">    let arr = new Array(4) // 记录密码等级</span><br><span class=\"line\">    num.split(&apos;&apos;).map(e =&gt; e.charCodeAt()).forEach(e =&gt; &#123;</span><br><span class=\"line\">        if (e &gt;= 48 &amp;&amp; e &lt;= 57) &#123; arr[0] = 1 &#125;</span><br><span class=\"line\">        else if (e &gt;= 65 &amp;&amp; e &lt;= 90) &#123; arr[1] = 1 &#125;</span><br><span class=\"line\">        else if (e &gt;= 91 &amp;&amp; e &lt;= 122) &#123; arr[2] = 1 &#125;</span><br><span class=\"line\">        else &#123; arr[3] = 1 &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return passwordLevel[arr.reduce((a, b) =&gt; a + b) - 1]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"title","_content":"\n\n### 记录文章内容和文件名得对应关系。\n\n* blogInit.md -> 基于HEXO博客框架和Github搭建个人博客简单教程\n\n* cssTitle.md -> css相关面试题\n\n* hexoDeplayBug.md -> hexo deplay出错\n\n* JS-thread.md -> 从多线程到Event Loop全面梳理\n\n* message-comp.md -> 模拟element-ui写message组件思路\n\n* node.md -> node 基础知识\n\n* npmBuild.md -> npm 部署自己的组件库\n\n* promise.md -> Promise\n\n* request.md -> 关于前端请求的那些事\n\n* vueSourceCoding.md -> 了解vue源码\n\n* vueTitle.md -> vue相关面试题\n\n* webTitle.md -> 前端面试题整理\n\n* axios.md -> axios 封装\n\n* virtualDom.md -> 虚拟dom\n\n* ForwardReverseProxy.md -> 正向代理&反向代理\n\n* commitMessage.md -> Commit message 代码提交规范\n\n* express.md -> express： 实现本地代码+本地mock+环境接口数据\n\n* reactive.md -> Vue响应式原理解析\n\n* Ts1.md -> [Typescript] 为第三方库添加声明文件 .d.ts\n\n* Mysql.md -> macOS 上安裝 MySQL\n\n* Node.md -> NO3:Node.js + mysql+Sequelize实现注册接口及校验逻辑\n\n* Node1.md -> NO1:使用 Node.js + Express 开发服务端\n\n* Node2.md -> NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete\n\n\n* Front-endEngineering\n* vueMessage.md -> 解读element-ui-----this.$message()\n\n* reactCom1.md -> 使用react搭建组件库--icon组件\n\n* reactCom2.md -> 使用react搭建组件库--radio组件\n\n* ssr.md -> 搭建Vue的SSR服务端渲染\n\n* Front-endEngineering.md -> 前端工程化\n\n* vueRouter.md -> 探究vue-router的源码\n\n* axios.md -> axios封装 Axios封装示例代码+封装思路\n\n* fixProject.md -> 如何优化项目\n\n* vueTest.md -> Vue.js 单元测试\n\n* vueI18.md -> vue项目中引入&使用国际化\n\n* ReactFragment.md -> ReactFragment用法介绍\n\n* axios1.md -> Axios源码解析","source":"_drafts/title.md","raw":"---\ntitle: title\ntags:\n---\n\n\n### 记录文章内容和文件名得对应关系。\n\n* blogInit.md -> 基于HEXO博客框架和Github搭建个人博客简单教程\n\n* cssTitle.md -> css相关面试题\n\n* hexoDeplayBug.md -> hexo deplay出错\n\n* JS-thread.md -> 从多线程到Event Loop全面梳理\n\n* message-comp.md -> 模拟element-ui写message组件思路\n\n* node.md -> node 基础知识\n\n* npmBuild.md -> npm 部署自己的组件库\n\n* promise.md -> Promise\n\n* request.md -> 关于前端请求的那些事\n\n* vueSourceCoding.md -> 了解vue源码\n\n* vueTitle.md -> vue相关面试题\n\n* webTitle.md -> 前端面试题整理\n\n* axios.md -> axios 封装\n\n* virtualDom.md -> 虚拟dom\n\n* ForwardReverseProxy.md -> 正向代理&反向代理\n\n* commitMessage.md -> Commit message 代码提交规范\n\n* express.md -> express： 实现本地代码+本地mock+环境接口数据\n\n* reactive.md -> Vue响应式原理解析\n\n* Ts1.md -> [Typescript] 为第三方库添加声明文件 .d.ts\n\n* Mysql.md -> macOS 上安裝 MySQL\n\n* Node.md -> NO3:Node.js + mysql+Sequelize实现注册接口及校验逻辑\n\n* Node1.md -> NO1:使用 Node.js + Express 开发服务端\n\n* Node2.md -> NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete\n\n\n* Front-endEngineering\n* vueMessage.md -> 解读element-ui-----this.$message()\n\n* reactCom1.md -> 使用react搭建组件库--icon组件\n\n* reactCom2.md -> 使用react搭建组件库--radio组件\n\n* ssr.md -> 搭建Vue的SSR服务端渲染\n\n* Front-endEngineering.md -> 前端工程化\n\n* vueRouter.md -> 探究vue-router的源码\n\n* axios.md -> axios封装 Axios封装示例代码+封装思路\n\n* fixProject.md -> 如何优化项目\n\n* vueTest.md -> Vue.js 单元测试\n\n* vueI18.md -> vue项目中引入&使用国际化\n\n* ReactFragment.md -> ReactFragment用法介绍\n\n* axios1.md -> Axios源码解析","slug":"title","published":0,"date":"2019-12-04T12:50:48.220Z","updated":"2020-07-27T09:56:15.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqc000i78p31mrt3cmd","content":"<h3 id=\"记录文章内容和文件名得对应关系。\"><a href=\"#记录文章内容和文件名得对应关系。\" class=\"headerlink\" title=\"记录文章内容和文件名得对应关系。\"></a>记录文章内容和文件名得对应关系。</h3><ul>\n<li><p>blogInit.md -&gt; 基于HEXO博客框架和Github搭建个人博客简单教程</p>\n</li>\n<li><p>cssTitle.md -&gt; css相关面试题</p>\n</li>\n<li><p>hexoDeplayBug.md -&gt; hexo deplay出错</p>\n</li>\n<li><p>JS-thread.md -&gt; 从多线程到Event Loop全面梳理</p>\n</li>\n<li><p>message-comp.md -&gt; 模拟element-ui写message组件思路</p>\n</li>\n<li><p>node.md -&gt; node 基础知识</p>\n</li>\n<li><p>npmBuild.md -&gt; npm 部署自己的组件库</p>\n</li>\n<li><p>promise.md -&gt; Promise</p>\n</li>\n<li><p>request.md -&gt; 关于前端请求的那些事</p>\n</li>\n<li><p>vueSourceCoding.md -&gt; 了解vue源码</p>\n</li>\n<li><p>vueTitle.md -&gt; vue相关面试题</p>\n</li>\n<li><p>webTitle.md -&gt; 前端面试题整理</p>\n</li>\n<li><p>axios.md -&gt; axios 封装</p>\n</li>\n<li><p>virtualDom.md -&gt; 虚拟dom</p>\n</li>\n<li><p>ForwardReverseProxy.md -&gt; 正向代理&amp;反向代理</p>\n</li>\n<li><p>commitMessage.md -&gt; Commit message 代码提交规范</p>\n</li>\n<li><p>express.md -&gt; express： 实现本地代码+本地mock+环境接口数据</p>\n</li>\n<li><p>reactive.md -&gt; Vue响应式原理解析</p>\n</li>\n<li><p>Ts1.md -&gt; [Typescript] 为第三方库添加声明文件 .d.ts</p>\n</li>\n<li><p>Mysql.md -&gt; macOS 上安裝 MySQL</p>\n</li>\n<li><p>Node.md -&gt; NO3:Node.js + mysql+Sequelize实现注册接口及校验逻辑</p>\n</li>\n<li><p>Node1.md -&gt; NO1:使用 Node.js + Express 开发服务端</p>\n</li>\n<li><p>Node2.md -&gt; NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete</p>\n</li>\n</ul>\n<ul>\n<li>Front-endEngineering</li>\n<li><p>vueMessage.md -&gt; 解读element-ui—–this.$message()</p>\n</li>\n<li><p>reactCom1.md -&gt; 使用react搭建组件库–icon组件</p>\n</li>\n<li><p>reactCom2.md -&gt; 使用react搭建组件库–radio组件</p>\n</li>\n<li><p>ssr.md -&gt; 搭建Vue的SSR服务端渲染</p>\n</li>\n<li><p>Front-endEngineering.md -&gt; 前端工程化</p>\n</li>\n<li><p>vueRouter.md -&gt; 探究vue-router的源码</p>\n</li>\n<li><p>axios.md -&gt; axios封装 Axios封装示例代码+封装思路</p>\n</li>\n<li><p>fixProject.md -&gt; 如何优化项目</p>\n</li>\n<li><p>vueTest.md -&gt; Vue.js 单元测试</p>\n</li>\n<li><p>vueI18.md -&gt; vue项目中引入&amp;使用国际化</p>\n</li>\n<li><p>ReactFragment.md -&gt; ReactFragment用法介绍</p>\n</li>\n<li><p>axios1.md -&gt; Axios源码解析</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"记录文章内容和文件名得对应关系。\"><a href=\"#记录文章内容和文件名得对应关系。\" class=\"headerlink\" title=\"记录文章内容和文件名得对应关系。\"></a>记录文章内容和文件名得对应关系。</h3><ul>\n<li><p>blogInit.md -&gt; 基于HEXO博客框架和Github搭建个人博客简单教程</p>\n</li>\n<li><p>cssTitle.md -&gt; css相关面试题</p>\n</li>\n<li><p>hexoDeplayBug.md -&gt; hexo deplay出错</p>\n</li>\n<li><p>JS-thread.md -&gt; 从多线程到Event Loop全面梳理</p>\n</li>\n<li><p>message-comp.md -&gt; 模拟element-ui写message组件思路</p>\n</li>\n<li><p>node.md -&gt; node 基础知识</p>\n</li>\n<li><p>npmBuild.md -&gt; npm 部署自己的组件库</p>\n</li>\n<li><p>promise.md -&gt; Promise</p>\n</li>\n<li><p>request.md -&gt; 关于前端请求的那些事</p>\n</li>\n<li><p>vueSourceCoding.md -&gt; 了解vue源码</p>\n</li>\n<li><p>vueTitle.md -&gt; vue相关面试题</p>\n</li>\n<li><p>webTitle.md -&gt; 前端面试题整理</p>\n</li>\n<li><p>axios.md -&gt; axios 封装</p>\n</li>\n<li><p>virtualDom.md -&gt; 虚拟dom</p>\n</li>\n<li><p>ForwardReverseProxy.md -&gt; 正向代理&amp;反向代理</p>\n</li>\n<li><p>commitMessage.md -&gt; Commit message 代码提交规范</p>\n</li>\n<li><p>express.md -&gt; express： 实现本地代码+本地mock+环境接口数据</p>\n</li>\n<li><p>reactive.md -&gt; Vue响应式原理解析</p>\n</li>\n<li><p>Ts1.md -&gt; [Typescript] 为第三方库添加声明文件 .d.ts</p>\n</li>\n<li><p>Mysql.md -&gt; macOS 上安裝 MySQL</p>\n</li>\n<li><p>Node.md -&gt; NO3:Node.js + mysql+Sequelize实现注册接口及校验逻辑</p>\n</li>\n<li><p>Node1.md -&gt; NO1:使用 Node.js + Express 开发服务端</p>\n</li>\n<li><p>Node2.md -&gt; NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete</p>\n</li>\n</ul>\n<ul>\n<li>Front-endEngineering</li>\n<li><p>vueMessage.md -&gt; 解读element-ui—–this.$message()</p>\n</li>\n<li><p>reactCom1.md -&gt; 使用react搭建组件库–icon组件</p>\n</li>\n<li><p>reactCom2.md -&gt; 使用react搭建组件库–radio组件</p>\n</li>\n<li><p>ssr.md -&gt; 搭建Vue的SSR服务端渲染</p>\n</li>\n<li><p>Front-endEngineering.md -&gt; 前端工程化</p>\n</li>\n<li><p>vueRouter.md -&gt; 探究vue-router的源码</p>\n</li>\n<li><p>axios.md -&gt; axios封装 Axios封装示例代码+封装思路</p>\n</li>\n<li><p>fixProject.md -&gt; 如何优化项目</p>\n</li>\n<li><p>vueTest.md -&gt; Vue.js 单元测试</p>\n</li>\n<li><p>vueI18.md -&gt; vue项目中引入&amp;使用国际化</p>\n</li>\n<li><p>ReactFragment.md -&gt; ReactFragment用法介绍</p>\n</li>\n<li><p>axios1.md -&gt; Axios源码解析</p>\n</li>\n</ul>\n"},{"title":"vueCli3-proxy","_content":"\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n\n##本地代理\n在根目录下新建一个vue.config.js文件\n\n\n```\nconst proxy_url = 'http://baidu.com';\nconst renewal_url = 'http://renewal-baidu.com';\n\nmodule.exports = {\n  productionSourceMap: false, //防止源码泄露\n  devServer: {\n    proxy: {\n      '/ccs-api': {\n        target: proxy_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/ccs-api': '' //需要rewrite的,\n        }\n      },\n      '/renewal': {\n        target: renewal_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/renewal': renewal_url //需要rewrite的,\n        }\n      }\n    }\n  }\n  \n}\n```\n\nForward Proxy; Reverse Proxy ","source":"_drafts/vueCli3-proxy.md","raw":"---\ntitle: vueCli3-proxy\ntags: proxy\n---\n\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n\n##本地代理\n在根目录下新建一个vue.config.js文件\n\n\n```\nconst proxy_url = 'http://baidu.com';\nconst renewal_url = 'http://renewal-baidu.com';\n\nmodule.exports = {\n  productionSourceMap: false, //防止源码泄露\n  devServer: {\n    proxy: {\n      '/ccs-api': {\n        target: proxy_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/ccs-api': '' //需要rewrite的,\n        }\n      },\n      '/renewal': {\n        target: renewal_url, // 接口域名\n        changeOrigin: true, //是否跨域\n        pathRewrite: {\n          '^/renewal': renewal_url //需要rewrite的,\n        }\n      }\n    }\n  }\n  \n}\n```\n\nForward Proxy; Reverse Proxy ","slug":"vueCli3-proxy","published":0,"date":"2019-12-04T12:50:48.220Z","updated":"2019-12-04T12:50:48.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqd000j78p3256dxgq1","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>##本地代理<br>在根目录下新建一个vue.config.js文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const proxy_url = &apos;http://baidu.com&apos;;</span><br><span class=\"line\">const renewal_url = &apos;http://renewal-baidu.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  productionSourceMap: false, //防止源码泄露</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &apos;/ccs-api&apos;: &#123;</span><br><span class=\"line\">        target: proxy_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/ccs-api&apos;: &apos;&apos; //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &apos;/renewal&apos;: &#123;</span><br><span class=\"line\">        target: renewal_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/renewal&apos;: renewal_url //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Forward Proxy; Reverse Proxy </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>##本地代理<br>在根目录下新建一个vue.config.js文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const proxy_url = &apos;http://baidu.com&apos;;</span><br><span class=\"line\">const renewal_url = &apos;http://renewal-baidu.com&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  productionSourceMap: false, //防止源码泄露</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    proxy: &#123;</span><br><span class=\"line\">      &apos;/ccs-api&apos;: &#123;</span><br><span class=\"line\">        target: proxy_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/ccs-api&apos;: &apos;&apos; //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &apos;/renewal&apos;: &#123;</span><br><span class=\"line\">        target: renewal_url, // 接口域名</span><br><span class=\"line\">        changeOrigin: true, //是否跨域</span><br><span class=\"line\">        pathRewrite: &#123;</span><br><span class=\"line\">          &apos;^/renewal&apos;: renewal_url //需要rewrite的,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Forward Proxy; Reverse Proxy </p>\n"},{"title":"vueSourceCoding","_content":"\n「从源码中学习」面试官都不知道的Vue题目答案\n\nhttps://juejin.im/post/5c959f74f265da610c068fa8","source":"_drafts/vueSourceCoding.md","raw":"---\ntitle: vueSourceCoding\ntags:\n---\n\n「从源码中学习」面试官都不知道的Vue题目答案\n\nhttps://juejin.im/post/5c959f74f265da610c068fa8","slug":"vueSourceCoding","published":0,"date":"2019-12-04T12:50:48.221Z","updated":"2019-12-04T12:50:48.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqf000k78p3x7u4hbup","content":"<p>「从源码中学习」面试官都不知道的Vue题目答案</p>\n<p><a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>「从源码中学习」面试官都不知道的Vue题目答案</p>\n<p><a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a></p>\n"},{"title":"正向代理&反向代理","date":"2019-09-20T03:12:13.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 11:12:13\n\n## ForwardProxy\n\n正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。\n\n\n```\n这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。\n\n有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。\n\n```\n\n![ForwardProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 正向代理，其实是\"代理服务器\"代理了\"客户端\"，去和\"目标服务器\"进行交互。\n#### 用途：\n* 突破访问限制 \n  通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。\n* 提高访问速度\n  通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。\n* 隐藏客户端真实IP\n  上网者也可以通过这种方法隐藏自己的IP，免受攻击。\n\n## ReverseProxy\n\n反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\n```\n对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。\n\n```\n\n![ReverseProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 反向代理，其实是\"代理服务器\"代理了\"目标服务器\"，去和\"客户端\"进行交互。\n#### 用途：\n* 负载均衡 \n  反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。\n* 提高访问速度\n  反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。\n* 隐藏客户端真实IP\n  使用反向代理，可以对客户端隐藏服务器的IP地址。\n* 提供安全保障\n  反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等\n","source":"_posts/ForwardReverseProxy.md","raw":"---\ntitle: 正向代理&反向代理\ndate: 2019-09-20 11:12:13\ntags: web\n---\n\nAuthor: Echo\nTime: 2019-09-20 11:12:13\n\n## ForwardProxy\n\n正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。\n\n\n```\n这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。\n\n有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。\n\n```\n\n![ForwardProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 正向代理，其实是\"代理服务器\"代理了\"客户端\"，去和\"目标服务器\"进行交互。\n#### 用途：\n* 突破访问限制 \n  通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。\n* 提高访问速度\n  通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。\n* 隐藏客户端真实IP\n  上网者也可以通过这种方法隐藏自己的IP，免受攻击。\n\n## ReverseProxy\n\n反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\n```\n对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。\n\n```\n\n![ReverseProxy](https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png)\n\n###### 反向代理，其实是\"代理服务器\"代理了\"目标服务器\"，去和\"客户端\"进行交互。\n#### 用途：\n* 负载均衡 \n  反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。\n* 提高访问速度\n  反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。\n* 隐藏客户端真实IP\n  使用反向代理，可以对客户端隐藏服务器的IP地址。\n* 提供安全保障\n  反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等\n","slug":"ForwardReverseProxy","published":1,"updated":"2019-12-04T12:50:48.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqh000m78p3c6fp0rhp","content":"<p>Author: Echo<br>Time: 2019-09-20 11:12:13</p>\n<h2 id=\"ForwardProxy\"><a href=\"#ForwardProxy\" class=\"headerlink\" title=\"ForwardProxy\"></a>ForwardProxy</h2><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。</span><br><span class=\"line\"></span><br><span class=\"line\">有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ForwardProxy\"></p>\n<h6 id=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"><a href=\"#正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\" class=\"headerlink\" title=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"></a>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。</h6><h4 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>突破访问限制<br>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</li>\n<li>提高访问速度<br>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>\n<li>隐藏客户端真实IP<br>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li>\n</ul>\n<h2 id=\"ReverseProxy\"><a href=\"#ReverseProxy\" class=\"headerlink\" title=\"ReverseProxy\"></a>ReverseProxy</h2><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ReverseProxy\"></p>\n<h6 id=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"><a href=\"#反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\" class=\"headerlink\" title=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"></a>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。</h6><h4 id=\"用途：-1\"><a href=\"#用途：-1\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>负载均衡<br>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</li>\n<li>提高访问速度<br>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li>\n<li>隐藏客户端真实IP<br>使用反向代理，可以对客户端隐藏服务器的IP地址。</li>\n<li>提供安全保障<br>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 11:12:13</p>\n<h2 id=\"ForwardProxy\"><a href=\"#ForwardProxy\" class=\"headerlink\" title=\"ForwardProxy\"></a>ForwardProxy</h2><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。</span><br><span class=\"line\"></span><br><span class=\"line\">有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ForwardProxy\"></p>\n<h6 id=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"><a href=\"#正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\" class=\"headerlink\" title=\"正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。\"></a>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。</h6><h4 id=\"用途：\"><a href=\"#用途：\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>突破访问限制<br>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</li>\n<li>提高访问速度<br>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>\n<li>隐藏客户端真实IP<br>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li>\n</ul>\n<h2 id=\"ReverseProxy\"><a href=\"#ReverseProxy\" class=\"headerlink\" title=\"ReverseProxy\"></a>ReverseProxy</h2><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png\" alt=\"ReverseProxy\"></p>\n<h6 id=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"><a href=\"#反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\" class=\"headerlink\" title=\"反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。\"></a>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。</h6><h4 id=\"用途：-1\"><a href=\"#用途：-1\" class=\"headerlink\" title=\"用途：\"></a>用途：</h4><ul>\n<li>负载均衡<br>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</li>\n<li>提高访问速度<br>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li>\n<li>隐藏客户端真实IP<br>使用反向代理，可以对客户端隐藏服务器的IP地址。</li>\n<li>提供安全保障<br>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</li>\n</ul>\n"},{"title":"前端工程化","date":"2020-05-27T06:55:06.000Z","_content":"\nAuthor: Echo\nTime: 2020-05-27 14:55:06\n\n#### 前言\n\nweb应用复杂度的增加，特别是单页面应用的风靡。组件化，工程化，自动化成了前端发展的趋势。\n每个前端团队都在打造自己的前端开发体系，这通常是一个东拼西凑，逐渐磨合的过程，在技术发展日新月异的今天，这样的过程真的是不可抽象和复制的么？通过拆解前端开发体系,对前端工程化有所理解。\n# I. 前端工程化\n---\n前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是\"前端工程化\"。\n\n###### 前端工程化面临的问题 ?\n 1. 开发成本\n大体量：多功能、多页面、多状态、多系统；\n大规模：多人甚至多团队合作开发；\n\n  * 提高开发生产效率\n  * 降低维护难度\n\n这两个问题的解决方案有两点：\n\n* 制定开发规范，提高团队协作能力；\n* 分治。软件工程中有个很重要的概念叫做`模块化开发`其中心思想就是分治。\n 2. 部署\n从部署角度，要解决的问题主要是资源管理，包括：\n* 代码审查\n* 压缩打包\n* 增量更新\n* 单元测试\n3. 高性能\nCDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。\n###### 如何做\"前端工程化\"？\n前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从模块化、组件化、规范化、自动化四个方面思考。\n\n### 模块化\n---\n>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。\n###### JS的模块化\n在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。\n现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。\n\n* 用 Webpack + Babel 将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；\n* 用 System+Babel 主要是分模块异步加载；\n* 用浏览器的<script type=\"module\">加载。\n###### CSS的模块化\n虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。\n\n按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。\n\n为了避免全局选择器的冲突，需要制定CSS命名风格：\n* BEM风格\n* Bootstrap风格\n* 团队CSS规范\n\n但是这毕竟是弱约束。所以很赞同一句话：\n\n>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。\n\n从工具层面，社区又创造出`Shadow DOM`、`CSS in JS`和`CSS Modules`三种解决方案。\n\n* Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；\n* CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；\n* CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的`scoped` style也算是一种。\n###### 资源的模块化\nWebpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。\n* `依赖关系单一化`。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；\n* `资源处理集成化`。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；\n* `项目结构清晰化`。使用Webpack后，你的项目结构总可以表示成这样的函数： `dest = webpack(src, config)`。\n### 组件化\n---\n从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。\n\n>`组件化≠模块化`。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。\n\n随着 web 应用规模越来越大，模块/组件化开发的需求就显得越来越迫切。模块/组件化开发的核心思想是分治，主要针对的是开发和维护阶段。\n\n1.  Web 应用的组件化开发。[http://blog.jobbole.com/56161/](http://blog.jobbole.com/56161/)\n2.  前端组件化开发实践。[http://web.jobbole.com/82689/](http://web.jobbole.com/82689/)\n3.  大规模的前端组件化与模块化。[http://www.infoq.com/cn/news/...](http://www.infoq.com/cn/news/2014/04/front-end-modular)\n\n###### 为什么搭建私有组件库?\n* 可复用 跨项目可以使用同一套私有组件库\n* 方便维护 如需组件调整 只需要修改组件库 不需要跨项目重复修改\n\n##### 添加新组件原则\n\n* 组件应先存在于具体项目中，经过重复验证后再抽象、沉淀到本组件库中\n* Vue component 只应负责渲染数据和内部逻辑，尽可能不包含 &dollar;t 国际化、ajax 请求等业务数据和逻辑\n* 组件和其他模块应尽可能的搭配单元测试、可运行的 storybook 例子\n* 应该在 CHANGELOG 中记录每次增删改的组件信息等\n\n### 规范化\n---\n\n规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。\n\n比如：\n\n* ######目录结构的制定\n* ######编码规范\n    制定一套良好的编码规范可以增强团队开发协作、提高代码质量。\n`推荐参考`\n**凹凸实验室**打造的[前端代码规范](https://guide.aotu.io/docs/index.html)。\n**Javascript Airbnb** 开发规范 [https://github.com/airbnb/jav...](https://github.com/airbnb/javascript)\n  * HTML规范\n  * CSS规范\n  * JS规范\n  * 图片规范\n  * 命名规范\n* ######前后端接口规范\n  “基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。\n\n  接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。\n* ###### 文档规范\n\n* ###### 组件管理\n\n* ###### git分支管理\n\n* ###### commit描述规范\n\n* ###### 定期 CodeReview\n\n### 自动化\n---\n   前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:\n\n>任何简单机械的重复劳动都应该让机器去完成。\n\n* 图标合并\n\n* 持续继承\n\n* 自动化构建\n\n* 自动化部署\n\n* 自动化测试\n\n# II. 工程化具体方法\n---\n## 1. 性能优化\n浏览器缓存是 Web 性能优化的重要方式。那么浏览器缓存的过程究竟是怎么样的呢？\n\n浏览器缓存主要分为`强强缓存（也称本地缓存）`和`协商缓存（也称弱缓存）`。\n ######强缓存\n *  Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。如我现在这个网页的 Expires 值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现 Cache-Control:max-age 和 Expires，那么 max-age 优先级更高。\n* Cache-Control 是在 http1.1 中出现的，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：\n\n  no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。\n\n  no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\n\n  public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。\n  private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。\n  Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候   Cache-Control 优先级高。\n ######弱缓存/协商缓存\n**Etag 和 If-None-Match**\n\nEtag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存\n\n与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。\n\n**Last-Modify/If-Modify-Since**\n\n浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。\n\n当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。\n\n如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。\n\nLast-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag\n* * *\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c4678e7b6821f8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* * *\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4c9053e0fd74c93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 访问量和性能指标\n\na.css 的请求，如果每次用户访问页面都要加载，很影响性能，很浪费带宽\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-41104d7c231d27e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* * *\n\n利用 304，让浏览器使用本地缓存。304 叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2fd0094493df3b08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？\n\n很好，相信有人想到了办法：通过`更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源`。好像这样：\n\n![`](https://upload-images.jianshu.io/upload_images/11846892-577a64c93602bf2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css，c.css 的缓存也失效，那岂不是又有浪费了？！\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c3a7badbd331fd6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n重新开启变态模式，我们不难发现，要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。\n\n什么东西与文件内容相关呢？我们会很自然的联想到利用  `数据摘要算法` 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把 url 改成带摘要信息的：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-027cf303a23fc22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 节点上，网页中引用的资源也会变成对应的部署路径：\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-ae5c4239f5b12df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这次发布，同时改了页面结构和样式，也更新了静态资源对应的 url 地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f05ceb812e53f51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* **先部署页面，再部署资源**：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。\n* **先部署资源，再部署页面**：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。\n\n---\n好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。\n有些公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！\n\n这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-3f21dab466192813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。\n\n---\n所以，静态资源优化方案，基本上要实现这么几个东西：\n\n配置超长时间的本地缓存 —— 节省带宽，提高性能\n采用内容摘要作为缓存更新依据 —— 精确的缓存控制\n静态资源 CDN 部署 —— 优化网络请求\n更资源发布路径实现非覆盖式发布 —— 平滑升级\n总之，前端性能优化绝逼是一个工程问题！\n---\n## 2. 静态资源部署 CDN\nCDN[Content Delivery Network] 内容分发网络 主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-80610fe2d3c9090e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n总结一下 CDN 的工作原理：通过权威 DNS 服务器来实现最优节点的选择，通过缓存来减少源站的压力。\n\n---\nCDN 应用场景：\n\n静态网页\n图片小文件、博客\n大文件下载\n软件下载、视频点播或图片存储网站\n动态加速\n直播网站\n应用加速\n手机 APP\n除却 CDN 自身的优势，在前端工程中，将静态文件放到 CDN 上，可以直观地减小资源包大小，同时加快首屏加载。\n\n若不使用 CDN，则所有的资源都会被打包到 app.js 和 vendor.js 中，页面需要等到这两个包下载完成才可以显示。\n若使用 CDN，则可以利用浏览器多线程的优势，同时下载若干静态文件以及剩下的 app.js 和 vendor.js，以此达到加快加载的目的。\n\n---\n\n### 3. 自动化文档生成\n\n`commit message` 作用\n\n*   提供更多的历史信息，方便快速浏览\n*   过滤某些 commit（比如文档改动），便于快速查找信息\n*   直接从 commit 生成 Change log\n*   可读性好，清晰，不必深入看代码即可了解当前 commit 的作用。\n*   为 Code Reviewing（代码审查）做准备\n*   方便跟踪工程历史\n*   提高项目的整体质量，提高个人工程素质\n\n目前，社区有多种 Commit message 的写法规范，我们介绍的工具是 commitizen，它使用的是 Angular 规范[AngularJS Git Commit Message Conventions](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0)，这是目前使用最广的写法，并且有对应的工具去生成 change log。\n\n**标准说明**\n\n每次提交， Commit message 都包括 Header, Body 和 Footer 三个部分。\n\n```\n<type>(<scope>): <subject>\n// 空行\n<body>\n// 空行\n<footer>\n```\n\n* * *\n\n**Header** 部分只有一行，包括三个字段：type, scope 和 subject 。\ntype 用于说明提交的类别，只运行使用下面几种，\n\n*   feat: 新功能\n*   fix: 修复 bug\n*   docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等等\n*   style: 格式更新（不影响代码运行的变动）\n*   refactor: 重构（既不是新增功能，又不是 bug 修复）\n*   test: 添加测试\n*   chore: 构建过程或辅助工具的变动\n*   perf: 优化相关，比如提升性能、体验\n*   revert: 回滚到上一个版本\n*   ci：自动化流程配置修改\n\n如果是 feat 和 fix ，则这个 commit 将肯定出现在 change log 中，其它情况可自行决定是否放入。\n\nscope 用于说明 commit 影响的范围 比如数据层、控制层、视图层等等，视项目不同而不同。\n\nsubject 是 commit 目的的简短描述，不超过 50 个字符。\n\n*   以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes\n*   第一个字母小写\n*   结尾不要加句号\n\n* * *\n\n**Body** 部分是对本次 commit 的详细描述，可分成多行。但是一般我都不写。\n\n**Footer** 部分只用于两种情况。\n\n不兼容变动\n\n如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n```\nBREAKING CHANGE: isolate scope bindings definition has changed.\n\n    To migrate the code follow the example below:\n\n    Before:\n\n    scope: {\n      myAttr: 'attribute',\n    }\n\n    After:\n\n    scope: {\n      myAttr: '@',\n    }\n\n    The removed `inject` wasn't generaly useful for directives so there should be no code using it.\n```\n\n* * *\n\n关闭 Issue\n如果当前 commit 针对某个 issue ，那么可以在 Footer 部分关闭这个 issue 。\n\n```\nCloses #1234\n```\n\n```\nCloses #1234, $1235, #1236\n```\n\n**Revert**\n\n如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header\n\n```\nrevert: feat(pencil): add 'graphiteWidth' option\n<br />\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\n```\n\n*   Body 部分的格式是固定的，必须写成 This reverts commit .，其中的 hash 是被撤销 commit 的 SHA 标识符。\n*   如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。\n\n* * *\n\n##### 自动生成 changelog 文档\n\n###### commitizen\n\nCommitizen 是一个撰写合格 Commit message 的工具。。\n\n```\nnpm install -g commitizen\n# 在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。\ncommitizen init cz-conventional-changelog --save --save-exact\n```\n\n用 git cz -m 代替 git commit -m 就可以轻松的写出 Angular 规范的 commit message 了。\n\n###### validate-commit-msg\n\n用于检查 Node 项目的 Commit message 是否符合格式。\n\n###### conventional-changelog\n\n生成 Change log 的工具，运行下面的命令即可。\n\n```\nnpm install -g conventional-changelog-cli\ncd my-project\nconventional-changelog -p angular -i CHANGELOG.md -s\n```\n\n* * *\n\n如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成\n\n生成的文档包括以下三个部分。\n\n*   New features\n*   Bug fixes\n*   Breaking changes.\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\n为了方便使用，可以将其写入 package.json 的 scripts 字段。\n\n```\n{\n  \"scripts\": {\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -w -r 0\"\n  }\n}\n```\n\n```\nnpm run changelog\n```\n\n### 4. 前端埋点\n**目的** \n获取用户基本信息、行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。\n**前端监控类别**\n前端监控可以分为三类：数据监控、性能监控和异常监控。\n`数据监控`就是监听用户信息和行为，常见的监控项有\n\n*PV(page view 页面访问量)：即页面浏览量或点击量\n* UV(unique visitor 独立访客)：指访问某个站点或点击某条新闻的不同 IP 地址的人数\n* 用户在每一个页面的停留时间\n* 用户通过什么入口来访问该网页\n* 用户在相应的页面中触发的行为\n统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。\n\n`性能监控`指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控项包括：\n\n* 不同用户，不同机型和不同系统下的首屏加载时间\n* http 等请求的响应时间\n* 静态资源整体下载时间\n* 页面渲染时间\n* 页面交互动画完成时间\n这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。\n\n`异常监控`由于产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 try catch 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：\n\n* Javascript 的异常监控\n* 样式丢失的异常监控\n* 服务器请求的异常监控\n我们说完了前端监控的三个分类，现在就来聊聊怎么实现前端监控。实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台，最后进行数据分析。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。\n***\n#####前端埋点分类\n\n\n收集监控数据我们是通过前端埋点来实现的，目前常见的前端埋点方法有三种：`  `手动埋点`、`可视化埋点`和`无埋点`。\n**手动埋点**，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像友盟、百度统计等第三方数据统计服务商大都采用这种方案。\n优势:\n\n  * 可自定义属性，自定义事件\n   * 可以细化需求\n   * 相比其他埋点方式减少服务器压力\n\n缺陷:\n\n   * 工程量大的话，手动埋点会出现疏漏，不方便审查。\n   * 需求变更要重新埋点，成本高。\n   * 每次需求变更都要重新发布版本，对线上系统稳定性有一定危害\n\n```\n$(document).ready(() => {\n  // ... 这里是你的业务逻辑代码\n  sendData(params) //这里是发送你的埋点数据，params是你封装的埋点数据\n})\n```\n***\n**前端框架式手动埋点**\n\n如果使用 Vue 或者 React 等前端框架，这些框架都有自己的各种生命周期，为了减少重复性的手动埋点次数，可以在各个生命周期位置，根据你的需求封装你所需的埋点。比如你是 SPA 单页应用，你希望在每一个页面的 componentDidMount 埋点，并由此确定用户已经打开了页面。\n\ncss 埋点：\n```\n.link:active::after {\n  content: url('http://www.example.com?action=yourdata');\n}\n<a class=\"link\">点击我，会发埋点数据</a>\n```\n***\n**可视化埋点**解决了纯手动埋点的开发成本和更新成本，通过可视化工具快速配置采集节点（圈点），在前端自动解析配置，并根据配置上传埋点数据，比起手动埋点看起来更无痕，\n\n比如国外比较早做可视化的是 Mixpanel，国内较早支持可视化埋点的有 TalkingData、诸葛 IO，2017 年腾讯的 MTA 也宣布支持可视化埋点；\n***\n**无埋点**则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。\n\n优点:\n前端只要一次加载埋点脚本\n\n缺点:\n服务器性能压力山大\n\n采用无埋点技术的有主流的 GrowingIO、神策。无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。\n\n#VI. 总结\n---\n\n在业界内有这么一句话：任何简单机械的重复劳动都应该让机器去完成。现代前端技术不再是以前刀耕火种的年代了。所以前端工程化的很多脏活累活都应该交给自动化工具来完成。\n\n如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说：\n\n你好，工程师！\n\n\n\n参考链接：\n1.  [前端工程化的理解](https://www.jianshu.com/p/88ed70476adb)\n2.  [大公司里怎样开发和部署前端代码？]([https://www.zhihu.com/question/20790576/answer/32602154])\n3. [前端埋点的那些事](http://www.imooc.com/article/27151)\n4.  [小谈前端埋点](https://www.jianshu.com/p/645a26619508)\n2.  [前端工程——基础篇](https://github.com/fouber/blog/issues/10)\n3.  [http-proxy-middleware](https://www.jianshu.com/p/a248b146c55a)\n4.  [Webpack dev server 使用 http-proxy 解决跨域问题](https://www.jianshu.com/p/3bdff821f859)\n5.  [chimurai/http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware)\n6.  [详解 webpack-dev-server 的简单使用](https://www.jb51.net/article/137608.htm)\n7.  [html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)\n8.  [webpack 使用 HtmlWebpackPlugin 进行 cdn 配置](https://www.jianshu.com/p/9248db0349fb)\n9.  [CDN 是什么？使用 CDN 有什么优势？](https://blog.csdn.net/const_ly/article/details/79788728)\n10.  [webpack4-06-开发、生产环境、动态 CDN 配置](https://www.codercto.com/a/76835.html)\n11.  [HTTP 强缓存和协商缓存](https://segmentfault.com/a/1190000008956069)\n12.  [Cache-Control 之 no-cache 和 max-age=0](https://www.jianshu.com/p/1744780ddda0)\n13.  [Commit message 代码提交规范](https://segmentfault.com/a/1190000019579621)\n14.  [Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n15.  [git commit 、CHANGELOG 和版本发布的标准自动化](https://www.cnblogs.com/zivxiaowei/p/10089201.html)\n\n","source":"_posts/Front-endEngineering.md","raw":"---\ntitle: 前端工程化\ndate: 2020-05-27 14:55:06\ntags:\n---\n\nAuthor: Echo\nTime: 2020-05-27 14:55:06\n\n#### 前言\n\nweb应用复杂度的增加，特别是单页面应用的风靡。组件化，工程化，自动化成了前端发展的趋势。\n每个前端团队都在打造自己的前端开发体系，这通常是一个东拼西凑，逐渐磨合的过程，在技术发展日新月异的今天，这样的过程真的是不可抽象和复制的么？通过拆解前端开发体系,对前端工程化有所理解。\n# I. 前端工程化\n---\n前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是\"前端工程化\"。\n\n###### 前端工程化面临的问题 ?\n 1. 开发成本\n大体量：多功能、多页面、多状态、多系统；\n大规模：多人甚至多团队合作开发；\n\n  * 提高开发生产效率\n  * 降低维护难度\n\n这两个问题的解决方案有两点：\n\n* 制定开发规范，提高团队协作能力；\n* 分治。软件工程中有个很重要的概念叫做`模块化开发`其中心思想就是分治。\n 2. 部署\n从部署角度，要解决的问题主要是资源管理，包括：\n* 代码审查\n* 压缩打包\n* 增量更新\n* 单元测试\n3. 高性能\nCDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。\n###### 如何做\"前端工程化\"？\n前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从模块化、组件化、规范化、自动化四个方面思考。\n\n### 模块化\n---\n>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。\n###### JS的模块化\n在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。\n现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。\n\n* 用 Webpack + Babel 将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；\n* 用 System+Babel 主要是分模块异步加载；\n* 用浏览器的<script type=\"module\">加载。\n###### CSS的模块化\n虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。\n\n按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。\n\n为了避免全局选择器的冲突，需要制定CSS命名风格：\n* BEM风格\n* Bootstrap风格\n* 团队CSS规范\n\n但是这毕竟是弱约束。所以很赞同一句话：\n\n>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。\n\n从工具层面，社区又创造出`Shadow DOM`、`CSS in JS`和`CSS Modules`三种解决方案。\n\n* Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；\n* CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；\n* CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的`scoped` style也算是一种。\n###### 资源的模块化\nWebpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。\n* `依赖关系单一化`。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；\n* `资源处理集成化`。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；\n* `项目结构清晰化`。使用Webpack后，你的项目结构总可以表示成这样的函数： `dest = webpack(src, config)`。\n### 组件化\n---\n从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。\n\n>`组件化≠模块化`。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。\n\n随着 web 应用规模越来越大，模块/组件化开发的需求就显得越来越迫切。模块/组件化开发的核心思想是分治，主要针对的是开发和维护阶段。\n\n1.  Web 应用的组件化开发。[http://blog.jobbole.com/56161/](http://blog.jobbole.com/56161/)\n2.  前端组件化开发实践。[http://web.jobbole.com/82689/](http://web.jobbole.com/82689/)\n3.  大规模的前端组件化与模块化。[http://www.infoq.com/cn/news/...](http://www.infoq.com/cn/news/2014/04/front-end-modular)\n\n###### 为什么搭建私有组件库?\n* 可复用 跨项目可以使用同一套私有组件库\n* 方便维护 如需组件调整 只需要修改组件库 不需要跨项目重复修改\n\n##### 添加新组件原则\n\n* 组件应先存在于具体项目中，经过重复验证后再抽象、沉淀到本组件库中\n* Vue component 只应负责渲染数据和内部逻辑，尽可能不包含 &dollar;t 国际化、ajax 请求等业务数据和逻辑\n* 组件和其他模块应尽可能的搭配单元测试、可运行的 storybook 例子\n* 应该在 CHANGELOG 中记录每次增删改的组件信息等\n\n### 规范化\n---\n\n规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。\n\n比如：\n\n* ######目录结构的制定\n* ######编码规范\n    制定一套良好的编码规范可以增强团队开发协作、提高代码质量。\n`推荐参考`\n**凹凸实验室**打造的[前端代码规范](https://guide.aotu.io/docs/index.html)。\n**Javascript Airbnb** 开发规范 [https://github.com/airbnb/jav...](https://github.com/airbnb/javascript)\n  * HTML规范\n  * CSS规范\n  * JS规范\n  * 图片规范\n  * 命名规范\n* ######前后端接口规范\n  “基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。\n\n  接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。\n* ###### 文档规范\n\n* ###### 组件管理\n\n* ###### git分支管理\n\n* ###### commit描述规范\n\n* ###### 定期 CodeReview\n\n### 自动化\n---\n   前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:\n\n>任何简单机械的重复劳动都应该让机器去完成。\n\n* 图标合并\n\n* 持续继承\n\n* 自动化构建\n\n* 自动化部署\n\n* 自动化测试\n\n# II. 工程化具体方法\n---\n## 1. 性能优化\n浏览器缓存是 Web 性能优化的重要方式。那么浏览器缓存的过程究竟是怎么样的呢？\n\n浏览器缓存主要分为`强强缓存（也称本地缓存）`和`协商缓存（也称弱缓存）`。\n ######强缓存\n *  Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。如我现在这个网页的 Expires 值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现 Cache-Control:max-age 和 Expires，那么 max-age 优先级更高。\n* Cache-Control 是在 http1.1 中出现的，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：\n\n  no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。\n\n  no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。\n\n  public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。\n  private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。\n  Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候   Cache-Control 优先级高。\n ######弱缓存/协商缓存\n**Etag 和 If-None-Match**\n\nEtag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存\n\n与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。\n\n**Last-Modify/If-Modify-Since**\n\n浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。\n\n当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。\n\n如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。\n\nLast-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag\n* * *\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c4678e7b6821f8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* * *\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4c9053e0fd74c93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 访问量和性能指标\n\na.css 的请求，如果每次用户访问页面都要加载，很影响性能，很浪费带宽\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-41104d7c231d27e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* * *\n\n利用 304，让浏览器使用本地缓存。304 叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2fd0094493df3b08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？\n\n很好，相信有人想到了办法：通过`更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源`。好像这样：\n\n![`](https://upload-images.jianshu.io/upload_images/11846892-577a64c93602bf2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css，c.css 的缓存也失效，那岂不是又有浪费了？！\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c3a7badbd331fd6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n重新开启变态模式，我们不难发现，要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。\n\n什么东西与文件内容相关呢？我们会很自然的联想到利用  `数据摘要算法` 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把 url 改成带摘要信息的：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-027cf303a23fc22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 节点上，网页中引用的资源也会变成对应的部署路径：\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-ae5c4239f5b12df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这次发布，同时改了页面结构和样式，也更新了静态资源对应的 url 地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f05ceb812e53f51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n* **先部署页面，再部署资源**：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。\n* **先部署资源，再部署页面**：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。\n\n---\n好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。\n有些公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！\n\n这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-3f21dab466192813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。\n\n---\n所以，静态资源优化方案，基本上要实现这么几个东西：\n\n配置超长时间的本地缓存 —— 节省带宽，提高性能\n采用内容摘要作为缓存更新依据 —— 精确的缓存控制\n静态资源 CDN 部署 —— 优化网络请求\n更资源发布路径实现非覆盖式发布 —— 平滑升级\n总之，前端性能优化绝逼是一个工程问题！\n---\n## 2. 静态资源部署 CDN\nCDN[Content Delivery Network] 内容分发网络 主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-80610fe2d3c9090e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n总结一下 CDN 的工作原理：通过权威 DNS 服务器来实现最优节点的选择，通过缓存来减少源站的压力。\n\n---\nCDN 应用场景：\n\n静态网页\n图片小文件、博客\n大文件下载\n软件下载、视频点播或图片存储网站\n动态加速\n直播网站\n应用加速\n手机 APP\n除却 CDN 自身的优势，在前端工程中，将静态文件放到 CDN 上，可以直观地减小资源包大小，同时加快首屏加载。\n\n若不使用 CDN，则所有的资源都会被打包到 app.js 和 vendor.js 中，页面需要等到这两个包下载完成才可以显示。\n若使用 CDN，则可以利用浏览器多线程的优势，同时下载若干静态文件以及剩下的 app.js 和 vendor.js，以此达到加快加载的目的。\n\n---\n\n### 3. 自动化文档生成\n\n`commit message` 作用\n\n*   提供更多的历史信息，方便快速浏览\n*   过滤某些 commit（比如文档改动），便于快速查找信息\n*   直接从 commit 生成 Change log\n*   可读性好，清晰，不必深入看代码即可了解当前 commit 的作用。\n*   为 Code Reviewing（代码审查）做准备\n*   方便跟踪工程历史\n*   提高项目的整体质量，提高个人工程素质\n\n目前，社区有多种 Commit message 的写法规范，我们介绍的工具是 commitizen，它使用的是 Angular 规范[AngularJS Git Commit Message Conventions](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0)，这是目前使用最广的写法，并且有对应的工具去生成 change log。\n\n**标准说明**\n\n每次提交， Commit message 都包括 Header, Body 和 Footer 三个部分。\n\n```\n<type>(<scope>): <subject>\n// 空行\n<body>\n// 空行\n<footer>\n```\n\n* * *\n\n**Header** 部分只有一行，包括三个字段：type, scope 和 subject 。\ntype 用于说明提交的类别，只运行使用下面几种，\n\n*   feat: 新功能\n*   fix: 修复 bug\n*   docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等等\n*   style: 格式更新（不影响代码运行的变动）\n*   refactor: 重构（既不是新增功能，又不是 bug 修复）\n*   test: 添加测试\n*   chore: 构建过程或辅助工具的变动\n*   perf: 优化相关，比如提升性能、体验\n*   revert: 回滚到上一个版本\n*   ci：自动化流程配置修改\n\n如果是 feat 和 fix ，则这个 commit 将肯定出现在 change log 中，其它情况可自行决定是否放入。\n\nscope 用于说明 commit 影响的范围 比如数据层、控制层、视图层等等，视项目不同而不同。\n\nsubject 是 commit 目的的简短描述，不超过 50 个字符。\n\n*   以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes\n*   第一个字母小写\n*   结尾不要加句号\n\n* * *\n\n**Body** 部分是对本次 commit 的详细描述，可分成多行。但是一般我都不写。\n\n**Footer** 部分只用于两种情况。\n\n不兼容变动\n\n如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n```\nBREAKING CHANGE: isolate scope bindings definition has changed.\n\n    To migrate the code follow the example below:\n\n    Before:\n\n    scope: {\n      myAttr: 'attribute',\n    }\n\n    After:\n\n    scope: {\n      myAttr: '@',\n    }\n\n    The removed `inject` wasn't generaly useful for directives so there should be no code using it.\n```\n\n* * *\n\n关闭 Issue\n如果当前 commit 针对某个 issue ，那么可以在 Footer 部分关闭这个 issue 。\n\n```\nCloses #1234\n```\n\n```\nCloses #1234, $1235, #1236\n```\n\n**Revert**\n\n如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header\n\n```\nrevert: feat(pencil): add 'graphiteWidth' option\n<br />\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\n```\n\n*   Body 部分的格式是固定的，必须写成 This reverts commit .，其中的 hash 是被撤销 commit 的 SHA 标识符。\n*   如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。\n\n* * *\n\n##### 自动生成 changelog 文档\n\n###### commitizen\n\nCommitizen 是一个撰写合格 Commit message 的工具。。\n\n```\nnpm install -g commitizen\n# 在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。\ncommitizen init cz-conventional-changelog --save --save-exact\n```\n\n用 git cz -m 代替 git commit -m 就可以轻松的写出 Angular 规范的 commit message 了。\n\n###### validate-commit-msg\n\n用于检查 Node 项目的 Commit message 是否符合格式。\n\n###### conventional-changelog\n\n生成 Change log 的工具，运行下面的命令即可。\n\n```\nnpm install -g conventional-changelog-cli\ncd my-project\nconventional-changelog -p angular -i CHANGELOG.md -s\n```\n\n* * *\n\n如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成\n\n生成的文档包括以下三个部分。\n\n*   New features\n*   Bug fixes\n*   Breaking changes.\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\n为了方便使用，可以将其写入 package.json 的 scripts 字段。\n\n```\n{\n  \"scripts\": {\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -w -r 0\"\n  }\n}\n```\n\n```\nnpm run changelog\n```\n\n### 4. 前端埋点\n**目的** \n获取用户基本信息、行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。\n**前端监控类别**\n前端监控可以分为三类：数据监控、性能监控和异常监控。\n`数据监控`就是监听用户信息和行为，常见的监控项有\n\n*PV(page view 页面访问量)：即页面浏览量或点击量\n* UV(unique visitor 独立访客)：指访问某个站点或点击某条新闻的不同 IP 地址的人数\n* 用户在每一个页面的停留时间\n* 用户通过什么入口来访问该网页\n* 用户在相应的页面中触发的行为\n统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。\n\n`性能监控`指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控项包括：\n\n* 不同用户，不同机型和不同系统下的首屏加载时间\n* http 等请求的响应时间\n* 静态资源整体下载时间\n* 页面渲染时间\n* 页面交互动画完成时间\n这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。\n\n`异常监控`由于产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 try catch 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：\n\n* Javascript 的异常监控\n* 样式丢失的异常监控\n* 服务器请求的异常监控\n我们说完了前端监控的三个分类，现在就来聊聊怎么实现前端监控。实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台，最后进行数据分析。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。\n***\n#####前端埋点分类\n\n\n收集监控数据我们是通过前端埋点来实现的，目前常见的前端埋点方法有三种：`  `手动埋点`、`可视化埋点`和`无埋点`。\n**手动埋点**，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像友盟、百度统计等第三方数据统计服务商大都采用这种方案。\n优势:\n\n  * 可自定义属性，自定义事件\n   * 可以细化需求\n   * 相比其他埋点方式减少服务器压力\n\n缺陷:\n\n   * 工程量大的话，手动埋点会出现疏漏，不方便审查。\n   * 需求变更要重新埋点，成本高。\n   * 每次需求变更都要重新发布版本，对线上系统稳定性有一定危害\n\n```\n$(document).ready(() => {\n  // ... 这里是你的业务逻辑代码\n  sendData(params) //这里是发送你的埋点数据，params是你封装的埋点数据\n})\n```\n***\n**前端框架式手动埋点**\n\n如果使用 Vue 或者 React 等前端框架，这些框架都有自己的各种生命周期，为了减少重复性的手动埋点次数，可以在各个生命周期位置，根据你的需求封装你所需的埋点。比如你是 SPA 单页应用，你希望在每一个页面的 componentDidMount 埋点，并由此确定用户已经打开了页面。\n\ncss 埋点：\n```\n.link:active::after {\n  content: url('http://www.example.com?action=yourdata');\n}\n<a class=\"link\">点击我，会发埋点数据</a>\n```\n***\n**可视化埋点**解决了纯手动埋点的开发成本和更新成本，通过可视化工具快速配置采集节点（圈点），在前端自动解析配置，并根据配置上传埋点数据，比起手动埋点看起来更无痕，\n\n比如国外比较早做可视化的是 Mixpanel，国内较早支持可视化埋点的有 TalkingData、诸葛 IO，2017 年腾讯的 MTA 也宣布支持可视化埋点；\n***\n**无埋点**则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。\n\n优点:\n前端只要一次加载埋点脚本\n\n缺点:\n服务器性能压力山大\n\n采用无埋点技术的有主流的 GrowingIO、神策。无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。\n\n#VI. 总结\n---\n\n在业界内有这么一句话：任何简单机械的重复劳动都应该让机器去完成。现代前端技术不再是以前刀耕火种的年代了。所以前端工程化的很多脏活累活都应该交给自动化工具来完成。\n\n如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说：\n\n你好，工程师！\n\n\n\n参考链接：\n1.  [前端工程化的理解](https://www.jianshu.com/p/88ed70476adb)\n2.  [大公司里怎样开发和部署前端代码？]([https://www.zhihu.com/question/20790576/answer/32602154])\n3. [前端埋点的那些事](http://www.imooc.com/article/27151)\n4.  [小谈前端埋点](https://www.jianshu.com/p/645a26619508)\n2.  [前端工程——基础篇](https://github.com/fouber/blog/issues/10)\n3.  [http-proxy-middleware](https://www.jianshu.com/p/a248b146c55a)\n4.  [Webpack dev server 使用 http-proxy 解决跨域问题](https://www.jianshu.com/p/3bdff821f859)\n5.  [chimurai/http-proxy-middleware](https://github.com/chimurai/http-proxy-middleware)\n6.  [详解 webpack-dev-server 的简单使用](https://www.jb51.net/article/137608.htm)\n7.  [html-webpack-plugin](https://github.com/jantimon/html-webpack-plugin)\n8.  [webpack 使用 HtmlWebpackPlugin 进行 cdn 配置](https://www.jianshu.com/p/9248db0349fb)\n9.  [CDN 是什么？使用 CDN 有什么优势？](https://blog.csdn.net/const_ly/article/details/79788728)\n10.  [webpack4-06-开发、生产环境、动态 CDN 配置](https://www.codercto.com/a/76835.html)\n11.  [HTTP 强缓存和协商缓存](https://segmentfault.com/a/1190000008956069)\n12.  [Cache-Control 之 no-cache 和 max-age=0](https://www.jianshu.com/p/1744780ddda0)\n13.  [Commit message 代码提交规范](https://segmentfault.com/a/1190000019579621)\n14.  [Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n15.  [git commit 、CHANGELOG 和版本发布的标准自动化](https://www.cnblogs.com/zivxiaowei/p/10089201.html)\n\n","slug":"Front-endEngineering","published":1,"updated":"2020-05-27T06:56:29.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqh000n78p3osj7ld7v","content":"<p>Author: Echo<br>Time: 2020-05-27 14:55:06</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>web应用复杂度的增加，特别是单页面应用的风靡。组件化，工程化，自动化成了前端发展的趋势。<br>每个前端团队都在打造自己的前端开发体系，这通常是一个东拼西凑，逐渐磨合的过程，在技术发展日新月异的今天，这样的过程真的是不可抽象和复制的么？通过拆解前端开发体系,对前端工程化有所理解。</p>\n<h1 id=\"I-前端工程化\"><a href=\"#I-前端工程化\" class=\"headerlink\" title=\"I. 前端工程化\"></a>I. 前端工程化</h1><hr>\n<p>前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是”前端工程化”。</p>\n<h6 id=\"前端工程化面临的问题\"><a href=\"#前端工程化面临的问题\" class=\"headerlink\" title=\"前端工程化面临的问题 ?\"></a>前端工程化面临的问题 ?</h6><ol>\n<li><p>开发成本<br>大体量：多功能、多页面、多状态、多系统；<br>大规模：多人甚至多团队合作开发；</p>\n<ul>\n<li>提高开发生产效率</li>\n<li>降低维护难度</li>\n</ul>\n</li>\n</ol>\n<p>这两个问题的解决方案有两点：</p>\n<ul>\n<li>制定开发规范，提高团队协作能力；</li>\n<li>分治。软件工程中有个很重要的概念叫做<code>模块化开发</code>其中心思想就是分治。<ol start=\"2\">\n<li>部署<br>从部署角度，要解决的问题主要是资源管理，包括：</li>\n</ol>\n</li>\n<li>代码审查</li>\n<li>压缩打包</li>\n<li>增量更新</li>\n<li>单元测试</li>\n</ul>\n<ol start=\"3\">\n<li>高性能<br>CDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。<h6 id=\"如何做”前端工程化”？\"><a href=\"#如何做”前端工程化”？\" class=\"headerlink\" title=\"如何做”前端工程化”？\"></a>如何做”前端工程化”？</h6>前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从模块化、组件化、规范化、自动化四个方面思考。</li>\n</ol>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><hr>\n<blockquote>\n<p>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。</p>\n</blockquote>\n<h6 id=\"JS的模块化\"><a href=\"#JS的模块化\" class=\"headerlink\" title=\"JS的模块化\"></a>JS的模块化</h6><p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。<br>现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。</p>\n<ul>\n<li>用 Webpack + Babel 将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；</li>\n<li>用 System+Babel 主要是分模块异步加载；</li>\n<li>用浏览器的<script type=\"module\">加载。<h6 id=\"CSS的模块化\"><a href=\"#CSS的模块化\" class=\"headerlink\" title=\"CSS的模块化\"></a>CSS的模块化</h6>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</li>\n</ul>\n<p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p>\n<p>为了避免全局选择器的冲突，需要制定CSS命名风格：</p>\n<ul>\n<li>BEM风格</li>\n<li>Bootstrap风格</li>\n<li>团队CSS规范</li>\n</ul>\n<p>但是这毕竟是弱约束。所以很赞同一句话：</p>\n<blockquote>\n<p>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</p>\n</blockquote>\n<p>从工具层面，社区又创造出<code>Shadow DOM</code>、<code>CSS in JS</code>和<code>CSS Modules</code>三种解决方案。</p>\n<ul>\n<li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li>\n<li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li>\n<li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的<code>scoped</code> style也算是一种。<h6 id=\"资源的模块化\"><a href=\"#资源的模块化\" class=\"headerlink\" title=\"资源的模块化\"></a>资源的模块化</h6>Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。</li>\n<li><code>依赖关系单一化</code>。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li>\n<li><code>资源处理集成化</code>。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；</li>\n<li><code>项目结构清晰化</code>。使用Webpack后，你的项目结构总可以表示成这样的函数： <code>dest = webpack(src, config)</code>。<h3 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h3></li>\n</ul>\n<hr>\n<p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p>\n<blockquote>\n<p><code>组件化≠模块化</code>。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p>\n</blockquote>\n<p>随着 web 应用规模越来越大，模块/组件化开发的需求就显得越来越迫切。模块/组件化开发的核心思想是分治，主要针对的是开发和维护阶段。</p>\n<ol>\n<li>Web 应用的组件化开发。<a href=\"http://blog.jobbole.com/56161/\">http://blog.jobbole.com/56161/</a></li>\n<li>前端组件化开发实践。<a href=\"http://web.jobbole.com/82689/\">http://web.jobbole.com/82689/</a></li>\n<li>大规模的前端组件化与模块化。<a href=\"http://www.infoq.com/cn/news/2014/04/front-end-modular\">http://www.infoq.com/cn/news/…</a></li>\n</ol>\n<h6 id=\"为什么搭建私有组件库\"><a href=\"#为什么搭建私有组件库\" class=\"headerlink\" title=\"为什么搭建私有组件库?\"></a>为什么搭建私有组件库?</h6><ul>\n<li>可复用 跨项目可以使用同一套私有组件库</li>\n<li>方便维护 如需组件调整 只需要修改组件库 不需要跨项目重复修改</li>\n</ul>\n<h5 id=\"添加新组件原则\"><a href=\"#添加新组件原则\" class=\"headerlink\" title=\"添加新组件原则\"></a>添加新组件原则</h5><ul>\n<li>组件应先存在于具体项目中，经过重复验证后再抽象、沉淀到本组件库中</li>\n<li>Vue component 只应负责渲染数据和内部逻辑，尽可能不包含 &dollar;t 国际化、ajax 请求等业务数据和逻辑</li>\n<li>组件和其他模块应尽可能的搭配单元测试、可运行的 storybook 例子</li>\n<li>应该在 CHANGELOG 中记录每次增删改的组件信息等</li>\n</ul>\n<h3 id=\"规范化\"><a href=\"#规范化\" class=\"headerlink\" title=\"规范化\"></a>规范化</h3><hr>\n<p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p>\n<p>比如：</p>\n<ul>\n<li>######目录结构的制定</li>\n<li>######编码规范<br>  制定一套良好的编码规范可以增强团队开发协作、提高代码质量。<br><code>推荐参考</code><br><strong>凹凸实验室</strong>打造的<a href=\"https://guide.aotu.io/docs/index.html\">前端代码规范</a>。<br><strong>Javascript Airbnb</strong> 开发规范 <a href=\"https://github.com/airbnb/javascript\">https://github.com/airbnb/jav…</a><ul>\n<li>HTML规范</li>\n<li>CSS规范</li>\n<li>JS规范</li>\n<li>图片规范</li>\n<li>命名规范</li>\n</ul>\n</li>\n<li><p>######前后端接口规范<br>“基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。</p>\n<p>接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。</p>\n</li>\n<li><h6 id=\"文档规范\"><a href=\"#文档规范\" class=\"headerlink\" title=\"文档规范\"></a>文档规范</h6></li>\n<li><h6 id=\"组件管理\"><a href=\"#组件管理\" class=\"headerlink\" title=\"组件管理\"></a>组件管理</h6></li>\n<li><h6 id=\"git分支管理\"><a href=\"#git分支管理\" class=\"headerlink\" title=\"git分支管理\"></a>git分支管理</h6></li>\n<li><h6 id=\"commit描述规范\"><a href=\"#commit描述规范\" class=\"headerlink\" title=\"commit描述规范\"></a>commit描述规范</h6></li>\n<li><h6 id=\"定期-CodeReview\"><a href=\"#定期-CodeReview\" class=\"headerlink\" title=\"定期 CodeReview\"></a>定期 CodeReview</h6></li>\n</ul>\n<h3 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h3><hr>\n<p>   前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:</p>\n<blockquote>\n<p>任何简单机械的重复劳动都应该让机器去完成。</p>\n</blockquote>\n<ul>\n<li><p>图标合并</p>\n</li>\n<li><p>持续继承</p>\n</li>\n<li><p>自动化构建</p>\n</li>\n<li><p>自动化部署</p>\n</li>\n<li><p>自动化测试</p>\n</li>\n</ul>\n<h1 id=\"II-工程化具体方法\"><a href=\"#II-工程化具体方法\" class=\"headerlink\" title=\"II. 工程化具体方法\"></a>II. 工程化具体方法</h1><hr>\n<h2 id=\"1-性能优化\"><a href=\"#1-性能优化\" class=\"headerlink\" title=\"1. 性能优化\"></a>1. 性能优化</h2><p>浏览器缓存是 Web 性能优化的重要方式。那么浏览器缓存的过程究竟是怎么样的呢？</p>\n<p>浏览器缓存主要分为<code>强强缓存（也称本地缓存）</code>和<code>协商缓存（也称弱缓存）</code>。</p>\n<p> ######强缓存</p>\n<ul>\n<li><p>Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。如我现在这个网页的 Expires 值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现 Cache-Control:max-age 和 Expires，那么 max-age 优先级更高。</p>\n<ul>\n<li>Cache-Control 是在 http1.1 中出现的，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</li>\n</ul>\n<p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>\n<p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>\n<p>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。<br>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。<br>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候   Cache-Control 优先级高。<br>######弱缓存/协商缓存<br><strong>Etag 和 If-None-Match</strong></p>\n</li>\n</ul>\n<p>Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存</p>\n<p>与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p>\n<p><strong>Last-Modify/If-Modify-Since</strong></p>\n<p>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>\n<p>当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</p>\n<p>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p>\n<p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag</p>\n<hr>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c4678e7b6821f8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4c9053e0fd74c93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"访问量和性能指标\"><a href=\"#访问量和性能指标\" class=\"headerlink\" title=\"访问量和性能指标\"></a>访问量和性能指标</h4><p>a.css 的请求，如果每次用户访问页面都要加载，很影响性能，很浪费带宽</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-41104d7c231d27e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<p>利用 304，让浏览器使用本地缓存。304 叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2fd0094493df3b08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？</p>\n<p>很好，相信有人想到了办法：通过<code>更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源</code>。好像这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-577a64c93602bf2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"`\"></p>\n<p>页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css，c.css 的缓存也失效，那岂不是又有浪费了？！</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c3a7badbd331fd6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>重新开启变态模式，我们不难发现，要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。</p>\n<p>什么东西与文件内容相关呢？我们会很自然的联想到利用  <code>数据摘要算法</code> 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把 url 改成带摘要信息的：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-027cf303a23fc22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 节点上，网页中引用的资源也会变成对应的部署路径：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-ae5c4239f5b12df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>这次发布，同时改了页面结构和样式，也更新了静态资源对应的 url 地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f05ceb812e53f51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li><strong>先部署页面，再部署资源</strong>：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。</li>\n<li><strong>先部署资源，再部署页面</strong>：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。</li>\n</ul>\n<hr>\n<p>好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。<br>有些公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！</p>\n<p>这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-3f21dab466192813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。</p>\n<hr>\n<p>所以，静态资源优化方案，基本上要实现这么几个东西：</p>\n<p>配置超长时间的本地缓存 —— 节省带宽，提高性能<br>采用内容摘要作为缓存更新依据 —— 精确的缓存控制<br>静态资源 CDN 部署 —— 优化网络请求<br>更资源发布路径实现非覆盖式发布 —— 平滑升级</p>\n<h2 id=\"总之，前端性能优化绝逼是一个工程问题！\"><a href=\"#总之，前端性能优化绝逼是一个工程问题！\" class=\"headerlink\" title=\"总之，前端性能优化绝逼是一个工程问题！\"></a>总之，前端性能优化绝逼是一个工程问题！</h2><h2 id=\"2-静态资源部署-CDN\"><a href=\"#2-静态资源部署-CDN\" class=\"headerlink\" title=\"2. 静态资源部署 CDN\"></a>2. 静态资源部署 CDN</h2><p>CDN[Content Delivery Network] 内容分发网络 主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-80610fe2d3c9090e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>总结一下 CDN 的工作原理：通过权威 DNS 服务器来实现最优节点的选择，通过缓存来减少源站的压力。</p>\n<hr>\n<p>CDN 应用场景：</p>\n<p>静态网页<br>图片小文件、博客<br>大文件下载<br>软件下载、视频点播或图片存储网站<br>动态加速<br>直播网站<br>应用加速<br>手机 APP<br>除却 CDN 自身的优势，在前端工程中，将静态文件放到 CDN 上，可以直观地减小资源包大小，同时加快首屏加载。</p>\n<p>若不使用 CDN，则所有的资源都会被打包到 app.js 和 vendor.js 中，页面需要等到这两个包下载完成才可以显示。<br>若使用 CDN，则可以利用浏览器多线程的优势，同时下载若干静态文件以及剩下的 app.js 和 vendor.js，以此达到加快加载的目的。</p>\n<hr>\n<h3 id=\"3-自动化文档生成\"><a href=\"#3-自动化文档生成\" class=\"headerlink\" title=\"3. 自动化文档生成\"></a>3. 自动化文档生成</h3><p><code>commit message</code> 作用</p>\n<ul>\n<li>提供更多的历史信息，方便快速浏览</li>\n<li>过滤某些 commit（比如文档改动），便于快速查找信息</li>\n<li>直接从 commit 生成 Change log</li>\n<li>可读性好，清晰，不必深入看代码即可了解当前 commit 的作用。</li>\n<li>为 Code Reviewing（代码审查）做准备</li>\n<li>方便跟踪工程历史</li>\n<li>提高项目的整体质量，提高个人工程素质</li>\n</ul>\n<p>目前，社区有多种 Commit message 的写法规范，我们介绍的工具是 commitizen，它使用的是 Angular 规范<a href=\"https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0\">AngularJS Git Commit Message Conventions</a>，这是目前使用最广的写法，并且有对应的工具去生成 change log。</p>\n<p><strong>标准说明</strong></p>\n<p>每次提交， Commit message 都包括 Header, Body 和 Footer 三个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class=\"line\">// 空行</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">// 空行</span><br><span class=\"line\">&lt;footer&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>Header</strong> 部分只有一行，包括三个字段：type, scope 和 subject 。<br>type 用于说明提交的类别，只运行使用下面几种，</p>\n<ul>\n<li>feat: 新功能</li>\n<li>fix: 修复 bug</li>\n<li>docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等等</li>\n<li>style: 格式更新（不影响代码运行的变动）</li>\n<li>refactor: 重构（既不是新增功能，又不是 bug 修复）</li>\n<li>test: 添加测试</li>\n<li>chore: 构建过程或辅助工具的变动</li>\n<li>perf: 优化相关，比如提升性能、体验</li>\n<li>revert: 回滚到上一个版本</li>\n<li>ci：自动化流程配置修改</li>\n</ul>\n<p>如果是 feat 和 fix ，则这个 commit 将肯定出现在 change log 中，其它情况可自行决定是否放入。</p>\n<p>scope 用于说明 commit 影响的范围 比如数据层、控制层、视图层等等，视项目不同而不同。</p>\n<p>subject 是 commit 目的的简短描述，不超过 50 个字符。</p>\n<ul>\n<li>以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li>\n<li>第一个字母小写</li>\n<li>结尾不要加句号</li>\n</ul>\n<hr>\n<p><strong>Body</strong> 部分是对本次 commit 的详细描述，可分成多行。但是一般我都不写。</p>\n<p><strong>Footer</strong> 部分只用于两种情况。</p>\n<p>不兼容变动</p>\n<p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class=\"line\"></span><br><span class=\"line\">    To migrate the code follow the example below:</span><br><span class=\"line\"></span><br><span class=\"line\">    Before:</span><br><span class=\"line\"></span><br><span class=\"line\">    scope: &#123;</span><br><span class=\"line\">      myAttr: &apos;attribute&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    After:</span><br><span class=\"line\"></span><br><span class=\"line\">    scope: &#123;</span><br><span class=\"line\">      myAttr: &apos;@&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure>\n<hr>\n<p>关闭 Issue<br>如果当前 commit 针对某个 issue ，那么可以在 Footer 部分关闭这个 issue 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Closes #1234</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Closes #1234, $1235, #1236</span><br></pre></td></tr></table></figure>\n<p><strong>Revert</strong></p>\n<p>如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class=\"line\">&lt;br /&gt;</span><br><span class=\"line\">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Body 部分的格式是固定的，必须写成 This reverts commit .，其中的 hash 是被撤销 commit 的 SHA 标识符。</li>\n<li>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。</li>\n</ul>\n<hr>\n<h5 id=\"自动生成-changelog-文档\"><a href=\"#自动生成-changelog-文档\" class=\"headerlink\" title=\"自动生成 changelog 文档\"></a>自动生成 changelog 文档</h5><h6 id=\"commitizen\"><a href=\"#commitizen\" class=\"headerlink\" title=\"commitizen\"></a>commitizen</h6><p>Commitizen 是一个撰写合格 Commit message 的工具。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g commitizen</span><br><span class=\"line\"># 在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</span><br><span class=\"line\">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>\n<p>用 git cz -m 代替 git commit -m 就可以轻松的写出 Angular 规范的 commit message 了。</p>\n<h6 id=\"validate-commit-msg\"><a href=\"#validate-commit-msg\" class=\"headerlink\" title=\"validate-commit-msg\"></a>validate-commit-msg</h6><p>用于检查 Node 项目的 Commit message 是否符合格式。</p>\n<h6 id=\"conventional-changelog\"><a href=\"#conventional-changelog\" class=\"headerlink\" title=\"conventional-changelog\"></a>conventional-changelog</h6><p>生成 Change log 的工具，运行下面的命令即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g conventional-changelog-cli</span><br><span class=\"line\">cd my-project</span><br><span class=\"line\">conventional-changelog -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>\n<hr>\n<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成</p>\n<p>生成的文档包括以下三个部分。</p>\n<ul>\n<li>New features</li>\n<li>Bug fixes</li>\n<li>Breaking changes.</li>\n</ul>\n<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>\n<p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run changelog</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-前端埋点\"><a href=\"#4-前端埋点\" class=\"headerlink\" title=\"4. 前端埋点\"></a>4. 前端埋点</h3><p><strong>目的</strong><br>获取用户基本信息、行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。<br><strong>前端监控类别</strong><br>前端监控可以分为三类：数据监控、性能监控和异常监控。<br><code>数据监控</code>就是监听用户信息和行为，常见的监控项有</p>\n<p>*PV(page view 页面访问量)：即页面浏览量或点击量</p>\n<ul>\n<li>UV(unique visitor 独立访客)：指访问某个站点或点击某条新闻的不同 IP 地址的人数</li>\n<li>用户在每一个页面的停留时间</li>\n<li>用户通过什么入口来访问该网页</li>\n<li>用户在相应的页面中触发的行为<br>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</li>\n</ul>\n<p><code>性能监控</code>指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控项包括：</p>\n<ul>\n<li>不同用户，不同机型和不同系统下的首屏加载时间</li>\n<li>http 等请求的响应时间</li>\n<li>静态资源整体下载时间</li>\n<li>页面渲染时间</li>\n<li>页面交互动画完成时间<br>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</li>\n</ul>\n<p><code>异常监控</code>由于产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 try catch 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>\n<ul>\n<li>Javascript 的异常监控</li>\n<li>样式丢失的异常监控</li>\n<li>服务器请求的异常监控<br>我们说完了前端监控的三个分类，现在就来聊聊怎么实现前端监控。实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台，最后进行数据分析。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。</li>\n</ul>\n<hr>\n<p>#####前端埋点分类</p>\n<p>收集监控数据我们是通过前端埋点来实现的，目前常见的前端埋点方法有三种：<code></code>手动埋点<code>、</code>可视化埋点<code>和</code>无埋点`。<br><strong>手动埋点</strong>，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像友盟、百度统计等第三方数据统计服务商大都采用这种方案。<br>优势:</p>\n<ul>\n<li>可自定义属性，自定义事件<ul>\n<li>可以细化需求</li>\n<li>相比其他埋点方式减少服务器压力</li>\n</ul>\n</li>\n</ul>\n<p>缺陷:</p>\n<ul>\n<li>工程量大的话，手动埋点会出现疏漏，不方便审查。</li>\n<li>需求变更要重新埋点，成本高。</li>\n<li>每次需求变更都要重新发布版本，对线上系统稳定性有一定危害</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(document).ready(() =&gt; &#123;</span><br><span class=\"line\">  // ... 这里是你的业务逻辑代码</span><br><span class=\"line\">  sendData(params) //这里是发送你的埋点数据，params是你封装的埋点数据</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>前端框架式手动埋点</strong></p>\n<p>如果使用 Vue 或者 React 等前端框架，这些框架都有自己的各种生命周期，为了减少重复性的手动埋点次数，可以在各个生命周期位置，根据你的需求封装你所需的埋点。比如你是 SPA 单页应用，你希望在每一个页面的 componentDidMount 埋点，并由此确定用户已经打开了页面。</p>\n<p>css 埋点：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.link:active::after &#123;</span><br><span class=\"line\">  content: url(&apos;http://www.example.com?action=yourdata&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;a class=&quot;link&quot;&gt;点击我，会发埋点数据&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>可视化埋点</strong>解决了纯手动埋点的开发成本和更新成本，通过可视化工具快速配置采集节点（圈点），在前端自动解析配置，并根据配置上传埋点数据，比起手动埋点看起来更无痕，</p>\n<p>比如国外比较早做可视化的是 Mixpanel，国内较早支持可视化埋点的有 TalkingData、诸葛 IO，2017 年腾讯的 MTA 也宣布支持可视化埋点；</p>\n<hr>\n<p><strong>无埋点</strong>则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>\n<p>优点:<br>前端只要一次加载埋点脚本</p>\n<p>缺点:<br>服务器性能压力山大</p>\n<p>采用无埋点技术的有主流的 GrowingIO、神策。无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>\n<h2 id=\"VI-总结\"><a href=\"#VI-总结\" class=\"headerlink\" title=\"#VI. 总结\"></a>#VI. 总结</h2><p>在业界内有这么一句话：任何简单机械的重复劳动都应该让机器去完成。现代前端技术不再是以前刀耕火种的年代了。所以前端工程化的很多脏活累活都应该交给自动化工具来完成。</p>\n<p>如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说：</p>\n<p>你好，工程师！</p>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/88ed70476adb\">前端工程化的理解</a></li>\n<li><a href=\"[https://www.zhihu.com/question/20790576/answer/32602154]\">大公司里怎样开发和部署前端代码？</a></li>\n<li><a href=\"http://www.imooc.com/article/27151\">前端埋点的那些事</a></li>\n<li><a href=\"https://www.jianshu.com/p/645a26619508\">小谈前端埋点</a></li>\n<li><a href=\"https://github.com/fouber/blog/issues/10\">前端工程——基础篇</a></li>\n<li><a href=\"https://www.jianshu.com/p/a248b146c55a\">http-proxy-middleware</a></li>\n<li><a href=\"https://www.jianshu.com/p/3bdff821f859\">Webpack dev server 使用 http-proxy 解决跨域问题</a></li>\n<li><a href=\"https://github.com/chimurai/http-proxy-middleware\">chimurai/http-proxy-middleware</a></li>\n<li><a href=\"https://www.jb51.net/article/137608.htm\">详解 webpack-dev-server 的简单使用</a></li>\n<li><a href=\"https://github.com/jantimon/html-webpack-plugin\">html-webpack-plugin</a></li>\n<li><a href=\"https://www.jianshu.com/p/9248db0349fb\">webpack 使用 HtmlWebpackPlugin 进行 cdn 配置</a></li>\n<li><a href=\"https://blog.csdn.net/const_ly/article/details/79788728\">CDN 是什么？使用 CDN 有什么优势？</a></li>\n<li><a href=\"https://www.codercto.com/a/76835.html\">webpack4-06-开发、生产环境、动态 CDN 配置</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008956069\">HTTP 强缓存和协商缓存</a></li>\n<li><a href=\"https://www.jianshu.com/p/1744780ddda0\">Cache-Control 之 no-cache 和 max-age=0</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019579621\">Commit message 代码提交规范</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\">Commit message 和 Change log 编写指南</a></li>\n<li><a href=\"https://www.cnblogs.com/zivxiaowei/p/10089201.html\">git commit 、CHANGELOG 和版本发布的标准自动化</a></li>\n</ol>\n</script></li></ul>","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2020-05-27 14:55:06</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>web应用复杂度的增加，特别是单页面应用的风靡。组件化，工程化，自动化成了前端发展的趋势。<br>每个前端团队都在打造自己的前端开发体系，这通常是一个东拼西凑，逐渐磨合的过程，在技术发展日新月异的今天，这样的过程真的是不可抽象和复制的么？通过拆解前端开发体系,对前端工程化有所理解。</p>\n<h1 id=\"I-前端工程化\"><a href=\"#I-前端工程化\" class=\"headerlink\" title=\"I. 前端工程化\"></a>I. 前端工程化</h1><hr>\n<p>前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是”前端工程化”。</p>\n<h6 id=\"前端工程化面临的问题\"><a href=\"#前端工程化面临的问题\" class=\"headerlink\" title=\"前端工程化面临的问题 ?\"></a>前端工程化面临的问题 ?</h6><ol>\n<li><p>开发成本<br>大体量：多功能、多页面、多状态、多系统；<br>大规模：多人甚至多团队合作开发；</p>\n<ul>\n<li>提高开发生产效率</li>\n<li>降低维护难度</li>\n</ul>\n</li>\n</ol>\n<p>这两个问题的解决方案有两点：</p>\n<ul>\n<li>制定开发规范，提高团队协作能力；</li>\n<li>分治。软件工程中有个很重要的概念叫做<code>模块化开发</code>其中心思想就是分治。<ol start=\"2\">\n<li>部署<br>从部署角度，要解决的问题主要是资源管理，包括：</li>\n</ol>\n</li>\n<li>代码审查</li>\n<li>压缩打包</li>\n<li>增量更新</li>\n<li>单元测试</li>\n</ul>\n<ol start=\"3\">\n<li>高性能<br>CDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。<h6 id=\"如何做”前端工程化”？\"><a href=\"#如何做”前端工程化”？\" class=\"headerlink\" title=\"如何做”前端工程化”？\"></a>如何做”前端工程化”？</h6>前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从模块化、组件化、规范化、自动化四个方面思考。</li>\n</ol>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><hr>\n<blockquote>\n<p>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。</p>\n</blockquote>\n<h6 id=\"JS的模块化\"><a href=\"#JS的模块化\" class=\"headerlink\" title=\"JS的模块化\"></a>JS的模块化</h6><p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。<br>现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。</p>\n<ul>\n<li>用 Webpack + Babel 将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；</li>\n<li>用 System+Babel 主要是分模块异步加载；</li>\n<li>用浏览器的<script type=\"module\">加载。<h6 id=\"CSS的模块化\"><a href=\"#CSS的模块化\" class=\"headerlink\" title=\"CSS的模块化\"></a>CSS的模块化</h6>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</li>\n</ul>\n<p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p>\n<p>为了避免全局选择器的冲突，需要制定CSS命名风格：</p>\n<ul>\n<li>BEM风格</li>\n<li>Bootstrap风格</li>\n<li>团队CSS规范</li>\n</ul>\n<p>但是这毕竟是弱约束。所以很赞同一句话：</p>\n<blockquote>\n<p>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</p>\n</blockquote>\n<p>从工具层面，社区又创造出<code>Shadow DOM</code>、<code>CSS in JS</code>和<code>CSS Modules</code>三种解决方案。</p>\n<ul>\n<li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li>\n<li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li>\n<li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的<code>scoped</code> style也算是一种。<h6 id=\"资源的模块化\"><a href=\"#资源的模块化\" class=\"headerlink\" title=\"资源的模块化\"></a>资源的模块化</h6>Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。</li>\n<li><code>依赖关系单一化</code>。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li>\n<li><code>资源处理集成化</code>。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；</li>\n<li><code>项目结构清晰化</code>。使用Webpack后，你的项目结构总可以表示成这样的函数： <code>dest = webpack(src, config)</code>。<h3 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h3></li>\n</ul>\n<hr>\n<p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p>\n<blockquote>\n<p><code>组件化≠模块化</code>。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p>\n</blockquote>\n<p>随着 web 应用规模越来越大，模块/组件化开发的需求就显得越来越迫切。模块/组件化开发的核心思想是分治，主要针对的是开发和维护阶段。</p>\n<ol>\n<li>Web 应用的组件化开发。<a href=\"http://blog.jobbole.com/56161/\">http://blog.jobbole.com/56161/</a></li>\n<li>前端组件化开发实践。<a href=\"http://web.jobbole.com/82689/\">http://web.jobbole.com/82689/</a></li>\n<li>大规模的前端组件化与模块化。<a href=\"http://www.infoq.com/cn/news/2014/04/front-end-modular\">http://www.infoq.com/cn/news/…</a></li>\n</ol>\n<h6 id=\"为什么搭建私有组件库\"><a href=\"#为什么搭建私有组件库\" class=\"headerlink\" title=\"为什么搭建私有组件库?\"></a>为什么搭建私有组件库?</h6><ul>\n<li>可复用 跨项目可以使用同一套私有组件库</li>\n<li>方便维护 如需组件调整 只需要修改组件库 不需要跨项目重复修改</li>\n</ul>\n<h5 id=\"添加新组件原则\"><a href=\"#添加新组件原则\" class=\"headerlink\" title=\"添加新组件原则\"></a>添加新组件原则</h5><ul>\n<li>组件应先存在于具体项目中，经过重复验证后再抽象、沉淀到本组件库中</li>\n<li>Vue component 只应负责渲染数据和内部逻辑，尽可能不包含 &dollar;t 国际化、ajax 请求等业务数据和逻辑</li>\n<li>组件和其他模块应尽可能的搭配单元测试、可运行的 storybook 例子</li>\n<li>应该在 CHANGELOG 中记录每次增删改的组件信息等</li>\n</ul>\n<h3 id=\"规范化\"><a href=\"#规范化\" class=\"headerlink\" title=\"规范化\"></a>规范化</h3><hr>\n<p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p>\n<p>比如：</p>\n<ul>\n<li>######目录结构的制定</li>\n<li>######编码规范<br>  制定一套良好的编码规范可以增强团队开发协作、提高代码质量。<br><code>推荐参考</code><br><strong>凹凸实验室</strong>打造的<a href=\"https://guide.aotu.io/docs/index.html\">前端代码规范</a>。<br><strong>Javascript Airbnb</strong> 开发规范 <a href=\"https://github.com/airbnb/javascript\">https://github.com/airbnb/jav…</a><ul>\n<li>HTML规范</li>\n<li>CSS规范</li>\n<li>JS规范</li>\n<li>图片规范</li>\n<li>命名规范</li>\n</ul>\n</li>\n<li><p>######前后端接口规范<br>“基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。</p>\n<p>接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。</p>\n</li>\n<li><h6 id=\"文档规范\"><a href=\"#文档规范\" class=\"headerlink\" title=\"文档规范\"></a>文档规范</h6></li>\n<li><h6 id=\"组件管理\"><a href=\"#组件管理\" class=\"headerlink\" title=\"组件管理\"></a>组件管理</h6></li>\n<li><h6 id=\"git分支管理\"><a href=\"#git分支管理\" class=\"headerlink\" title=\"git分支管理\"></a>git分支管理</h6></li>\n<li><h6 id=\"commit描述规范\"><a href=\"#commit描述规范\" class=\"headerlink\" title=\"commit描述规范\"></a>commit描述规范</h6></li>\n<li><h6 id=\"定期-CodeReview\"><a href=\"#定期-CodeReview\" class=\"headerlink\" title=\"定期 CodeReview\"></a>定期 CodeReview</h6></li>\n</ul>\n<h3 id=\"自动化\"><a href=\"#自动化\" class=\"headerlink\" title=\"自动化\"></a>自动化</h3><hr>\n<p>   前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:</p>\n<blockquote>\n<p>任何简单机械的重复劳动都应该让机器去完成。</p>\n</blockquote>\n<ul>\n<li><p>图标合并</p>\n</li>\n<li><p>持续继承</p>\n</li>\n<li><p>自动化构建</p>\n</li>\n<li><p>自动化部署</p>\n</li>\n<li><p>自动化测试</p>\n</li>\n</ul>\n<h1 id=\"II-工程化具体方法\"><a href=\"#II-工程化具体方法\" class=\"headerlink\" title=\"II. 工程化具体方法\"></a>II. 工程化具体方法</h1><hr>\n<h2 id=\"1-性能优化\"><a href=\"#1-性能优化\" class=\"headerlink\" title=\"1. 性能优化\"></a>1. 性能优化</h2><p>浏览器缓存是 Web 性能优化的重要方式。那么浏览器缓存的过程究竟是怎么样的呢？</p>\n<p>浏览器缓存主要分为<code>强强缓存（也称本地缓存）</code>和<code>协商缓存（也称弱缓存）</code>。</p>\n<p> ######强缓存</p>\n<ul>\n<li><p>Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。如我现在这个网页的 Expires 值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现 Cache-Control:max-age 和 Expires，那么 max-age 优先级更高。</p>\n<ul>\n<li>Cache-Control 是在 http1.1 中出现的，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</li>\n</ul>\n<p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>\n<p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>\n<p>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。<br>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。<br>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候   Cache-Control 优先级高。<br>######弱缓存/协商缓存<br><strong>Etag 和 If-None-Match</strong></p>\n</li>\n</ul>\n<p>Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存</p>\n<p>与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p>\n<p><strong>Last-Modify/If-Modify-Since</strong></p>\n<p>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>\n<p>当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</p>\n<p>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p>\n<p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag</p>\n<hr>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c4678e7b6821f8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4c9053e0fd74c93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"访问量和性能指标\"><a href=\"#访问量和性能指标\" class=\"headerlink\" title=\"访问量和性能指标\"></a>访问量和性能指标</h4><p>a.css 的请求，如果每次用户访问页面都要加载，很影响性能，很浪费带宽</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-41104d7c231d27e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<hr>\n<p>利用 304，让浏览器使用本地缓存。304 叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2fd0094493df3b08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？</p>\n<p>很好，相信有人想到了办法：通过<code>更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源</code>。好像这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-577a64c93602bf2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"`\"></p>\n<p>页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css，c.css 的缓存也失效，那岂不是又有浪费了？！</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c3a7badbd331fd6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>重新开启变态模式，我们不难发现，要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。</p>\n<p>什么东西与文件内容相关呢？我们会很自然的联想到利用  <code>数据摘要算法</code> 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把 url 改成带摘要信息的：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-027cf303a23fc22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 节点上，网页中引用的资源也会变成对应的部署路径：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-ae5c4239f5b12df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>这次发布，同时改了页面结构和样式，也更新了静态资源对应的 url 地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f05ceb812e53f51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li><strong>先部署页面，再部署资源</strong>：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。</li>\n<li><strong>先部署资源，再部署页面</strong>：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。</li>\n</ul>\n<hr>\n<p>好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。<br>有些公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！</p>\n<p>这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-3f21dab466192813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。</p>\n<hr>\n<p>所以，静态资源优化方案，基本上要实现这么几个东西：</p>\n<p>配置超长时间的本地缓存 —— 节省带宽，提高性能<br>采用内容摘要作为缓存更新依据 —— 精确的缓存控制<br>静态资源 CDN 部署 —— 优化网络请求<br>更资源发布路径实现非覆盖式发布 —— 平滑升级</p>\n<h2 id=\"总之，前端性能优化绝逼是一个工程问题！\"><a href=\"#总之，前端性能优化绝逼是一个工程问题！\" class=\"headerlink\" title=\"总之，前端性能优化绝逼是一个工程问题！\"></a>总之，前端性能优化绝逼是一个工程问题！</h2><h2 id=\"2-静态资源部署-CDN\"><a href=\"#2-静态资源部署-CDN\" class=\"headerlink\" title=\"2. 静态资源部署 CDN\"></a>2. 静态资源部署 CDN</h2><p>CDN[Content Delivery Network] 内容分发网络 主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-80610fe2d3c9090e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>总结一下 CDN 的工作原理：通过权威 DNS 服务器来实现最优节点的选择，通过缓存来减少源站的压力。</p>\n<hr>\n<p>CDN 应用场景：</p>\n<p>静态网页<br>图片小文件、博客<br>大文件下载<br>软件下载、视频点播或图片存储网站<br>动态加速<br>直播网站<br>应用加速<br>手机 APP<br>除却 CDN 自身的优势，在前端工程中，将静态文件放到 CDN 上，可以直观地减小资源包大小，同时加快首屏加载。</p>\n<p>若不使用 CDN，则所有的资源都会被打包到 app.js 和 vendor.js 中，页面需要等到这两个包下载完成才可以显示。<br>若使用 CDN，则可以利用浏览器多线程的优势，同时下载若干静态文件以及剩下的 app.js 和 vendor.js，以此达到加快加载的目的。</p>\n<hr>\n<h3 id=\"3-自动化文档生成\"><a href=\"#3-自动化文档生成\" class=\"headerlink\" title=\"3. 自动化文档生成\"></a>3. 自动化文档生成</h3><p><code>commit message</code> 作用</p>\n<ul>\n<li>提供更多的历史信息，方便快速浏览</li>\n<li>过滤某些 commit（比如文档改动），便于快速查找信息</li>\n<li>直接从 commit 生成 Change log</li>\n<li>可读性好，清晰，不必深入看代码即可了解当前 commit 的作用。</li>\n<li>为 Code Reviewing（代码审查）做准备</li>\n<li>方便跟踪工程历史</li>\n<li>提高项目的整体质量，提高个人工程素质</li>\n</ul>\n<p>目前，社区有多种 Commit message 的写法规范，我们介绍的工具是 commitizen，它使用的是 Angular 规范<a href=\"https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0\">AngularJS Git Commit Message Conventions</a>，这是目前使用最广的写法，并且有对应的工具去生成 change log。</p>\n<p><strong>标准说明</strong></p>\n<p>每次提交， Commit message 都包括 Header, Body 和 Footer 三个部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class=\"line\">// 空行</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">// 空行</span><br><span class=\"line\">&lt;footer&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>Header</strong> 部分只有一行，包括三个字段：type, scope 和 subject 。<br>type 用于说明提交的类别，只运行使用下面几种，</p>\n<ul>\n<li>feat: 新功能</li>\n<li>fix: 修复 bug</li>\n<li>docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等等</li>\n<li>style: 格式更新（不影响代码运行的变动）</li>\n<li>refactor: 重构（既不是新增功能，又不是 bug 修复）</li>\n<li>test: 添加测试</li>\n<li>chore: 构建过程或辅助工具的变动</li>\n<li>perf: 优化相关，比如提升性能、体验</li>\n<li>revert: 回滚到上一个版本</li>\n<li>ci：自动化流程配置修改</li>\n</ul>\n<p>如果是 feat 和 fix ，则这个 commit 将肯定出现在 change log 中，其它情况可自行决定是否放入。</p>\n<p>scope 用于说明 commit 影响的范围 比如数据层、控制层、视图层等等，视项目不同而不同。</p>\n<p>subject 是 commit 目的的简短描述，不超过 50 个字符。</p>\n<ul>\n<li>以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li>\n<li>第一个字母小写</li>\n<li>结尾不要加句号</li>\n</ul>\n<hr>\n<p><strong>Body</strong> 部分是对本次 commit 的详细描述，可分成多行。但是一般我都不写。</p>\n<p><strong>Footer</strong> 部分只用于两种情况。</p>\n<p>不兼容变动</p>\n<p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class=\"line\"></span><br><span class=\"line\">    To migrate the code follow the example below:</span><br><span class=\"line\"></span><br><span class=\"line\">    Before:</span><br><span class=\"line\"></span><br><span class=\"line\">    scope: &#123;</span><br><span class=\"line\">      myAttr: &apos;attribute&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    After:</span><br><span class=\"line\"></span><br><span class=\"line\">    scope: &#123;</span><br><span class=\"line\">      myAttr: &apos;@&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure>\n<hr>\n<p>关闭 Issue<br>如果当前 commit 针对某个 issue ，那么可以在 Footer 部分关闭这个 issue 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Closes #1234</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Closes #1234, $1235, #1236</span><br></pre></td></tr></table></figure>\n<p><strong>Revert</strong></p>\n<p>如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class=\"line\">&lt;br /&gt;</span><br><span class=\"line\">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Body 部分的格式是固定的，必须写成 This reverts commit .，其中的 hash 是被撤销 commit 的 SHA 标识符。</li>\n<li>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。</li>\n</ul>\n<hr>\n<h5 id=\"自动生成-changelog-文档\"><a href=\"#自动生成-changelog-文档\" class=\"headerlink\" title=\"自动生成 changelog 文档\"></a>自动生成 changelog 文档</h5><h6 id=\"commitizen\"><a href=\"#commitizen\" class=\"headerlink\" title=\"commitizen\"></a>commitizen</h6><p>Commitizen 是一个撰写合格 Commit message 的工具。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g commitizen</span><br><span class=\"line\"># 在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</span><br><span class=\"line\">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>\n<p>用 git cz -m 代替 git commit -m 就可以轻松的写出 Angular 规范的 commit message 了。</p>\n<h6 id=\"validate-commit-msg\"><a href=\"#validate-commit-msg\" class=\"headerlink\" title=\"validate-commit-msg\"></a>validate-commit-msg</h6><p>用于检查 Node 项目的 Commit message 是否符合格式。</p>\n<h6 id=\"conventional-changelog\"><a href=\"#conventional-changelog\" class=\"headerlink\" title=\"conventional-changelog\"></a>conventional-changelog</h6><p>生成 Change log 的工具，运行下面的命令即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g conventional-changelog-cli</span><br><span class=\"line\">cd my-project</span><br><span class=\"line\">conventional-changelog -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>\n<hr>\n<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成</p>\n<p>生成的文档包括以下三个部分。</p>\n<ul>\n<li>New features</li>\n<li>Bug fixes</li>\n<li>Breaking changes.</li>\n</ul>\n<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>\n<p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run changelog</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-前端埋点\"><a href=\"#4-前端埋点\" class=\"headerlink\" title=\"4. 前端埋点\"></a>4. 前端埋点</h3><p><strong>目的</strong><br>获取用户基本信息、行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。<br><strong>前端监控类别</strong><br>前端监控可以分为三类：数据监控、性能监控和异常监控。<br><code>数据监控</code>就是监听用户信息和行为，常见的监控项有</p>\n<p>*PV(page view 页面访问量)：即页面浏览量或点击量</p>\n<ul>\n<li>UV(unique visitor 独立访客)：指访问某个站点或点击某条新闻的不同 IP 地址的人数</li>\n<li>用户在每一个页面的停留时间</li>\n<li>用户通过什么入口来访问该网页</li>\n<li>用户在相应的页面中触发的行为<br>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</li>\n</ul>\n<p><code>性能监控</code>指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控项包括：</p>\n<ul>\n<li>不同用户，不同机型和不同系统下的首屏加载时间</li>\n<li>http 等请求的响应时间</li>\n<li>静态资源整体下载时间</li>\n<li>页面渲染时间</li>\n<li>页面交互动画完成时间<br>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</li>\n</ul>\n<p><code>异常监控</code>由于产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 try catch 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>\n<ul>\n<li>Javascript 的异常监控</li>\n<li>样式丢失的异常监控</li>\n<li>服务器请求的异常监控<br>我们说完了前端监控的三个分类，现在就来聊聊怎么实现前端监控。实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台，最后进行数据分析。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。</li>\n</ul>\n<hr>\n<p>#####前端埋点分类</p>\n<p>收集监控数据我们是通过前端埋点来实现的，目前常见的前端埋点方法有三种：<code></code>手动埋点<code>、</code>可视化埋点<code>和</code>无埋点`。<br><strong>手动埋点</strong>，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像友盟、百度统计等第三方数据统计服务商大都采用这种方案。<br>优势:</p>\n<ul>\n<li>可自定义属性，自定义事件<ul>\n<li>可以细化需求</li>\n<li>相比其他埋点方式减少服务器压力</li>\n</ul>\n</li>\n</ul>\n<p>缺陷:</p>\n<ul>\n<li>工程量大的话，手动埋点会出现疏漏，不方便审查。</li>\n<li>需求变更要重新埋点，成本高。</li>\n<li>每次需求变更都要重新发布版本，对线上系统稳定性有一定危害</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(document).ready(() =&gt; &#123;</span><br><span class=\"line\">  // ... 这里是你的业务逻辑代码</span><br><span class=\"line\">  sendData(params) //这里是发送你的埋点数据，params是你封装的埋点数据</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>前端框架式手动埋点</strong></p>\n<p>如果使用 Vue 或者 React 等前端框架，这些框架都有自己的各种生命周期，为了减少重复性的手动埋点次数，可以在各个生命周期位置，根据你的需求封装你所需的埋点。比如你是 SPA 单页应用，你希望在每一个页面的 componentDidMount 埋点，并由此确定用户已经打开了页面。</p>\n<p>css 埋点：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.link:active::after &#123;</span><br><span class=\"line\">  content: url(&apos;http://www.example.com?action=yourdata&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;a class=&quot;link&quot;&gt;点击我，会发埋点数据&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p><strong>可视化埋点</strong>解决了纯手动埋点的开发成本和更新成本，通过可视化工具快速配置采集节点（圈点），在前端自动解析配置，并根据配置上传埋点数据，比起手动埋点看起来更无痕，</p>\n<p>比如国外比较早做可视化的是 Mixpanel，国内较早支持可视化埋点的有 TalkingData、诸葛 IO，2017 年腾讯的 MTA 也宣布支持可视化埋点；</p>\n<hr>\n<p><strong>无埋点</strong>则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>\n<p>优点:<br>前端只要一次加载埋点脚本</p>\n<p>缺点:<br>服务器性能压力山大</p>\n<p>采用无埋点技术的有主流的 GrowingIO、神策。无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>\n<h2 id=\"VI-总结\"><a href=\"#VI-总结\" class=\"headerlink\" title=\"#VI. 总结\"></a>#VI. 总结</h2><p>在业界内有这么一句话：任何简单机械的重复劳动都应该让机器去完成。现代前端技术不再是以前刀耕火种的年代了。所以前端工程化的很多脏活累活都应该交给自动化工具来完成。</p>\n<p>如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说：</p>\n<p>你好，工程师！</p>\n<p>参考链接：</p>\n<ol>\n<li><a href=\"https://www.jianshu.com/p/88ed70476adb\">前端工程化的理解</a></li>\n<li><a href=\"[https://www.zhihu.com/question/20790576/answer/32602154]\">大公司里怎样开发和部署前端代码？</a></li>\n<li><a href=\"http://www.imooc.com/article/27151\">前端埋点的那些事</a></li>\n<li><a href=\"https://www.jianshu.com/p/645a26619508\">小谈前端埋点</a></li>\n<li><a href=\"https://github.com/fouber/blog/issues/10\">前端工程——基础篇</a></li>\n<li><a href=\"https://www.jianshu.com/p/a248b146c55a\">http-proxy-middleware</a></li>\n<li><a href=\"https://www.jianshu.com/p/3bdff821f859\">Webpack dev server 使用 http-proxy 解决跨域问题</a></li>\n<li><a href=\"https://github.com/chimurai/http-proxy-middleware\">chimurai/http-proxy-middleware</a></li>\n<li><a href=\"https://www.jb51.net/article/137608.htm\">详解 webpack-dev-server 的简单使用</a></li>\n<li><a href=\"https://github.com/jantimon/html-webpack-plugin\">html-webpack-plugin</a></li>\n<li><a href=\"https://www.jianshu.com/p/9248db0349fb\">webpack 使用 HtmlWebpackPlugin 进行 cdn 配置</a></li>\n<li><a href=\"https://blog.csdn.net/const_ly/article/details/79788728\">CDN 是什么？使用 CDN 有什么优势？</a></li>\n<li><a href=\"https://www.codercto.com/a/76835.html\">webpack4-06-开发、生产环境、动态 CDN 配置</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008956069\">HTTP 强缓存和协商缓存</a></li>\n<li><a href=\"https://www.jianshu.com/p/1744780ddda0\">Cache-Control 之 no-cache 和 max-age=0</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000019579621\">Commit message 代码提交规范</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\">Commit message 和 Change log 编写指南</a></li>\n<li><a href=\"https://www.cnblogs.com/zivxiaowei/p/10089201.html\">git commit 、CHANGELOG 和版本发布的标准自动化</a></li>\n</ol>\n</script></li></ul>"},{"title":"从多线程到Event Loop全面梳理","date":"2019-08-21T07:36:08.000Z","_content":"\nAuthor: Echo\nTime: 2019-08-21 15:36:08\n\n\n\n## 引言\n几乎在每一本JS相关的书籍中，都会说JS是`单线程`的，JS是通过`事件队列(Event Loop)`的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 `异步`的能力，所以，我试图从`进程`、`线程`的角度来解释这个问题。\n## CPU\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n计算机的核心是`CPU`，它承担了所有的计算任务。\n它就像一座工厂，时刻在运行。\n## 进程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n`进程`就好比工厂的车间，它代表CPU所能处理的单个任务。 `进程`之间相互独立，任一时刻，CPU总是运行一个`进程`，其他`进程`处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个`进程`。\n## 线程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。\n`线程`就好比车间里的工人，一个`进程`可以包括多个`线程`，多个`线程`共享`进程`资源。\n## CPU、进程、线程之间的关系\n从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。\n* `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n* `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n* 不同`进程`之间也可以通信，不过代价较大\n* `单线程`与`多线程`，都是指在一个`进程`内的单和多\n## 浏览器是多进程的\n\n我们已经知道了`CPU`、`进程`、`线程`之间的关系，对于计算机来说，每一个应用程序都是一个`进程`，\n而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过`子进程`来实现的。\n对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。\n而对于浏览器来说，浏览器就是`多进程`的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n如上图，我们可以看到一个Chrome浏览器启动了好多个进程。\n\n总结一下：\n\n* 浏览器是多进程的\n* 每一个Tab页，就是一个独立的进程\n## 浏览器包含了哪些进程\n* 主进程\n>*  协调控制其他子进程（创建、销毁）\n>*  浏览器界面显示，用户交互，前进、后退、收藏\n>*  将渲染进程得到的内存中的Bitmap，绘制到用户界面上\n>*   处理不可见操作，网络请求，文件访问等\n* 第三方插件进程\n>*  每种类型的插件对应一个进程，仅当使用该插件时才创建\n* GPU进程\n>*  用于3D绘制等\n* `渲染进程`，就是我们说的`浏览器内核`\n>*  负责页面渲染，脚本执行，事件处理等\n>*  每个tab页一个渲染进程\n\n那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？\n\n答案是`渲染进程`，也就是我们常说的`浏览器内核`\n## 浏览器内核（渲染进程）\n从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。\n而对于`渲染进程`来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。\n* GUI渲染线程\n>*  负责渲染页面，布局和绘制\n>*  页面需要重绘和回流时，该线程就会执行\n>*  与js引擎线程互斥，防止渲染结果不可预期\n* JS引擎线程\n>*  负责处理解析和执行javascript脚本程序\n>*  只有一个JS引擎线程（单线程）\n>*  与GUI渲染线程互斥，防止渲染结果不可预期\n* 事件触发线程\n>*  用来控制事件循环（鼠标点击、setTimeout、ajax等）\n>*  当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中\n* 定时触发器线程\n>*  setInterval与setTimeout所在的线程\n>*  定时任务并不是由JS引擎计时的，是由定时触发线程来计时的\n>*  计时完毕后，通知事件触发线程\n* 异步http请求线程\n>*  浏览器有一个单独的线程用于处理AJAX请求\n>*  当请求完成时，若有回调函数，通知事件触发线程\n\n当我们了解了渲染进程包含的这些线程后，我们思考两个问题：\n\n1. 为什么 javascript 是单线程的\n2. 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n## 为什么 javascript 是单线程的\n首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。\n\n其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。\n## 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n\n这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，\n那么渲染线程前后获得的元素就可能不一致了。\n因此，为了防止渲染出现不可预期的结果，浏览器设定 `GUI渲染线程`和`JS引擎线程`为互斥关系，\n当JS引擎线程执行时`GUI渲染线程`会被挂起，GUI更新则会被保存在一个队列中等待`JS引擎线程`空闲时立即被执行。\n## 从 Event Loop 看 JS 的运行机制\n到了这里，终于要进入我们的主题，什么是 Event Loop\n先理解一些概念\n* JS 分为同步任务和异步任务\n* 同步任务都在JS引擎线程上执行，形成一个`执行栈`\n* 事件触发线程管理一个`任务队列`，异步任务触发条件达成，将回调事件放到`任务队列`中\n* `执行栈`中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取`任务队列`，将可运行的异步任务回调事件添加到`执行栈`中，开始执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n在前端开发中我们会通过`setTimeout/setInterval`来指定定时任务，会通过`XHR/fetch`发送网络请求， 接下来简述一下`setTimeout/setInterval`和`XHR/fetch`到底做了什么事\n\n我们知道，不管是`setTimeout/setInterval`和`XHR/fetch`代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。\n\n当代码执行到`setTimeout/setInterval`时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而`定时触发器线程`在接收到这个消息后，会在等待的时间后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当代码执行到`XHR/fetch`时，实际上是`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成后的回调事件， 而`异步http请求线程`在接收到这个消息后，会在请求成功后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在`事件队列`中是否有待执行的回调函数，如果有就会加入到执行栈中交给`JS引擎线程`执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n再用代码来解释一下：\n```\nlet timerCallback = function() {\n  console.log('wait one second');\n};\nlet httpCallback = function() {\n  console.log('get server data success');\n}\n\n// 同步任务\nconsole.log('hello');\n// 同步任务\n// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理\n// 1s 后事件触发线程将 timerCallback 加入到事件队列中\nsetTimeout(timerCallback,1000);\n// 同步任务\n// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理\n// 请求成功后事件触发线程将 httpCallback 加入到事件队列中\n$.get('www.xxxx.com',httpCallback);\n// 同步任务\nconsole.log('world');\n//...\n// 所有同步任务执行完后\n// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数\n// 如果没有，一直询问，直到有为止\n// 如果有，将回调事件加入执行栈中，开始执行回调代码\n\n```\n总结一下：\n\n* JS引擎线程只执行执行栈中的事件\n* 执行栈中的代码执行完毕，就会读取事件队列中的事件\n* 事件队列中的回调事件，是由各自线程插入到事件队列中的\n* 如此循环\n\n## 宏任务、微任务\n当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中`宏任务`、`微任务`\n#### 什么是宏任务\n我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），\n每一个宏任务会从头到尾执行完毕，不会执行其他。\n\n我们前文提到过`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染。\n>宏任务-->渲染-->宏任务-->渲染-->渲染．．．\n\n###### 主代码块，setTimeout，setInterval等，都属于宏任务\n第一个例子：\n```\ndocument.body.style = 'background:black';\ndocument.body.style = 'background:red';\ndocument.body.style = 'background:blue';\ndocument.body.style = 'background:grey';\n```\n我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip)\n我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次`宏任务`，所以全部执行完才触发`页面渲染`，渲染时`GUI线程`会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。\n\n第二个例子:\n```\ndocument.body.style = 'background:blue';\nsetTimeout(function(){\n    document.body.style = 'background:black'\n},0)\n```\n执行一下，再看效果\n![image](https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip)\n我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次`宏任务`，第一次`宏任务`执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色\n\n## 什么是微任务\n\n我们已经知道`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`， 而`微任务`可以理解成在当前`宏任务`执行后立即执行的任务。\n也就是说，当`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完。\n\n###### Promise，process.nextTick等，属于微任务。\n第一个例子：\n```\ndocument.body.style = 'background:blue'\nconsole.log(1);\nPromise.resolve().then(()=>{\n    console.log(2);\n    document.body.style = 'background:black'\n});\nconsole.log(3);\n```\n执行一下，再看效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip)\n\n控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。\n页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染\n第二个例子：\n```\nsetTimeout(() => {\n    console.log(1)\n    Promise.resolve(3).then(data => console.log(data))\n}, 0)\n\nsetTimeout(() => {\n    console.log(2)\n}, 0)\n\n// print : 1 3 2\n```\n\n上面代码共包含两个 `setTimeout` ，也就是说除主代码块外，共有两个`宏任务`，\n其中第一个`宏任务`执行中，输出 1 ，并且创建了`微任务队列`，所以在下一个`宏任务队列`执行前，\n先执行`微任务`，在`微任务`执行中，输出 3 ，`微任务`执行后，执行下一次`宏任务`，执行中输出 2\n## 总结\n* 执行一个`宏任务`（栈中没有就从`事件队列`中获取）\n* 执行过程中如果遇到`微任务`，就将它添加到`微任务`的任务队列中\n* `宏任务`执行完毕后，立即执行当前微`任务队列`中的所有`微任务`（依次执行）\n* 当前`宏任务`执行完毕，开始检查渲染，然后`GUI线程`接管渲染\n* 渲染完毕后，`JS线程`继续接管，开始下一个`宏任务`（从事件队列中获取）\n\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n参考链接：https://juejin.im/post/5d5b4c2df265da03dd3d73e5\n\n","source":"_posts/JS-thread.md","raw":"---\ntitle: 从多线程到Event Loop全面梳理\ndate: 2019-08-21 15:36:08\ntags: js\n---\n\nAuthor: Echo\nTime: 2019-08-21 15:36:08\n\n\n\n## 引言\n几乎在每一本JS相关的书籍中，都会说JS是`单线程`的，JS是通过`事件队列(Event Loop)`的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 `异步`的能力，所以，我试图从`进程`、`线程`的角度来解释这个问题。\n## CPU\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n计算机的核心是`CPU`，它承担了所有的计算任务。\n它就像一座工厂，时刻在运行。\n## 进程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n`进程`就好比工厂的车间，它代表CPU所能处理的单个任务。 `进程`之间相互独立，任一时刻，CPU总是运行一个`进程`，其他`进程`处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个`进程`。\n## 线程\n![image](https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。\n`线程`就好比车间里的工人，一个`进程`可以包括多个`线程`，多个`线程`共享`进程`资源。\n## CPU、进程、线程之间的关系\n从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。\n* `进程`是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n* `线程`是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n* 不同`进程`之间也可以通信，不过代价较大\n* `单线程`与`多线程`，都是指在一个`进程`内的单和多\n## 浏览器是多进程的\n\n我们已经知道了`CPU`、`进程`、`线程`之间的关系，对于计算机来说，每一个应用程序都是一个`进程`，\n而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过`子进程`来实现的。\n对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。\n而对于浏览器来说，浏览器就是`多进程`的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n如上图，我们可以看到一个Chrome浏览器启动了好多个进程。\n\n总结一下：\n\n* 浏览器是多进程的\n* 每一个Tab页，就是一个独立的进程\n## 浏览器包含了哪些进程\n* 主进程\n>*  协调控制其他子进程（创建、销毁）\n>*  浏览器界面显示，用户交互，前进、后退、收藏\n>*  将渲染进程得到的内存中的Bitmap，绘制到用户界面上\n>*   处理不可见操作，网络请求，文件访问等\n* 第三方插件进程\n>*  每种类型的插件对应一个进程，仅当使用该插件时才创建\n* GPU进程\n>*  用于3D绘制等\n* `渲染进程`，就是我们说的`浏览器内核`\n>*  负责页面渲染，脚本执行，事件处理等\n>*  每个tab页一个渲染进程\n\n那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？\n\n答案是`渲染进程`，也就是我们常说的`浏览器内核`\n## 浏览器内核（渲染进程）\n从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。\n而对于`渲染进程`来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。\n* GUI渲染线程\n>*  负责渲染页面，布局和绘制\n>*  页面需要重绘和回流时，该线程就会执行\n>*  与js引擎线程互斥，防止渲染结果不可预期\n* JS引擎线程\n>*  负责处理解析和执行javascript脚本程序\n>*  只有一个JS引擎线程（单线程）\n>*  与GUI渲染线程互斥，防止渲染结果不可预期\n* 事件触发线程\n>*  用来控制事件循环（鼠标点击、setTimeout、ajax等）\n>*  当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中\n* 定时触发器线程\n>*  setInterval与setTimeout所在的线程\n>*  定时任务并不是由JS引擎计时的，是由定时触发线程来计时的\n>*  计时完毕后，通知事件触发线程\n* 异步http请求线程\n>*  浏览器有一个单独的线程用于处理AJAX请求\n>*  当请求完成时，若有回调函数，通知事件触发线程\n\n当我们了解了渲染进程包含的这些线程后，我们思考两个问题：\n\n1. 为什么 javascript 是单线程的\n2. 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n## 为什么 javascript 是单线程的\n首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。\n\n其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。\n## 为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\n\n这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，\n那么渲染线程前后获得的元素就可能不一致了。\n因此，为了防止渲染出现不可预期的结果，浏览器设定 `GUI渲染线程`和`JS引擎线程`为互斥关系，\n当JS引擎线程执行时`GUI渲染线程`会被挂起，GUI更新则会被保存在一个队列中等待`JS引擎线程`空闲时立即被执行。\n## 从 Event Loop 看 JS 的运行机制\n到了这里，终于要进入我们的主题，什么是 Event Loop\n先理解一些概念\n* JS 分为同步任务和异步任务\n* 同步任务都在JS引擎线程上执行，形成一个`执行栈`\n* 事件触发线程管理一个`任务队列`，异步任务触发条件达成，将回调事件放到`任务队列`中\n* `执行栈`中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取`任务队列`，将可运行的异步任务回调事件添加到`执行栈`中，开始执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n在前端开发中我们会通过`setTimeout/setInterval`来指定定时任务，会通过`XHR/fetch`发送网络请求， 接下来简述一下`setTimeout/setInterval`和`XHR/fetch`到底做了什么事\n\n我们知道，不管是`setTimeout/setInterval`和`XHR/fetch`代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。\n\n当代码执行到`setTimeout/setInterval`时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而`定时触发器线程`在接收到这个消息后，会在等待的时间后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当代码执行到`XHR/fetch`时，实际上是`JS引擎线程`通知`异步http请求线程`，发送一个网络请求，并制定请求完成后的回调事件， 而`异步http请求线程`在接收到这个消息后，会在请求成功后，将回调事件放入到由`事件触发线程`所管理的`事件队列`中。\n\n当我们的同步任务执行完，`JS引擎线程`会询问`事件触发线程`，在`事件队列`中是否有待执行的回调函数，如果有就会加入到执行栈中交给`JS引擎线程`执行\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n再用代码来解释一下：\n```\nlet timerCallback = function() {\n  console.log('wait one second');\n};\nlet httpCallback = function() {\n  console.log('get server data success');\n}\n\n// 同步任务\nconsole.log('hello');\n// 同步任务\n// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理\n// 1s 后事件触发线程将 timerCallback 加入到事件队列中\nsetTimeout(timerCallback,1000);\n// 同步任务\n// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理\n// 请求成功后事件触发线程将 httpCallback 加入到事件队列中\n$.get('www.xxxx.com',httpCallback);\n// 同步任务\nconsole.log('world');\n//...\n// 所有同步任务执行完后\n// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数\n// 如果没有，一直询问，直到有为止\n// 如果有，将回调事件加入执行栈中，开始执行回调代码\n\n```\n总结一下：\n\n* JS引擎线程只执行执行栈中的事件\n* 执行栈中的代码执行完毕，就会读取事件队列中的事件\n* 事件队列中的回调事件，是由各自线程插入到事件队列中的\n* 如此循环\n\n## 宏任务、微任务\n当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中`宏任务`、`微任务`\n#### 什么是宏任务\n我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），\n每一个宏任务会从头到尾执行完毕，不会执行其他。\n\n我们前文提到过`JS引擎线程`和`GUI渲染线程`是互斥的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个`宏任务`执行结果后，在下一个`宏任务`执行前，`GUI渲染线程`开始工作，对页面进行渲染。\n>宏任务-->渲染-->宏任务-->渲染-->渲染．．．\n\n###### 主代码块，setTimeout，setInterval等，都属于宏任务\n第一个例子：\n```\ndocument.body.style = 'background:black';\ndocument.body.style = 'background:red';\ndocument.body.style = 'background:blue';\ndocument.body.style = 'background:grey';\n```\n我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip)\n我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次`宏任务`，所以全部执行完才触发`页面渲染`，渲染时`GUI线程`会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。\n\n第二个例子:\n```\ndocument.body.style = 'background:blue';\nsetTimeout(function(){\n    document.body.style = 'background:black'\n},0)\n```\n执行一下，再看效果\n![image](https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip)\n我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次`宏任务`，第一次`宏任务`执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色\n\n## 什么是微任务\n\n我们已经知道`宏任务`结束后，会执行渲染，然后执行下一个`宏任务`， 而`微任务`可以理解成在当前`宏任务`执行后立即执行的任务。\n也就是说，当`宏任务`执行完，会在渲染前，将执行期间所产生的所有`微任务`都执行完。\n\n###### Promise，process.nextTick等，属于微任务。\n第一个例子：\n```\ndocument.body.style = 'background:blue'\nconsole.log(1);\nPromise.resolve().then(()=>{\n    console.log(2);\n    document.body.style = 'background:black'\n});\nconsole.log(3);\n```\n执行一下，再看效果：\n![image](https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip)\n\n控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。\n页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染\n第二个例子：\n```\nsetTimeout(() => {\n    console.log(1)\n    Promise.resolve(3).then(data => console.log(data))\n}, 0)\n\nsetTimeout(() => {\n    console.log(2)\n}, 0)\n\n// print : 1 3 2\n```\n\n上面代码共包含两个 `setTimeout` ，也就是说除主代码块外，共有两个`宏任务`，\n其中第一个`宏任务`执行中，输出 1 ，并且创建了`微任务队列`，所以在下一个`宏任务队列`执行前，\n先执行`微任务`，在`微任务`执行中，输出 3 ，`微任务`执行后，执行下一次`宏任务`，执行中输出 2\n## 总结\n* 执行一个`宏任务`（栈中没有就从`事件队列`中获取）\n* 执行过程中如果遇到`微任务`，就将它添加到`微任务`的任务队列中\n* `宏任务`执行完毕后，立即执行当前微`任务队列`中的所有`微任务`（依次执行）\n* 当前`宏任务`执行完毕，开始检查渲染，然后`GUI线程`接管渲染\n* 渲染完毕后，`JS线程`继续接管，开始下一个`宏任务`（从事件队列中获取）\n\n![image](https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n参考链接：https://juejin.im/post/5d5b4c2df265da03dd3d73e5\n\n","slug":"JS-thread","published":1,"updated":"2019-12-04T12:50:48.221Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqk000o78p38dgugfct","content":"<p>Author: Echo<br>Time: 2019-08-21 15:36:08</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>几乎在每一本JS相关的书籍中，都会说JS是<code>单线程</code>的，JS是通过<code>事件队列(Event Loop)</code>的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 <code>异步</code>的能力，所以，我试图从<code>进程</code>、<code>线程</code>的角度来解释这个问题。</p>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>计算机的核心是<code>CPU</code>，它承担了所有的计算任务。<br>它就像一座工厂，时刻在运行。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br><code>进程</code>就好比工厂的车间，它代表CPU所能处理的单个任务。 <code>进程</code>之间相互独立，任一时刻，CPU总是运行一个<code>进程</code>，其他<code>进程</code>处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个<code>进程</code>。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。<br><code>线程</code>就好比车间里的工人，一个<code>进程</code>可以包括多个<code>线程</code>，多个<code>线程</code>共享<code>进程</code>资源。</p>\n<h2 id=\"CPU、进程、线程之间的关系\"><a href=\"#CPU、进程、线程之间的关系\" class=\"headerlink\" title=\"CPU、进程、线程之间的关系\"></a>CPU、进程、线程之间的关系</h2><p>从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。</p>\n<ul>\n<li><code>进程</code>是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>\n<li><code>线程</code>是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>\n<li>不同<code>进程</code>之间也可以通信，不过代价较大</li>\n<li><code>单线程</code>与<code>多线程</code>，都是指在一个<code>进程</code>内的单和多<h2 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h2></li>\n</ul>\n<p>我们已经知道了<code>CPU</code>、<code>进程</code>、<code>线程</code>之间的关系，对于计算机来说，每一个应用程序都是一个<code>进程</code>，<br>而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过<code>子进程</code>来实现的。<br>对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。<br>而对于浏览器来说，浏览器就是<code>多进程</code>的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>如上图，我们可以看到一个Chrome浏览器启动了好多个进程。</p>\n<p>总结一下：</p>\n<ul>\n<li>浏览器是多进程的</li>\n<li>每一个Tab页，就是一个独立的进程<h2 id=\"浏览器包含了哪些进程\"><a href=\"#浏览器包含了哪些进程\" class=\"headerlink\" title=\"浏览器包含了哪些进程\"></a>浏览器包含了哪些进程</h2></li>\n<li>主进程<blockquote>\n<ul>\n<li>协调控制其他子进程（创建、销毁）</li>\n<li>浏览器界面显示，用户交互，前进、后退、收藏</li>\n<li>将渲染进程得到的内存中的Bitmap，绘制到用户界面上</li>\n<li>处理不可见操作，网络请求，文件访问等</li>\n</ul>\n</blockquote>\n</li>\n<li>第三方插件进程<blockquote>\n<ul>\n<li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li>\n</ul>\n</blockquote>\n</li>\n<li>GPU进程<blockquote>\n<ul>\n<li>用于3D绘制等</li>\n</ul>\n</blockquote>\n</li>\n<li><code>渲染进程</code>，就是我们说的<code>浏览器内核</code><blockquote>\n<ul>\n<li>负责页面渲染，脚本执行，事件处理等</li>\n<li>每个tab页一个渲染进程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？</p>\n<p>答案是<code>渲染进程</code>，也就是我们常说的<code>浏览器内核</code></p>\n<h2 id=\"浏览器内核（渲染进程）\"><a href=\"#浏览器内核（渲染进程）\" class=\"headerlink\" title=\"浏览器内核（渲染进程）\"></a>浏览器内核（渲染进程）</h2><p>从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。<br>而对于<code>渲染进程</code>来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。</p>\n<ul>\n<li>GUI渲染线程<blockquote>\n<ul>\n<li>负责渲染页面，布局和绘制</li>\n<li>页面需要重绘和回流时，该线程就会执行</li>\n<li>与js引擎线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>JS引擎线程<blockquote>\n<ul>\n<li>负责处理解析和执行javascript脚本程序</li>\n<li>只有一个JS引擎线程（单线程）</li>\n<li>与GUI渲染线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>事件触发线程<blockquote>\n<ul>\n<li>用来控制事件循环（鼠标点击、setTimeout、ajax等）</li>\n<li>当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</li>\n</ul>\n</blockquote>\n</li>\n<li>定时触发器线程<blockquote>\n<ul>\n<li>setInterval与setTimeout所在的线程</li>\n<li>定时任务并不是由JS引擎计时的，是由定时触发线程来计时的</li>\n<li>计时完毕后，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n<li>异步http请求线程<blockquote>\n<ul>\n<li>浏览器有一个单独的线程用于处理AJAX请求</li>\n<li>当请求完成时，若有回调函数，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>当我们了解了渲染进程包含的这些线程后，我们思考两个问题：</p>\n<ol>\n<li>为什么 javascript 是单线程的</li>\n<li>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥<h2 id=\"为什么-javascript-是单线程的\"><a href=\"#为什么-javascript-是单线程的\" class=\"headerlink\" title=\"为什么 javascript 是单线程的\"></a>为什么 javascript 是单线程的</h2>首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。</li>\n</ol>\n<p>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</p>\n<h2 id=\"为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\"><a href=\"#为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\" class=\"headerlink\" title=\"为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\"></a>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥</h2><p>这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，<br>那么渲染线程前后获得的元素就可能不一致了。<br>因此，为了防止渲染出现不可预期的结果，浏览器设定 <code>GUI渲染线程</code>和<code>JS引擎线程</code>为互斥关系，<br>当JS引擎线程执行时<code>GUI渲染线程</code>会被挂起，GUI更新则会被保存在一个队列中等待<code>JS引擎线程</code>空闲时立即被执行。</p>\n<h2 id=\"从-Event-Loop-看-JS-的运行机制\"><a href=\"#从-Event-Loop-看-JS-的运行机制\" class=\"headerlink\" title=\"从 Event Loop 看 JS 的运行机制\"></a>从 Event Loop 看 JS 的运行机制</h2><p>到了这里，终于要进入我们的主题，什么是 Event Loop<br>先理解一些概念</p>\n<ul>\n<li>JS 分为同步任务和异步任务</li>\n<li>同步任务都在JS引擎线程上执行，形成一个<code>执行栈</code></li>\n<li>事件触发线程管理一个<code>任务队列</code>，异步任务触发条件达成，将回调事件放到<code>任务队列</code>中</li>\n<li><code>执行栈</code>中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取<code>任务队列</code>，将可运行的异步任务回调事件添加到<code>执行栈</code>中，开始执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>在前端开发中我们会通过<code>setTimeout/setInterval</code>来指定定时任务，会通过<code>XHR/fetch</code>发送网络请求， 接下来简述一下<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>到底做了什么事</p>\n<p>我们知道，不管是<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。</p>\n<p>当代码执行到<code>setTimeout/setInterval</code>时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而<code>定时触发器线程</code>在接收到这个消息后，会在等待的时间后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当代码执行到<code>XHR/fetch</code>时，实际上是<code>JS引擎线程</code>通知<code>异步http请求线程</code>，发送一个网络请求，并制定请求完成后的回调事件， 而<code>异步http请求线程</code>在接收到这个消息后，会在请求成功后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当我们的同步任务执行完，<code>JS引擎线程</code>会询问<code>事件触发线程</code>，在<code>事件队列</code>中是否有待执行的回调函数，如果有就会加入到执行栈中交给<code>JS引擎线程</code>执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>再用代码来解释一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let timerCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;wait one second&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let httpCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;get server data success&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;hello&apos;);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><br><span class=\"line\">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><br><span class=\"line\">setTimeout(timerCallback,1000);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><br><span class=\"line\">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span><br><span class=\"line\">$.get(&apos;www.xxxx.com&apos;,httpCallback);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;world&apos;);</span><br><span class=\"line\">//...</span><br><span class=\"line\">// 所有同步任务执行完后</span><br><span class=\"line\">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><br><span class=\"line\">// 如果没有，一直询问，直到有为止</span><br><span class=\"line\">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span><br></pre></td></tr></table></figure></p>\n<p>总结一下：</p>\n<ul>\n<li>JS引擎线程只执行执行栈中的事件</li>\n<li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li>\n<li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li>\n<li>如此循环</li>\n</ul>\n<h2 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h2><p>当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中<code>宏任务</code>、<code>微任务</code></p>\n<h4 id=\"什么是宏任务\"><a href=\"#什么是宏任务\" class=\"headerlink\" title=\"什么是宏任务\"></a>什么是宏任务</h4><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），<br>每一个宏任务会从头到尾执行完毕，不会执行其他。</p>\n<p>我们前文提到过<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染。</p>\n<blockquote>\n<p>宏任务–&gt;渲染–&gt;宏任务–&gt;渲染–&gt;渲染．．．</p>\n</blockquote>\n<h6 id=\"主代码块，setTimeout，setInterval等，都属于宏任务\"><a href=\"#主代码块，setTimeout，setInterval等，都属于宏任务\" class=\"headerlink\" title=\"主代码块，setTimeout，setInterval等，都属于宏任务\"></a>主代码块，setTimeout，setInterval等，都属于宏任务</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:black&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:red&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:grey&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次<code>宏任务</code>，所以全部执行完才触发<code>页面渲染</code>，渲染时<code>GUI线程</code>会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。</p>\n<p>第二个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;,0)</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p>\n<h2 id=\"什么是微任务\"><a href=\"#什么是微任务\" class=\"headerlink\" title=\"什么是微任务\"></a>什么是微任务</h2><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而<code>微任务</code>可以理解成在当前<code>宏任务</code>执行后立即执行的任务。<br>也就是说，当<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完。</p>\n<h6 id=\"Promise，process-nextTick等，属于微任务。\"><a href=\"#Promise，process-nextTick等，属于微任务。\" class=\"headerlink\" title=\"Promise，process.nextTick等，属于微任务。\"></a>Promise，process.nextTick等，属于微任务。</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;</span><br><span class=\"line\">console.log(1);</span><br><span class=\"line\">Promise.resolve().then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(3);</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。<br>页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染<br>第二个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">    Promise.resolve(3).then(data =&gt; console.log(data))</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">// print : 1 3 2</span><br></pre></td></tr></table></figure></p>\n<p>上面代码共包含两个 <code>setTimeout</code> ，也就是说除主代码块外，共有两个<code>宏任务</code>，<br>其中第一个<code>宏任务</code>执行中，输出 1 ，并且创建了<code>微任务队列</code>，所以在下一个<code>宏任务队列</code>执行前，<br>先执行<code>微任务</code>，在<code>微任务</code>执行中，输出 3 ，<code>微任务</code>执行后，执行下一次<code>宏任务</code>，执行中输出 2</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>执行一个<code>宏任务</code>（栈中没有就从<code>事件队列</code>中获取）</li>\n<li>执行过程中如果遇到<code>微任务</code>，就将它添加到<code>微任务</code>的任务队列中</li>\n<li><code>宏任务</code>执行完毕后，立即执行当前微<code>任务队列</code>中的所有<code>微任务</code>（依次执行）</li>\n<li>当前<code>宏任务</code>执行完毕，开始检查渲染，然后<code>GUI线程</code>接管渲染</li>\n<li>渲染完毕后，<code>JS线程</code>继续接管，开始下一个<code>宏任务</code>（从事件队列中获取）</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>参考链接：<a href=\"https://juejin.im/post/5d5b4c2df265da03dd3d73e5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d5b4c2df265da03dd3d73e5</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-21 15:36:08</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>几乎在每一本JS相关的书籍中，都会说JS是<code>单线程</code>的，JS是通过<code>事件队列(Event Loop)</code>的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 <code>异步</code>的能力，所以，我试图从<code>进程</code>、<code>线程</code>的角度来解释这个问题。</p>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>计算机的核心是<code>CPU</code>，它承担了所有的计算任务。<br>它就像一座工厂，时刻在运行。</p>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br><code>进程</code>就好比工厂的车间，它代表CPU所能处理的单个任务。 <code>进程</code>之间相互独立，任一时刻，CPU总是运行一个<code>进程</code>，其他<code>进程</code>处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个<code>进程</code>。</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p><img src=\"https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。<br><code>线程</code>就好比车间里的工人，一个<code>进程</code>可以包括多个<code>线程</code>，多个<code>线程</code>共享<code>进程</code>资源。</p>\n<h2 id=\"CPU、进程、线程之间的关系\"><a href=\"#CPU、进程、线程之间的关系\" class=\"headerlink\" title=\"CPU、进程、线程之间的关系\"></a>CPU、进程、线程之间的关系</h2><p>从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。</p>\n<ul>\n<li><code>进程</code>是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>\n<li><code>线程</code>是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>\n<li>不同<code>进程</code>之间也可以通信，不过代价较大</li>\n<li><code>单线程</code>与<code>多线程</code>，都是指在一个<code>进程</code>内的单和多<h2 id=\"浏览器是多进程的\"><a href=\"#浏览器是多进程的\" class=\"headerlink\" title=\"浏览器是多进程的\"></a>浏览器是多进程的</h2></li>\n</ul>\n<p>我们已经知道了<code>CPU</code>、<code>进程</code>、<code>线程</code>之间的关系，对于计算机来说，每一个应用程序都是一个<code>进程</code>，<br>而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过<code>子进程</code>来实现的。<br>对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。<br>而对于浏览器来说，浏览器就是<code>多进程</code>的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>如上图，我们可以看到一个Chrome浏览器启动了好多个进程。</p>\n<p>总结一下：</p>\n<ul>\n<li>浏览器是多进程的</li>\n<li>每一个Tab页，就是一个独立的进程<h2 id=\"浏览器包含了哪些进程\"><a href=\"#浏览器包含了哪些进程\" class=\"headerlink\" title=\"浏览器包含了哪些进程\"></a>浏览器包含了哪些进程</h2></li>\n<li>主进程<blockquote>\n<ul>\n<li>协调控制其他子进程（创建、销毁）</li>\n<li>浏览器界面显示，用户交互，前进、后退、收藏</li>\n<li>将渲染进程得到的内存中的Bitmap，绘制到用户界面上</li>\n<li>处理不可见操作，网络请求，文件访问等</li>\n</ul>\n</blockquote>\n</li>\n<li>第三方插件进程<blockquote>\n<ul>\n<li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li>\n</ul>\n</blockquote>\n</li>\n<li>GPU进程<blockquote>\n<ul>\n<li>用于3D绘制等</li>\n</ul>\n</blockquote>\n</li>\n<li><code>渲染进程</code>，就是我们说的<code>浏览器内核</code><blockquote>\n<ul>\n<li>负责页面渲染，脚本执行，事件处理等</li>\n<li>每个tab页一个渲染进程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？</p>\n<p>答案是<code>渲染进程</code>，也就是我们常说的<code>浏览器内核</code></p>\n<h2 id=\"浏览器内核（渲染进程）\"><a href=\"#浏览器内核（渲染进程）\" class=\"headerlink\" title=\"浏览器内核（渲染进程）\"></a>浏览器内核（渲染进程）</h2><p>从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。<br>而对于<code>渲染进程</code>来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。</p>\n<ul>\n<li>GUI渲染线程<blockquote>\n<ul>\n<li>负责渲染页面，布局和绘制</li>\n<li>页面需要重绘和回流时，该线程就会执行</li>\n<li>与js引擎线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>JS引擎线程<blockquote>\n<ul>\n<li>负责处理解析和执行javascript脚本程序</li>\n<li>只有一个JS引擎线程（单线程）</li>\n<li>与GUI渲染线程互斥，防止渲染结果不可预期</li>\n</ul>\n</blockquote>\n</li>\n<li>事件触发线程<blockquote>\n<ul>\n<li>用来控制事件循环（鼠标点击、setTimeout、ajax等）</li>\n<li>当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</li>\n</ul>\n</blockquote>\n</li>\n<li>定时触发器线程<blockquote>\n<ul>\n<li>setInterval与setTimeout所在的线程</li>\n<li>定时任务并不是由JS引擎计时的，是由定时触发线程来计时的</li>\n<li>计时完毕后，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n<li>异步http请求线程<blockquote>\n<ul>\n<li>浏览器有一个单独的线程用于处理AJAX请求</li>\n<li>当请求完成时，若有回调函数，通知事件触发线程</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>当我们了解了渲染进程包含的这些线程后，我们思考两个问题：</p>\n<ol>\n<li>为什么 javascript 是单线程的</li>\n<li>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥<h2 id=\"为什么-javascript-是单线程的\"><a href=\"#为什么-javascript-是单线程的\" class=\"headerlink\" title=\"为什么 javascript 是单线程的\"></a>为什么 javascript 是单线程的</h2>首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。</li>\n</ol>\n<p>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</p>\n<h2 id=\"为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\"><a href=\"#为什么-GUI-渲染线程为什么与-JS-引擎线程互斥\" class=\"headerlink\" title=\"为什么 GUI 渲染线程为什么与 JS 引擎线程互斥\"></a>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥</h2><p>这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，<br>那么渲染线程前后获得的元素就可能不一致了。<br>因此，为了防止渲染出现不可预期的结果，浏览器设定 <code>GUI渲染线程</code>和<code>JS引擎线程</code>为互斥关系，<br>当JS引擎线程执行时<code>GUI渲染线程</code>会被挂起，GUI更新则会被保存在一个队列中等待<code>JS引擎线程</code>空闲时立即被执行。</p>\n<h2 id=\"从-Event-Loop-看-JS-的运行机制\"><a href=\"#从-Event-Loop-看-JS-的运行机制\" class=\"headerlink\" title=\"从 Event Loop 看 JS 的运行机制\"></a>从 Event Loop 看 JS 的运行机制</h2><p>到了这里，终于要进入我们的主题，什么是 Event Loop<br>先理解一些概念</p>\n<ul>\n<li>JS 分为同步任务和异步任务</li>\n<li>同步任务都在JS引擎线程上执行，形成一个<code>执行栈</code></li>\n<li>事件触发线程管理一个<code>任务队列</code>，异步任务触发条件达成，将回调事件放到<code>任务队列</code>中</li>\n<li><code>执行栈</code>中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取<code>任务队列</code>，将可运行的异步任务回调事件添加到<code>执行栈</code>中，开始执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></li>\n</ul>\n<p>在前端开发中我们会通过<code>setTimeout/setInterval</code>来指定定时任务，会通过<code>XHR/fetch</code>发送网络请求， 接下来简述一下<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>到底做了什么事</p>\n<p>我们知道，不管是<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。</p>\n<p>当代码执行到<code>setTimeout/setInterval</code>时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而<code>定时触发器线程</code>在接收到这个消息后，会在等待的时间后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当代码执行到<code>XHR/fetch</code>时，实际上是<code>JS引擎线程</code>通知<code>异步http请求线程</code>，发送一个网络请求，并制定请求完成后的回调事件， 而<code>异步http请求线程</code>在接收到这个消息后，会在请求成功后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>\n<p>当我们的同步任务执行完，<code>JS引擎线程</code>会询问<code>事件触发线程</code>，在<code>事件队列</code>中是否有待执行的回调函数，如果有就会加入到执行栈中交给<code>JS引擎线程</code>执行<br><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>再用代码来解释一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let timerCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;wait one second&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let httpCallback = function() &#123;</span><br><span class=\"line\">  console.log(&apos;get server data success&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;hello&apos;);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><br><span class=\"line\">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><br><span class=\"line\">setTimeout(timerCallback,1000);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><br><span class=\"line\">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span><br><span class=\"line\">$.get(&apos;www.xxxx.com&apos;,httpCallback);</span><br><span class=\"line\">// 同步任务</span><br><span class=\"line\">console.log(&apos;world&apos;);</span><br><span class=\"line\">//...</span><br><span class=\"line\">// 所有同步任务执行完后</span><br><span class=\"line\">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><br><span class=\"line\">// 如果没有，一直询问，直到有为止</span><br><span class=\"line\">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span><br></pre></td></tr></table></figure></p>\n<p>总结一下：</p>\n<ul>\n<li>JS引擎线程只执行执行栈中的事件</li>\n<li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li>\n<li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li>\n<li>如此循环</li>\n</ul>\n<h2 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h2><p>当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中<code>宏任务</code>、<code>微任务</code></p>\n<h4 id=\"什么是宏任务\"><a href=\"#什么是宏任务\" class=\"headerlink\" title=\"什么是宏任务\"></a>什么是宏任务</h4><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），<br>每一个宏任务会从头到尾执行完毕，不会执行其他。</p>\n<p>我们前文提到过<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染。</p>\n<blockquote>\n<p>宏任务–&gt;渲染–&gt;宏任务–&gt;渲染–&gt;渲染．．．</p>\n</blockquote>\n<h6 id=\"主代码块，setTimeout，setInterval等，都属于宏任务\"><a href=\"#主代码块，setTimeout，setInterval等，都属于宏任务\" class=\"headerlink\" title=\"主代码块，setTimeout，setInterval等，都属于宏任务\"></a>主代码块，setTimeout，setInterval等，都属于宏任务</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:black&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:red&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">document.body.style = &apos;background:grey&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次<code>宏任务</code>，所以全部执行完才触发<code>页面渲染</code>，渲染时<code>GUI线程</code>会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。</p>\n<p>第二个例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;;</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;,0)</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip\" alt=\"image\"><br>我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p>\n<h2 id=\"什么是微任务\"><a href=\"#什么是微任务\" class=\"headerlink\" title=\"什么是微任务\"></a>什么是微任务</h2><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而<code>微任务</code>可以理解成在当前<code>宏任务</code>执行后立即执行的任务。<br>也就是说，当<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完。</p>\n<h6 id=\"Promise，process-nextTick等，属于微任务。\"><a href=\"#Promise，process-nextTick等，属于微任务。\" class=\"headerlink\" title=\"Promise，process.nextTick等，属于微任务。\"></a>Promise，process.nextTick等，属于微任务。</h6><p>第一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.body.style = &apos;background:blue&apos;</span><br><span class=\"line\">console.log(1);</span><br><span class=\"line\">Promise.resolve().then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(2);</span><br><span class=\"line\">    document.body.style = &apos;background:black&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(3);</span><br></pre></td></tr></table></figure></p>\n<p>执行一下，再看效果：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。<br>页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染<br>第二个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">    Promise.resolve(3).then(data =&gt; console.log(data))</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">// print : 1 3 2</span><br></pre></td></tr></table></figure></p>\n<p>上面代码共包含两个 <code>setTimeout</code> ，也就是说除主代码块外，共有两个<code>宏任务</code>，<br>其中第一个<code>宏任务</code>执行中，输出 1 ，并且创建了<code>微任务队列</code>，所以在下一个<code>宏任务队列</code>执行前，<br>先执行<code>微任务</code>，在<code>微任务</code>执行中，输出 3 ，<code>微任务</code>执行后，执行下一次<code>宏任务</code>，执行中输出 2</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>执行一个<code>宏任务</code>（栈中没有就从<code>事件队列</code>中获取）</li>\n<li>执行过程中如果遇到<code>微任务</code>，就将它添加到<code>微任务</code>的任务队列中</li>\n<li><code>宏任务</code>执行完毕后，立即执行当前微<code>任务队列</code>中的所有<code>微任务</code>（依次执行）</li>\n<li>当前<code>宏任务</code>执行完毕，开始检查渲染，然后<code>GUI线程</code>接管渲染</li>\n<li>渲染完毕后，<code>JS线程</code>继续接管，开始下一个<code>宏任务</code>（从事件队列中获取）</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"></p>\n<p>参考链接：<a href=\"https://juejin.im/post/5d5b4c2df265da03dd3d73e5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d5b4c2df265da03dd3d73e5</a></p>\n"},{"title":"macOS 上安裝 MySQL","date":"2020-07-27T09:11:18.000Z","_content":"\n> 在 macOS 下安裝 MySQL 资料库，并且基本的设定 root 密码。\n## 一、安装步骤\n* [官网页面](https://dev.mysql.com/downloads/file/?id=454017)下方` No thanks, just start my download.`\n* 借用站点-[mysql-5.6.21-osx10.9-x86_64.dmg](https://cdn.ioa.tw/MacEnvInit/mysql-5.6.21-osx10.9-x86_64.dmg)\n* 对` mysql-5.6.21-osx10.9-x86_64.dmg`点击两下进行安装，点击两下` mysql-5.6.21-osx10.8-x86_64.pkg` 开始安装\n* ‼️若是 OSX 10.10 以上，请在 安装类型 的步骤时点击自定 把 `Startup Item` 选择 取消勾选！\n* 安装完成后，打开 系统偏好设置 > MySQL > Start MySQL Server\n若 系统偏好设置 里面没看到 MySQL 的话，请重开 系统偏好设置\n## 二、变更启动权限\n* 每次启动 MySQL 都要输入密码，很麻烦，所以变更一下权限，终端输入命令 `sudo chmod 777 /usr/local/mysql/support-files/mysql.server`\n## 三、加入指令\n* 打开终端输入 `vim ~/.zshrc`\n* 在最下面新增 `export PATH=\"/usr/local/mysql/bin:$PATH\"`执行`:wq`\n* 退出之后，在终端执行`source ~/.zshrc`\n## 四、设定密码\n* 打开终端\n* 进入 MySQL，终端执行命令 `mysql -u root`\n* 执行命令`use mysql;`选择资料库\n* 执行命令`update user set password=PASSWORD(\"你的密碼\") where User='root';` 设定密码\n* 执行命令`flush privileges;`刷新MySQL\n* 执行命令`quit` 离开 MySQL\n\n>注意！设置密码时，要记得加上引号，假设密码为1234，应该为：\nupdate user set password=PASSWORD(\"1234\") where User='root';\n\n相关参考：[https://www.ioa.tw/macOS/MySQL.html](https://www.ioa.tw/macOS/MySQL.html)\n\n大功告成✌️✌️\n","source":"_posts/Mysql.md","raw":"---\ntitle: macOS 上安裝 MySQL\ndate: 2020-07-27 17:11:18\ntags: Software\n---\n\n> 在 macOS 下安裝 MySQL 资料库，并且基本的设定 root 密码。\n## 一、安装步骤\n* [官网页面](https://dev.mysql.com/downloads/file/?id=454017)下方` No thanks, just start my download.`\n* 借用站点-[mysql-5.6.21-osx10.9-x86_64.dmg](https://cdn.ioa.tw/MacEnvInit/mysql-5.6.21-osx10.9-x86_64.dmg)\n* 对` mysql-5.6.21-osx10.9-x86_64.dmg`点击两下进行安装，点击两下` mysql-5.6.21-osx10.8-x86_64.pkg` 开始安装\n* ‼️若是 OSX 10.10 以上，请在 安装类型 的步骤时点击自定 把 `Startup Item` 选择 取消勾选！\n* 安装完成后，打开 系统偏好设置 > MySQL > Start MySQL Server\n若 系统偏好设置 里面没看到 MySQL 的话，请重开 系统偏好设置\n## 二、变更启动权限\n* 每次启动 MySQL 都要输入密码，很麻烦，所以变更一下权限，终端输入命令 `sudo chmod 777 /usr/local/mysql/support-files/mysql.server`\n## 三、加入指令\n* 打开终端输入 `vim ~/.zshrc`\n* 在最下面新增 `export PATH=\"/usr/local/mysql/bin:$PATH\"`执行`:wq`\n* 退出之后，在终端执行`source ~/.zshrc`\n## 四、设定密码\n* 打开终端\n* 进入 MySQL，终端执行命令 `mysql -u root`\n* 执行命令`use mysql;`选择资料库\n* 执行命令`update user set password=PASSWORD(\"你的密碼\") where User='root';` 设定密码\n* 执行命令`flush privileges;`刷新MySQL\n* 执行命令`quit` 离开 MySQL\n\n>注意！设置密码时，要记得加上引号，假设密码为1234，应该为：\nupdate user set password=PASSWORD(\"1234\") where User='root';\n\n相关参考：[https://www.ioa.tw/macOS/MySQL.html](https://www.ioa.tw/macOS/MySQL.html)\n\n大功告成✌️✌️\n","slug":"Mysql","published":1,"updated":"2020-12-14T10:35:01.968Z","_id":"ckioehjqm000r78p3vr4f7s7z","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>在 macOS 下安裝 MySQL 资料库，并且基本的设定 root 密码。</p>\n</blockquote>\n<h2 id=\"一、安装步骤\"><a href=\"#一、安装步骤\" class=\"headerlink\" title=\"一、安装步骤\"></a>一、安装步骤</h2><ul>\n<li><a href=\"https://dev.mysql.com/downloads/file/?id=454017\" target=\"_blank\" rel=\"noopener\">官网页面</a>下方<code>No thanks, just start my download.</code></li>\n<li>借用站点-<a href=\"https://cdn.ioa.tw/MacEnvInit/mysql-5.6.21-osx10.9-x86_64.dmg\" target=\"_blank\" rel=\"noopener\">mysql-5.6.21-osx10.9-x86_64.dmg</a></li>\n<li>对<code>mysql-5.6.21-osx10.9-x86_64.dmg</code>点击两下进行安装，点击两下<code>mysql-5.6.21-osx10.8-x86_64.pkg</code> 开始安装</li>\n<li>‼️若是 OSX 10.10 以上，请在 安装类型 的步骤时点击自定 把 <code>Startup Item</code> 选择 取消勾选！</li>\n<li>安装完成后，打开 系统偏好设置 &gt; MySQL &gt; Start MySQL Server<br>若 系统偏好设置 里面没看到 MySQL 的话，请重开 系统偏好设置<h2 id=\"二、变更启动权限\"><a href=\"#二、变更启动权限\" class=\"headerlink\" title=\"二、变更启动权限\"></a>二、变更启动权限</h2></li>\n<li>每次启动 MySQL 都要输入密码，很麻烦，所以变更一下权限，终端输入命令 <code>sudo chmod 777 /usr/local/mysql/support-files/mysql.server</code><h2 id=\"三、加入指令\"><a href=\"#三、加入指令\" class=\"headerlink\" title=\"三、加入指令\"></a>三、加入指令</h2></li>\n<li>打开终端输入 <code>vim ~/.zshrc</code></li>\n<li>在最下面新增 <code>export PATH=&quot;/usr/local/mysql/bin:$PATH&quot;</code>执行<code>:wq</code></li>\n<li>退出之后，在终端执行<code>source ~/.zshrc</code><h2 id=\"四、设定密码\"><a href=\"#四、设定密码\" class=\"headerlink\" title=\"四、设定密码\"></a>四、设定密码</h2></li>\n<li>打开终端</li>\n<li>进入 MySQL，终端执行命令 <code>mysql -u root</code></li>\n<li>执行命令<code>use mysql;</code>选择资料库</li>\n<li>执行命令<code>update user set password=PASSWORD(&quot;你的密碼&quot;) where User=&#39;root&#39;;</code> 设定密码</li>\n<li>执行命令<code>flush privileges;</code>刷新MySQL</li>\n<li>执行命令<code>quit</code> 离开 MySQL</li>\n</ul>\n<blockquote>\n<p>注意！设置密码时，要记得加上引号，假设密码为1234，应该为：<br>update user set password=PASSWORD(“1234”) where User=’root’;</p>\n</blockquote>\n<p>相关参考：<a href=\"https://www.ioa.tw/macOS/MySQL.html\" target=\"_blank\" rel=\"noopener\">https://www.ioa.tw/macOS/MySQL.html</a></p>\n<p>大功告成✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在 macOS 下安裝 MySQL 资料库，并且基本的设定 root 密码。</p>\n</blockquote>\n<h2 id=\"一、安装步骤\"><a href=\"#一、安装步骤\" class=\"headerlink\" title=\"一、安装步骤\"></a>一、安装步骤</h2><ul>\n<li><a href=\"https://dev.mysql.com/downloads/file/?id=454017\" target=\"_blank\" rel=\"noopener\">官网页面</a>下方<code>No thanks, just start my download.</code></li>\n<li>借用站点-<a href=\"https://cdn.ioa.tw/MacEnvInit/mysql-5.6.21-osx10.9-x86_64.dmg\" target=\"_blank\" rel=\"noopener\">mysql-5.6.21-osx10.9-x86_64.dmg</a></li>\n<li>对<code>mysql-5.6.21-osx10.9-x86_64.dmg</code>点击两下进行安装，点击两下<code>mysql-5.6.21-osx10.8-x86_64.pkg</code> 开始安装</li>\n<li>‼️若是 OSX 10.10 以上，请在 安装类型 的步骤时点击自定 把 <code>Startup Item</code> 选择 取消勾选！</li>\n<li>安装完成后，打开 系统偏好设置 &gt; MySQL &gt; Start MySQL Server<br>若 系统偏好设置 里面没看到 MySQL 的话，请重开 系统偏好设置<h2 id=\"二、变更启动权限\"><a href=\"#二、变更启动权限\" class=\"headerlink\" title=\"二、变更启动权限\"></a>二、变更启动权限</h2></li>\n<li>每次启动 MySQL 都要输入密码，很麻烦，所以变更一下权限，终端输入命令 <code>sudo chmod 777 /usr/local/mysql/support-files/mysql.server</code><h2 id=\"三、加入指令\"><a href=\"#三、加入指令\" class=\"headerlink\" title=\"三、加入指令\"></a>三、加入指令</h2></li>\n<li>打开终端输入 <code>vim ~/.zshrc</code></li>\n<li>在最下面新增 <code>export PATH=&quot;/usr/local/mysql/bin:$PATH&quot;</code>执行<code>:wq</code></li>\n<li>退出之后，在终端执行<code>source ~/.zshrc</code><h2 id=\"四、设定密码\"><a href=\"#四、设定密码\" class=\"headerlink\" title=\"四、设定密码\"></a>四、设定密码</h2></li>\n<li>打开终端</li>\n<li>进入 MySQL，终端执行命令 <code>mysql -u root</code></li>\n<li>执行命令<code>use mysql;</code>选择资料库</li>\n<li>执行命令<code>update user set password=PASSWORD(&quot;你的密碼&quot;) where User=&#39;root&#39;;</code> 设定密码</li>\n<li>执行命令<code>flush privileges;</code>刷新MySQL</li>\n<li>执行命令<code>quit</code> 离开 MySQL</li>\n</ul>\n<blockquote>\n<p>注意！设置密码时，要记得加上引号，假设密码为1234，应该为：<br>update user set password=PASSWORD(“1234”) where User=’root’;</p>\n</blockquote>\n<p>相关参考：<a href=\"https://www.ioa.tw/macOS/MySQL.html\" target=\"_blank\" rel=\"noopener\">https://www.ioa.tw/macOS/MySQL.html</a></p>\n<p>大功告成✌️✌️</p>\n"},{"title":"NO3:Node.js + mysql+Sequelize实现注册接口及校验逻辑","date":"2020-07-27T09:12:00.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n在上一篇的基础上，继续升级!\n\n[NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete](https://www.jianshu.com/p/02085294b6ed)\n\n## 一、安装依赖\n---\n* 安装`mysql2`+`sequelize` +  `jsonwebtoken` + `joi`\n\n* `sequelize`\n`sequelize.js` 提供对 [MySQL](http://www.oschina.net/p/mysql)，[MariaDB](http://www.oschina.net/p/mariadb)，[SQLite](http://www.oschina.net/p/sqlite) 和 [PostgreSQL](http://www.oschina.net/p/postgresql) 数据库的简单访问，通过映射数据库条目到对象，或者对象到数据库条目。简而言之，就是 ORM（Object-Relational-Mapper）。Sequelize.js 完全是使用 JavaScript 编写，适用于 Node.js 的环境。\n参考链接：\n* [使用Sequelize](https://www.liaoxuefeng.com/wiki/1022910821149312/1101571555324224)\n* [sequelize](https://sequelize.org/)\n* [https://github.com/caiya/node-sequelize/tree/master/bin](https://github.com/caiya/node-sequelize/tree/master/bin)\n```\n $ npm install --save sequelize mysql2 joi jsonwebtoken\n```\n\n\n## 二、添加+修改配置文件\n---\n`修改app.js`\n```\n// app.js\nvar indexRouter = require('./routes/index');\n// var usersRouter = require('./routes/users');\n\napp.use('/', indexRouter);\n// app.use('/users', usersRouter);\n```\n`修改bin/www`\n```\nconst {sequelize} = require('../models')\nsequelize.sync({force: false})\n  .then(() => {\n    server.listen(port);\n    console.log(`Server started on port ${config.port}`)\n  }).catch(function (err) {\n    console.log('failed: ' + err);\n});\n// server.listen(port);\n```\n`新建models/index.js + models/user.js`:配置各种数据库模型类\n```\n//models/index.js\nconst fs = require('fs')\nconst path = require('path')\nconst Sequelize = require('sequelize')\nconst config = require('../config/config')\nconst db = {}\n\nconst sequelize = new Sequelize(config.database, config.username, config.password, {\n  host: config.host,\n  dialect: 'mysql',\n  pool: {\n      max: 5,\n      min: 0,\n      idle: 30000\n  }\n});\n\nfs\n  .readdirSync(__dirname)\n  .filter((file) =>\n    file !== 'index.js'\n  )\n  .forEach((file) => {\n    const model = sequelize.import(path.join(__dirname, file))\n    db[model.name] = model\n  })\n\nObject.keys(db).forEach(function (modelName) {\n  if ('associate' in db[modelName]) {\n    db[modelName].associate(db)\n  }\n})\n\ndb.sequelize = sequelize\ndb.Sequelize = Sequelize\n\nmodule.exports = db\n\n```\n```\n//models/user.js\nconst Promise = require('bluebird')\nconst bcrypt = Promise.promisifyAll(require('bcrypt'))\n\n// function hashPassword (user, options) {\n//   const SALT_FACTOR = 8\n\n//   if (!user.changed('password')) {\n//     return\n//   }\n\n//   return bcrypt\n//     .genSaltAsync(SALT_FACTOR)\n//     .then(salt => bcrypt.hashAsync(user.password, salt, null))\n//     .then(hash => {\n//       user.setDataValue('password', hash)\n//     })\n// }\n\nmodule.exports = (sequelize, DataTypes) => {\n  const User = sequelize.define('User', {\n    email: {\n      type: DataTypes.STRING,\n      unique: true\n    },\n    password: DataTypes.STRING\n  }, \n// {\n//     hooks: {\n//       beforeCreate: hashPassword,\n//       beforeUpdate: hashPassword,\n//       beforeSave: hashPassword\n//     }\n//   }\n)\n\n  User.prototype.comparePassword = function (password) {\n    return bcrypt.compareAsync(password, this.password)\n  }\n\n  User.associate = function (models) {\n  }\n\n  return User\n}\n\n```\n`新建config/config.js`:数据库相关配置\n\n```\nvar config = {\n  host     : 'localhost', // 主机名\n  username : 'root', // 用户名\n  password : '1234567w', // 口令\n  database : 'nodemysql', // 使用哪个数据库\n  port: 3000, // 端口号，MySQL默认3306\n  authentication: {\n    jwtSecret: process.env.JWT_SECRET || 'secret'\n  }\n};\nmodule.exports = config;\n```\n`修改router/index.js`:添加注册接口\n```\n// // index.js\nconst express = require('express');\nconst router = express.Router();\nconst AuthenticationControllerPolicy = require('../policies/AuthenticationControllerPolicy')\nconst AuthenticationController = require('../controllers/AuthenticationController')\n\nrouter.post('/register',\n    AuthenticationControllerPolicy.register,\n    AuthenticationController.register)\n/* GET home page. */\nrouter.post('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\nmodule.exports = router;\n```\n`新建policies/AuthenticationControllerPolicy.js`:用于校验注册逻辑\n```\nconst Joi = require('joi')\n\nmodule.exports = {\n  register (req, res, next) {\n    const schema = {\n      email: Joi.string().email(),\n      password: Joi.string().regex(\n        new RegExp('^[a-zA-Z0-9]{8,32}$')\n      )\n    }\n    \n    const {error} = Joi.validate(req.body, schema)\n    if (error) {\n      switch (error.details[0].context.key) {\n        case 'email':\n          res.status(400).send({\n            error: 'You must provide a valid email address'\n          })\n          break\n        case 'password':\n          res.status(400).send({\n            error: `The password provided failed to match the following rules:\n              <br>\n              1. It must contain ONLY the following characters: lower case, upper case, numerics.\n              <br>\n              2. It must be at least 8 characters in length and not greater than 32 characters in length.\n            `\n          })\n          break\n        default:\n          res.status(400).send({\n            error: 'Invalid registration information'\n          })\n      }\n    } else {\n      next()\n    }\n  }\n}\n\n```\n`新建controllers/AuthenticationController.js`:用于在数据库表中创建注册数据逻辑\n```\nconst {User} = require('../models')\nconst jwt = require('jsonwebtoken')\nconst config = require('../config/config')\n\nfunction jwtSignUser (user) {\n  const ONE_WEEK = 60 * 60 * 24 * 7\n  return jwt.sign(user, config.authentication.jwtSecret, {\n    expiresIn: ONE_WEEK\n  })\n}\n\nmodule.exports = {\n  async register (req, res) {\n    console.log(14, req.body)\n    try {\n      const user = await User.create(req.body)\n      console.log(user)\n      const userJson = user.toJSON()\n      res.send({\n        user: userJson,\n        token: jwtSignUser(userJson)\n      })\n    } catch (err) {\n      res.status(400).send({\n        error: 'This email account is already in use.'\n      })\n    }\n  }\n}\n\n```\n## 三、 接口测试\n---\n\n>此处推荐一款接口测试工具！`POSTMAN`！ 简单来说，四个词，简单实用大方美观！\n\n* 打开`postman`\n用post方法请求接口，可以看到下面可以成功的返回message\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c7be54c38a8b1669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照相关提示进行 注册数据，即可\n\n`打开数据库可视化工具：`\n可以看到在table表中有一个名为user的数据表,在user表中可以看到数据创建成功:\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-bb8daab7b371cb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n我们的注册接口就成功啦！\n\n大功告成✌️✌️✌️","source":"_posts/Node.md","raw":"---\ntitle: NO3:Node.js + mysql+Sequelize实现注册接口及校验逻辑\ndate: 2020-07-27 17:12:00\ntags: Node\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n在上一篇的基础上，继续升级!\n\n[NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete](https://www.jianshu.com/p/02085294b6ed)\n\n## 一、安装依赖\n---\n* 安装`mysql2`+`sequelize` +  `jsonwebtoken` + `joi`\n\n* `sequelize`\n`sequelize.js` 提供对 [MySQL](http://www.oschina.net/p/mysql)，[MariaDB](http://www.oschina.net/p/mariadb)，[SQLite](http://www.oschina.net/p/sqlite) 和 [PostgreSQL](http://www.oschina.net/p/postgresql) 数据库的简单访问，通过映射数据库条目到对象，或者对象到数据库条目。简而言之，就是 ORM（Object-Relational-Mapper）。Sequelize.js 完全是使用 JavaScript 编写，适用于 Node.js 的环境。\n参考链接：\n* [使用Sequelize](https://www.liaoxuefeng.com/wiki/1022910821149312/1101571555324224)\n* [sequelize](https://sequelize.org/)\n* [https://github.com/caiya/node-sequelize/tree/master/bin](https://github.com/caiya/node-sequelize/tree/master/bin)\n```\n $ npm install --save sequelize mysql2 joi jsonwebtoken\n```\n\n\n## 二、添加+修改配置文件\n---\n`修改app.js`\n```\n// app.js\nvar indexRouter = require('./routes/index');\n// var usersRouter = require('./routes/users');\n\napp.use('/', indexRouter);\n// app.use('/users', usersRouter);\n```\n`修改bin/www`\n```\nconst {sequelize} = require('../models')\nsequelize.sync({force: false})\n  .then(() => {\n    server.listen(port);\n    console.log(`Server started on port ${config.port}`)\n  }).catch(function (err) {\n    console.log('failed: ' + err);\n});\n// server.listen(port);\n```\n`新建models/index.js + models/user.js`:配置各种数据库模型类\n```\n//models/index.js\nconst fs = require('fs')\nconst path = require('path')\nconst Sequelize = require('sequelize')\nconst config = require('../config/config')\nconst db = {}\n\nconst sequelize = new Sequelize(config.database, config.username, config.password, {\n  host: config.host,\n  dialect: 'mysql',\n  pool: {\n      max: 5,\n      min: 0,\n      idle: 30000\n  }\n});\n\nfs\n  .readdirSync(__dirname)\n  .filter((file) =>\n    file !== 'index.js'\n  )\n  .forEach((file) => {\n    const model = sequelize.import(path.join(__dirname, file))\n    db[model.name] = model\n  })\n\nObject.keys(db).forEach(function (modelName) {\n  if ('associate' in db[modelName]) {\n    db[modelName].associate(db)\n  }\n})\n\ndb.sequelize = sequelize\ndb.Sequelize = Sequelize\n\nmodule.exports = db\n\n```\n```\n//models/user.js\nconst Promise = require('bluebird')\nconst bcrypt = Promise.promisifyAll(require('bcrypt'))\n\n// function hashPassword (user, options) {\n//   const SALT_FACTOR = 8\n\n//   if (!user.changed('password')) {\n//     return\n//   }\n\n//   return bcrypt\n//     .genSaltAsync(SALT_FACTOR)\n//     .then(salt => bcrypt.hashAsync(user.password, salt, null))\n//     .then(hash => {\n//       user.setDataValue('password', hash)\n//     })\n// }\n\nmodule.exports = (sequelize, DataTypes) => {\n  const User = sequelize.define('User', {\n    email: {\n      type: DataTypes.STRING,\n      unique: true\n    },\n    password: DataTypes.STRING\n  }, \n// {\n//     hooks: {\n//       beforeCreate: hashPassword,\n//       beforeUpdate: hashPassword,\n//       beforeSave: hashPassword\n//     }\n//   }\n)\n\n  User.prototype.comparePassword = function (password) {\n    return bcrypt.compareAsync(password, this.password)\n  }\n\n  User.associate = function (models) {\n  }\n\n  return User\n}\n\n```\n`新建config/config.js`:数据库相关配置\n\n```\nvar config = {\n  host     : 'localhost', // 主机名\n  username : 'root', // 用户名\n  password : '1234567w', // 口令\n  database : 'nodemysql', // 使用哪个数据库\n  port: 3000, // 端口号，MySQL默认3306\n  authentication: {\n    jwtSecret: process.env.JWT_SECRET || 'secret'\n  }\n};\nmodule.exports = config;\n```\n`修改router/index.js`:添加注册接口\n```\n// // index.js\nconst express = require('express');\nconst router = express.Router();\nconst AuthenticationControllerPolicy = require('../policies/AuthenticationControllerPolicy')\nconst AuthenticationController = require('../controllers/AuthenticationController')\n\nrouter.post('/register',\n    AuthenticationControllerPolicy.register,\n    AuthenticationController.register)\n/* GET home page. */\nrouter.post('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\nmodule.exports = router;\n```\n`新建policies/AuthenticationControllerPolicy.js`:用于校验注册逻辑\n```\nconst Joi = require('joi')\n\nmodule.exports = {\n  register (req, res, next) {\n    const schema = {\n      email: Joi.string().email(),\n      password: Joi.string().regex(\n        new RegExp('^[a-zA-Z0-9]{8,32}$')\n      )\n    }\n    \n    const {error} = Joi.validate(req.body, schema)\n    if (error) {\n      switch (error.details[0].context.key) {\n        case 'email':\n          res.status(400).send({\n            error: 'You must provide a valid email address'\n          })\n          break\n        case 'password':\n          res.status(400).send({\n            error: `The password provided failed to match the following rules:\n              <br>\n              1. It must contain ONLY the following characters: lower case, upper case, numerics.\n              <br>\n              2. It must be at least 8 characters in length and not greater than 32 characters in length.\n            `\n          })\n          break\n        default:\n          res.status(400).send({\n            error: 'Invalid registration information'\n          })\n      }\n    } else {\n      next()\n    }\n  }\n}\n\n```\n`新建controllers/AuthenticationController.js`:用于在数据库表中创建注册数据逻辑\n```\nconst {User} = require('../models')\nconst jwt = require('jsonwebtoken')\nconst config = require('../config/config')\n\nfunction jwtSignUser (user) {\n  const ONE_WEEK = 60 * 60 * 24 * 7\n  return jwt.sign(user, config.authentication.jwtSecret, {\n    expiresIn: ONE_WEEK\n  })\n}\n\nmodule.exports = {\n  async register (req, res) {\n    console.log(14, req.body)\n    try {\n      const user = await User.create(req.body)\n      console.log(user)\n      const userJson = user.toJSON()\n      res.send({\n        user: userJson,\n        token: jwtSignUser(userJson)\n      })\n    } catch (err) {\n      res.status(400).send({\n        error: 'This email account is already in use.'\n      })\n    }\n  }\n}\n\n```\n## 三、 接口测试\n---\n\n>此处推荐一款接口测试工具！`POSTMAN`！ 简单来说，四个词，简单实用大方美观！\n\n* 打开`postman`\n用post方法请求接口，可以看到下面可以成功的返回message\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c7be54c38a8b1669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n按照相关提示进行 注册数据，即可\n\n`打开数据库可视化工具：`\n可以看到在table表中有一个名为user的数据表,在user表中可以看到数据创建成功:\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-bb8daab7b371cb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n我们的注册接口就成功啦！\n\n大功告成✌️✌️✌️","slug":"Node","published":1,"updated":"2020-12-14T10:30:27.019Z","_id":"ckioehjqn000s78p3ykr3z6ch","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>在上一篇的基础上，继续升级!</p>\n<p><a href=\"https://www.jianshu.com/p/02085294b6ed\" target=\"_blank\" rel=\"noopener\">NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete</a></p>\n<h2 id=\"一、安装依赖\"><a href=\"#一、安装依赖\" class=\"headerlink\" title=\"一、安装依赖\"></a>一、安装依赖</h2><hr>\n<ul>\n<li><p>安装<code>mysql2</code>+<code>sequelize</code> +  <code>jsonwebtoken</code> + <code>joi</code></p>\n</li>\n<li><p><code>sequelize</code><br><code>sequelize.js</code> 提供对 <a href=\"http://www.oschina.net/p/mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a>，<a href=\"http://www.oschina.net/p/mariadb\" target=\"_blank\" rel=\"noopener\">MariaDB</a>，<a href=\"http://www.oschina.net/p/sqlite\" target=\"_blank\" rel=\"noopener\">SQLite</a> 和 <a href=\"http://www.oschina.net/p/postgresql\" target=\"_blank\" rel=\"noopener\">PostgreSQL</a> 数据库的简单访问，通过映射数据库条目到对象，或者对象到数据库条目。简而言之，就是 ORM（Object-Relational-Mapper）。Sequelize.js 完全是使用 JavaScript 编写，适用于 Node.js 的环境。<br>参考链接：</p>\n</li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1101571555324224\" target=\"_blank\" rel=\"noopener\">使用Sequelize</a></li>\n<li><a href=\"https://sequelize.org/\" target=\"_blank\" rel=\"noopener\">sequelize</a></li>\n<li><a href=\"https://github.com/caiya/node-sequelize/tree/master/bin\" target=\"_blank\" rel=\"noopener\">https://github.com/caiya/node-sequelize/tree/master/bin</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save sequelize mysql2 joi jsonwebtoken</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二、添加-修改配置文件\"><a href=\"#二、添加-修改配置文件\" class=\"headerlink\" title=\"二、添加+修改配置文件\"></a>二、添加+修改配置文件</h2><hr>\n<p><code>修改app.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// app.js</span><br><span class=\"line\">var indexRouter = require(&apos;./routes/index&apos;);</span><br><span class=\"line\">// var usersRouter = require(&apos;./routes/users&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(&apos;/&apos;, indexRouter);</span><br><span class=\"line\">// app.use(&apos;/users&apos;, usersRouter);</span><br></pre></td></tr></table></figure></p>\n<p><code>修改bin/www</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;sequelize&#125; = require(&apos;../models&apos;)</span><br><span class=\"line\">sequelize.sync(&#123;force: false&#125;)</span><br><span class=\"line\">  .then(() =&gt; &#123;</span><br><span class=\"line\">    server.listen(port);</span><br><span class=\"line\">    console.log(`Server started on port $&#123;config.port&#125;`)</span><br><span class=\"line\">  &#125;).catch(function (err) &#123;</span><br><span class=\"line\">    console.log(&apos;failed: &apos; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// server.listen(port);</span><br></pre></td></tr></table></figure></p>\n<p><code>新建models/index.js + models/user.js</code>:配置各种数据库模型类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//models/index.js</span><br><span class=\"line\">const fs = require(&apos;fs&apos;)</span><br><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">const Sequelize = require(&apos;sequelize&apos;)</span><br><span class=\"line\">const config = require(&apos;../config/config&apos;)</span><br><span class=\"line\">const db = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const sequelize = new Sequelize(config.database, config.username, config.password, &#123;</span><br><span class=\"line\">  host: config.host,</span><br><span class=\"line\">  dialect: &apos;mysql&apos;,</span><br><span class=\"line\">  pool: &#123;</span><br><span class=\"line\">      max: 5,</span><br><span class=\"line\">      min: 0,</span><br><span class=\"line\">      idle: 30000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs</span><br><span class=\"line\">  .readdirSync(__dirname)</span><br><span class=\"line\">  .filter((file) =&gt;</span><br><span class=\"line\">    file !== &apos;index.js&apos;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .forEach((file) =&gt; &#123;</span><br><span class=\"line\">    const model = sequelize.import(path.join(__dirname, file))</span><br><span class=\"line\">    db[model.name] = model</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.keys(db).forEach(function (modelName) &#123;</span><br><span class=\"line\">  if (&apos;associate&apos; in db[modelName]) &#123;</span><br><span class=\"line\">    db[modelName].associate(db)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.sequelize = sequelize</span><br><span class=\"line\">db.Sequelize = Sequelize</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = db</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//models/user.js</span><br><span class=\"line\">const Promise = require(&apos;bluebird&apos;)</span><br><span class=\"line\">const bcrypt = Promise.promisifyAll(require(&apos;bcrypt&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">// function hashPassword (user, options) &#123;</span><br><span class=\"line\">//   const SALT_FACTOR = 8</span><br><span class=\"line\"></span><br><span class=\"line\">//   if (!user.changed(&apos;password&apos;)) &#123;</span><br><span class=\"line\">//     return</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//   return bcrypt</span><br><span class=\"line\">//     .genSaltAsync(SALT_FACTOR)</span><br><span class=\"line\">//     .then(salt =&gt; bcrypt.hashAsync(user.password, salt, null))</span><br><span class=\"line\">//     .then(hash =&gt; &#123;</span><br><span class=\"line\">//       user.setDataValue(&apos;password&apos;, hash)</span><br><span class=\"line\">//     &#125;)</span><br><span class=\"line\">// &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = (sequelize, DataTypes) =&gt; &#123;</span><br><span class=\"line\">  const User = sequelize.define(&apos;User&apos;, &#123;</span><br><span class=\"line\">    email: &#123;</span><br><span class=\"line\">      type: DataTypes.STRING,</span><br><span class=\"line\">      unique: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    password: DataTypes.STRING</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">// &#123;</span><br><span class=\"line\">//     hooks: &#123;</span><br><span class=\"line\">//       beforeCreate: hashPassword,</span><br><span class=\"line\">//       beforeUpdate: hashPassword,</span><br><span class=\"line\">//       beforeSave: hashPassword</span><br><span class=\"line\">//     &#125;</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">  User.prototype.comparePassword = function (password) &#123;</span><br><span class=\"line\">    return bcrypt.compareAsync(password, this.password)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  User.associate = function (models) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return User</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>新建config/config.js</code>:数据库相关配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var config = &#123;</span><br><span class=\"line\">  host     : &apos;localhost&apos;, // 主机名</span><br><span class=\"line\">  username : &apos;root&apos;, // 用户名</span><br><span class=\"line\">  password : &apos;1234567w&apos;, // 口令</span><br><span class=\"line\">  database : &apos;nodemysql&apos;, // 使用哪个数据库</span><br><span class=\"line\">  port: 3000, // 端口号，MySQL默认3306</span><br><span class=\"line\">  authentication: &#123;</span><br><span class=\"line\">    jwtSecret: process.env.JWT_SECRET || &apos;secret&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p><code>修改router/index.js</code>:添加注册接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// // index.js</span><br><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const router = express.Router();</span><br><span class=\"line\">const AuthenticationControllerPolicy = require(&apos;../policies/AuthenticationControllerPolicy&apos;)</span><br><span class=\"line\">const AuthenticationController = require(&apos;../controllers/AuthenticationController&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(&apos;/register&apos;,</span><br><span class=\"line\">    AuthenticationControllerPolicy.register,</span><br><span class=\"line\">    AuthenticationController.register)</span><br><span class=\"line\">/* GET home page. */</span><br><span class=\"line\">router.post(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">  res.render(&apos;index&apos;, &#123; title: &apos;Express&apos; &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">module.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p><code>新建policies/AuthenticationControllerPolicy.js</code>:用于校验注册逻辑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Joi = require(&apos;joi&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  register (req, res, next) &#123;</span><br><span class=\"line\">    const schema = &#123;</span><br><span class=\"line\">      email: Joi.string().email(),</span><br><span class=\"line\">      password: Joi.string().regex(</span><br><span class=\"line\">        new RegExp(&apos;^[a-zA-Z0-9]&#123;8,32&#125;$&apos;)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const &#123;error&#125; = Joi.validate(req.body, schema)</span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">      switch (error.details[0].context.key) &#123;</span><br><span class=\"line\">        case &apos;email&apos;:</span><br><span class=\"line\">          res.status(400).send(&#123;</span><br><span class=\"line\">            error: &apos;You must provide a valid email address&apos;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          break</span><br><span class=\"line\">        case &apos;password&apos;:</span><br><span class=\"line\">          res.status(400).send(&#123;</span><br><span class=\"line\">            error: `The password provided failed to match the following rules:</span><br><span class=\"line\">              &lt;br&gt;</span><br><span class=\"line\">              1. It must contain ONLY the following characters: lower case, upper case, numerics.</span><br><span class=\"line\">              &lt;br&gt;</span><br><span class=\"line\">              2. It must be at least 8 characters in length and not greater than 32 characters in length.</span><br><span class=\"line\">            `</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          break</span><br><span class=\"line\">        default:</span><br><span class=\"line\">          res.status(400).send(&#123;</span><br><span class=\"line\">            error: &apos;Invalid registration information&apos;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>新建controllers/AuthenticationController.js</code>:用于在数据库表中创建注册数据逻辑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;User&#125; = require(&apos;../models&apos;)</span><br><span class=\"line\">const jwt = require(&apos;jsonwebtoken&apos;)</span><br><span class=\"line\">const config = require(&apos;../config/config&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">function jwtSignUser (user) &#123;</span><br><span class=\"line\">  const ONE_WEEK = 60 * 60 * 24 * 7</span><br><span class=\"line\">  return jwt.sign(user, config.authentication.jwtSecret, &#123;</span><br><span class=\"line\">    expiresIn: ONE_WEEK</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  async register (req, res) &#123;</span><br><span class=\"line\">    console.log(14, req.body)</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      const user = await User.create(req.body)</span><br><span class=\"line\">      console.log(user)</span><br><span class=\"line\">      const userJson = user.toJSON()</span><br><span class=\"line\">      res.send(&#123;</span><br><span class=\"line\">        user: userJson,</span><br><span class=\"line\">        token: jwtSignUser(userJson)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; catch (err) &#123;</span><br><span class=\"line\">      res.status(400).send(&#123;</span><br><span class=\"line\">        error: &apos;This email account is already in use.&apos;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、-接口测试\"><a href=\"#三、-接口测试\" class=\"headerlink\" title=\"三、 接口测试\"></a>三、 接口测试</h2><hr>\n<blockquote>\n<p>此处推荐一款接口测试工具！<code>POSTMAN</code>！ 简单来说，四个词，简单实用大方美观！</p>\n</blockquote>\n<ul>\n<li>打开<code>postman</code><br>用post方法请求接口，可以看到下面可以成功的返回message<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c7be54c38a8b1669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n</ul>\n<p>按照相关提示进行 注册数据，即可</p>\n<p><code>打开数据库可视化工具：</code><br>可以看到在table表中有一个名为user的数据表,在user表中可以看到数据创建成功:<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-bb8daab7b371cb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>我们的注册接口就成功啦！</p>\n<p>大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<p>在上一篇的基础上，继续升级!</p>\n<p><a href=\"https://www.jianshu.com/p/02085294b6ed\" target=\"_blank\" rel=\"noopener\">NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete</a></p>\n<h2 id=\"一、安装依赖\"><a href=\"#一、安装依赖\" class=\"headerlink\" title=\"一、安装依赖\"></a>一、安装依赖</h2><hr>\n<ul>\n<li><p>安装<code>mysql2</code>+<code>sequelize</code> +  <code>jsonwebtoken</code> + <code>joi</code></p>\n</li>\n<li><p><code>sequelize</code><br><code>sequelize.js</code> 提供对 <a href=\"http://www.oschina.net/p/mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a>，<a href=\"http://www.oschina.net/p/mariadb\" target=\"_blank\" rel=\"noopener\">MariaDB</a>，<a href=\"http://www.oschina.net/p/sqlite\" target=\"_blank\" rel=\"noopener\">SQLite</a> 和 <a href=\"http://www.oschina.net/p/postgresql\" target=\"_blank\" rel=\"noopener\">PostgreSQL</a> 数据库的简单访问，通过映射数据库条目到对象，或者对象到数据库条目。简而言之，就是 ORM（Object-Relational-Mapper）。Sequelize.js 完全是使用 JavaScript 编写，适用于 Node.js 的环境。<br>参考链接：</p>\n</li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1101571555324224\" target=\"_blank\" rel=\"noopener\">使用Sequelize</a></li>\n<li><a href=\"https://sequelize.org/\" target=\"_blank\" rel=\"noopener\">sequelize</a></li>\n<li><a href=\"https://github.com/caiya/node-sequelize/tree/master/bin\" target=\"_blank\" rel=\"noopener\">https://github.com/caiya/node-sequelize/tree/master/bin</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install --save sequelize mysql2 joi jsonwebtoken</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二、添加-修改配置文件\"><a href=\"#二、添加-修改配置文件\" class=\"headerlink\" title=\"二、添加+修改配置文件\"></a>二、添加+修改配置文件</h2><hr>\n<p><code>修改app.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// app.js</span><br><span class=\"line\">var indexRouter = require(&apos;./routes/index&apos;);</span><br><span class=\"line\">// var usersRouter = require(&apos;./routes/users&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(&apos;/&apos;, indexRouter);</span><br><span class=\"line\">// app.use(&apos;/users&apos;, usersRouter);</span><br></pre></td></tr></table></figure></p>\n<p><code>修改bin/www</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;sequelize&#125; = require(&apos;../models&apos;)</span><br><span class=\"line\">sequelize.sync(&#123;force: false&#125;)</span><br><span class=\"line\">  .then(() =&gt; &#123;</span><br><span class=\"line\">    server.listen(port);</span><br><span class=\"line\">    console.log(`Server started on port $&#123;config.port&#125;`)</span><br><span class=\"line\">  &#125;).catch(function (err) &#123;</span><br><span class=\"line\">    console.log(&apos;failed: &apos; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// server.listen(port);</span><br></pre></td></tr></table></figure></p>\n<p><code>新建models/index.js + models/user.js</code>:配置各种数据库模型类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//models/index.js</span><br><span class=\"line\">const fs = require(&apos;fs&apos;)</span><br><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">const Sequelize = require(&apos;sequelize&apos;)</span><br><span class=\"line\">const config = require(&apos;../config/config&apos;)</span><br><span class=\"line\">const db = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const sequelize = new Sequelize(config.database, config.username, config.password, &#123;</span><br><span class=\"line\">  host: config.host,</span><br><span class=\"line\">  dialect: &apos;mysql&apos;,</span><br><span class=\"line\">  pool: &#123;</span><br><span class=\"line\">      max: 5,</span><br><span class=\"line\">      min: 0,</span><br><span class=\"line\">      idle: 30000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fs</span><br><span class=\"line\">  .readdirSync(__dirname)</span><br><span class=\"line\">  .filter((file) =&gt;</span><br><span class=\"line\">    file !== &apos;index.js&apos;</span><br><span class=\"line\">  )</span><br><span class=\"line\">  .forEach((file) =&gt; &#123;</span><br><span class=\"line\">    const model = sequelize.import(path.join(__dirname, file))</span><br><span class=\"line\">    db[model.name] = model</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.keys(db).forEach(function (modelName) &#123;</span><br><span class=\"line\">  if (&apos;associate&apos; in db[modelName]) &#123;</span><br><span class=\"line\">    db[modelName].associate(db)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.sequelize = sequelize</span><br><span class=\"line\">db.Sequelize = Sequelize</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = db</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//models/user.js</span><br><span class=\"line\">const Promise = require(&apos;bluebird&apos;)</span><br><span class=\"line\">const bcrypt = Promise.promisifyAll(require(&apos;bcrypt&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">// function hashPassword (user, options) &#123;</span><br><span class=\"line\">//   const SALT_FACTOR = 8</span><br><span class=\"line\"></span><br><span class=\"line\">//   if (!user.changed(&apos;password&apos;)) &#123;</span><br><span class=\"line\">//     return</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//   return bcrypt</span><br><span class=\"line\">//     .genSaltAsync(SALT_FACTOR)</span><br><span class=\"line\">//     .then(salt =&gt; bcrypt.hashAsync(user.password, salt, null))</span><br><span class=\"line\">//     .then(hash =&gt; &#123;</span><br><span class=\"line\">//       user.setDataValue(&apos;password&apos;, hash)</span><br><span class=\"line\">//     &#125;)</span><br><span class=\"line\">// &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = (sequelize, DataTypes) =&gt; &#123;</span><br><span class=\"line\">  const User = sequelize.define(&apos;User&apos;, &#123;</span><br><span class=\"line\">    email: &#123;</span><br><span class=\"line\">      type: DataTypes.STRING,</span><br><span class=\"line\">      unique: true</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    password: DataTypes.STRING</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">// &#123;</span><br><span class=\"line\">//     hooks: &#123;</span><br><span class=\"line\">//       beforeCreate: hashPassword,</span><br><span class=\"line\">//       beforeUpdate: hashPassword,</span><br><span class=\"line\">//       beforeSave: hashPassword</span><br><span class=\"line\">//     &#125;</span><br><span class=\"line\">//   &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">  User.prototype.comparePassword = function (password) &#123;</span><br><span class=\"line\">    return bcrypt.compareAsync(password, this.password)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  User.associate = function (models) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return User</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>新建config/config.js</code>:数据库相关配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var config = &#123;</span><br><span class=\"line\">  host     : &apos;localhost&apos;, // 主机名</span><br><span class=\"line\">  username : &apos;root&apos;, // 用户名</span><br><span class=\"line\">  password : &apos;1234567w&apos;, // 口令</span><br><span class=\"line\">  database : &apos;nodemysql&apos;, // 使用哪个数据库</span><br><span class=\"line\">  port: 3000, // 端口号，MySQL默认3306</span><br><span class=\"line\">  authentication: &#123;</span><br><span class=\"line\">    jwtSecret: process.env.JWT_SECRET || &apos;secret&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports = config;</span><br></pre></td></tr></table></figure>\n<p><code>修改router/index.js</code>:添加注册接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// // index.js</span><br><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const router = express.Router();</span><br><span class=\"line\">const AuthenticationControllerPolicy = require(&apos;../policies/AuthenticationControllerPolicy&apos;)</span><br><span class=\"line\">const AuthenticationController = require(&apos;../controllers/AuthenticationController&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">router.post(&apos;/register&apos;,</span><br><span class=\"line\">    AuthenticationControllerPolicy.register,</span><br><span class=\"line\">    AuthenticationController.register)</span><br><span class=\"line\">/* GET home page. */</span><br><span class=\"line\">router.post(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">  res.render(&apos;index&apos;, &#123; title: &apos;Express&apos; &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">module.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p><code>新建policies/AuthenticationControllerPolicy.js</code>:用于校验注册逻辑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Joi = require(&apos;joi&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  register (req, res, next) &#123;</span><br><span class=\"line\">    const schema = &#123;</span><br><span class=\"line\">      email: Joi.string().email(),</span><br><span class=\"line\">      password: Joi.string().regex(</span><br><span class=\"line\">        new RegExp(&apos;^[a-zA-Z0-9]&#123;8,32&#125;$&apos;)</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const &#123;error&#125; = Joi.validate(req.body, schema)</span><br><span class=\"line\">    if (error) &#123;</span><br><span class=\"line\">      switch (error.details[0].context.key) &#123;</span><br><span class=\"line\">        case &apos;email&apos;:</span><br><span class=\"line\">          res.status(400).send(&#123;</span><br><span class=\"line\">            error: &apos;You must provide a valid email address&apos;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          break</span><br><span class=\"line\">        case &apos;password&apos;:</span><br><span class=\"line\">          res.status(400).send(&#123;</span><br><span class=\"line\">            error: `The password provided failed to match the following rules:</span><br><span class=\"line\">              &lt;br&gt;</span><br><span class=\"line\">              1. It must contain ONLY the following characters: lower case, upper case, numerics.</span><br><span class=\"line\">              &lt;br&gt;</span><br><span class=\"line\">              2. It must be at least 8 characters in length and not greater than 32 characters in length.</span><br><span class=\"line\">            `</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          break</span><br><span class=\"line\">        default:</span><br><span class=\"line\">          res.status(400).send(&#123;</span><br><span class=\"line\">            error: &apos;Invalid registration information&apos;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      next()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>新建controllers/AuthenticationController.js</code>:用于在数据库表中创建注册数据逻辑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;User&#125; = require(&apos;../models&apos;)</span><br><span class=\"line\">const jwt = require(&apos;jsonwebtoken&apos;)</span><br><span class=\"line\">const config = require(&apos;../config/config&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">function jwtSignUser (user) &#123;</span><br><span class=\"line\">  const ONE_WEEK = 60 * 60 * 24 * 7</span><br><span class=\"line\">  return jwt.sign(user, config.authentication.jwtSecret, &#123;</span><br><span class=\"line\">    expiresIn: ONE_WEEK</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  async register (req, res) &#123;</span><br><span class=\"line\">    console.log(14, req.body)</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      const user = await User.create(req.body)</span><br><span class=\"line\">      console.log(user)</span><br><span class=\"line\">      const userJson = user.toJSON()</span><br><span class=\"line\">      res.send(&#123;</span><br><span class=\"line\">        user: userJson,</span><br><span class=\"line\">        token: jwtSignUser(userJson)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; catch (err) &#123;</span><br><span class=\"line\">      res.status(400).send(&#123;</span><br><span class=\"line\">        error: &apos;This email account is already in use.&apos;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、-接口测试\"><a href=\"#三、-接口测试\" class=\"headerlink\" title=\"三、 接口测试\"></a>三、 接口测试</h2><hr>\n<blockquote>\n<p>此处推荐一款接口测试工具！<code>POSTMAN</code>！ 简单来说，四个词，简单实用大方美观！</p>\n</blockquote>\n<ul>\n<li>打开<code>postman</code><br>用post方法请求接口，可以看到下面可以成功的返回message<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c7be54c38a8b1669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n</ul>\n<p>按照相关提示进行 注册数据，即可</p>\n<p><code>打开数据库可视化工具：</code><br>可以看到在table表中有一个名为user的数据表,在user表中可以看到数据创建成功:<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-bb8daab7b371cb5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>我们的注册接口就成功啦！</p>\n<p>大功告成✌️✌️✌️</p>\n"},{"title":"NO1:使用 Node.js + Express 开发服务端","date":"2020-07-27T09:13:28.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 一、 准备工作\n---\n#### 1.安装Express\n```\n$ npm install express -g\n$ npm install express-generator -g\n```\n\n#### 2.初始化项目\n```\n$ cd /Users/SPRINT/Desktop 进入桌面\n$ express 项目名称\n```\n项目名称我们指定为APIServer，从项目名称可以看出 我们是模拟服务器API\n在这里我们将提供一个获取用户详情接口 并输出JSON数据。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f958d66e6ce428e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在终端最后位置 看到输出两个命令\n\n```\ninstall dependencies:\n   $ cd APIServer && npm install //告诉我们进入项目根目录 执行npm install安装依赖模块\n\nrun the app:\n   $ DEBUG=APIServer:* npm start //告诉我们启动服务器\n```\n\n执行如下命令：\n```\n$ cd APIServer //进入项目根目录\n$ npm install  //安装依赖\n```\n回到项目中，会看到一个APIServer目录\n> bin: 用来启动应用（服务器）\n >public: 存放静态资源目录\n >outes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。\n>views: 模板文件所在目录 文件格式为.jade\n目录app.js程序main文件 这个是服务器启动的入口\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5d35fab3915217e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 二、 启动服务器\n---\n首先启动服务器\n```\n$ npm start\n```\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9bac37c86b235821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在浏览器中访问 [http://localhost:3000/](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F)\n## 三、 基本使用\n---\n打开`app.js` 这里介绍下主要代码\n```\n  var express = require('express');\n  var path = require('path');\n  var favicon = require('serve-favicon');\n  var logger = require('morgan');\n  var cookieParser = require('cookie-parser');\n  var bodyParser = require('body-parser');\n\n  var app = express();\n\n\n///=======路由信息 （接口地址）开始 存放在./routes目录下===========//\n  var routes = require('./routes/index');//home page接口\n  var users = require('./routes/users'); //用户接口\n\n  app.use('/', routes); //在app中注册routes该接口 \n  app.use('/users', users);//在app中注册users接口\n///=======路由信息 （接口地址 介绍===========//\n\n\n\n///=======模板 开始===========//\n// view engine setup\n  app.set('views', path.join(__dirname, 'views'));\n  app.set('view engine', 'jade');\n///=======模板 结束===========//\n```\n当我们在浏览器中 访问 [http://localhost:3000/](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F) 调用的就是index中的接口\n我们打开index.js就可以看到该接口的定义：\n```\nvar express = require('express');\nvar router = express.Router();\n\n\n//定义一个get请求 path为根目录\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n    res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n定义一个路由的基本格式为：\n\n```\napp.METHOD(PATH, HANDLER)\n\n```\n\n其中：\n> app 是 express 的实例。\n> METHOD是 [HTTP 请求方法](https://links.jianshu.com/go?to=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHypertext_Transfer_Protocol)。\nPATH 是服务器上的路径。\nHANDLER 是在路由匹配时执行的函数。\n以上的定义代表\n在根路由 (/) 上（应用程序的主页）对 GET 请求进行响应：\n\n是不是明白了？\n\n如果我们想要实现一个获取用户信息接口该怎么写呢？\n新建`routes\\user.js`文件\n定义一个User模型\n\n```\nfunction User() {\n      this.name;\n      this.city;\n      this.age;\n}\nmodule.exports = User;\n\n```\n修改`users.js`文件\n```\nvar express = require('express');\nvar router = express.Router();\nvar URL = require('url');  \nvar User = require('./user');\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nrouter.get('/getUserInfo', function(req, res, next) {\n\n  var user = new User();\n// 获取url参数 依赖于url模块 使用前需要使用  require('url')\n  var params = URL.parse(req.url, true).query;\n\nif(params.id == '1') {\n\n  user.name = \"ligh\";\n  user.age = \"1\";\n  user.city = \"北京市\";\n\n}else{  \n  user.name = \"SPTING\";\n  user.age = \"1\";\n  user.city = \"杭州市\";\n}\n\nvar response = {status:1,data:user};\nres.send(JSON.stringify(response));\n\n});\nmodule.exports = router;\n\n```\n\n由于users.js路由信息已经在app.js注册\n停止服务器 重新start服务器即可直接访问\n```\n$ npm start\n```\n\n调用方式`http://localhost:3000/users/getUserInfo?id=1`\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2fef11908aa7525f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n大功告成✌️✌️✌️\n\n你可能需要：[NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete](https://www.jianshu.com/p/02085294b6ed)\n","source":"_posts/Node1.md","raw":"---\ntitle: NO1:使用 Node.js + Express 开发服务端\ndate: 2020-07-27 17:13:28\ntags: Node\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 一、 准备工作\n---\n#### 1.安装Express\n```\n$ npm install express -g\n$ npm install express-generator -g\n```\n\n#### 2.初始化项目\n```\n$ cd /Users/SPRINT/Desktop 进入桌面\n$ express 项目名称\n```\n项目名称我们指定为APIServer，从项目名称可以看出 我们是模拟服务器API\n在这里我们将提供一个获取用户详情接口 并输出JSON数据。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f958d66e6ce428e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在终端最后位置 看到输出两个命令\n\n```\ninstall dependencies:\n   $ cd APIServer && npm install //告诉我们进入项目根目录 执行npm install安装依赖模块\n\nrun the app:\n   $ DEBUG=APIServer:* npm start //告诉我们启动服务器\n```\n\n执行如下命令：\n```\n$ cd APIServer //进入项目根目录\n$ npm install  //安装依赖\n```\n回到项目中，会看到一个APIServer目录\n> bin: 用来启动应用（服务器）\n >public: 存放静态资源目录\n >outes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。\n>views: 模板文件所在目录 文件格式为.jade\n目录app.js程序main文件 这个是服务器启动的入口\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5d35fab3915217e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 二、 启动服务器\n---\n首先启动服务器\n```\n$ npm start\n```\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9bac37c86b235821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n在浏览器中访问 [http://localhost:3000/](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F)\n## 三、 基本使用\n---\n打开`app.js` 这里介绍下主要代码\n```\n  var express = require('express');\n  var path = require('path');\n  var favicon = require('serve-favicon');\n  var logger = require('morgan');\n  var cookieParser = require('cookie-parser');\n  var bodyParser = require('body-parser');\n\n  var app = express();\n\n\n///=======路由信息 （接口地址）开始 存放在./routes目录下===========//\n  var routes = require('./routes/index');//home page接口\n  var users = require('./routes/users'); //用户接口\n\n  app.use('/', routes); //在app中注册routes该接口 \n  app.use('/users', users);//在app中注册users接口\n///=======路由信息 （接口地址 介绍===========//\n\n\n\n///=======模板 开始===========//\n// view engine setup\n  app.set('views', path.join(__dirname, 'views'));\n  app.set('view engine', 'jade');\n///=======模板 结束===========//\n```\n当我们在浏览器中 访问 [http://localhost:3000/](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F) 调用的就是index中的接口\n我们打开index.js就可以看到该接口的定义：\n```\nvar express = require('express');\nvar router = express.Router();\n\n\n//定义一个get请求 path为根目录\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n    res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n定义一个路由的基本格式为：\n\n```\napp.METHOD(PATH, HANDLER)\n\n```\n\n其中：\n> app 是 express 的实例。\n> METHOD是 [HTTP 请求方法](https://links.jianshu.com/go?to=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHypertext_Transfer_Protocol)。\nPATH 是服务器上的路径。\nHANDLER 是在路由匹配时执行的函数。\n以上的定义代表\n在根路由 (/) 上（应用程序的主页）对 GET 请求进行响应：\n\n是不是明白了？\n\n如果我们想要实现一个获取用户信息接口该怎么写呢？\n新建`routes\\user.js`文件\n定义一个User模型\n\n```\nfunction User() {\n      this.name;\n      this.city;\n      this.age;\n}\nmodule.exports = User;\n\n```\n修改`users.js`文件\n```\nvar express = require('express');\nvar router = express.Router();\nvar URL = require('url');  \nvar User = require('./user');\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nrouter.get('/getUserInfo', function(req, res, next) {\n\n  var user = new User();\n// 获取url参数 依赖于url模块 使用前需要使用  require('url')\n  var params = URL.parse(req.url, true).query;\n\nif(params.id == '1') {\n\n  user.name = \"ligh\";\n  user.age = \"1\";\n  user.city = \"北京市\";\n\n}else{  \n  user.name = \"SPTING\";\n  user.age = \"1\";\n  user.city = \"杭州市\";\n}\n\nvar response = {status:1,data:user};\nres.send(JSON.stringify(response));\n\n});\nmodule.exports = router;\n\n```\n\n由于users.js路由信息已经在app.js注册\n停止服务器 重新start服务器即可直接访问\n```\n$ npm start\n```\n\n调用方式`http://localhost:3000/users/getUserInfo?id=1`\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2fef11908aa7525f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n大功告成✌️✌️✌️\n\n你可能需要：[NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete](https://www.jianshu.com/p/02085294b6ed)\n","slug":"Node1","published":1,"updated":"2020-12-14T10:26:16.124Z","_id":"ckioehjqt000u78p3n97a2qvs","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h2 id=\"一、-准备工作\"><a href=\"#一、-准备工作\" class=\"headerlink\" title=\"一、 准备工作\"></a>一、 准备工作</h2><hr>\n<h4 id=\"1-安装Express\"><a href=\"#1-安装Express\" class=\"headerlink\" title=\"1.安装Express\"></a>1.安装Express</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express -g</span><br><span class=\"line\">$ npm install express-generator -g</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2.初始化项目\"></a>2.初始化项目</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd /Users/SPRINT/Desktop 进入桌面</span><br><span class=\"line\">$ express 项目名称</span><br></pre></td></tr></table></figure>\n<p>项目名称我们指定为APIServer，从项目名称可以看出 我们是模拟服务器API<br>在这里我们将提供一个获取用户详情接口 并输出JSON数据。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f958d66e6ce428e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>在终端最后位置 看到输出两个命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">install dependencies:</span><br><span class=\"line\">   $ cd APIServer &amp;&amp; npm install //告诉我们进入项目根目录 执行npm install安装依赖模块</span><br><span class=\"line\"></span><br><span class=\"line\">run the app:</span><br><span class=\"line\">   $ DEBUG=APIServer:* npm start //告诉我们启动服务器</span><br></pre></td></tr></table></figure>\n<p>执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd APIServer //进入项目根目录</span><br><span class=\"line\">$ npm install  //安装依赖</span><br></pre></td></tr></table></figure></p>\n<p>回到项目中，会看到一个APIServer目录</p>\n<blockquote>\n<p>bin: 用来启动应用（服务器）<br>public: 存放静态资源目录<br>outes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。<br>views: 模板文件所在目录 文件格式为.jade<br>目录app.js程序main文件 这个是服务器启动的入口</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5d35fab3915217e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"二、-启动服务器\"><a href=\"#二、-启动服务器\" class=\"headerlink\" title=\"二、 启动服务器\"></a>二、 启动服务器</h2><hr>\n<p>首先启动服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bac37c86b235821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>在浏览器中访问 <a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a></p>\n<h2 id=\"三、-基本使用\"><a href=\"#三、-基本使用\" class=\"headerlink\" title=\"三、 基本使用\"></a>三、 基本使用</h2><hr>\n<p>打开<code>app.js</code> 这里介绍下主要代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  var express = require(&apos;express&apos;);</span><br><span class=\"line\">  var path = require(&apos;path&apos;);</span><br><span class=\"line\">  var favicon = require(&apos;serve-favicon&apos;);</span><br><span class=\"line\">  var logger = require(&apos;morgan&apos;);</span><br><span class=\"line\">  var cookieParser = require(&apos;cookie-parser&apos;);</span><br><span class=\"line\">  var bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">///=======路由信息 （接口地址）开始 存放在./routes目录下===========//</span><br><span class=\"line\">  var routes = require(&apos;./routes/index&apos;);//home page接口</span><br><span class=\"line\">  var users = require(&apos;./routes/users&apos;); //用户接口</span><br><span class=\"line\"></span><br><span class=\"line\">  app.use(&apos;/&apos;, routes); //在app中注册routes该接口 </span><br><span class=\"line\">  app.use(&apos;/users&apos;, users);//在app中注册users接口</span><br><span class=\"line\">///=======路由信息 （接口地址 介绍===========//</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">///=======模板 开始===========//</span><br><span class=\"line\">// view engine setup</span><br><span class=\"line\">  app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));</span><br><span class=\"line\">  app.set(&apos;view engine&apos;, &apos;jade&apos;);</span><br><span class=\"line\">///=======模板 结束===========//</span><br></pre></td></tr></table></figure></p>\n<p>当我们在浏览器中 访问 <a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a> 调用的就是index中的接口<br>我们打开index.js就可以看到该接口的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//定义一个get请求 path为根目录</span><br><span class=\"line\">/* GET home page. */</span><br><span class=\"line\">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">    res.render(&apos;index&apos;, &#123; title: &apos;Express&apos; &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>定义一个路由的基本格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<blockquote>\n<p>app 是 express 的实例。<br>METHOD是 <a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHypertext_Transfer_Protocol\" target=\"_blank\" rel=\"noopener\">HTTP 请求方法</a>。<br>PATH 是服务器上的路径。<br>HANDLER 是在路由匹配时执行的函数。<br>以上的定义代表<br>在根路由 (/) 上（应用程序的主页）对 GET 请求进行响应：</p>\n</blockquote>\n<p>是不是明白了？</p>\n<p>如果我们想要实现一个获取用户信息接口该怎么写呢？<br>新建<code>routes\\user.js</code>文件<br>定义一个User模型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function User() &#123;</span><br><span class=\"line\">      this.name;</span><br><span class=\"line\">      this.city;</span><br><span class=\"line\">      this.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = User;</span><br></pre></td></tr></table></figure>\n<p>修改<code>users.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\">var URL = require(&apos;url&apos;);  </span><br><span class=\"line\">var User = require(&apos;./user&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">/* GET users listing. */</span><br><span class=\"line\">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">  res.send(&apos;respond with a resource&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(&apos;/getUserInfo&apos;, function(req, res, next) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var user = new User();</span><br><span class=\"line\">// 获取url参数 依赖于url模块 使用前需要使用  require(&apos;url&apos;)</span><br><span class=\"line\">  var params = URL.parse(req.url, true).query;</span><br><span class=\"line\"></span><br><span class=\"line\">if(params.id == &apos;1&apos;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  user.name = &quot;ligh&quot;;</span><br><span class=\"line\">  user.age = &quot;1&quot;;</span><br><span class=\"line\">  user.city = &quot;北京市&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;else&#123;  </span><br><span class=\"line\">  user.name = &quot;SPTING&quot;;</span><br><span class=\"line\">  user.age = &quot;1&quot;;</span><br><span class=\"line\">  user.city = &quot;杭州市&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var response = &#123;status:1,data:user&#125;;</span><br><span class=\"line\">res.send(JSON.stringify(response));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">module.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>由于users.js路由信息已经在app.js注册<br>停止服务器 重新start服务器即可直接访问<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p>调用方式<code>http://localhost:3000/users/getUserInfo?id=1</code><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2fef11908aa7525f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>大功告成✌️✌️✌️</p>\n<p>你可能需要：<a href=\"https://www.jianshu.com/p/02085294b6ed\" target=\"_blank\" rel=\"noopener\">NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete</a></p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h2 id=\"一、-准备工作\"><a href=\"#一、-准备工作\" class=\"headerlink\" title=\"一、 准备工作\"></a>一、 准备工作</h2><hr>\n<h4 id=\"1-安装Express\"><a href=\"#1-安装Express\" class=\"headerlink\" title=\"1.安装Express\"></a>1.安装Express</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express -g</span><br><span class=\"line\">$ npm install express-generator -g</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-初始化项目\"><a href=\"#2-初始化项目\" class=\"headerlink\" title=\"2.初始化项目\"></a>2.初始化项目</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd /Users/SPRINT/Desktop 进入桌面</span><br><span class=\"line\">$ express 项目名称</span><br></pre></td></tr></table></figure>\n<p>项目名称我们指定为APIServer，从项目名称可以看出 我们是模拟服务器API<br>在这里我们将提供一个获取用户详情接口 并输出JSON数据。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f958d66e6ce428e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>在终端最后位置 看到输出两个命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">install dependencies:</span><br><span class=\"line\">   $ cd APIServer &amp;&amp; npm install //告诉我们进入项目根目录 执行npm install安装依赖模块</span><br><span class=\"line\"></span><br><span class=\"line\">run the app:</span><br><span class=\"line\">   $ DEBUG=APIServer:* npm start //告诉我们启动服务器</span><br></pre></td></tr></table></figure>\n<p>执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd APIServer //进入项目根目录</span><br><span class=\"line\">$ npm install  //安装依赖</span><br></pre></td></tr></table></figure></p>\n<p>回到项目中，会看到一个APIServer目录</p>\n<blockquote>\n<p>bin: 用来启动应用（服务器）<br>public: 存放静态资源目录<br>outes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。<br>views: 模板文件所在目录 文件格式为.jade<br>目录app.js程序main文件 这个是服务器启动的入口</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5d35fab3915217e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"二、-启动服务器\"><a href=\"#二、-启动服务器\" class=\"headerlink\" title=\"二、 启动服务器\"></a>二、 启动服务器</h2><hr>\n<p>首先启动服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bac37c86b235821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>在浏览器中访问 <a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a></p>\n<h2 id=\"三、-基本使用\"><a href=\"#三、-基本使用\" class=\"headerlink\" title=\"三、 基本使用\"></a>三、 基本使用</h2><hr>\n<p>打开<code>app.js</code> 这里介绍下主要代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  var express = require(&apos;express&apos;);</span><br><span class=\"line\">  var path = require(&apos;path&apos;);</span><br><span class=\"line\">  var favicon = require(&apos;serve-favicon&apos;);</span><br><span class=\"line\">  var logger = require(&apos;morgan&apos;);</span><br><span class=\"line\">  var cookieParser = require(&apos;cookie-parser&apos;);</span><br><span class=\"line\">  var bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">  var app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">///=======路由信息 （接口地址）开始 存放在./routes目录下===========//</span><br><span class=\"line\">  var routes = require(&apos;./routes/index&apos;);//home page接口</span><br><span class=\"line\">  var users = require(&apos;./routes/users&apos;); //用户接口</span><br><span class=\"line\"></span><br><span class=\"line\">  app.use(&apos;/&apos;, routes); //在app中注册routes该接口 </span><br><span class=\"line\">  app.use(&apos;/users&apos;, users);//在app中注册users接口</span><br><span class=\"line\">///=======路由信息 （接口地址 介绍===========//</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">///=======模板 开始===========//</span><br><span class=\"line\">// view engine setup</span><br><span class=\"line\">  app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));</span><br><span class=\"line\">  app.set(&apos;view engine&apos;, &apos;jade&apos;);</span><br><span class=\"line\">///=======模板 结束===========//</span><br></pre></td></tr></table></figure></p>\n<p>当我们在浏览器中 访问 <a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A3000%2F\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/</a> 调用的就是index中的接口<br>我们打开index.js就可以看到该接口的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//定义一个get请求 path为根目录</span><br><span class=\"line\">/* GET home page. */</span><br><span class=\"line\">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">    res.render(&apos;index&apos;, &#123; title: &apos;Express&apos; &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>定义一个路由的基本格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.METHOD(PATH, HANDLER)</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<blockquote>\n<p>app 是 express 的实例。<br>METHOD是 <a href=\"https://links.jianshu.com/go?to=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHypertext_Transfer_Protocol\" target=\"_blank\" rel=\"noopener\">HTTP 请求方法</a>。<br>PATH 是服务器上的路径。<br>HANDLER 是在路由匹配时执行的函数。<br>以上的定义代表<br>在根路由 (/) 上（应用程序的主页）对 GET 请求进行响应：</p>\n</blockquote>\n<p>是不是明白了？</p>\n<p>如果我们想要实现一个获取用户信息接口该怎么写呢？<br>新建<code>routes\\user.js</code>文件<br>定义一个User模型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function User() &#123;</span><br><span class=\"line\">      this.name;</span><br><span class=\"line\">      this.city;</span><br><span class=\"line\">      this.age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = User;</span><br></pre></td></tr></table></figure>\n<p>修改<code>users.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);</span><br><span class=\"line\">var router = express.Router();</span><br><span class=\"line\">var URL = require(&apos;url&apos;);  </span><br><span class=\"line\">var User = require(&apos;./user&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">/* GET users listing. */</span><br><span class=\"line\">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class=\"line\">  res.send(&apos;respond with a resource&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">router.get(&apos;/getUserInfo&apos;, function(req, res, next) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  var user = new User();</span><br><span class=\"line\">// 获取url参数 依赖于url模块 使用前需要使用  require(&apos;url&apos;)</span><br><span class=\"line\">  var params = URL.parse(req.url, true).query;</span><br><span class=\"line\"></span><br><span class=\"line\">if(params.id == &apos;1&apos;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  user.name = &quot;ligh&quot;;</span><br><span class=\"line\">  user.age = &quot;1&quot;;</span><br><span class=\"line\">  user.city = &quot;北京市&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;else&#123;  </span><br><span class=\"line\">  user.name = &quot;SPTING&quot;;</span><br><span class=\"line\">  user.age = &quot;1&quot;;</span><br><span class=\"line\">  user.city = &quot;杭州市&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var response = &#123;status:1,data:user&#125;;</span><br><span class=\"line\">res.send(JSON.stringify(response));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">module.exports = router;</span><br></pre></td></tr></table></figure></p>\n<p>由于users.js路由信息已经在app.js注册<br>停止服务器 重新start服务器即可直接访问<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p>调用方式<code>http://localhost:3000/users/getUserInfo?id=1</code><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2fef11908aa7525f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>大功告成✌️✌️✌️</p>\n<p>你可能需要：<a href=\"https://www.jianshu.com/p/02085294b6ed\" target=\"_blank\" rel=\"noopener\">NO2:Node JS + MySQL CRUD Workshop : Insert, Update, Select, Delete</a></p>\n"},{"title":"ReactFragment用法介绍","date":"2020-07-27T09:55:39.000Z","_content":"\nreact中一个常见模式是一个组件返回多个元素，`Fragments`允许你将子列表分组，而无需像DOM添加额外的节点。\n```\nrender() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n```\n一个常见模式是为一个组件返回一个子元素列表。以这个示例的 React 片段为例：\n```\nclass Table extends React.Component {\n  render() {\n    return (\n      <table>\n        <tr>\n          <Columns />\n        </tr>\n      </table>\n    );\n  }\n}\n```\n为了渲染有效的 HTML ， `Columns`需要返回多个`td`元素。如果一个父` div` 在 `Columns` 的 `render()` 函数里面使用，那么最终的 HTML 将是无效的。\n```\nclass Columns extends React.Component {\n  render() {\n    return (\n      <div>\n        <td>Hello</td>\n        <td>World</td>\n      </div>\n    );\n  }\n}\n```\n在`Table` 组件中的输出结果如下：\n```\n<table>\n  <tr>\n    <div>\n      <td>Hello</td>\n      <td>World</td>\n    </div>\n  </tr>\n</table>\n```\n所以，我们介绍 Fragments。\n```\nclass Columns extends React.Component {\n  render() {\n    return (\n      <React.Fragment>\n        <td>Hello</td>\n        <td>World</td>\n      </React.Fragment>\n    );\n  }\n}\n```\n在正确的`Table`组件中，这个结果输出如下：\n```\n<table>\n  <tr>\n    <td>Hello</td>\n    <td>World</td>\n  </tr>\n</table>\n```\n如果子元素需要父元素包裹起来，但是不需要渲染父元素，我们就可以使用`fragment`。其实它的功能和vue的template一样，都只是占位，不渲染。\n\n我们也可以把`<React.Fragment></React.Fragment>`简写为`<></>`,看着像空组件；\n\n`<></>` 是 `<React.Fragment/>` 的语法糖。\n`<></>` 语法不能接受键值或属性。\n\n如果你需要一个带 key 的片段，你可以直接使用 `<React.Fragment /> 。\n一个使用场景是映射一个集合为一个片段数组 — 例如：创建一个描述列表：\n```\nfunction Glossary(props) {\n  return (\n    <dl>\n      {props.items.map(item => (\n        // 没有`key`，将会触发一个key警告\n        <React.Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.description}</dd>\n        </React.Fragment>\n      ))}\n    </dl>\n  );\n}\n```\nkey 是唯一可以传递给 `Fragment` 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。\n\n大功告成✌️✌️✌️\n\n参考链接：https://www.jianshu.com/p/36bb4d88f26c","source":"_posts/ReactFragment.md","raw":"---\ntitle: ReactFragment用法介绍\ndate: 2020-07-27 17:55:39\ntags: React\n---\n\nreact中一个常见模式是一个组件返回多个元素，`Fragments`允许你将子列表分组，而无需像DOM添加额外的节点。\n```\nrender() {\n  return (\n    <React.Fragment>\n      <ChildA />\n      <ChildB />\n      <ChildC />\n    </React.Fragment>\n  );\n}\n```\n一个常见模式是为一个组件返回一个子元素列表。以这个示例的 React 片段为例：\n```\nclass Table extends React.Component {\n  render() {\n    return (\n      <table>\n        <tr>\n          <Columns />\n        </tr>\n      </table>\n    );\n  }\n}\n```\n为了渲染有效的 HTML ， `Columns`需要返回多个`td`元素。如果一个父` div` 在 `Columns` 的 `render()` 函数里面使用，那么最终的 HTML 将是无效的。\n```\nclass Columns extends React.Component {\n  render() {\n    return (\n      <div>\n        <td>Hello</td>\n        <td>World</td>\n      </div>\n    );\n  }\n}\n```\n在`Table` 组件中的输出结果如下：\n```\n<table>\n  <tr>\n    <div>\n      <td>Hello</td>\n      <td>World</td>\n    </div>\n  </tr>\n</table>\n```\n所以，我们介绍 Fragments。\n```\nclass Columns extends React.Component {\n  render() {\n    return (\n      <React.Fragment>\n        <td>Hello</td>\n        <td>World</td>\n      </React.Fragment>\n    );\n  }\n}\n```\n在正确的`Table`组件中，这个结果输出如下：\n```\n<table>\n  <tr>\n    <td>Hello</td>\n    <td>World</td>\n  </tr>\n</table>\n```\n如果子元素需要父元素包裹起来，但是不需要渲染父元素，我们就可以使用`fragment`。其实它的功能和vue的template一样，都只是占位，不渲染。\n\n我们也可以把`<React.Fragment></React.Fragment>`简写为`<></>`,看着像空组件；\n\n`<></>` 是 `<React.Fragment/>` 的语法糖。\n`<></>` 语法不能接受键值或属性。\n\n如果你需要一个带 key 的片段，你可以直接使用 `<React.Fragment /> 。\n一个使用场景是映射一个集合为一个片段数组 — 例如：创建一个描述列表：\n```\nfunction Glossary(props) {\n  return (\n    <dl>\n      {props.items.map(item => (\n        // 没有`key`，将会触发一个key警告\n        <React.Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.description}</dd>\n        </React.Fragment>\n      ))}\n    </dl>\n  );\n}\n```\nkey 是唯一可以传递给 `Fragment` 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。\n\n大功告成✌️✌️✌️\n\n参考链接：https://www.jianshu.com/p/36bb4d88f26c","slug":"ReactFragment","published":1,"updated":"2020-12-14T09:04:08.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqv000w78p3m704mlxd","content":"<p>react中一个常见模式是一个组件返回多个元素，<code>Fragments</code>允许你将子列表分组，而无需像DOM添加额外的节点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;React.Fragment&gt;</span><br><span class=\"line\">      &lt;ChildA /&gt;</span><br><span class=\"line\">      &lt;ChildB /&gt;</span><br><span class=\"line\">      &lt;ChildC /&gt;</span><br><span class=\"line\">    &lt;/React.Fragment&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个常见模式是为一个组件返回一个子元素列表。以这个示例的 React 片段为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Table extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;table&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">          &lt;Columns /&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">      &lt;/table&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了渲染有效的 HTML ， <code>Columns</code>需要返回多个<code>td</code>元素。如果一个父<code>div</code> 在 <code>Columns</code> 的 <code>render()</code> 函数里面使用，那么最终的 HTML 将是无效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Columns extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">        &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>Table</code> 组件中的输出结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;tr&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">      &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>\n<p>所以，我们介绍 Fragments。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Columns extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;React.Fragment&gt;</span><br><span class=\"line\">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">        &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">      &lt;/React.Fragment&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在正确的<code>Table</code>组件中，这个结果输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;tr&gt;</span><br><span class=\"line\">    &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">  &lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果子元素需要父元素包裹起来，但是不需要渲染父元素，我们就可以使用<code>fragment</code>。其实它的功能和vue的template一样，都只是占位，不渲染。</p>\n<p>我们也可以把<code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code>简写为<code>&lt;&gt;&lt;/&gt;</code>,看着像空组件；</p>\n<p><code>&lt;&gt;&lt;/&gt;</code> 是 <code>&lt;React.Fragment/&gt;</code> 的语法糖。<br><code>&lt;&gt;&lt;/&gt;</code> 语法不能接受键值或属性。</p>\n<p>如果你需要一个带 key 的片段，你可以直接使用 `&lt;React.Fragment /&gt; 。<br>一个使用场景是映射一个集合为一个片段数组 — 例如：创建一个描述列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Glossary(props) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;dl&gt;</span><br><span class=\"line\">      &#123;props.items.map(item =&gt; (</span><br><span class=\"line\">        // 没有`key`，将会触发一个key警告</span><br><span class=\"line\">        &lt;React.Fragment key=&#123;item.id&#125;&gt;</span><br><span class=\"line\">          &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt;</span><br><span class=\"line\">          &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt;</span><br><span class=\"line\">        &lt;/React.Fragment&gt;</span><br><span class=\"line\">      ))&#125;</span><br><span class=\"line\">    &lt;/dl&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>key 是唯一可以传递给 <code>Fragment</code> 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。</p>\n<p>大功告成✌️✌️✌️</p>\n<p>参考链接：<a href=\"https://www.jianshu.com/p/36bb4d88f26c\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/36bb4d88f26c</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>react中一个常见模式是一个组件返回多个元素，<code>Fragments</code>允许你将子列表分组，而无需像DOM添加额外的节点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">render() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;React.Fragment&gt;</span><br><span class=\"line\">      &lt;ChildA /&gt;</span><br><span class=\"line\">      &lt;ChildB /&gt;</span><br><span class=\"line\">      &lt;ChildC /&gt;</span><br><span class=\"line\">    &lt;/React.Fragment&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>一个常见模式是为一个组件返回一个子元素列表。以这个示例的 React 片段为例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Table extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;table&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">          &lt;Columns /&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">      &lt;/table&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了渲染有效的 HTML ， <code>Columns</code>需要返回多个<code>td</code>元素。如果一个父<code>div</code> 在 <code>Columns</code> 的 <code>render()</code> 函数里面使用，那么最终的 HTML 将是无效的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Columns extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">        &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>Table</code> 组件中的输出结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;tr&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">      &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>\n<p>所以，我们介绍 Fragments。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Columns extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;React.Fragment&gt;</span><br><span class=\"line\">        &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">        &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">      &lt;/React.Fragment&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在正确的<code>Table</code>组件中，这个结果输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">  &lt;tr&gt;</span><br><span class=\"line\">    &lt;td&gt;Hello&lt;/td&gt;</span><br><span class=\"line\">    &lt;td&gt;World&lt;/td&gt;</span><br><span class=\"line\">  &lt;/tr&gt;</span><br><span class=\"line\">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果子元素需要父元素包裹起来，但是不需要渲染父元素，我们就可以使用<code>fragment</code>。其实它的功能和vue的template一样，都只是占位，不渲染。</p>\n<p>我们也可以把<code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code>简写为<code>&lt;&gt;&lt;/&gt;</code>,看着像空组件；</p>\n<p><code>&lt;&gt;&lt;/&gt;</code> 是 <code>&lt;React.Fragment/&gt;</code> 的语法糖。<br><code>&lt;&gt;&lt;/&gt;</code> 语法不能接受键值或属性。</p>\n<p>如果你需要一个带 key 的片段，你可以直接使用 `&lt;React.Fragment /&gt; 。<br>一个使用场景是映射一个集合为一个片段数组 — 例如：创建一个描述列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Glossary(props) &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;dl&gt;</span><br><span class=\"line\">      &#123;props.items.map(item =&gt; (</span><br><span class=\"line\">        // 没有`key`，将会触发一个key警告</span><br><span class=\"line\">        &lt;React.Fragment key=&#123;item.id&#125;&gt;</span><br><span class=\"line\">          &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt;</span><br><span class=\"line\">          &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt;</span><br><span class=\"line\">        &lt;/React.Fragment&gt;</span><br><span class=\"line\">      ))&#125;</span><br><span class=\"line\">    &lt;/dl&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>key 是唯一可以传递给 <code>Fragment</code> 的属性。在将来，我们可能增加额外的属性支持，比如事件处理。</p>\n<p>大功告成✌️✌️✌️</p>\n<p>参考链接：<a href=\"https://www.jianshu.com/p/36bb4d88f26c\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/36bb4d88f26c</a></p>\n"},{"title":"axios封装","date":"2019-09-20T02:50:39.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\n[axios文档地址](https://www.npmjs.com/package/axios)\n\n在vue项目中，和后台交互获取数据这块，我们通常使用的是`axios`库，它是基于`promise`的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如`拦截请求和响应、取消请求、转换json、客户端防御cSRF`等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.\n\n`\n本次封装以vue项目为例做实践。\n`\n##### 安装\n\n```\n$ npm install axios\n```\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\n###### api.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api/export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","source":"_posts/axios.md","raw":"---\ntitle: axios封装\ndate: 2019-09-20 10:50:39\ntags: es6, vue\n---\n\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\n[axios文档地址](https://www.npmjs.com/package/axios)\n\n在vue项目中，和后台交互获取数据这块，我们通常使用的是`axios`库，它是基于`promise`的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如`拦截请求和响应、取消请求、转换json、客户端防御cSRF`等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.\n\n`\n本次封装以vue项目为例做实践。\n`\n##### 安装\n\n```\n$ npm install axios\n```\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\n###### api.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api/export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","slug":"axios","published":1,"updated":"2020-05-11T08:42:42.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqw000x78p3gjme8y81","content":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p><a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios文档地址</a></p>\n<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是<code>axios</code>库，它是基于<code>promise</code>的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如<code>拦截请求和响应、取消请求、转换json、客户端防御cSRF</code>等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.</p>\n<p><code>本次封装以vue项目为例做实践。</code></p>\n<h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install axios</span><br></pre></td></tr></table></figure>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV]</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<h6 id=\"api-js使用实例：\"><a href=\"#api-js使用实例：\" class=\"headerlink\" title=\"api.js使用实例：\"></a>api.js使用实例：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api/export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p><a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios文档地址</a></p>\n<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是<code>axios</code>库，它是基于<code>promise</code>的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如<code>拦截请求和响应、取消请求、转换json、客户端防御cSRF</code>等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.</p>\n<p><code>本次封装以vue项目为例做实践。</code></p>\n<h5 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install axios</span><br></pre></td></tr></table></figure>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV]</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<h6 id=\"api-js使用实例：\"><a href=\"#api-js使用实例：\" class=\"headerlink\" title=\"api.js使用实例：\"></a>api.js使用实例：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api/export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n"},{"title":"Axios源码解析","date":"2020-07-27T09:21:00.000Z","_content":"\n## axios如何实现多种请求方式\n---\n#### `原理`： \n通过数组循环来批量注册接口，统一调用同一个方法，参数差异：通过until.merge()方法来解决差异。类型：通过方法循环的method来区分。\n#### `实现逻辑`：\n\n* 1. 生成axios实例；\n* 2. 通过bind方法将axios原型中的request方法指向axios实例；\n* 3. 通过extend方法将axios实例和axios的原型链合并并指向context\n目的： 扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。\n* 4. 利用通过数组循环来批量注册接口，统一调用同一个方法.\n通过until.merge()方法来解决参数差异。\n\n`代码示例`：\n```\nfunction Axios (instanceConfig) {\n  this.default = instanceConfig;\n}\n/** \n * bind({}, {})\n * bind:将第一个参数的指向第二个参数;\n * extend({}, {})\n * extend:将两个对象进行合并;\n*/\nfunction creatInstance (defaultConfig) {\n  let context = new Axios(defaultConfig);\n  // 将Axios中的request方法，指向新的Axios对象\n  let instance = bind(Axios.prototype.request, context);\n  // 将前两个对象合并，合并后的this指向context\n  // 目的：扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。\n  extend(instance, Axios.prototype, context);\n  return instance;\n}\n// axios.get()\n\nlet arr = ['get', 'post', 'push ' ,'delete'];\n\narr.forEach((method) => {\n  // 循环在原型链上注册请求方法。\n  Axios.prototype[method] = function(url,config){\n    // config :post的data,\n    // util.merge :axios中的一个方法，原理对象合并\n    return this.request(util.merge(config || {}, {\n        methods: method,\n        url: url\n      })\n    );\n  };\n})\n```\n\n\n## axios如何实现请求拦截\n---\n\n#### `实现逻辑`：\n* 1. 在axios中配置拦截器 `interceptors`，拦截器包含request属性，和response属性，两个属性对应拦截器管理方法interceptorsManner。\n* 2. interceptorsManner方法中配置handler属性，handler属性用于存放use加入的方法。\n* 3. 在interceptorsManner的原型上配置use方法，user方法将参数fulilled, rejected两个方法存入对象中并存入到handler中。\n* 4. 在axios的原型的request方法中注册数组chain  =  ['dispatchRequest', undefined];\n 其中：request 会通过dispatchRequest将请求发送出去；\n4.1 循环interceptors.request.handler将用户存入的请求拦截的两个参数方法通过unshift分别存放到数组中。\n4.2 循环interceptors.response.handler将用户存入的响应拦截的两个参数方法通过shift分别存放到数组中。\n 4.3 注册promise = Promise.resolve()；\n4.4 循环chain，通过promise执行chain数组中的方法。\n`示例代码`：\n```\nfunction Axios (instanceConfig) {\n  this.default = instanceConfig;\n  this.interceptors={\n    request: new interceptorsManner(),\n    response: new interceptorsManner(),\n  };\n}\n\nAxios.prototype.request = function(){\n  // request 会通过dispatchRequest将请求发送出去\n  let chain = ['dispatchRequest', undefined];\n  let promise = Promise.resolve();\n  this.interceptors.request.handler.forEach((interceptor) => {\n    chain.unshift(interceptor.fulilled, interceptor.rejected)\n  })\n  this.interceptors.response.handler.forEach((interceptor) => {\n    chain.unshift(interceptor.fulilled, interceptor.rejected)\n  // chain = [console.log(1), console.log(2),dispatchRequest,undefined, console.log(3), console.log(4)]\n  })\n  while(chain.length) {\n    promise = promise.then(chain.shift(), chain.shift())\n    // 举例\n    // 第一次循环执行请求拦截前的成功和失败方法\n    // 第二次循环执行发送请求和undefined;\n    // 第一次循环执行响应拦截前的成功和失败方法\n  }\n  // 依次执行，并保证上一个方法完成之后在继续执行下一个方法。\n};\nfunction interceptorsManner () {\n  this.handler= []; //存放use加入的方法\n}\ninterceptorsManner.prototype.use = function use(fulilled, rejected) {\n  this.handler.push({\n    fulilled:  fulilled,\n    rejected: rejected\n  });\n};\n//请求拦截器&响应拦截器的使用方法\nAxios.interceptors.request.use(function(){\n\n},function(){\n\n});\nAxios.interceptors.response.use(function(){\n\n},function(){\n\n});\n```\n大功告成✌️✌️✌️\n\n接下来你可能想要了解的：\n[axios文档地址](https://www.npmjs.com/package/axios)\n[Axios封装示例代码+封装思路](https://www.jianshu.com/p/7f7b655bd3c4)","source":"_posts/axios1.md","raw":"---\ntitle: Axios源码解析\ndate: 2020-07-27 17:21:00\ntags: Axios\n---\n\n## axios如何实现多种请求方式\n---\n#### `原理`： \n通过数组循环来批量注册接口，统一调用同一个方法，参数差异：通过until.merge()方法来解决差异。类型：通过方法循环的method来区分。\n#### `实现逻辑`：\n\n* 1. 生成axios实例；\n* 2. 通过bind方法将axios原型中的request方法指向axios实例；\n* 3. 通过extend方法将axios实例和axios的原型链合并并指向context\n目的： 扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。\n* 4. 利用通过数组循环来批量注册接口，统一调用同一个方法.\n通过until.merge()方法来解决参数差异。\n\n`代码示例`：\n```\nfunction Axios (instanceConfig) {\n  this.default = instanceConfig;\n}\n/** \n * bind({}, {})\n * bind:将第一个参数的指向第二个参数;\n * extend({}, {})\n * extend:将两个对象进行合并;\n*/\nfunction creatInstance (defaultConfig) {\n  let context = new Axios(defaultConfig);\n  // 将Axios中的request方法，指向新的Axios对象\n  let instance = bind(Axios.prototype.request, context);\n  // 将前两个对象合并，合并后的this指向context\n  // 目的：扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。\n  extend(instance, Axios.prototype, context);\n  return instance;\n}\n// axios.get()\n\nlet arr = ['get', 'post', 'push ' ,'delete'];\n\narr.forEach((method) => {\n  // 循环在原型链上注册请求方法。\n  Axios.prototype[method] = function(url,config){\n    // config :post的data,\n    // util.merge :axios中的一个方法，原理对象合并\n    return this.request(util.merge(config || {}, {\n        methods: method,\n        url: url\n      })\n    );\n  };\n})\n```\n\n\n## axios如何实现请求拦截\n---\n\n#### `实现逻辑`：\n* 1. 在axios中配置拦截器 `interceptors`，拦截器包含request属性，和response属性，两个属性对应拦截器管理方法interceptorsManner。\n* 2. interceptorsManner方法中配置handler属性，handler属性用于存放use加入的方法。\n* 3. 在interceptorsManner的原型上配置use方法，user方法将参数fulilled, rejected两个方法存入对象中并存入到handler中。\n* 4. 在axios的原型的request方法中注册数组chain  =  ['dispatchRequest', undefined];\n 其中：request 会通过dispatchRequest将请求发送出去；\n4.1 循环interceptors.request.handler将用户存入的请求拦截的两个参数方法通过unshift分别存放到数组中。\n4.2 循环interceptors.response.handler将用户存入的响应拦截的两个参数方法通过shift分别存放到数组中。\n 4.3 注册promise = Promise.resolve()；\n4.4 循环chain，通过promise执行chain数组中的方法。\n`示例代码`：\n```\nfunction Axios (instanceConfig) {\n  this.default = instanceConfig;\n  this.interceptors={\n    request: new interceptorsManner(),\n    response: new interceptorsManner(),\n  };\n}\n\nAxios.prototype.request = function(){\n  // request 会通过dispatchRequest将请求发送出去\n  let chain = ['dispatchRequest', undefined];\n  let promise = Promise.resolve();\n  this.interceptors.request.handler.forEach((interceptor) => {\n    chain.unshift(interceptor.fulilled, interceptor.rejected)\n  })\n  this.interceptors.response.handler.forEach((interceptor) => {\n    chain.unshift(interceptor.fulilled, interceptor.rejected)\n  // chain = [console.log(1), console.log(2),dispatchRequest,undefined, console.log(3), console.log(4)]\n  })\n  while(chain.length) {\n    promise = promise.then(chain.shift(), chain.shift())\n    // 举例\n    // 第一次循环执行请求拦截前的成功和失败方法\n    // 第二次循环执行发送请求和undefined;\n    // 第一次循环执行响应拦截前的成功和失败方法\n  }\n  // 依次执行，并保证上一个方法完成之后在继续执行下一个方法。\n};\nfunction interceptorsManner () {\n  this.handler= []; //存放use加入的方法\n}\ninterceptorsManner.prototype.use = function use(fulilled, rejected) {\n  this.handler.push({\n    fulilled:  fulilled,\n    rejected: rejected\n  });\n};\n//请求拦截器&响应拦截器的使用方法\nAxios.interceptors.request.use(function(){\n\n},function(){\n\n});\nAxios.interceptors.response.use(function(){\n\n},function(){\n\n});\n```\n大功告成✌️✌️✌️\n\n接下来你可能想要了解的：\n[axios文档地址](https://www.npmjs.com/package/axios)\n[Axios封装示例代码+封装思路](https://www.jianshu.com/p/7f7b655bd3c4)","slug":"axios1","published":1,"updated":"2020-12-14T10:04:17.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjqy001078p3tveu0nvh","content":"<h2 id=\"axios如何实现多种请求方式\"><a href=\"#axios如何实现多种请求方式\" class=\"headerlink\" title=\"axios如何实现多种请求方式\"></a>axios如何实现多种请求方式</h2><hr>\n<h4 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a><code>原理</code>：</h4><p>通过数组循环来批量注册接口，统一调用同一个方法，参数差异：通过until.merge()方法来解决差异。类型：通过方法循环的method来区分。</p>\n<h4 id=\"实现逻辑：\"><a href=\"#实现逻辑：\" class=\"headerlink\" title=\"实现逻辑：\"></a><code>实现逻辑</code>：</h4><ul>\n<li><ol>\n<li>生成axios实例；</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>通过bind方法将axios原型中的request方法指向axios实例；</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>通过extend方法将axios实例和axios的原型链合并并指向context<br>目的： 扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>利用通过数组循环来批量注册接口，统一调用同一个方法.<br>通过until.merge()方法来解决参数差异。</li>\n</ol>\n</li>\n</ul>\n<p><code>代码示例</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Axios (instanceConfig) &#123;</span><br><span class=\"line\">  this.default = instanceConfig;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/** </span><br><span class=\"line\"> * bind(&#123;&#125;, &#123;&#125;)</span><br><span class=\"line\"> * bind:将第一个参数的指向第二个参数;</span><br><span class=\"line\"> * extend(&#123;&#125;, &#123;&#125;)</span><br><span class=\"line\"> * extend:将两个对象进行合并;</span><br><span class=\"line\">*/</span><br><span class=\"line\">function creatInstance (defaultConfig) &#123;</span><br><span class=\"line\">  let context = new Axios(defaultConfig);</span><br><span class=\"line\">  // 将Axios中的request方法，指向新的Axios对象</span><br><span class=\"line\">  let instance = bind(Axios.prototype.request, context);</span><br><span class=\"line\">  // 将前两个对象合并，合并后的this指向context</span><br><span class=\"line\">  // 目的：扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。</span><br><span class=\"line\">  extend(instance, Axios.prototype, context);</span><br><span class=\"line\">  return instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// axios.get()</span><br><span class=\"line\"></span><br><span class=\"line\">let arr = [&apos;get&apos;, &apos;post&apos;, &apos;push &apos; ,&apos;delete&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach((method) =&gt; &#123;</span><br><span class=\"line\">  // 循环在原型链上注册请求方法。</span><br><span class=\"line\">  Axios.prototype[method] = function(url,config)&#123;</span><br><span class=\"line\">    // config :post的data,</span><br><span class=\"line\">    // util.merge :axios中的一个方法，原理对象合并</span><br><span class=\"line\">    return this.request(util.merge(config || &#123;&#125;, &#123;</span><br><span class=\"line\">        methods: method,</span><br><span class=\"line\">        url: url</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"axios如何实现请求拦截\"><a href=\"#axios如何实现请求拦截\" class=\"headerlink\" title=\"axios如何实现请求拦截\"></a>axios如何实现请求拦截</h2><hr>\n<h4 id=\"实现逻辑：-1\"><a href=\"#实现逻辑：-1\" class=\"headerlink\" title=\"实现逻辑：\"></a><code>实现逻辑</code>：</h4><ul>\n<li><ol>\n<li>在axios中配置拦截器 <code>interceptors</code>，拦截器包含request属性，和response属性，两个属性对应拦截器管理方法interceptorsManner。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>interceptorsManner方法中配置handler属性，handler属性用于存放use加入的方法。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>在interceptorsManner的原型上配置use方法，user方法将参数fulilled, rejected两个方法存入对象中并存入到handler中。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>在axios的原型的request方法中注册数组chain  =  [‘dispatchRequest’, undefined];<br>其中：request 会通过dispatchRequest将请求发送出去；<br>4.1 循环interceptors.request.handler将用户存入的请求拦截的两个参数方法通过unshift分别存放到数组中。<br>4.2 循环interceptors.response.handler将用户存入的响应拦截的两个参数方法通过shift分别存放到数组中。<br>4.3 注册promise = Promise.resolve()；<br>4.4 循环chain，通过promise执行chain数组中的方法。<br><code>示例代码</code>：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Axios (instanceConfig) &#123;</span><br><span class=\"line\">  this.default = instanceConfig;</span><br><span class=\"line\">  this.interceptors=&#123;</span><br><span class=\"line\">    request: new interceptorsManner(),</span><br><span class=\"line\">    response: new interceptorsManner(),</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Axios.prototype.request = function()&#123;</span><br><span class=\"line\">  // request 会通过dispatchRequest将请求发送出去</span><br><span class=\"line\">  let chain = [&apos;dispatchRequest&apos;, undefined];</span><br><span class=\"line\">  let promise = Promise.resolve();</span><br><span class=\"line\">  this.interceptors.request.handler.forEach((interceptor) =&gt; &#123;</span><br><span class=\"line\">    chain.unshift(interceptor.fulilled, interceptor.rejected)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  this.interceptors.response.handler.forEach((interceptor) =&gt; &#123;</span><br><span class=\"line\">    chain.unshift(interceptor.fulilled, interceptor.rejected)</span><br><span class=\"line\">  // chain = [console.log(1), console.log(2),dispatchRequest,undefined, console.log(3), console.log(4)]</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  while(chain.length) &#123;</span><br><span class=\"line\">    promise = promise.then(chain.shift(), chain.shift())</span><br><span class=\"line\">    // 举例</span><br><span class=\"line\">    // 第一次循环执行请求拦截前的成功和失败方法</span><br><span class=\"line\">    // 第二次循环执行发送请求和undefined;</span><br><span class=\"line\">    // 第一次循环执行响应拦截前的成功和失败方法</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 依次执行，并保证上一个方法完成之后在继续执行下一个方法。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function interceptorsManner () &#123;</span><br><span class=\"line\">  this.handler= []; //存放use加入的方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interceptorsManner.prototype.use = function use(fulilled, rejected) &#123;</span><br><span class=\"line\">  this.handler.push(&#123;</span><br><span class=\"line\">    fulilled:  fulilled,</span><br><span class=\"line\">    rejected: rejected</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//请求拦截器&amp;响应拦截器的使用方法</span><br><span class=\"line\">Axios.interceptors.request.use(function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Axios.interceptors.response.use(function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<p>大功告成✌️✌️✌️</p>\n<p>接下来你可能想要了解的：<br><a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios文档地址</a><br><a href=\"https://www.jianshu.com/p/7f7b655bd3c4\" target=\"_blank\" rel=\"noopener\">Axios封装示例代码+封装思路</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"axios如何实现多种请求方式\"><a href=\"#axios如何实现多种请求方式\" class=\"headerlink\" title=\"axios如何实现多种请求方式\"></a>axios如何实现多种请求方式</h2><hr>\n<h4 id=\"原理：\"><a href=\"#原理：\" class=\"headerlink\" title=\"原理：\"></a><code>原理</code>：</h4><p>通过数组循环来批量注册接口，统一调用同一个方法，参数差异：通过until.merge()方法来解决差异。类型：通过方法循环的method来区分。</p>\n<h4 id=\"实现逻辑：\"><a href=\"#实现逻辑：\" class=\"headerlink\" title=\"实现逻辑：\"></a><code>实现逻辑</code>：</h4><ul>\n<li><ol>\n<li>生成axios实例；</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>通过bind方法将axios原型中的request方法指向axios实例；</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>通过extend方法将axios实例和axios的原型链合并并指向context<br>目的： 扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>利用通过数组循环来批量注册接口，统一调用同一个方法.<br>通过until.merge()方法来解决参数差异。</li>\n</ol>\n</li>\n</ul>\n<p><code>代码示例</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Axios (instanceConfig) &#123;</span><br><span class=\"line\">  this.default = instanceConfig;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/** </span><br><span class=\"line\"> * bind(&#123;&#125;, &#123;&#125;)</span><br><span class=\"line\"> * bind:将第一个参数的指向第二个参数;</span><br><span class=\"line\"> * extend(&#123;&#125;, &#123;&#125;)</span><br><span class=\"line\"> * extend:将两个对象进行合并;</span><br><span class=\"line\">*/</span><br><span class=\"line\">function creatInstance (defaultConfig) &#123;</span><br><span class=\"line\">  let context = new Axios(defaultConfig);</span><br><span class=\"line\">  // 将Axios中的request方法，指向新的Axios对象</span><br><span class=\"line\">  let instance = bind(Axios.prototype.request, context);</span><br><span class=\"line\">  // 将前两个对象合并，合并后的this指向context</span><br><span class=\"line\">  // 目的：扩展axios的调用方法。使axios可以通过axios.get去调用，也可以通过原型链去调用。</span><br><span class=\"line\">  extend(instance, Axios.prototype, context);</span><br><span class=\"line\">  return instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// axios.get()</span><br><span class=\"line\"></span><br><span class=\"line\">let arr = [&apos;get&apos;, &apos;post&apos;, &apos;push &apos; ,&apos;delete&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.forEach((method) =&gt; &#123;</span><br><span class=\"line\">  // 循环在原型链上注册请求方法。</span><br><span class=\"line\">  Axios.prototype[method] = function(url,config)&#123;</span><br><span class=\"line\">    // config :post的data,</span><br><span class=\"line\">    // util.merge :axios中的一个方法，原理对象合并</span><br><span class=\"line\">    return this.request(util.merge(config || &#123;&#125;, &#123;</span><br><span class=\"line\">        methods: method,</span><br><span class=\"line\">        url: url</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"axios如何实现请求拦截\"><a href=\"#axios如何实现请求拦截\" class=\"headerlink\" title=\"axios如何实现请求拦截\"></a>axios如何实现请求拦截</h2><hr>\n<h4 id=\"实现逻辑：-1\"><a href=\"#实现逻辑：-1\" class=\"headerlink\" title=\"实现逻辑：\"></a><code>实现逻辑</code>：</h4><ul>\n<li><ol>\n<li>在axios中配置拦截器 <code>interceptors</code>，拦截器包含request属性，和response属性，两个属性对应拦截器管理方法interceptorsManner。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>interceptorsManner方法中配置handler属性，handler属性用于存放use加入的方法。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>在interceptorsManner的原型上配置use方法，user方法将参数fulilled, rejected两个方法存入对象中并存入到handler中。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>在axios的原型的request方法中注册数组chain  =  [‘dispatchRequest’, undefined];<br>其中：request 会通过dispatchRequest将请求发送出去；<br>4.1 循环interceptors.request.handler将用户存入的请求拦截的两个参数方法通过unshift分别存放到数组中。<br>4.2 循环interceptors.response.handler将用户存入的响应拦截的两个参数方法通过shift分别存放到数组中。<br>4.3 注册promise = Promise.resolve()；<br>4.4 循环chain，通过promise执行chain数组中的方法。<br><code>示例代码</code>：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Axios (instanceConfig) &#123;</span><br><span class=\"line\">  this.default = instanceConfig;</span><br><span class=\"line\">  this.interceptors=&#123;</span><br><span class=\"line\">    request: new interceptorsManner(),</span><br><span class=\"line\">    response: new interceptorsManner(),</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Axios.prototype.request = function()&#123;</span><br><span class=\"line\">  // request 会通过dispatchRequest将请求发送出去</span><br><span class=\"line\">  let chain = [&apos;dispatchRequest&apos;, undefined];</span><br><span class=\"line\">  let promise = Promise.resolve();</span><br><span class=\"line\">  this.interceptors.request.handler.forEach((interceptor) =&gt; &#123;</span><br><span class=\"line\">    chain.unshift(interceptor.fulilled, interceptor.rejected)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  this.interceptors.response.handler.forEach((interceptor) =&gt; &#123;</span><br><span class=\"line\">    chain.unshift(interceptor.fulilled, interceptor.rejected)</span><br><span class=\"line\">  // chain = [console.log(1), console.log(2),dispatchRequest,undefined, console.log(3), console.log(4)]</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  while(chain.length) &#123;</span><br><span class=\"line\">    promise = promise.then(chain.shift(), chain.shift())</span><br><span class=\"line\">    // 举例</span><br><span class=\"line\">    // 第一次循环执行请求拦截前的成功和失败方法</span><br><span class=\"line\">    // 第二次循环执行发送请求和undefined;</span><br><span class=\"line\">    // 第一次循环执行响应拦截前的成功和失败方法</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 依次执行，并保证上一个方法完成之后在继续执行下一个方法。</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function interceptorsManner () &#123;</span><br><span class=\"line\">  this.handler= []; //存放use加入的方法</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interceptorsManner.prototype.use = function use(fulilled, rejected) &#123;</span><br><span class=\"line\">  this.handler.push(&#123;</span><br><span class=\"line\">    fulilled:  fulilled,</span><br><span class=\"line\">    rejected: rejected</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//请求拦截器&amp;响应拦截器的使用方法</span><br><span class=\"line\">Axios.interceptors.request.use(function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Axios.interceptors.response.use(function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<p>大功告成✌️✌️✌️</p>\n<p>接下来你可能想要了解的：<br><a href=\"https://www.npmjs.com/package/axios\" target=\"_blank\" rel=\"noopener\">axios文档地址</a><br><a href=\"https://www.jianshu.com/p/7f7b655bd3c4\" target=\"_blank\" rel=\"noopener\">Axios封装示例代码+封装思路</a></p>\n"},{"title":"asyncAwit","date":"2019-11-04T06:58:15.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n##### async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n// 或者直接设置成基本变量：\nconst TIMEOUT = 30000;\n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\napi.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api//export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","source":"_posts/asyncAwit.md","raw":"---\ntitle: asyncAwit\ndate: 2019-11-04 14:58:15\ntags:\n---\n\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n##### async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n// 或者直接设置成基本变量：\nconst TIMEOUT = 30000;\n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\napi.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api//export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","slug":"asyncAwit","published":1,"updated":"2019-12-14T10:29:55.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjr0001178p3rk8ektm5","content":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>\n<h5 id=\"async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\"><a href=\"#async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\" class=\"headerlink\" title=\"async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\"></a>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</h5><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class=\"line\">// 或者直接设置成基本变量：</span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<p>api.js使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api//export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>\n<h5 id=\"async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\"><a href=\"#async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\" class=\"headerlink\" title=\"async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\"></a>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</h5><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class=\"line\">// 或者直接设置成基本变量：</span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<p>api.js使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api//export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n"},{"title":"基于HEXO博客框架和Github搭建个人博客简单教程","date":"2019-07-24T06:44:05.000Z","_content":"\nAuthor: Echo\nTime: 2019-07-24 14:44:23\n\n### 准备工作\n配置环境\n\n* 安装Node.js\n* 安装Git\n* 注册GitHub\n\n# Hexo 部分\n### Hexo简介\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n### Hexo安装方法\n参考官网中文文档,只需要一条命令即可自动安装hexo框架。\n```\n$ npm install -g hexo-cli #使用 npm 安装 Hexo\n```\n\n* 初始化\n创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：\n```\nhexo init\n```\n* 生成静态页面\n继续再Blog目录下执行如下命令，生成静态页面\n```\nhexo generate （或者 hexo g）\n```\n\n* 本地启动\n启动本地服务，进行文章预览调试，命令：\n```\nhexo server\n```\n\n* 本地测试\n\n浏览器输入 http://localhost:4000\n\n# Github 部分\n* 注册github\n* 新建仓库\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!\n* 本地_config.yml文配置件，建立关联\n我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)\n```\ndeploy:  \n   type: git   \n   repository: https://github.com/leopardpan/  leopardpan.github.io.git  \n   branch: master\n```\n# 部署\n执行如下命令才能使用git部署\n```\nnpm install hexo-deployer-git --save\n```\n(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)\n执行配置命令：\n```\nhexo deploy\n```\n然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了\n\n发文章\n每次部署的步骤，可按以下三步来进行。\n```\nhexo clean  \nhexo generate  \nhexo deploy\n```\n一些常用命令：\n```\nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成静态页面至public目录  \nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）  \nhexo deploy #将.deploy目录部署到GitHub  \nhexo help  #查看帮助  \nhexo version  #查看Hexo的版本\n```\n参考：\n\nhttp://www.jianshu.com/p/465830080ea9\nhttp://www.chinaz.com/web/2016/0105/491998.shtml","source":"_posts/blogInit.md","raw":"---\ntitle: 基于HEXO博客框架和Github搭建个人博客简单教程\ndate: 2019-07-24 14:44:05\ntags: blog-hexo\n---\n\nAuthor: Echo\nTime: 2019-07-24 14:44:23\n\n### 准备工作\n配置环境\n\n* 安装Node.js\n* 安装Git\n* 注册GitHub\n\n# Hexo 部分\n### Hexo简介\nHexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务\n\n### Hexo安装方法\n参考官网中文文档,只需要一条命令即可自动安装hexo框架。\n```\n$ npm install -g hexo-cli #使用 npm 安装 Hexo\n```\n\n* 初始化\n创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：\n```\nhexo init\n```\n* 生成静态页面\n继续再Blog目录下执行如下命令，生成静态页面\n```\nhexo generate （或者 hexo g）\n```\n\n* 本地启动\n启动本地服务，进行文章预览调试，命令：\n```\nhexo server\n```\n\n* 本地测试\n\n浏览器输入 http://localhost:4000\n\n# Github 部分\n* 注册github\n* 新建仓库\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!\n* 本地_config.yml文配置件，建立关联\n我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)\n```\ndeploy:  \n   type: git   \n   repository: https://github.com/leopardpan/  leopardpan.github.io.git  \n   branch: master\n```\n# 部署\n执行如下命令才能使用git部署\n```\nnpm install hexo-deployer-git --save\n```\n(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)\n执行配置命令：\n```\nhexo deploy\n```\n然后再浏览器中输入http://username.github.io/就行了，把 username ,改成你 github 的账户名就行了\n\n发文章\n每次部署的步骤，可按以下三步来进行。\n```\nhexo clean  \nhexo generate  \nhexo deploy\n```\n一些常用命令：\n```\nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成静态页面至public目录  \nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）  \nhexo deploy #将.deploy目录部署到GitHub  \nhexo help  #查看帮助  \nhexo version  #查看Hexo的版本\n```\n参考：\n\nhttp://www.jianshu.com/p/465830080ea9\nhttp://www.chinaz.com/web/2016/0105/491998.shtml","slug":"blogInit","published":1,"updated":"2020-07-27T09:27:00.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjr2001278p3sabcpgfy","content":"<p>Author: Echo<br>Time: 2019-07-24 14:44:23</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>配置环境</p>\n<ul>\n<li>安装Node.js</li>\n<li>安装Git</li>\n<li>注册GitHub</li>\n</ul>\n<h1 id=\"Hexo-部分\"><a href=\"#Hexo-部分\" class=\"headerlink\" title=\"Hexo 部分\"></a>Hexo 部分</h1><h3 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h3><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。<br>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<h3 id=\"Hexo安装方法\"><a href=\"#Hexo安装方法\" class=\"headerlink\" title=\"Hexo安装方法\"></a>Hexo安装方法</h3><p>参考官网中文文档,只需要一条命令即可自动安装hexo框架。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli #使用 npm 安装 Hexo</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>初始化<br>创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态页面<br>继续再Blog目录下执行如下命令，生成静态页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate （或者 hexo g）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地启动<br>启动本地服务，进行文章预览调试，命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地测试</p>\n</li>\n</ul>\n<p>浏览器输入 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<h1 id=\"Github-部分\"><a href=\"#Github-部分\" class=\"headerlink\" title=\"Github 部分\"></a>Github 部分</h1><ul>\n<li>注册github</li>\n<li>新建仓库<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!</li>\n<li>本地_config.yml文配置件，建立关联<br>我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">   type: git   </span><br><span class=\"line\">   repository: https://github.com/leopardpan/  leopardpan.github.io.git  </span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>执行如下命令才能使用git部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)<br>执行配置命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>然后再浏览器中输入<a href=\"http://username.github.io/就行了，把\" target=\"_blank\" rel=\"noopener\">http://username.github.io/就行了，把</a> username ,改成你 github 的账户名就行了</p>\n<p>发文章<br>每次部署的步骤，可按以下三步来进行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  </span><br><span class=\"line\">hexo generate  </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>一些常用命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章  </span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </span><br><span class=\"line\">hexo generate #生成静态页面至public目录  </span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）  </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub  </span><br><span class=\"line\">hexo help  #查看帮助  </span><br><span class=\"line\">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure></p>\n<p>参考：</p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/465830080ea9</a><br><a href=\"http://www.chinaz.com/web/2016/0105/491998.shtml\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/web/2016/0105/491998.shtml</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 14:44:23</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>配置环境</p>\n<ul>\n<li>安装Node.js</li>\n<li>安装Git</li>\n<li>注册GitHub</li>\n</ul>\n<h1 id=\"Hexo-部分\"><a href=\"#Hexo-部分\" class=\"headerlink\" title=\"Hexo 部分\"></a>Hexo 部分</h1><h3 id=\"Hexo简介\"><a href=\"#Hexo简介\" class=\"headerlink\" title=\"Hexo简介\"></a>Hexo简介</h3><p>Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。<br>而架设Hexo的环境更简单了 不需要 lnmp/lamp/XAMPP 这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务</p>\n<h3 id=\"Hexo安装方法\"><a href=\"#Hexo安装方法\" class=\"headerlink\" title=\"Hexo安装方法\"></a>Hexo安装方法</h3><p>参考官网中文文档,只需要一条命令即可自动安装hexo框架。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli #使用 npm 安装 Hexo</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>初始化<br>创建一个文件夹，如：Blog，cd到Blog里执行hexo init的。命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生成静态页面<br>继续再Blog目录下执行如下命令，生成静态页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate （或者 hexo g）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地启动<br>启动本地服务，进行文章预览调试，命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地测试</p>\n</li>\n</ul>\n<p>浏览器输入 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<h1 id=\"Github-部分\"><a href=\"#Github-部分\" class=\"headerlink\" title=\"Github 部分\"></a>Github 部分</h1><ul>\n<li>注册github</li>\n<li>新建仓库<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】， 固定写法 !!!</li>\n<li>本地_config.yml文配置件，建立关联<br>我们需要_config.yml文件，来建立关联(注意冒号后面要有空格)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:  </span><br><span class=\"line\">   type: git   </span><br><span class=\"line\">   repository: https://github.com/leopardpan/  leopardpan.github.io.git  </span><br><span class=\"line\">   branch: master</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>执行如下命令才能使用git部署<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>(我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。)<br>执行配置命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>然后再浏览器中输入<a href=\"http://username.github.io/就行了，把\" target=\"_blank\" rel=\"noopener\">http://username.github.io/就行了，把</a> username ,改成你 github 的账户名就行了</p>\n<p>发文章<br>每次部署的步骤，可按以下三步来进行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean  </span><br><span class=\"line\">hexo generate  </span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>一些常用命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;postName&quot; #新建文章  </span><br><span class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </span><br><span class=\"line\">hexo generate #生成静态页面至public目录  </span><br><span class=\"line\">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）  </span><br><span class=\"line\">hexo deploy #将.deploy目录部署到GitHub  </span><br><span class=\"line\">hexo help  #查看帮助  </span><br><span class=\"line\">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure></p>\n<p>参考：</p>\n<p><a href=\"http://www.jianshu.com/p/465830080ea9\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/465830080ea9</a><br><a href=\"http://www.chinaz.com/web/2016/0105/491998.shtml\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/web/2016/0105/491998.shtml</a></p>\n"},{"title":"Commit message 代码提交规范","date":"2019-09-20T07:52:39.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 15:52:39\n\n#### 前言\n\n在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。\n\n##### Commit message 的作用\n* 提供更多的历史信息，方便快速浏览\n* 过滤某些commit（比如文档改动），便于快速查找信息\n* 直接从commit生成Change log\n* 可读性好，清晰，不必深入看代码即可了解当前commit的作用。\n* 为 Code Reviewing（代码审查）做准备\n* 方便跟踪工程历史\n* 提高项目的整体质量，提高个人工程素质\n\n##### Commit message 的格式\n\nCommit message 包括三个部分：Header，Body 和 Footer\n\n###### 一、Header\n`\nHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）\n`\n\n* type\n\n type用于说明 commit 的类别，只允许使用下面的标识\n\n    feat：新增功能（feature）\n    fix：修补bug\n    docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等\n    style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑\n    refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    test：增加测试，包括单元测试、集成测试等\n    chore：构建过程或辅助工具的变动\n    type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。\n    perf: 优化相关，比如提升性能、体验\n    revert: 回滚到上一个版本\n    ci：自动化流程配置修改\n注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中\n\n* scope\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。\n\n* subject\n\n①subject是 commit 目的的简短描述，不超过50个字符。\n②以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n③第一个字母小写\n④结尾不加句号（.）\n\n###### 一、Body\n\n`\nBody 部分是对本次 commit 的详细描述，可以分成多行\n`\n\n###### 三、Footer\nFooter 部分只用于两种情况：\n* 不兼容变动\n如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法\n* 关闭 Issue\n\n```\n如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue\n\nCloses #234\n\n也可以一次关闭多个 issue\n\nCloses #123, #245, #992\n```\n\n#### 全局安装\n```\n$ npm install -g commitizen\n```\n#### 项目中安装\n\n```\n$ commitizen init cz-conventional-changelog --save --save-exact\n```\n注意：如果是第二次配置，需要用–force：\n```\n$ commitizen init cz-conventional-changelog --save --force\n```\n\n#### 将未暂存文件所有变化提交到暂存区\n\n```\n$ git add .\n```\n\n① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。\n\n②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add --update的缩写）。add -u 不会提交新文件。\n\n③git add -a ：是上面两个功能的合集（git add --all的缩写）\n\n#### 命令行输入提交命令\n```\n$ git cz\n```\n输入命令后依次提示：\n```\n1. 上、下键选择要提交的更改类型\n\n2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)\n\n3. 写一个简短的祈使句来描述这个变化\n\n4. 提供更详细的更改说明:(按回车键跳过)\n\n5. 有什么重大变化吗?\n\n6. 这一变化是否会影响\n任何未解决的问题?\n```\n#### 再推送到本地git仓库\n\n```\n$ git push\n```\n\n#### 打印日志命令\n```\n$ git log\n```\n#### 输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\n\n* 安装生成 Change log 的工具\n\n```\n$ npm install -g conventional-changelog-cli\n```\n* 通过提交记录生成 CHANGELOG.md\n\n```\n$ conventional-changelog -p -i CHANGELOG.md -s\n```\n#### 打印出 git log 的日志记录（详细日志记录）\n\n```\n$ git log > 文件名\n```\n\n参考链接： https://segmentfault.com/a/1190000019579621","source":"_posts/commitMessage.md","raw":"---\ntitle: Commit message 代码提交规范\ndate: 2019-09-20 15:52:39\ntags: git\n---\n\nAuthor: Echo\nTime: 2019-09-20 15:52:39\n\n#### 前言\n\n在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。\n\n##### Commit message 的作用\n* 提供更多的历史信息，方便快速浏览\n* 过滤某些commit（比如文档改动），便于快速查找信息\n* 直接从commit生成Change log\n* 可读性好，清晰，不必深入看代码即可了解当前commit的作用。\n* 为 Code Reviewing（代码审查）做准备\n* 方便跟踪工程历史\n* 提高项目的整体质量，提高个人工程素质\n\n##### Commit message 的格式\n\nCommit message 包括三个部分：Header，Body 和 Footer\n\n###### 一、Header\n`\nHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）\n`\n\n* type\n\n type用于说明 commit 的类别，只允许使用下面的标识\n\n    feat：新增功能（feature）\n    fix：修补bug\n    docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等\n    style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑\n    refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    test：增加测试，包括单元测试、集成测试等\n    chore：构建过程或辅助工具的变动\n    type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。\n    perf: 优化相关，比如提升性能、体验\n    revert: 回滚到上一个版本\n    ci：自动化流程配置修改\n注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中\n\n* scope\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。\n\n* subject\n\n①subject是 commit 目的的简短描述，不超过50个字符。\n②以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n③第一个字母小写\n④结尾不加句号（.）\n\n###### 一、Body\n\n`\nBody 部分是对本次 commit 的详细描述，可以分成多行\n`\n\n###### 三、Footer\nFooter 部分只用于两种情况：\n* 不兼容变动\n如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法\n* 关闭 Issue\n\n```\n如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue\n\nCloses #234\n\n也可以一次关闭多个 issue\n\nCloses #123, #245, #992\n```\n\n#### 全局安装\n```\n$ npm install -g commitizen\n```\n#### 项目中安装\n\n```\n$ commitizen init cz-conventional-changelog --save --save-exact\n```\n注意：如果是第二次配置，需要用–force：\n```\n$ commitizen init cz-conventional-changelog --save --force\n```\n\n#### 将未暂存文件所有变化提交到暂存区\n\n```\n$ git add .\n```\n\n① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。\n\n②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add --update的缩写）。add -u 不会提交新文件。\n\n③git add -a ：是上面两个功能的合集（git add --all的缩写）\n\n#### 命令行输入提交命令\n```\n$ git cz\n```\n输入命令后依次提示：\n```\n1. 上、下键选择要提交的更改类型\n\n2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)\n\n3. 写一个简短的祈使句来描述这个变化\n\n4. 提供更详细的更改说明:(按回车键跳过)\n\n5. 有什么重大变化吗?\n\n6. 这一变化是否会影响\n任何未解决的问题?\n```\n#### 再推送到本地git仓库\n\n```\n$ git push\n```\n\n#### 打印日志命令\n```\n$ git log\n```\n#### 输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\n\n* 安装生成 Change log 的工具\n\n```\n$ npm install -g conventional-changelog-cli\n```\n* 通过提交记录生成 CHANGELOG.md\n\n```\n$ conventional-changelog -p -i CHANGELOG.md -s\n```\n#### 打印出 git log 的日志记录（详细日志记录）\n\n```\n$ git log > 文件名\n```\n\n参考链接： https://segmentfault.com/a/1190000019579621","slug":"commitMessage","published":1,"updated":"2020-11-19T07:56:51.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjr6001578p3qrwt5jfm","content":"<p>Author: Echo<br>Time: 2019-09-20 15:52:39</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。</p>\n<h5 id=\"Commit-message-的作用\"><a href=\"#Commit-message-的作用\" class=\"headerlink\" title=\"Commit message 的作用\"></a>Commit message 的作用</h5><ul>\n<li>提供更多的历史信息，方便快速浏览</li>\n<li>过滤某些commit（比如文档改动），便于快速查找信息</li>\n<li>直接从commit生成Change log</li>\n<li>可读性好，清晰，不必深入看代码即可了解当前commit的作用。</li>\n<li>为 Code Reviewing（代码审查）做准备</li>\n<li>方便跟踪工程历史</li>\n<li>提高项目的整体质量，提高个人工程素质</li>\n</ul>\n<h5 id=\"Commit-message-的格式\"><a href=\"#Commit-message-的格式\" class=\"headerlink\" title=\"Commit message 的格式\"></a>Commit message 的格式</h5><p>Commit message 包括三个部分：Header，Body 和 Footer</p>\n<h6 id=\"一、Header\"><a href=\"#一、Header\" class=\"headerlink\" title=\"一、Header\"></a>一、Header</h6><p><code>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）</code></p>\n<ul>\n<li><p>type</p>\n<p>type用于说明 commit 的类别，只允许使用下面的标识</p>\n<p>  feat：新增功能（feature）<br>  fix：修补bug<br>  docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等<br>  style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑<br>  refactor：重构（即不是新增功能，也不是修改bug的代码变动）<br>  test：增加测试，包括单元测试、集成测试等<br>  chore：构建过程或辅助工具的变动<br>  type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。<br>  perf: 优化相关，比如提升性能、体验<br>  revert: 回滚到上一个版本<br>  ci：自动化流程配置修改<br>注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中</p>\n</li>\n<li><p>scope</p>\n</li>\n</ul>\n<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。</p>\n<ul>\n<li>subject</li>\n</ul>\n<p>①subject是 commit 目的的简短描述，不超过50个字符。<br>②以动词开头，使用第一人称现在时，比如change，而不是changed或changes<br>③第一个字母小写<br>④结尾不加句号（.）</p>\n<h6 id=\"一、Body\"><a href=\"#一、Body\" class=\"headerlink\" title=\"一、Body\"></a>一、Body</h6><p><code>Body 部分是对本次 commit 的详细描述，可以分成多行</code></p>\n<h6 id=\"三、Footer\"><a href=\"#三、Footer\" class=\"headerlink\" title=\"三、Footer\"></a>三、Footer</h6><p>Footer 部分只用于两种情况：</p>\n<ul>\n<li>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法</li>\n<li>关闭 Issue</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #234</span><br><span class=\"line\"></span><br><span class=\"line\">也可以一次关闭多个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #123, #245, #992</span><br></pre></td></tr></table></figure>\n<h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g commitizen</span><br></pre></td></tr></table></figure>\n<h4 id=\"项目中安装\"><a href=\"#项目中安装\" class=\"headerlink\" title=\"项目中安装\"></a>项目中安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>\n<p>注意：如果是第二次配置，需要用–force：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --force</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"将未暂存文件所有变化提交到暂存区\"><a href=\"#将未暂存文件所有变化提交到暂存区\" class=\"headerlink\" title=\"将未暂存文件所有变化提交到暂存区\"></a>将未暂存文件所有变化提交到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<p>① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p>\n<p>②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add –update的缩写）。add -u 不会提交新文件。</p>\n<p>③git add -a ：是上面两个功能的合集（git add –all的缩写）</p>\n<h4 id=\"命令行输入提交命令\"><a href=\"#命令行输入提交命令\" class=\"headerlink\" title=\"命令行输入提交命令\"></a>命令行输入提交命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git cz</span><br></pre></td></tr></table></figure>\n<p>输入命令后依次提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 上、下键选择要提交的更改类型</span><br><span class=\"line\"></span><br><span class=\"line\">2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">3. 写一个简短的祈使句来描述这个变化</span><br><span class=\"line\"></span><br><span class=\"line\">4. 提供更详细的更改说明:(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">5. 有什么重大变化吗?</span><br><span class=\"line\"></span><br><span class=\"line\">6. 这一变化是否会影响</span><br><span class=\"line\">任何未解决的问题?</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"再推送到本地git仓库\"><a href=\"#再推送到本地git仓库\" class=\"headerlink\" title=\"再推送到本地git仓库\"></a>再推送到本地git仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印日志命令\"><a href=\"#打印日志命令\" class=\"headerlink\" title=\"打印日志命令\"></a>打印日志命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\"><a href=\"#输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\" class=\"headerlink\" title=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\"></a>输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件</h4><ul>\n<li>安装生成 Change log 的工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过提交记录生成 CHANGELOG.md</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ conventional-changelog -p -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印出-git-log-的日志记录（详细日志记录）\"><a href=\"#打印出-git-log-的日志记录（详细日志记录）\" class=\"headerlink\" title=\"打印出 git log 的日志记录（详细日志记录）\"></a>打印出 git log 的日志记录（详细日志记录）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log &gt; 文件名</span><br></pre></td></tr></table></figure>\n<p>参考链接： <a href=\"https://segmentfault.com/a/1190000019579621\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000019579621</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 15:52:39</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>在多人协作项目中，如果代码风格统一、代码提交信息的说明准确，那么在后期协作以及Bug处理时会更加方便。Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的。</p>\n<h5 id=\"Commit-message-的作用\"><a href=\"#Commit-message-的作用\" class=\"headerlink\" title=\"Commit message 的作用\"></a>Commit message 的作用</h5><ul>\n<li>提供更多的历史信息，方便快速浏览</li>\n<li>过滤某些commit（比如文档改动），便于快速查找信息</li>\n<li>直接从commit生成Change log</li>\n<li>可读性好，清晰，不必深入看代码即可了解当前commit的作用。</li>\n<li>为 Code Reviewing（代码审查）做准备</li>\n<li>方便跟踪工程历史</li>\n<li>提高项目的整体质量，提高个人工程素质</li>\n</ul>\n<h5 id=\"Commit-message-的格式\"><a href=\"#Commit-message-的格式\" class=\"headerlink\" title=\"Commit message 的格式\"></a>Commit message 的格式</h5><p>Commit message 包括三个部分：Header，Body 和 Footer</p>\n<h6 id=\"一、Header\"><a href=\"#一、Header\" class=\"headerlink\" title=\"一、Header\"></a>一、Header</h6><p><code>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）</code></p>\n<ul>\n<li><p>type</p>\n<p>type用于说明 commit 的类别，只允许使用下面的标识</p>\n<p>  feat：新增功能（feature）<br>  fix：修补bug<br>  docs：仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等<br>  style： 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑<br>  refactor：重构（即不是新增功能，也不是修改bug的代码变动）<br>  test：增加测试，包括单元测试、集成测试等<br>  chore：构建过程或辅助工具的变动<br>  type：代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。<br>  perf: 优化相关，比如提升性能、体验<br>  revert: 回滚到上一个版本<br>  ci：自动化流程配置修改<br>注：如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中</p>\n</li>\n<li><p>scope</p>\n</li>\n</ul>\n<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不  同。</p>\n<ul>\n<li>subject</li>\n</ul>\n<p>①subject是 commit 目的的简短描述，不超过50个字符。<br>②以动词开头，使用第一人称现在时，比如change，而不是changed或changes<br>③第一个字母小写<br>④结尾不加句号（.）</p>\n<h6 id=\"一、Body\"><a href=\"#一、Body\" class=\"headerlink\" title=\"一、Body\"></a>一、Body</h6><p><code>Body 部分是对本次 commit 的详细描述，可以分成多行</code></p>\n<h6 id=\"三、Footer\"><a href=\"#三、Footer\" class=\"headerlink\" title=\"三、Footer\"></a>三、Footer</h6><p>Footer 部分只用于两种情况：</p>\n<ul>\n<li>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法</li>\n<li>关闭 Issue</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #234</span><br><span class=\"line\"></span><br><span class=\"line\">也可以一次关闭多个 issue</span><br><span class=\"line\"></span><br><span class=\"line\">Closes #123, #245, #992</span><br></pre></td></tr></table></figure>\n<h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g commitizen</span><br></pre></td></tr></table></figure>\n<h4 id=\"项目中安装\"><a href=\"#项目中安装\" class=\"headerlink\" title=\"项目中安装\"></a>项目中安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>\n<p>注意：如果是第二次配置，需要用–force：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ commitizen init cz-conventional-changelog --save --force</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"将未暂存文件所有变化提交到暂存区\"><a href=\"#将未暂存文件所有变化提交到暂存区\" class=\"headerlink\" title=\"将未暂存文件所有变化提交到暂存区\"></a>将未暂存文件所有变化提交到暂存区</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br></pre></td></tr></table></figure>\n<p>① git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。</p>\n<p>②git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区（git add –update的缩写）。add -u 不会提交新文件。</p>\n<p>③git add -a ：是上面两个功能的合集（git add –all的缩写）</p>\n<h4 id=\"命令行输入提交命令\"><a href=\"#命令行输入提交命令\" class=\"headerlink\" title=\"命令行输入提交命令\"></a>命令行输入提交命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git cz</span><br></pre></td></tr></table></figure>\n<p>输入命令后依次提示：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 上、下键选择要提交的更改类型</span><br><span class=\"line\"></span><br><span class=\"line\">2. 此更改的范围是什么(例如组件或文件名)?(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">3. 写一个简短的祈使句来描述这个变化</span><br><span class=\"line\"></span><br><span class=\"line\">4. 提供更详细的更改说明:(按回车键跳过)</span><br><span class=\"line\"></span><br><span class=\"line\">5. 有什么重大变化吗?</span><br><span class=\"line\"></span><br><span class=\"line\">6. 这一变化是否会影响</span><br><span class=\"line\">任何未解决的问题?</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"再推送到本地git仓库\"><a href=\"#再推送到本地git仓库\" class=\"headerlink\" title=\"再推送到本地git仓库\"></a>再推送到本地git仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印日志命令\"><a href=\"#打印日志命令\" class=\"headerlink\" title=\"打印日志命令\"></a>打印日志命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\"><a href=\"#输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成-CHANGELOG-md-文件\" class=\"headerlink\" title=\"输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件\"></a>输出CHANGELOG记录，（文件名称自己设置），通过以下命令，在项目中生成 CHANGELOG.md 文件</h4><ul>\n<li>安装生成 Change log 的工具</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过提交记录生成 CHANGELOG.md</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ conventional-changelog -p -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印出-git-log-的日志记录（详细日志记录）\"><a href=\"#打印出-git-log-的日志记录（详细日志记录）\" class=\"headerlink\" title=\"打印出 git log 的日志记录（详细日志记录）\"></a>打印出 git log 的日志记录（详细日志记录）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log &gt; 文件名</span><br></pre></td></tr></table></figure>\n<p>参考链接： <a href=\"https://segmentfault.com/a/1190000019579621\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000019579621</a></p>\n"},{"title":"前端css相关面试题汇总","date":"2019-09-19T12:53:19.000Z","_content":"\n##### 什么是 BFC机制\n##### CSS3中新增的选择器以及属性\n##### 居中布局\n##### 清除浮动有哪些方法, 各有什么优缺点\n##### 用纯CSS创建一个三角形的原理是什么\n##### 实现三栏布局有哪些方法, 分别描述一下\n##### css3实现0.5px的细线\n##### link 与 @import 的区别\n##### 开发中为什么要初始化css样式\n##### CSS优化、提高性能的方法有哪些\n\n答案参考链接：https://lujinggirl.github.io/2019/09/19/cssTitle/\n\n\n\n","source":"_posts/css.md","raw":"---\ntitle: 前端css相关面试题汇总\ndate: 2019-09-19 20:53:19\ntags: 前端面试题\n---\n\n##### 什么是 BFC机制\n##### CSS3中新增的选择器以及属性\n##### 居中布局\n##### 清除浮动有哪些方法, 各有什么优缺点\n##### 用纯CSS创建一个三角形的原理是什么\n##### 实现三栏布局有哪些方法, 分别描述一下\n##### css3实现0.5px的细线\n##### link 与 @import 的区别\n##### 开发中为什么要初始化css样式\n##### CSS优化、提高性能的方法有哪些\n\n答案参考链接：https://lujinggirl.github.io/2019/09/19/cssTitle/\n\n\n\n","slug":"css","published":1,"updated":"2019-12-14T10:29:55.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjr7001678p3m0elzhbs","content":"<h5 id=\"什么是-BFC机制\"><a href=\"#什么是-BFC机制\" class=\"headerlink\" title=\"什么是 BFC机制\"></a>什么是 BFC机制</h5><h5 id=\"CSS3中新增的选择器以及属性\"><a href=\"#CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"CSS3中新增的选择器以及属性\"></a>CSS3中新增的选择器以及属性</h5><h5 id=\"居中布局\"><a href=\"#居中布局\" class=\"headerlink\" title=\"居中布局\"></a>居中布局</h5><h5 id=\"清除浮动有哪些方法-各有什么优缺点\"><a href=\"#清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"清除浮动有哪些方法, 各有什么优缺点\"></a>清除浮动有哪些方法, 各有什么优缺点</h5><h5 id=\"用纯CSS创建一个三角形的原理是什么\"><a href=\"#用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"用纯CSS创建一个三角形的原理是什么\"></a>用纯CSS创建一个三角形的原理是什么</h5><h5 id=\"实现三栏布局有哪些方法-分别描述一下\"><a href=\"#实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"实现三栏布局有哪些方法, 分别描述一下\"></a>实现三栏布局有哪些方法, 分别描述一下</h5><h5 id=\"css3实现0-5px的细线\"><a href=\"#css3实现0-5px的细线\" class=\"headerlink\" title=\"css3实现0.5px的细线\"></a>css3实现0.5px的细线</h5><h5 id=\"link-与-import-的区别\"><a href=\"#link-与-import-的区别\" class=\"headerlink\" title=\"link 与 @import 的区别\"></a>link 与 @import 的区别</h5><h5 id=\"开发中为什么要初始化css样式\"><a href=\"#开发中为什么要初始化css样式\" class=\"headerlink\" title=\"开发中为什么要初始化css样式\"></a>开发中为什么要初始化css样式</h5><h5 id=\"CSS优化、提高性能的方法有哪些\"><a href=\"#CSS优化、提高性能的方法有哪些\" class=\"headerlink\" title=\"CSS优化、提高性能的方法有哪些\"></a>CSS优化、提高性能的方法有哪些</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/19/cssTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/19/cssTitle/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"什么是-BFC机制\"><a href=\"#什么是-BFC机制\" class=\"headerlink\" title=\"什么是 BFC机制\"></a>什么是 BFC机制</h5><h5 id=\"CSS3中新增的选择器以及属性\"><a href=\"#CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"CSS3中新增的选择器以及属性\"></a>CSS3中新增的选择器以及属性</h5><h5 id=\"居中布局\"><a href=\"#居中布局\" class=\"headerlink\" title=\"居中布局\"></a>居中布局</h5><h5 id=\"清除浮动有哪些方法-各有什么优缺点\"><a href=\"#清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"清除浮动有哪些方法, 各有什么优缺点\"></a>清除浮动有哪些方法, 各有什么优缺点</h5><h5 id=\"用纯CSS创建一个三角形的原理是什么\"><a href=\"#用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"用纯CSS创建一个三角形的原理是什么\"></a>用纯CSS创建一个三角形的原理是什么</h5><h5 id=\"实现三栏布局有哪些方法-分别描述一下\"><a href=\"#实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"实现三栏布局有哪些方法, 分别描述一下\"></a>实现三栏布局有哪些方法, 分别描述一下</h5><h5 id=\"css3实现0-5px的细线\"><a href=\"#css3实现0-5px的细线\" class=\"headerlink\" title=\"css3实现0.5px的细线\"></a>css3实现0.5px的细线</h5><h5 id=\"link-与-import-的区别\"><a href=\"#link-与-import-的区别\" class=\"headerlink\" title=\"link 与 @import 的区别\"></a>link 与 @import 的区别</h5><h5 id=\"开发中为什么要初始化css样式\"><a href=\"#开发中为什么要初始化css样式\" class=\"headerlink\" title=\"开发中为什么要初始化css样式\"></a>开发中为什么要初始化css样式</h5><h5 id=\"CSS优化、提高性能的方法有哪些\"><a href=\"#CSS优化、提高性能的方法有哪些\" class=\"headerlink\" title=\"CSS优化、提高性能的方法有哪些\"></a>CSS优化、提高性能的方法有哪些</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/19/cssTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/19/cssTitle/</a></p>\n"},{"title":"express： 实现本地代码+本地mock+环境接口数据","date":"2019-09-20T09:29:05.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 17:29:05\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```\n","source":"_posts/express.md","raw":"---\ntitle: express： 实现本地代码+本地mock+环境接口数据\ndate: 2019-09-20 17:29:05\ntags: node\n---\n\nAuthor: Echo\nTime: 2019-09-20 17:29:05\n\n### express\n\n* 简介\n基于 Node.js 平台，快速、开放、极简的 Web 开发框架\n\n简单来说，封装了node中http核心模块，专注于业务逻辑的开发.\n\nexpress中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展\n* 安装\n```\n& npm install express --save-dev\n```\n\n>以vue项目为例\n在根目录下新建api文件->server.js文件。\n\n\n###### 安装其他依赖: \n* body-parser\n  一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。\n\n* request: Request - Simplified HTTP client\n* klaw-sync：klaw-sync is a Node.js recursive and fast file system walker\n\n实例代码如下：\n\n```\nconst express = require('express');\nconst bodyParser = require('body-parser');\n\nconst request = require('request');\nconst path = require('path');\nconst walk = require('klaw-sync');\nconst config = require(\"../vue.config\");\n\n\nconst origin_proxy_url = 'http://origin_proxy_url.jdcloud.com'; //测试接口url\nconst local_proxy_port = 3002;                                  //本地server端口\nconst local_proxy_url = `http://localhost:${local_proxy_port}`; //本地接口url\n\n\nconst app = express();\n\n//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据\napp.use(bodyParser.urlencoded({ extended: false })); \n// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true\n\n\n// create application/json parser\napp.use(bodyParser.json());\napp.use(function (req, res, next) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n  next();\n});\n\nlet _existRoutes = [];\napp.use((req, res, next) => { //TODO post和上传还有问题\n  const { url, body, method } = req;\n  if (!~_existRoutes.indexOf(req.path)) {\n    const rurl = origin_proxy_url.replace(/\\/$/, '') + url;\n    let r = method === 'POST'\n      ? request.post({ url: rurl, form: body }, (err, httpRes, reqBody) => {\n        console.log(err, reqBody, body)\n      })\n      : request(rurl);\n    console.log(`本地未定义的请求，跳转到 ${method} ${rurl}`);\n    req.pipe(r).pipe(res);\n    return;\n  }\n  next();\n});\n\n//遍历本目录下的 *.api.js\nwalk(path.resolve('./'))\n  .filter(p => /\\.api\\.js$/.test(p.path))\n  .map(p => p.path)\n  .forEach(part => require(part)(app));\n\n\n//全局配置，只在应用启动时读取一次\n\n\n//记录注册过的路由\n_existRoutes = app._router.stack.filter(s => s.route).map(s => s.route.path);\n\napp.listen(local_proxy_port, () => {\n  console.log(`\\n\\n local server running at ${local_proxy_url} \\n\\n`);\n});\n```\n\n## 运行express服务器\n\n```\n\"scripts\": {\n    \"serve\": \"vue-cli-service serve\", // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口\n\n    // express 相关命令\n    \"server\": \"nodemon api/server.js\", //  本地express服务器\n    \"devlocal\": \"shell-exec --colored-output \\\"npm run serve --local\\\" \\\"npm run server\\\"\" \n    // 启动本地项目: 本地代码+ 本地mock接口/测试接口\n  },\n```\n* 安装运行依赖\n```\n$ npm install shell-executor --save-dev\n$ npm install nodemon --save-dev\n```\n> shell-executor: A small nodejs module to execute shell commands in parallel\n> nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中\n\n* 运行项目\n\n```\n$ npm run devlocal\n```\n","slug":"express","published":1,"updated":"2020-06-04T10:38:27.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjr8001878p34iit4jxk","content":"<p>Author: Echo<br>Time: 2019-09-20 17:29:05</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 17:29:05</p>\n<h3 id=\"express\"><a href=\"#express\" class=\"headerlink\" title=\"express\"></a>express</h3><ul>\n<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>\n</ul>\n<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>\n<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>\n<ul>\n<li>安装<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>\n</blockquote>\n<h6 id=\"安装其他依赖\"><a href=\"#安装其他依赖\" class=\"headerlink\" title=\"安装其他依赖:\"></a>安装其他依赖:</h6><ul>\n<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>\n</li>\n<li><p>request: Request - Simplified HTTP client</p>\n</li>\n<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>\n</ul>\n<p>实例代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const walk = require(&apos;klaw-sync&apos;);</span><br><span class=\"line\">const config = require(&quot;../vue.config&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class=\"line\">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class=\"line\">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const app = express();</span><br><span class=\"line\"></span><br><span class=\"line\">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class=\"line\">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// create application/json parser</span><br><span class=\"line\">app.use(bodyParser.json());</span><br><span class=\"line\">app.use(function (req, res, next) &#123;</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class=\"line\">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">let _existRoutes = [];</span><br><span class=\"line\">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class=\"line\">  const &#123; url, body, method &#125; = req;</span><br><span class=\"line\">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class=\"line\">    const rurl = origin_proxy_url.replace(/\\/$/, &apos;&apos;) + url;</span><br><span class=\"line\">    let r = method === &apos;POST&apos;</span><br><span class=\"line\">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class=\"line\">        console.log(err, reqBody, body)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      : request(rurl);</span><br><span class=\"line\">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class=\"line\">    req.pipe(r).pipe(res);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//遍历本目录下的 *.api.js</span><br><span class=\"line\">walk(path.resolve(&apos;./&apos;))</span><br><span class=\"line\">  .filter(p =&gt; /\\.api\\.js$/.test(p.path))</span><br><span class=\"line\">  .map(p =&gt; p.path)</span><br><span class=\"line\">  .forEach(part =&gt; require(part)(app));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//全局配置，只在应用启动时读取一次</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//记录注册过的路由</span><br><span class=\"line\">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class=\"line\">  console.log(`\\n\\n local server running at $&#123;local_proxy_url&#125; \\n\\n`);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行express服务器\"><a href=\"#运行express服务器\" class=\"headerlink\" title=\"运行express服务器\"></a>运行express服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class=\"line\"></span><br><span class=\"line\">    // express 相关命令</span><br><span class=\"line\">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class=\"line\">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \\&quot;npm run serve --local\\&quot; \\&quot;npm run server\\&quot;&quot; </span><br><span class=\"line\">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n<ul>\n<li>安装运行依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install shell-executor --save-dev</span><br><span class=\"line\">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>\n</blockquote>\n<ul>\n<li>运行项目</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run devlocal</span><br></pre></td></tr></table></figure>\n"},{"title":"css相关面试题","date":"2019-09-19T03:27:51.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-19 15:46:24\n\n## 1.什么是 BFC机制\n\nBFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\n* 触发条件 (以下任意一条)\n1. float的值不为none\n2. overflow的值不为visible\n3. display的值为table-cell、tabble-caption和inline-block之一\n4. position的值不为static或则releative中的任何一个\n`\n在IE下, Layout,可通过zoom:1 触发\n`\n* BFC布局与普通文档流布局区别:\n\n###### BFC布局规则:\n1. 浮动的元素会被父级计算高度(父级元素触发了BFC)\n2. 非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)\n3. margin不会传递给父级(父级触发BFC)\n4. 属于同一个BFC的两个相邻元素上下margin会重叠\n1. 普通文档流布局: 浮动的元素是不会被父级计算高度\n2. 非浮动元素会覆盖浮动元素的位置\n3. margin会传递给父级元素\n4. 两个相邻元素上下的margin会重叠\n* 开发中的应用\n1. 阻止margin重叠\n2. 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)\n3. 自适应两栏布局\n4. 可以阻止元素被浮动元素覆盖\n\n## 2. CSS3中新增的选择器以及属性\n\n* 属性选择器\n\n| 属性选择器        | 含义描述    |\n| --------   | -----:  |\n| E[att^=\"val\"]        | 属性att的值以\"val\"开头的元素      |\n| E[att$=\"val\"]        | 属性att的值以\"val\"结尾的元素      |\n| E[att*=\"val\"]        | 属性att的值包含\"val\"字符串的元素     |\n\n* 结构伪类选择器\n\t\n| 选择器        | 含义描述    |\n| --------   | -----:  |\n| E:root       | 匹配文档的根元素，对于HTML文档，就是HTML元素      |\n| E:nth-child(n)       | 匹配其父元素的第n个子元素，第一个编号为1      |\n| E:nth-last-child(n)       | 匹配其父元素的倒数第n个子元素，第一个编号为1     |\n| E:nth-of-type(n)       | 与:nth-child()作用类似，但是仅匹配使用同种标签的元素    |\n| E:nth-last-of-type(n)       | 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素    |\n| E:last-child       | 匹配父元素的最后一个子元素，等同于:nth-last-child(1)    |\n| E:first-of-type       | 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)    |\n| E:last-of-type      | 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)    |\n| E:only-child       | 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)    |\n| E:only-of-type      | 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)   |\n| E:empty     | 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素   |\n\t\ncss3新增属性\n\n| 属性        | 含义描述    | 兼容    |\n| --------   | -----:  | -----:  |\n| transition       | 设置过渡效果      |        |\n| transform       | 变换效果(移动、缩放、转动、拉长或拉伸)      |        |\n| animation       | 动画效果      |        |\n| box-shadow       | 阴影效果      |     FF3.5, Safari 4, Chrome 3   |\n| text-shadow       | 文本阴影      |    FF 3.5, Opera 10, Safari 4, Chrome 3    |\n| border-colors       | 为边框设置多种颜色      |    FF3+    |\n| boder-image       | 图片边框      |    FF 3.5, Safari 4, Chrome 3    |\n| text-overflow       | 文本截断      |    IE6+, Safari4, Chrome3, Opera10    |\n| word-wrap       | 自动换行      |    IE6+, FF 3.5, Safari 4, Chrome 3    |\n| border-radius       | 圆角边框      |    FF 3+, Safari 4 , Chrome 3    |\n| opacity       | 不透明度      |    all    |\n| box-sizing       | 控制盒模型的组成模式      |    FF3+, Opera 10, Safari 4, Chrome 3    |\n| outline       | 外边框      |    FF3+, safari 4, chrome 3, opera 10    |\n| background-size       | 不指定背景图片的尺寸      |    safari 4, chrome 3, opera 10    |\n| background-origin      | 指定背景图片从哪里开始显示      |    safari 4, chrome 3, FF 3+    |\n| background-clip       | 指定背景图片从什么位置开始裁切      |    safari 4, chrome 3    |\n| rgba       | 基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度      |    safari 4, chrome 3, FF3, opera 10    |\n\t\t\n## 3. 居中布局\n\n* 水平居中\n1. 行内元素: text-align:center\n2. 块级元素: margin:0 auto\n3. 绝对定位和移动: absolute + transform\n4. 绝对定位和负边距: absolute + margin\n5. flex布局: flex + justify-content:center\n* 垂直居中\n1. 子元素为单行文本: line-height:height;\n                    absolute + transform;\n                    flex + align-items:center;\n                    table: display:table-cell; vertical-align: middle;\n2. 利用position和top和负margin\n* 水平垂直居中\n\n1. 已知元素宽高:绝对定位+margin:auto:\n  ```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n2. 已知元素宽高:  绝对定位+负margin\n```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n3. absolute+transform\n```\n   div{\n     width: 200px;\n     height: 200px;\n     background: green;\n\n     position:absolute;\n     left:50%;    /* 定位父级的50% */\n     top:50%;\n     transform: translate(-50%,-50%); /*自己的50% */\n   }\n\n```\n4.flex + justify-content + align-items\n```\n.box{\n   height:600px;\n\n   display:flex;\n   justify-content:center;  //子元素水平居中\n   align-items:center;      //子元素垂直居中\n     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/\n    }\n  .box>div{\n    background: green;\n    width: 200px;\n    height: 200px;\n  }\n```\n## 4. 清除浮动有哪些方法, 各有什么优缺点\n\n* 使用clear属性的空元素 \n  在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\" />或<hr class=\"clear\" />来进行清理。\n\n优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大\n\n* 使用css的overflow属性 \n给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden\n\n* 使用CSS的:after伪元素 结合 :after 伪元素\n（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个\tclearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格\"020\"或点\".\"，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。\n\n优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持\n给父级元素设置高度\n简单, 代码少,好掌握 缺点: 只适用于高度固定的布局\n## 5. 用纯CSS创建一个三角形的原理是什么\n\n之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就......回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:\n1. 写一个我们最熟悉的 border应用\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 3px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n效果如下:\n2. 接下来,我们将border值增大\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n很容易发现, border渲染并不是正方形, 而是梯形的.\n\n3. 在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;\n\n4. 设置透明, 隐藏其中三个三角形\n```\n .box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:transparent transparent transparent #ef4848;\n}\n```\n三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid transparent;\n\tborder-left:50px solid #ef4848;\n}\n```\n\n这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用\n\n\n## 6. 实现三栏布局有哪些方法, 分别描述一下\n\n三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:\n\n* Flex 布局\n```\n<style>\n.container{\n  display:flex;\n  justify-content: center;\n  height: 200px;\n  background: #eee;\n}\n.left {\n   width: 200px;\n   background-color: red;\n   height: 100%;\n }\n.main {\n    background-color: yellow;\n    flex: 1;\n}\n.right {\n    width: 200px;\n    background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```\n简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。\n\n* 绝对定位布局\n```\n<style>\n.container {\n  position: relative;\n  background:#eee;\n  height:200px;\n\t}\n.main {\n  height: 200px;\n  margin: 0 120px;\n  background-color: yellow;\n\t}\n.left {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  left: 0;\n  top: 0;\n  background-color: red;\n\t}\n.right {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  background-color: green;\n  right: 0;\n  top: 0;\n}\n</style>\n\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```* \n这种方案也简单实用, 并且可以将 <div class=\"main\"></div>元素放到第一位,使得主要内容优先加载!\n\n双飞翼布局\n```\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}\t\n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n* 圣杯布局\n```\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n```\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。\n\n\n## 7. css3实现0.5px的细线\n```\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<div class=\"line\"></div>\n```\n\n## 8. link 与 @import 的区别\n\n* 从属关系区别\n@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等\n* 加载顺序区别\n加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。\n* 兼容性区别\n@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。\nDOM可控性区别\n可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。\ncss部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他\n## 9. 开发中为什么要初始化css样式\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n## 10. CSS优化、提高性能的方法有哪些?\n\n尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：\n* 内容和样式分离，易于管理和维护\n* 减少页面体积\n* css文件可以被缓存、重用，维护成本降低\n* 不使用@import\n* 避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：\n精简页面的样式文件，去掉不用的样式\n* 利用CSS继承减少代码量\n* 避免！important，可以选择其他选择器\n\n## 11. css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\n\n参考链接: https://blog.csdn.net/yushuangyushuang/article/details/79209752.\n\n\n* 预处理器 :Less,sass,Stylus.PostCSS。\n市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性，例如代码混合，嵌套选择器，继承选择器等。这些特性让CSS的结构更加具有可读性且易于维护。\n* 后处理器 :rework，postcss。对css进行处理，有的可以对css进行压缩，有的可以自动处理兼容性问题。\n\n\n参考链接：http://www.pinlue.com/article/2019/05/2002/158990051021.html","source":"_posts/cssTitle.md","raw":"---\ntitle: css相关面试题\ndate: 2019-09-19 11:27:51\ntags: css\n---\n\nAuthor: Echo\nTime: 2019-09-19 15:46:24\n\n## 1.什么是 BFC机制\n\nBFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\n* 触发条件 (以下任意一条)\n1. float的值不为none\n2. overflow的值不为visible\n3. display的值为table-cell、tabble-caption和inline-block之一\n4. position的值不为static或则releative中的任何一个\n`\n在IE下, Layout,可通过zoom:1 触发\n`\n* BFC布局与普通文档流布局区别:\n\n###### BFC布局规则:\n1. 浮动的元素会被父级计算高度(父级元素触发了BFC)\n2. 非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)\n3. margin不会传递给父级(父级触发BFC)\n4. 属于同一个BFC的两个相邻元素上下margin会重叠\n1. 普通文档流布局: 浮动的元素是不会被父级计算高度\n2. 非浮动元素会覆盖浮动元素的位置\n3. margin会传递给父级元素\n4. 两个相邻元素上下的margin会重叠\n* 开发中的应用\n1. 阻止margin重叠\n2. 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)\n3. 自适应两栏布局\n4. 可以阻止元素被浮动元素覆盖\n\n## 2. CSS3中新增的选择器以及属性\n\n* 属性选择器\n\n| 属性选择器        | 含义描述    |\n| --------   | -----:  |\n| E[att^=\"val\"]        | 属性att的值以\"val\"开头的元素      |\n| E[att$=\"val\"]        | 属性att的值以\"val\"结尾的元素      |\n| E[att*=\"val\"]        | 属性att的值包含\"val\"字符串的元素     |\n\n* 结构伪类选择器\n\t\n| 选择器        | 含义描述    |\n| --------   | -----:  |\n| E:root       | 匹配文档的根元素，对于HTML文档，就是HTML元素      |\n| E:nth-child(n)       | 匹配其父元素的第n个子元素，第一个编号为1      |\n| E:nth-last-child(n)       | 匹配其父元素的倒数第n个子元素，第一个编号为1     |\n| E:nth-of-type(n)       | 与:nth-child()作用类似，但是仅匹配使用同种标签的元素    |\n| E:nth-last-of-type(n)       | 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素    |\n| E:last-child       | 匹配父元素的最后一个子元素，等同于:nth-last-child(1)    |\n| E:first-of-type       | 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)    |\n| E:last-of-type      | 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)    |\n| E:only-child       | 匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)    |\n| E:only-of-type      | 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)   |\n| E:empty     | 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素   |\n\t\ncss3新增属性\n\n| 属性        | 含义描述    | 兼容    |\n| --------   | -----:  | -----:  |\n| transition       | 设置过渡效果      |        |\n| transform       | 变换效果(移动、缩放、转动、拉长或拉伸)      |        |\n| animation       | 动画效果      |        |\n| box-shadow       | 阴影效果      |     FF3.5, Safari 4, Chrome 3   |\n| text-shadow       | 文本阴影      |    FF 3.5, Opera 10, Safari 4, Chrome 3    |\n| border-colors       | 为边框设置多种颜色      |    FF3+    |\n| boder-image       | 图片边框      |    FF 3.5, Safari 4, Chrome 3    |\n| text-overflow       | 文本截断      |    IE6+, Safari4, Chrome3, Opera10    |\n| word-wrap       | 自动换行      |    IE6+, FF 3.5, Safari 4, Chrome 3    |\n| border-radius       | 圆角边框      |    FF 3+, Safari 4 , Chrome 3    |\n| opacity       | 不透明度      |    all    |\n| box-sizing       | 控制盒模型的组成模式      |    FF3+, Opera 10, Safari 4, Chrome 3    |\n| outline       | 外边框      |    FF3+, safari 4, chrome 3, opera 10    |\n| background-size       | 不指定背景图片的尺寸      |    safari 4, chrome 3, opera 10    |\n| background-origin      | 指定背景图片从哪里开始显示      |    safari 4, chrome 3, FF 3+    |\n| background-clip       | 指定背景图片从什么位置开始裁切      |    safari 4, chrome 3    |\n| rgba       | 基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度      |    safari 4, chrome 3, FF3, opera 10    |\n\t\t\n## 3. 居中布局\n\n* 水平居中\n1. 行内元素: text-align:center\n2. 块级元素: margin:0 auto\n3. 绝对定位和移动: absolute + transform\n4. 绝对定位和负边距: absolute + margin\n5. flex布局: flex + justify-content:center\n* 垂直居中\n1. 子元素为单行文本: line-height:height;\n                    absolute + transform;\n                    flex + align-items:center;\n                    table: display:table-cell; vertical-align: middle;\n2. 利用position和top和负margin\n* 水平垂直居中\n\n1. 已知元素宽高:绝对定位+margin:auto:\n  ```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n2. 已知元素宽高:  绝对定位+负margin\n```\n   div{\n      width: 200px;\n      height: 200px;\n      background: green;\n\n      position:absolute;\n      left:0;\n      top: 0;\n      bottom: 0;\n      right: 0;\n      margin: auto;\n  }\n```\n3. absolute+transform\n```\n   div{\n     width: 200px;\n     height: 200px;\n     background: green;\n\n     position:absolute;\n     left:50%;    /* 定位父级的50% */\n     top:50%;\n     transform: translate(-50%,-50%); /*自己的50% */\n   }\n\n```\n4.flex + justify-content + align-items\n```\n.box{\n   height:600px;\n\n   display:flex;\n   justify-content:center;  //子元素水平居中\n   align-items:center;      //子元素垂直居中\n     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/\n    }\n  .box>div{\n    background: green;\n    width: 200px;\n    height: 200px;\n  }\n```\n## 4. 清除浮动有哪些方法, 各有什么优缺点\n\n* 使用clear属性的空元素 \n  在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\" />或<hr class=\"clear\" />来进行清理。\n\n优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大\n\n* 使用css的overflow属性 \n给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。\n\n优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden\n\n* 使用CSS的:after伪元素 结合 :after 伪元素\n（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个\tclearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格\"020\"或点\".\"，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。\n\n优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持\n给父级元素设置高度\n简单, 代码少,好掌握 缺点: 只适用于高度固定的布局\n## 5. 用纯CSS创建一个三角形的原理是什么\n\n之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就......回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:\n1. 写一个我们最熟悉的 border应用\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 3px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n效果如下:\n2. 接下来,我们将border值增大\n```\n.box{\n\twidth:100px;\n\theight:100px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n很容易发现, border渲染并不是正方形, 而是梯形的.\n\n3. 在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;\n}\n```\n四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;\n\n4. 设置透明, 隐藏其中三个三角形\n```\n .box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid;\n\tborder-color:transparent transparent transparent #ef4848;\n}\n```\n三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的\n```\n.box{\n\twidth:0px;\n\theight:0px;\n\tborder: 50px solid transparent;\n\tborder-left:50px solid #ef4848;\n}\n```\n\n这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用\n\n\n## 6. 实现三栏布局有哪些方法, 分别描述一下\n\n三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:\n\n* Flex 布局\n```\n<style>\n.container{\n  display:flex;\n  justify-content: center;\n  height: 200px;\n  background: #eee;\n}\n.left {\n   width: 200px;\n   background-color: red;\n   height: 100%;\n }\n.main {\n    background-color: yellow;\n    flex: 1;\n}\n.right {\n    width: 200px;\n    background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```\n简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。\n\n* 绝对定位布局\n```\n<style>\n.container {\n  position: relative;\n  background:#eee;\n  height:200px;\n\t}\n.main {\n  height: 200px;\n  margin: 0 120px;\n  background-color: yellow;\n\t}\n.left {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  left: 0;\n  top: 0;\n  background-color: red;\n\t}\n.right {\n  position: absolute;\n  width: 100px;\n  height: 200px;\n  background-color: green;\n  right: 0;\n  top: 0;\n}\n</style>\n\n<div class=\"container\">\n  <div class=\"left\">1</div>\n  <div class=\"main\">2</div>\n  <div class=\"right\">3</div>\n</div>\n```* \n这种方案也简单实用, 并且可以将 <div class=\"main\"></div>元素放到第一位,使得主要内容优先加载!\n\n双飞翼布局\n```\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}\t\n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n* 圣杯布局\n```\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n```\n圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。\n\n\n## 7. css3实现0.5px的细线\n```\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<div class=\"line\"></div>\n```\n\n## 8. link 与 @import 的区别\n\n* 从属关系区别\n@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等\n* 加载顺序区别\n加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。\n* 兼容性区别\n@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。\nDOM可控性区别\n可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。\ncss部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他\n## 9. 开发中为什么要初始化css样式\n\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n## 10. CSS优化、提高性能的方法有哪些?\n\n尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：\n* 内容和样式分离，易于管理和维护\n* 减少页面体积\n* css文件可以被缓存、重用，维护成本降低\n* 不使用@import\n* 避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：\n精简页面的样式文件，去掉不用的样式\n* 利用CSS继承减少代码量\n* 避免！important，可以选择其他选择器\n\n## 11. css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\n\n参考链接: https://blog.csdn.net/yushuangyushuang/article/details/79209752.\n\n\n* 预处理器 :Less,sass,Stylus.PostCSS。\n市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性，例如代码混合，嵌套选择器，继承选择器等。这些特性让CSS的结构更加具有可读性且易于维护。\n* 后处理器 :rework，postcss。对css进行处理，有的可以对css进行压缩，有的可以自动处理兼容性问题。\n\n\n参考链接：http://www.pinlue.com/article/2019/05/2002/158990051021.html","slug":"cssTitle","published":1,"updated":"2019-12-14T10:29:55.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrb001a78p32pc3okdl","content":"<p>Author: Echo<br>Time: 2019-09-19 15:46:24</p>\n<h2 id=\"1-什么是-BFC机制\"><a href=\"#1-什么是-BFC机制\" class=\"headerlink\" title=\"1.什么是 BFC机制\"></a>1.什么是 BFC机制</h2><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>\n<ul>\n<li>触发条件 (以下任意一条)</li>\n</ul>\n<ol>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为table-cell、tabble-caption和inline-block之一</li>\n<li>position的值不为static或则releative中的任何一个<br><code>在IE下, Layout,可通过zoom:1 触发</code></li>\n</ol>\n<ul>\n<li>BFC布局与普通文档流布局区别:</li>\n</ul>\n<h6 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则:\"></a>BFC布局规则:</h6><ol>\n<li>浮动的元素会被父级计算高度(父级元素触发了BFC)</li>\n<li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)</li>\n<li>margin不会传递给父级(父级触发BFC)</li>\n<li>属于同一个BFC的两个相邻元素上下margin会重叠</li>\n<li>普通文档流布局: 浮动的元素是不会被父级计算高度</li>\n<li>非浮动元素会覆盖浮动元素的位置</li>\n<li>margin会传递给父级元素</li>\n<li>两个相邻元素上下的margin会重叠</li>\n</ol>\n<ul>\n<li>开发中的应用</li>\n</ul>\n<ol>\n<li>阻止margin重叠</li>\n<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)</li>\n<li>自适应两栏布局</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n</ol>\n<h2 id=\"2-CSS3中新增的选择器以及属性\"><a href=\"#2-CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"2. CSS3中新增的选择器以及属性\"></a>2. CSS3中新增的选择器以及属性</h2><ul>\n<li>属性选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E[att^=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”开头的元素</td>\n</tr>\n<tr>\n<td>E[att$=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”结尾的元素</td>\n</tr>\n<tr>\n<td>E[att*=”val”]</td>\n<td style=\"text-align:right\">属性att的值包含”val”字符串的元素</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>结构伪类选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E:root</td>\n<td style=\"text-align:right\">匹配文档的根元素，对于HTML文档，就是HTML元素</td>\n</tr>\n<tr>\n<td>E:nth-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-last-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的倒数第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:nth-last-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:last-child</td>\n<td style=\"text-align:right\">匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:first-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>\n</tr>\n<tr>\n<td>E:last-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:only-child</td>\n<td style=\"text-align:right\">匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:only-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:empty</td>\n<td style=\"text-align:right\">匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>\n</tr>\n</tbody>\n</table>\n<p>css3新增属性</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:right\">含义描述</th>\n<th style=\"text-align:right\">兼容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>transition</td>\n<td style=\"text-align:right\">设置过渡效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>transform</td>\n<td style=\"text-align:right\">变换效果(移动、缩放、转动、拉长或拉伸)</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>animation</td>\n<td style=\"text-align:right\">动画效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>box-shadow</td>\n<td style=\"text-align:right\">阴影效果</td>\n<td style=\"text-align:right\">FF3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-shadow</td>\n<td style=\"text-align:right\">文本阴影</td>\n<td style=\"text-align:right\">FF 3.5, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-colors</td>\n<td style=\"text-align:right\">为边框设置多种颜色</td>\n<td style=\"text-align:right\">FF3+</td>\n</tr>\n<tr>\n<td>boder-image</td>\n<td style=\"text-align:right\">图片边框</td>\n<td style=\"text-align:right\">FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-overflow</td>\n<td style=\"text-align:right\">文本截断</td>\n<td style=\"text-align:right\">IE6+, Safari4, Chrome3, Opera10</td>\n</tr>\n<tr>\n<td>word-wrap</td>\n<td style=\"text-align:right\">自动换行</td>\n<td style=\"text-align:right\">IE6+, FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-radius</td>\n<td style=\"text-align:right\">圆角边框</td>\n<td style=\"text-align:right\">FF 3+, Safari 4 , Chrome 3</td>\n</tr>\n<tr>\n<td>opacity</td>\n<td style=\"text-align:right\">不透明度</td>\n<td style=\"text-align:right\">all</td>\n</tr>\n<tr>\n<td>box-sizing</td>\n<td style=\"text-align:right\">控制盒模型的组成模式</td>\n<td style=\"text-align:right\">FF3+, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>outline</td>\n<td style=\"text-align:right\">外边框</td>\n<td style=\"text-align:right\">FF3+, safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-size</td>\n<td style=\"text-align:right\">不指定背景图片的尺寸</td>\n<td style=\"text-align:right\">safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-origin</td>\n<td style=\"text-align:right\">指定背景图片从哪里开始显示</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF 3+</td>\n</tr>\n<tr>\n<td>background-clip</td>\n<td style=\"text-align:right\">指定背景图片从什么位置开始裁切</td>\n<td style=\"text-align:right\">safari 4, chrome 3</td>\n</tr>\n<tr>\n<td>rgba</td>\n<td style=\"text-align:right\">基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF3, opera 10</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-居中布局\"><a href=\"#3-居中布局\" class=\"headerlink\" title=\"3. 居中布局\"></a>3. 居中布局</h2><ul>\n<li>水平居中</li>\n</ul>\n<ol>\n<li>行内元素: text-align:center</li>\n<li>块级元素: margin:0 auto</li>\n<li>绝对定位和移动: absolute + transform</li>\n<li>绝对定位和负边距: absolute + margin</li>\n<li>flex布局: flex + justify-content:center</li>\n</ol>\n<ul>\n<li>垂直居中</li>\n</ul>\n<ol>\n<li>子元素为单行文本: line-height:height;<pre><code>absolute + transform;\nflex + align-items:center;\ntable: display:table-cell; vertical-align: middle;\n</code></pre></li>\n<li>利用position和top和负margin</li>\n</ol>\n<ul>\n<li>水平垂直居中</li>\n</ul>\n<ol>\n<li><p>已知元素宽高:绝对定位+margin:auto:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知元素宽高:  绝对定位+负margin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>absolute+transform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">  position:absolute;</span><br><span class=\"line\">  left:50%;    /* 定位父级的50% */</span><br><span class=\"line\">  top:50%;</span><br><span class=\"line\">  transform: translate(-50%,-50%); /*自己的50% */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.flex + justify-content + align-items<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">   height:600px;</span><br><span class=\"line\"></span><br><span class=\"line\">   display:flex;</span><br><span class=\"line\">   justify-content:center;  //子元素水平居中</span><br><span class=\"line\">   align-items:center;      //子元素垂直居中</span><br><span class=\"line\">     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  .box&gt;div&#123;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-清除浮动有哪些方法-各有什么优缺点\"><a href=\"#4-清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"4. 清除浮动有哪些方法, 各有什么优缺点\"></a>4. 清除浮动有哪些方法, 各有什么优缺点</h2><ul>\n<li>使用clear属性的空元素<br>在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\">或<hr class=\"clear\">来进行清理。</li>\n</ul>\n<p>优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大</p>\n<ul>\n<li>使用css的overflow属性<br>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</li>\n</ul>\n<p>优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden</p>\n<ul>\n<li>使用CSS的:after伪元素 结合 :after 伪元素<br>（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个    clearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</li>\n</ul>\n<p>优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持<br>给父级元素设置高度<br>简单, 代码少,好掌握 缺点: 只适用于高度固定的布局</p>\n<h2 id=\"5-用纯CSS创建一个三角形的原理是什么\"><a href=\"#5-用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"5. 用纯CSS创建一个三角形的原理是什么\"></a>5. 用纯CSS创建一个三角形的原理是什么</h2><p>之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就……回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:</p>\n<ol>\n<li>写一个我们最熟悉的 border应用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 3px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>效果如下:</p>\n<ol start=\"2\">\n<li>接下来,我们将border值增大<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>很容易发现, border渲染并不是正方形, 而是梯形的.</p>\n<ol start=\"3\">\n<li>在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;</p>\n<ol start=\"4\">\n<li>设置透明, 隐藏其中三个三角形<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> .box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:transparent transparent transparent #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid transparent;</span><br><span class=\"line\">\tborder-left:50px solid #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用</p>\n<h2 id=\"6-实现三栏布局有哪些方法-分别描述一下\"><a href=\"#6-实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"6. 实现三栏布局有哪些方法, 分别描述一下\"></a>6. 实现三栏布局有哪些方法, 分别描述一下</h2><p>三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:</p>\n<ul>\n<li>Flex 布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display:flex;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: #eee;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">   width: 200px;</span><br><span class=\"line\">   background-color: red;</span><br><span class=\"line\">   height: 100%;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">    background-color: yellow;</span><br><span class=\"line\">    flex: 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    background-color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。</p>\n<ul>\n<li>绝对定位布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  background:#eee;</span><br><span class=\"line\">  height:200px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  margin: 0 120px;</span><br><span class=\"line\">  background-color: yellow;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  background-color: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background-color: green;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">```* </span><br><span class=\"line\">这种方案也简单实用, 并且可以将 &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;元素放到第一位,使得主要内容优先加载!</span><br><span class=\"line\"></span><br><span class=\"line\">双飞翼布局</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}    \n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 圣杯布局</span><br></pre></td></tr></table></figure>\n\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 7. css3实现0.5px的细线</span><br></pre></td></tr></table></figure>\n\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<p><div class=\"line\"></div><br><code>`</code></p>\n<h2 id=\"8-link-与-import-的区别\"><a href=\"#8-link-与-import-的区别\" class=\"headerlink\" title=\"8. link 与 @import 的区别\"></a>8. link 与 @import 的区别</h2><ul>\n<li>从属关系区别<br>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等</li>\n<li>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</li>\n<li>兼容性区别<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。<br>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。<br>css部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他<h2 id=\"9-开发中为什么要初始化css样式\"><a href=\"#9-开发中为什么要初始化css样式\" class=\"headerlink\" title=\"9. 开发中为什么要初始化css样式\"></a>9. 开发中为什么要初始化css样式</h2></li>\n</ul>\n<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>\n<h2 id=\"10-CSS优化、提高性能的方法有哪些\"><a href=\"#10-CSS优化、提高性能的方法有哪些\" class=\"headerlink\" title=\"10. CSS优化、提高性能的方法有哪些?\"></a>10. CSS优化、提高性能的方法有哪些?</h2><p>尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：</p>\n<ul>\n<li>内容和样式分离，易于管理和维护</li>\n<li>减少页面体积</li>\n<li>css文件可以被缓存、重用，维护成本降低</li>\n<li>不使用@import</li>\n<li>避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：<br>精简页面的样式文件，去掉不用的样式</li>\n<li>利用CSS继承减少代码量</li>\n<li>避免！important，可以选择其他选择器</li>\n</ul>\n<h2 id=\"11-css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\"><a href=\"#11-css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\" class=\"headerlink\" title=\"11. css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\"></a>11. css的预处理器和后处理器都有哪些吗？它们有什么区别呢？</h2><p>参考链接: <a href=\"https://blog.csdn.net/yushuangyushuang/article/details/79209752\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yushuangyushuang/article/details/79209752</a>.</p>\n<ul>\n<li>预处理器 :Less,sass,Stylus.PostCSS。<br>市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性，例如代码混合，嵌套选择器，继承选择器等。这些特性让CSS的结构更加具有可读性且易于维护。</li>\n<li>后处理器 :rework，postcss。对css进行处理，有的可以对css进行压缩，有的可以自动处理兼容性问题。</li>\n</ul>\n<p>参考链接：<a href=\"http://www.pinlue.com/article/2019/05/2002/158990051021.html\" target=\"_blank\" rel=\"noopener\">http://www.pinlue.com/article/2019/05/2002/158990051021.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-19 15:46:24</p>\n<h2 id=\"1-什么是-BFC机制\"><a href=\"#1-什么是-BFC机制\" class=\"headerlink\" title=\"1.什么是 BFC机制\"></a>1.什么是 BFC机制</h2><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>\n<ul>\n<li>触发条件 (以下任意一条)</li>\n</ul>\n<ol>\n<li>float的值不为none</li>\n<li>overflow的值不为visible</li>\n<li>display的值为table-cell、tabble-caption和inline-block之一</li>\n<li>position的值不为static或则releative中的任何一个<br><code>在IE下, Layout,可通过zoom:1 触发</code></li>\n</ol>\n<ul>\n<li>BFC布局与普通文档流布局区别:</li>\n</ul>\n<h6 id=\"BFC布局规则\"><a href=\"#BFC布局规则\" class=\"headerlink\" title=\"BFC布局规则:\"></a>BFC布局规则:</h6><ol>\n<li>浮动的元素会被父级计算高度(父级元素触发了BFC)</li>\n<li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)</li>\n<li>margin不会传递给父级(父级触发BFC)</li>\n<li>属于同一个BFC的两个相邻元素上下margin会重叠</li>\n<li>普通文档流布局: 浮动的元素是不会被父级计算高度</li>\n<li>非浮动元素会覆盖浮动元素的位置</li>\n<li>margin会传递给父级元素</li>\n<li>两个相邻元素上下的margin会重叠</li>\n</ol>\n<ul>\n<li>开发中的应用</li>\n</ul>\n<ol>\n<li>阻止margin重叠</li>\n<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)</li>\n<li>自适应两栏布局</li>\n<li>可以阻止元素被浮动元素覆盖</li>\n</ol>\n<h2 id=\"2-CSS3中新增的选择器以及属性\"><a href=\"#2-CSS3中新增的选择器以及属性\" class=\"headerlink\" title=\"2. CSS3中新增的选择器以及属性\"></a>2. CSS3中新增的选择器以及属性</h2><ul>\n<li>属性选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>属性选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E[att^=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”开头的元素</td>\n</tr>\n<tr>\n<td>E[att$=”val”]</td>\n<td style=\"text-align:right\">属性att的值以”val”结尾的元素</td>\n</tr>\n<tr>\n<td>E[att*=”val”]</td>\n<td style=\"text-align:right\">属性att的值包含”val”字符串的元素</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>结构伪类选择器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th style=\"text-align:right\">含义描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E:root</td>\n<td style=\"text-align:right\">匹配文档的根元素，对于HTML文档，就是HTML元素</td>\n</tr>\n<tr>\n<td>E:nth-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-last-child(n)</td>\n<td style=\"text-align:right\">匹配其父元素的倒数第n个子元素，第一个编号为1</td>\n</tr>\n<tr>\n<td>E:nth-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:nth-last-of-type(n)</td>\n<td style=\"text-align:right\">与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>\n</tr>\n<tr>\n<td>E:last-child</td>\n<td style=\"text-align:right\">匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:first-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>\n</tr>\n<tr>\n<td>E:last-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:only-child</td>\n<td style=\"text-align:right\">匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>\n</tr>\n<tr>\n<td>E:only-of-type</td>\n<td style=\"text-align:right\">匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>\n</tr>\n<tr>\n<td>E:empty</td>\n<td style=\"text-align:right\">匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>\n</tr>\n</tbody>\n</table>\n<p>css3新增属性</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th style=\"text-align:right\">含义描述</th>\n<th style=\"text-align:right\">兼容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>transition</td>\n<td style=\"text-align:right\">设置过渡效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>transform</td>\n<td style=\"text-align:right\">变换效果(移动、缩放、转动、拉长或拉伸)</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>animation</td>\n<td style=\"text-align:right\">动画效果</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td>box-shadow</td>\n<td style=\"text-align:right\">阴影效果</td>\n<td style=\"text-align:right\">FF3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-shadow</td>\n<td style=\"text-align:right\">文本阴影</td>\n<td style=\"text-align:right\">FF 3.5, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-colors</td>\n<td style=\"text-align:right\">为边框设置多种颜色</td>\n<td style=\"text-align:right\">FF3+</td>\n</tr>\n<tr>\n<td>boder-image</td>\n<td style=\"text-align:right\">图片边框</td>\n<td style=\"text-align:right\">FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>text-overflow</td>\n<td style=\"text-align:right\">文本截断</td>\n<td style=\"text-align:right\">IE6+, Safari4, Chrome3, Opera10</td>\n</tr>\n<tr>\n<td>word-wrap</td>\n<td style=\"text-align:right\">自动换行</td>\n<td style=\"text-align:right\">IE6+, FF 3.5, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>border-radius</td>\n<td style=\"text-align:right\">圆角边框</td>\n<td style=\"text-align:right\">FF 3+, Safari 4 , Chrome 3</td>\n</tr>\n<tr>\n<td>opacity</td>\n<td style=\"text-align:right\">不透明度</td>\n<td style=\"text-align:right\">all</td>\n</tr>\n<tr>\n<td>box-sizing</td>\n<td style=\"text-align:right\">控制盒模型的组成模式</td>\n<td style=\"text-align:right\">FF3+, Opera 10, Safari 4, Chrome 3</td>\n</tr>\n<tr>\n<td>outline</td>\n<td style=\"text-align:right\">外边框</td>\n<td style=\"text-align:right\">FF3+, safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-size</td>\n<td style=\"text-align:right\">不指定背景图片的尺寸</td>\n<td style=\"text-align:right\">safari 4, chrome 3, opera 10</td>\n</tr>\n<tr>\n<td>background-origin</td>\n<td style=\"text-align:right\">指定背景图片从哪里开始显示</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF 3+</td>\n</tr>\n<tr>\n<td>background-clip</td>\n<td style=\"text-align:right\">指定背景图片从什么位置开始裁切</td>\n<td style=\"text-align:right\">safari 4, chrome 3</td>\n</tr>\n<tr>\n<td>rgba</td>\n<td style=\"text-align:right\">基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度</td>\n<td style=\"text-align:right\">safari 4, chrome 3, FF3, opera 10</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-居中布局\"><a href=\"#3-居中布局\" class=\"headerlink\" title=\"3. 居中布局\"></a>3. 居中布局</h2><ul>\n<li>水平居中</li>\n</ul>\n<ol>\n<li>行内元素: text-align:center</li>\n<li>块级元素: margin:0 auto</li>\n<li>绝对定位和移动: absolute + transform</li>\n<li>绝对定位和负边距: absolute + margin</li>\n<li>flex布局: flex + justify-content:center</li>\n</ol>\n<ul>\n<li>垂直居中</li>\n</ul>\n<ol>\n<li>子元素为单行文本: line-height:height;<pre><code>absolute + transform;\nflex + align-items:center;\ntable: display:table-cell; vertical-align: middle;\n</code></pre></li>\n<li>利用position和top和负margin</li>\n</ol>\n<ul>\n<li>水平垂直居中</li>\n</ul>\n<ol>\n<li><p>已知元素宽高:绝对定位+margin:auto:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>已知元素宽高:  绝对定位+负margin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> div&#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">    position:absolute;</span><br><span class=\"line\">    left:0;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    bottom: 0;</span><br><span class=\"line\">    right: 0;</span><br><span class=\"line\">    margin: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>absolute+transform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div&#123;</span><br><span class=\"line\">  width: 200px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: green;</span><br><span class=\"line\"></span><br><span class=\"line\">  position:absolute;</span><br><span class=\"line\">  left:50%;    /* 定位父级的50% */</span><br><span class=\"line\">  top:50%;</span><br><span class=\"line\">  transform: translate(-50%,-50%); /*自己的50% */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.flex + justify-content + align-items<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">   height:600px;</span><br><span class=\"line\"></span><br><span class=\"line\">   display:flex;</span><br><span class=\"line\">   justify-content:center;  //子元素水平居中</span><br><span class=\"line\">   align-items:center;      //子元素垂直居中</span><br><span class=\"line\">     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  .box&gt;div&#123;</span><br><span class=\"line\">    background: green;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    height: 200px;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-清除浮动有哪些方法-各有什么优缺点\"><a href=\"#4-清除浮动有哪些方法-各有什么优缺点\" class=\"headerlink\" title=\"4. 清除浮动有哪些方法, 各有什么优缺点\"></a>4. 清除浮动有哪些方法, 各有什么优缺点</h2><ul>\n<li>使用clear属性的空元素<br>在浮动元素后使用一个空元素如<div class=\"clear\"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class=\"clear\">或<hr class=\"clear\">来进行清理。</li>\n</ul>\n<p>优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大</p>\n<ul>\n<li>使用css的overflow属性<br>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</li>\n</ul>\n<p>优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden</p>\n<ul>\n<li>使用CSS的:after伪元素 结合 :after 伪元素<br>（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个    clearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</li>\n</ul>\n<p>优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持<br>给父级元素设置高度<br>简单, 代码少,好掌握 缺点: 只适用于高度固定的布局</p>\n<h2 id=\"5-用纯CSS创建一个三角形的原理是什么\"><a href=\"#5-用纯CSS创建一个三角形的原理是什么\" class=\"headerlink\" title=\"5. 用纯CSS创建一个三角形的原理是什么\"></a>5. 用纯CSS创建一个三角形的原理是什么</h2><p>之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就……回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:</p>\n<ol>\n<li>写一个我们最熟悉的 border应用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 3px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>效果如下:</p>\n<ol start=\"2\">\n<li>接下来,我们将border值增大<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:100px;</span><br><span class=\"line\">\theight:100px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>很容易发现, border渲染并不是正方形, 而是梯形的.</p>\n<ol start=\"3\">\n<li>在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;</p>\n<ol start=\"4\">\n<li>设置透明, 隐藏其中三个三角形<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> .box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid;</span><br><span class=\"line\">\tborder-color:transparent transparent transparent #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box&#123;</span><br><span class=\"line\">\twidth:0px;</span><br><span class=\"line\">\theight:0px;</span><br><span class=\"line\">\tborder: 50px solid transparent;</span><br><span class=\"line\">\tborder-left:50px solid #ef4848;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用</p>\n<h2 id=\"6-实现三栏布局有哪些方法-分别描述一下\"><a href=\"#6-实现三栏布局有哪些方法-分别描述一下\" class=\"headerlink\" title=\"6. 实现三栏布局有哪些方法, 分别描述一下\"></a>6. 实现三栏布局有哪些方法, 分别描述一下</h2><p>三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:</p>\n<ul>\n<li>Flex 布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container&#123;</span><br><span class=\"line\">  display:flex;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background: #eee;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">   width: 200px;</span><br><span class=\"line\">   background-color: red;</span><br><span class=\"line\">   height: 100%;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">    background-color: yellow;</span><br><span class=\"line\">    flex: 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">    width: 200px;</span><br><span class=\"line\">    background-color: green;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。</p>\n<ul>\n<li>绝对定位布局<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.container &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  background:#eee;</span><br><span class=\"line\">  height:200px;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.main &#123;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  margin: 0 120px;</span><br><span class=\"line\">  background-color: yellow;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.left &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  background-color: red;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">.right &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 200px;</span><br><span class=\"line\">  background-color: green;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">```* </span><br><span class=\"line\">这种方案也简单实用, 并且可以将 &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;元素放到第一位,使得主要内容优先加载!</span><br><span class=\"line\"></span><br><span class=\"line\">双飞翼布局</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<style>\n.content {\n  float: left;\n  width: 100%;\n}\n.main {\n  height: 200px;\n  margin-left: 110px;\n  margin-right: 220px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  height: 200px;\n  width: 100px;\n  margin-left: -100%;\n  background-color: red;\n}\n.right {\n  width: 200px;\n  height: 200px;\n  float: right;\n  margin-left: -200px;\n  background-color: green;\n}    \n\n</style>\n<div class=\"content\">\n  <div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 圣杯布局</span><br></pre></td></tr></table></figure>\n\n<style>\n.container {\n  margin-left: 120px;\n  margin-right: 220px;\n}\n.main {\n  float: left;\n  width: 100%;\n  height: 300px;\n  background-color: yellow;\n}\n.left {\n  float: left;\n  width: 100px;\n  height: 300px;\n  margin-left: -100%;\n  position: relative;\n  left: -120px;\n  background-color: blue;\n}\n.right {\n  float: left;\n  width: 200px;\n  height: 300px;\n  margin-left: -200px;\n  position: relative;\n  right: -220px;\n  background-color: green;\n}\n</style>\n<div class=\"container\">\n  <div class=\"main\"></div>\n  <div class=\"left\"></div>\n  <div class=\"right\"></div>\n</div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 7. css3实现0.5px的细线</span><br></pre></td></tr></table></figure>\n\n<style>\n.line {\n    position: relative;\n}\n.line:after {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 1px;\n    background-color: #000000;\n    -webkit-transform: scaleY(.5);\n    transform: scaleY(.5);\n}\n</style>\n\n<p><div class=\"line\"></div><br><code>`</code></p>\n<h2 id=\"8-link-与-import-的区别\"><a href=\"#8-link-与-import-的区别\" class=\"headerlink\" title=\"8. link 与 @import 的区别\"></a>8. link 与 @import 的区别</h2><ul>\n<li>从属关系区别<br>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等</li>\n<li>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</li>\n<li>兼容性区别<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。<br>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。<br>css部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他<h2 id=\"9-开发中为什么要初始化css样式\"><a href=\"#9-开发中为什么要初始化css样式\" class=\"headerlink\" title=\"9. 开发中为什么要初始化css样式\"></a>9. 开发中为什么要初始化css样式</h2></li>\n</ul>\n<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>\n<h2 id=\"10-CSS优化、提高性能的方法有哪些\"><a href=\"#10-CSS优化、提高性能的方法有哪些\" class=\"headerlink\" title=\"10. CSS优化、提高性能的方法有哪些?\"></a>10. CSS优化、提高性能的方法有哪些?</h2><p>尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：</p>\n<ul>\n<li>内容和样式分离，易于管理和维护</li>\n<li>减少页面体积</li>\n<li>css文件可以被缓存、重用，维护成本降低</li>\n<li>不使用@import</li>\n<li>避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：<br>精简页面的样式文件，去掉不用的样式</li>\n<li>利用CSS继承减少代码量</li>\n<li>避免！important，可以选择其他选择器</li>\n</ul>\n<h2 id=\"11-css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\"><a href=\"#11-css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\" class=\"headerlink\" title=\"11. css的预处理器和后处理器都有哪些吗？它们有什么区别呢？\"></a>11. css的预处理器和后处理器都有哪些吗？它们有什么区别呢？</h2><p>参考链接: <a href=\"https://blog.csdn.net/yushuangyushuang/article/details/79209752\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yushuangyushuang/article/details/79209752</a>.</p>\n<ul>\n<li>预处理器 :Less,sass,Stylus.PostCSS。<br>市面上有很多CSS预处理器可供选择，且绝大多数CSS预处理器会增加一些原生CSS不具备的特性，例如代码混合，嵌套选择器，继承选择器等。这些特性让CSS的结构更加具有可读性且易于维护。</li>\n<li>后处理器 :rework，postcss。对css进行处理，有的可以对css进行压缩，有的可以自动处理兼容性问题。</li>\n</ul>\n<p>参考链接：<a href=\"http://www.pinlue.com/article/2019/05/2002/158990051021.html\" target=\"_blank\" rel=\"noopener\">http://www.pinlue.com/article/2019/05/2002/158990051021.html</a></p>\n"},{"title":"如何优化项目","date":"2020-07-27T09:22:37.000Z","_content":"\n\n\n## 一些有意思的loader 和 plugins\n---\n\n#### 如何自动加载\n`require.context`：根据自定的规则获取需要的内容。\n\n> 解决困扰：新增或减少页面每次需要更改路由配置？\n\n* 以vue项目为例，实现动态配置路由。\n\n在vue的component中按照如下格式配置页面。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> mode (模块名称)\n>> index.routes.js (该模块下路由解析配置)\n>> pages (文件统一名称)\n>>> mode.index.vue (模块下默认页面)\n>>> mode.resource.vue  (模块下其他页面)\n\n在mode中的index.routes.js中配置路由解析代码,会自动生成routes\n```\n// 第1个参数： 路径\n// 第2个参数: 是否遍历1参数下面的子文件夹\n// 第3个参数： 正则匹配对应后缀的文件\n\nlet r = require.context('./pages', false, /.vue/);\n// r是一个func,直接调用会报错。\nlet routesArr = [];\nr.keys().forEach((key) => {\n  console.log(r(key))\n  let _keyArr = key.split('.');\n  if (key.indexOf('index') != -1) {\n    routesArr.push ({\n      path: _keyArr[1],\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  } else {\n    routesArr.push ({\n      path: `${_keyArr[1]}/${_keyArr[2]}`,\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  }\n})\nexport default routesArr\n```\n在总路由地址下引用各个模块下面的路由：\n\n在`router > index.js`配置如下代码。\n```\nlet r = require.context('./components', true, /\\.routes\\.js/);\nlet routesArr: any[] = [];\nr.keys().forEach((key) => {\n  console.log(r(key));\n  routesArr = routesArr.concat(r(key).defalut);\n})\nexport const routes = [\n  {\n    path: \"/\",\n    name: 'Home',\n    components:Home\n  },\n  ...routesArr\n];\n```\n缺点： \n  1.不能按需引入\n  2.不能实现动态路由。\n优点：\n  1.规范项目结构+文件命名+路由命名\n  2.减少配置路由的困扰\n\n## 如何优化打包\n---\n\n\n#### Dll优化\n原理： 减少处理内容和步骤\njs - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)\n\n步骤： 预处理第三方库 -> 打包其他文件。\n\n* 以vue项目为例，封装Dll优化。\n\n在vue项目的bulid文件下新建`webpack.dll.js`文件\n```\nvar path = require('path')\nvar webpack = require('webpack')\nvar config = require('../config')\n\nmodule.exports = {\n  entry: {\n    // 定义提前处理的文件\n    vendor: ['vue/dist/vue.esm.js', 'vue-router']\n  },\n  output: {\n    // 将预处理打包好的文件资源，放在静态文件夹中。\n    path: path.join(__dirname, '../static/js'),\n    filename: '[name].dll.js',\n    library: '[name]_library'\n  },\n  plugins: [\n    // 在当前目录下生成一个通知，命名为[name]_manifest.json\n    new webpack.DllPlugin({\n      path:path.join(__dirname,'.', '[name]-manifest.json'),\n      name: '[name]_library' // 对应output中的library\n\n    })\n  ]\n}\n```\n在package.json 的 `scripts`中配置`npm run dll `命令\n```\n\"dll\": \"webpack --config build/webpack.dll.js\"\n```\n\n然后执行`npm run dll`命令看一下打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后在执行一下`npm run build` 命令查看一下原始打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n执行`npm run dll `命令之后会发现在`bulid`文件夹下生成了\n`vendor-manifest.json`,在`static/js`下生成了`vendor.dll.js`。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在`bulid/webpack.prod.conf.js`中配置正常打包下的文件。\n\n```\nplugins: [\n    new webpack.DllReferencePlugin({\n      //context: 在html中引入的路径。\n      context: path.join(__dirname, '..'),\n      manifest: require('./vendor-manifest.json')\n    })\n]\n```\n最后在执行一下`npm run build` 命令查看一下dll处理之后打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n很完美的节约了一些时间，时间就是金钱，时间就是生命。\n#### 如何开发插件与loader\n---\n\n> 示例问题：项目vuex过大，导致打包结果过大。\n> 处理： 按组件异步加载vuex\n\n在src/store文件夹下index文件中存储首屏加载的vuex数据;\n在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在src下新建vuePlugins/index封装插件\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n示例代码如下：\n```\nlet a = {\n  install:function(vue) {\n    vue.mixin({\n      beforeCreate:function(){\n        if (this.$options.isVuex) {\n          // 在对应页面中配置store\n          // store中存储需要按需加载的vuex相关的js文件\n          let store = this.$options.store;\n          // 动态引入vuex\n          // 注意：import的参数不能传入变量。\n          import('../store/model/'+ store).then((res) => {\n            // registerModul方法是vuex的方法;\n            this.$store.registerModule(store, res.default);\n          });\n        }\n      }\n    })\n  }\n}\nexport default a;\n```\n在main.js引入插件\n```\nimport Vuepl from \"./vuePlugins\";\nVue.use(Vuepl);\n```\n在需要懒加载vuex的页面配置\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nisVuex:true;\nstore: 'modelIndex';\n```\n\n👌了！以上就是vuex实现按需加载的栗子。\n\n大功告成✌️✌️✌️\n","source":"_posts/fixProject.md","raw":"---\ntitle: 如何优化项目\ndate: 2020-07-27 17:22:37\ntags: 前端工程化\n---\n\n\n\n## 一些有意思的loader 和 plugins\n---\n\n#### 如何自动加载\n`require.context`：根据自定的规则获取需要的内容。\n\n> 解决困扰：新增或减少页面每次需要更改路由配置？\n\n* 以vue项目为例，实现动态配置路由。\n\n在vue的component中按照如下格式配置页面。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> mode (模块名称)\n>> index.routes.js (该模块下路由解析配置)\n>> pages (文件统一名称)\n>>> mode.index.vue (模块下默认页面)\n>>> mode.resource.vue  (模块下其他页面)\n\n在mode中的index.routes.js中配置路由解析代码,会自动生成routes\n```\n// 第1个参数： 路径\n// 第2个参数: 是否遍历1参数下面的子文件夹\n// 第3个参数： 正则匹配对应后缀的文件\n\nlet r = require.context('./pages', false, /.vue/);\n// r是一个func,直接调用会报错。\nlet routesArr = [];\nr.keys().forEach((key) => {\n  console.log(r(key))\n  let _keyArr = key.split('.');\n  if (key.indexOf('index') != -1) {\n    routesArr.push ({\n      path: _keyArr[1],\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  } else {\n    routesArr.push ({\n      path: `${_keyArr[1]}/${_keyArr[2]}`,\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  }\n})\nexport default routesArr\n```\n在总路由地址下引用各个模块下面的路由：\n\n在`router > index.js`配置如下代码。\n```\nlet r = require.context('./components', true, /\\.routes\\.js/);\nlet routesArr: any[] = [];\nr.keys().forEach((key) => {\n  console.log(r(key));\n  routesArr = routesArr.concat(r(key).defalut);\n})\nexport const routes = [\n  {\n    path: \"/\",\n    name: 'Home',\n    components:Home\n  },\n  ...routesArr\n];\n```\n缺点： \n  1.不能按需引入\n  2.不能实现动态路由。\n优点：\n  1.规范项目结构+文件命名+路由命名\n  2.减少配置路由的困扰\n\n## 如何优化打包\n---\n\n\n#### Dll优化\n原理： 减少处理内容和步骤\njs - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)\n\n步骤： 预处理第三方库 -> 打包其他文件。\n\n* 以vue项目为例，封装Dll优化。\n\n在vue项目的bulid文件下新建`webpack.dll.js`文件\n```\nvar path = require('path')\nvar webpack = require('webpack')\nvar config = require('../config')\n\nmodule.exports = {\n  entry: {\n    // 定义提前处理的文件\n    vendor: ['vue/dist/vue.esm.js', 'vue-router']\n  },\n  output: {\n    // 将预处理打包好的文件资源，放在静态文件夹中。\n    path: path.join(__dirname, '../static/js'),\n    filename: '[name].dll.js',\n    library: '[name]_library'\n  },\n  plugins: [\n    // 在当前目录下生成一个通知，命名为[name]_manifest.json\n    new webpack.DllPlugin({\n      path:path.join(__dirname,'.', '[name]-manifest.json'),\n      name: '[name]_library' // 对应output中的library\n\n    })\n  ]\n}\n```\n在package.json 的 `scripts`中配置`npm run dll `命令\n```\n\"dll\": \"webpack --config build/webpack.dll.js\"\n```\n\n然后执行`npm run dll`命令看一下打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后在执行一下`npm run build` 命令查看一下原始打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n执行`npm run dll `命令之后会发现在`bulid`文件夹下生成了\n`vendor-manifest.json`,在`static/js`下生成了`vendor.dll.js`。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在`bulid/webpack.prod.conf.js`中配置正常打包下的文件。\n\n```\nplugins: [\n    new webpack.DllReferencePlugin({\n      //context: 在html中引入的路径。\n      context: path.join(__dirname, '..'),\n      manifest: require('./vendor-manifest.json')\n    })\n]\n```\n最后在执行一下`npm run build` 命令查看一下dll处理之后打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n很完美的节约了一些时间，时间就是金钱，时间就是生命。\n#### 如何开发插件与loader\n---\n\n> 示例问题：项目vuex过大，导致打包结果过大。\n> 处理： 按组件异步加载vuex\n\n在src/store文件夹下index文件中存储首屏加载的vuex数据;\n在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在src下新建vuePlugins/index封装插件\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n示例代码如下：\n```\nlet a = {\n  install:function(vue) {\n    vue.mixin({\n      beforeCreate:function(){\n        if (this.$options.isVuex) {\n          // 在对应页面中配置store\n          // store中存储需要按需加载的vuex相关的js文件\n          let store = this.$options.store;\n          // 动态引入vuex\n          // 注意：import的参数不能传入变量。\n          import('../store/model/'+ store).then((res) => {\n            // registerModul方法是vuex的方法;\n            this.$store.registerModule(store, res.default);\n          });\n        }\n      }\n    })\n  }\n}\nexport default a;\n```\n在main.js引入插件\n```\nimport Vuepl from \"./vuePlugins\";\nVue.use(Vuepl);\n```\n在需要懒加载vuex的页面配置\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nisVuex:true;\nstore: 'modelIndex';\n```\n\n👌了！以上就是vuex实现按需加载的栗子。\n\n大功告成✌️✌️✌️\n","slug":"fixProject","published":1,"updated":"2020-12-14T09:10:38.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrc001d78p3862w65lp","content":"<h2 id=\"一些有意思的loader-和-plugins\"><a href=\"#一些有意思的loader-和-plugins\" class=\"headerlink\" title=\"一些有意思的loader 和 plugins\"></a>一些有意思的loader 和 plugins</h2><hr>\n<h4 id=\"如何自动加载\"><a href=\"#如何自动加载\" class=\"headerlink\" title=\"如何自动加载\"></a>如何自动加载</h4><p><code>require.context</code>：根据自定的规则获取需要的内容。</p>\n<blockquote>\n<p>解决困扰：新增或减少页面每次需要更改路由配置？</p>\n</blockquote>\n<ul>\n<li>以vue项目为例，实现动态配置路由。</li>\n</ul>\n<p>在vue的component中按照如下格式配置页面。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<blockquote>\n<p>mode (模块名称)</p>\n<blockquote>\n<p>index.routes.js (该模块下路由解析配置)<br>pages (文件统一名称)</p>\n<blockquote>\n<p>mode.index.vue (模块下默认页面)<br>mode.resource.vue  (模块下其他页面)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>在mode中的index.routes.js中配置路由解析代码,会自动生成routes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第1个参数： 路径</span><br><span class=\"line\">// 第2个参数: 是否遍历1参数下面的子文件夹</span><br><span class=\"line\">// 第3个参数： 正则匹配对应后缀的文件</span><br><span class=\"line\"></span><br><span class=\"line\">let r = require.context(&apos;./pages&apos;, false, /.vue/);</span><br><span class=\"line\">// r是一个func,直接调用会报错。</span><br><span class=\"line\">let routesArr = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key))</span><br><span class=\"line\">  let _keyArr = key.split(&apos;.&apos;);</span><br><span class=\"line\">  if (key.indexOf(&apos;index&apos;) != -1) &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: _keyArr[1],</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: `$&#123;_keyArr[1]&#125;/$&#123;_keyArr[2]&#125;`,</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export default routesArr</span><br></pre></td></tr></table></figure></p>\n<p>在总路由地址下引用各个模块下面的路由：</p>\n<p>在<code>router &gt; index.js</code>配置如下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let r = require.context(&apos;./components&apos;, true, /\\.routes\\.js/);</span><br><span class=\"line\">let routesArr: any[] = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key));</span><br><span class=\"line\">  routesArr = routesArr.concat(r(key).defalut);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &quot;/&quot;,</span><br><span class=\"line\">    name: &apos;Home&apos;,</span><br><span class=\"line\">    components:Home</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...routesArr</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure></p>\n<p>缺点：<br>  1.不能按需引入<br>  2.不能实现动态路由。<br>优点：<br>  1.规范项目结构+文件命名+路由命名<br>  2.减少配置路由的困扰</p>\n<h2 id=\"如何优化打包\"><a href=\"#如何优化打包\" class=\"headerlink\" title=\"如何优化打包\"></a>如何优化打包</h2><hr>\n<h4 id=\"Dll优化\"><a href=\"#Dll优化\" class=\"headerlink\" title=\"Dll优化\"></a>Dll优化</h4><p>原理： 减少处理内容和步骤<br>js - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)</p>\n<p>步骤： 预处理第三方库 -&gt; 打包其他文件。</p>\n<ul>\n<li>以vue项目为例，封装Dll优化。</li>\n</ul>\n<p>在vue项目的bulid文件下新建<code>webpack.dll.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;)</span><br><span class=\"line\">var webpack = require(&apos;webpack&apos;)</span><br><span class=\"line\">var config = require(&apos;../config&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    // 定义提前处理的文件</span><br><span class=\"line\">    vendor: [&apos;vue/dist/vue.esm.js&apos;, &apos;vue-router&apos;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 将预处理打包好的文件资源，放在静态文件夹中。</span><br><span class=\"line\">    path: path.join(__dirname, &apos;../static/js&apos;),</span><br><span class=\"line\">    filename: &apos;[name].dll.js&apos;,</span><br><span class=\"line\">    library: &apos;[name]_library&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 在当前目录下生成一个通知，命名为[name]_manifest.json</span><br><span class=\"line\">    new webpack.DllPlugin(&#123;</span><br><span class=\"line\">      path:path.join(__dirname,&apos;.&apos;, &apos;[name]-manifest.json&apos;),</span><br><span class=\"line\">      name: &apos;[name]_library&apos; // 对应output中的library</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在package.json 的 <code>scripts</code>中配置<code>npm run dll</code>命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dll&quot;: &quot;webpack --config build/webpack.dll.js&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后执行<code>npm run dll</code>命令看一下打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在执行一下<code>npm run build</code> 命令查看一下原始打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>执行<code>npm run dll</code>命令之后会发现在<code>bulid</code>文件夹下生成了<br><code>vendor-manifest.json</code>,在<code>static/js</code>下生成了<code>vendor.dll.js</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在<code>bulid/webpack.prod.conf.js</code>中配置正常打包下的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      //context: 在html中引入的路径。</span><br><span class=\"line\">      context: path.join(__dirname, &apos;..&apos;),</span><br><span class=\"line\">      manifest: require(&apos;./vendor-manifest.json&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>最后在执行一下<code>npm run build</code> 命令查看一下dll处理之后打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>很完美的节约了一些时间，时间就是金钱，时间就是生命。</p>\n<h4 id=\"如何开发插件与loader\"><a href=\"#如何开发插件与loader\" class=\"headerlink\" title=\"如何开发插件与loader\"></a>如何开发插件与loader</h4><hr>\n<blockquote>\n<p>示例问题：项目vuex过大，导致打包结果过大。<br>处理： 按组件异步加载vuex</p>\n</blockquote>\n<p>在src/store文件夹下index文件中存储首屏加载的vuex数据;<br>在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>在src下新建vuePlugins/index封装插件<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>示例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  install:function(vue) &#123;</span><br><span class=\"line\">    vue.mixin(&#123;</span><br><span class=\"line\">      beforeCreate:function()&#123;</span><br><span class=\"line\">        if (this.$options.isVuex) &#123;</span><br><span class=\"line\">          // 在对应页面中配置store</span><br><span class=\"line\">          // store中存储需要按需加载的vuex相关的js文件</span><br><span class=\"line\">          let store = this.$options.store;</span><br><span class=\"line\">          // 动态引入vuex</span><br><span class=\"line\">          // 注意：import的参数不能传入变量。</span><br><span class=\"line\">          import(&apos;../store/model/&apos;+ store).then((res) =&gt; &#123;</span><br><span class=\"line\">            // registerModul方法是vuex的方法;</span><br><span class=\"line\">            this.$store.registerModule(store, res.default);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default a;</span><br></pre></td></tr></table></figure></p>\n<p>在main.js引入插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vuepl from &quot;./vuePlugins&quot;;</span><br><span class=\"line\">Vue.use(Vuepl);</span><br></pre></td></tr></table></figure></p>\n<p>在需要懒加载vuex的页面配置<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isVuex:true;</span><br><span class=\"line\">store: &apos;modelIndex&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>👌了！以上就是vuex实现按需加载的栗子。</p>\n<p>大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一些有意思的loader-和-plugins\"><a href=\"#一些有意思的loader-和-plugins\" class=\"headerlink\" title=\"一些有意思的loader 和 plugins\"></a>一些有意思的loader 和 plugins</h2><hr>\n<h4 id=\"如何自动加载\"><a href=\"#如何自动加载\" class=\"headerlink\" title=\"如何自动加载\"></a>如何自动加载</h4><p><code>require.context</code>：根据自定的规则获取需要的内容。</p>\n<blockquote>\n<p>解决困扰：新增或减少页面每次需要更改路由配置？</p>\n</blockquote>\n<ul>\n<li>以vue项目为例，实现动态配置路由。</li>\n</ul>\n<p>在vue的component中按照如下格式配置页面。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<blockquote>\n<p>mode (模块名称)</p>\n<blockquote>\n<p>index.routes.js (该模块下路由解析配置)<br>pages (文件统一名称)</p>\n<blockquote>\n<p>mode.index.vue (模块下默认页面)<br>mode.resource.vue  (模块下其他页面)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>在mode中的index.routes.js中配置路由解析代码,会自动生成routes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第1个参数： 路径</span><br><span class=\"line\">// 第2个参数: 是否遍历1参数下面的子文件夹</span><br><span class=\"line\">// 第3个参数： 正则匹配对应后缀的文件</span><br><span class=\"line\"></span><br><span class=\"line\">let r = require.context(&apos;./pages&apos;, false, /.vue/);</span><br><span class=\"line\">// r是一个func,直接调用会报错。</span><br><span class=\"line\">let routesArr = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key))</span><br><span class=\"line\">  let _keyArr = key.split(&apos;.&apos;);</span><br><span class=\"line\">  if (key.indexOf(&apos;index&apos;) != -1) &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: _keyArr[1],</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: `$&#123;_keyArr[1]&#125;/$&#123;_keyArr[2]&#125;`,</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export default routesArr</span><br></pre></td></tr></table></figure></p>\n<p>在总路由地址下引用各个模块下面的路由：</p>\n<p>在<code>router &gt; index.js</code>配置如下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let r = require.context(&apos;./components&apos;, true, /\\.routes\\.js/);</span><br><span class=\"line\">let routesArr: any[] = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key));</span><br><span class=\"line\">  routesArr = routesArr.concat(r(key).defalut);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &quot;/&quot;,</span><br><span class=\"line\">    name: &apos;Home&apos;,</span><br><span class=\"line\">    components:Home</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...routesArr</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure></p>\n<p>缺点：<br>  1.不能按需引入<br>  2.不能实现动态路由。<br>优点：<br>  1.规范项目结构+文件命名+路由命名<br>  2.减少配置路由的困扰</p>\n<h2 id=\"如何优化打包\"><a href=\"#如何优化打包\" class=\"headerlink\" title=\"如何优化打包\"></a>如何优化打包</h2><hr>\n<h4 id=\"Dll优化\"><a href=\"#Dll优化\" class=\"headerlink\" title=\"Dll优化\"></a>Dll优化</h4><p>原理： 减少处理内容和步骤<br>js - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)</p>\n<p>步骤： 预处理第三方库 -&gt; 打包其他文件。</p>\n<ul>\n<li>以vue项目为例，封装Dll优化。</li>\n</ul>\n<p>在vue项目的bulid文件下新建<code>webpack.dll.js</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;)</span><br><span class=\"line\">var webpack = require(&apos;webpack&apos;)</span><br><span class=\"line\">var config = require(&apos;../config&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    // 定义提前处理的文件</span><br><span class=\"line\">    vendor: [&apos;vue/dist/vue.esm.js&apos;, &apos;vue-router&apos;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 将预处理打包好的文件资源，放在静态文件夹中。</span><br><span class=\"line\">    path: path.join(__dirname, &apos;../static/js&apos;),</span><br><span class=\"line\">    filename: &apos;[name].dll.js&apos;,</span><br><span class=\"line\">    library: &apos;[name]_library&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 在当前目录下生成一个通知，命名为[name]_manifest.json</span><br><span class=\"line\">    new webpack.DllPlugin(&#123;</span><br><span class=\"line\">      path:path.join(__dirname,&apos;.&apos;, &apos;[name]-manifest.json&apos;),</span><br><span class=\"line\">      name: &apos;[name]_library&apos; // 对应output中的library</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在package.json 的 <code>scripts</code>中配置<code>npm run dll</code>命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dll&quot;: &quot;webpack --config build/webpack.dll.js&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后执行<code>npm run dll</code>命令看一下打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在执行一下<code>npm run build</code> 命令查看一下原始打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>执行<code>npm run dll</code>命令之后会发现在<code>bulid</code>文件夹下生成了<br><code>vendor-manifest.json</code>,在<code>static/js</code>下生成了<code>vendor.dll.js</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在<code>bulid/webpack.prod.conf.js</code>中配置正常打包下的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      //context: 在html中引入的路径。</span><br><span class=\"line\">      context: path.join(__dirname, &apos;..&apos;),</span><br><span class=\"line\">      manifest: require(&apos;./vendor-manifest.json&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>最后在执行一下<code>npm run build</code> 命令查看一下dll处理之后打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>很完美的节约了一些时间，时间就是金钱，时间就是生命。</p>\n<h4 id=\"如何开发插件与loader\"><a href=\"#如何开发插件与loader\" class=\"headerlink\" title=\"如何开发插件与loader\"></a>如何开发插件与loader</h4><hr>\n<blockquote>\n<p>示例问题：项目vuex过大，导致打包结果过大。<br>处理： 按组件异步加载vuex</p>\n</blockquote>\n<p>在src/store文件夹下index文件中存储首屏加载的vuex数据;<br>在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>在src下新建vuePlugins/index封装插件<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>示例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  install:function(vue) &#123;</span><br><span class=\"line\">    vue.mixin(&#123;</span><br><span class=\"line\">      beforeCreate:function()&#123;</span><br><span class=\"line\">        if (this.$options.isVuex) &#123;</span><br><span class=\"line\">          // 在对应页面中配置store</span><br><span class=\"line\">          // store中存储需要按需加载的vuex相关的js文件</span><br><span class=\"line\">          let store = this.$options.store;</span><br><span class=\"line\">          // 动态引入vuex</span><br><span class=\"line\">          // 注意：import的参数不能传入变量。</span><br><span class=\"line\">          import(&apos;../store/model/&apos;+ store).then((res) =&gt; &#123;</span><br><span class=\"line\">            // registerModul方法是vuex的方法;</span><br><span class=\"line\">            this.$store.registerModule(store, res.default);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default a;</span><br></pre></td></tr></table></figure></p>\n<p>在main.js引入插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vuepl from &quot;./vuePlugins&quot;;</span><br><span class=\"line\">Vue.use(Vuepl);</span><br></pre></td></tr></table></figure></p>\n<p>在需要懒加载vuex的页面配置<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isVuex:true;</span><br><span class=\"line\">store: &apos;modelIndex&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>👌了！以上就是vuex实现按需加载的栗子。</p>\n<p>大功告成✌️✌️✌️</p>\n"},{"title":"hexo deplay出错","date":"2019-07-24T07:28:39.000Z","_content":"\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：\n\n# 当部署失败的时候，请按照以下步骤进行：\n报错内容如下：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 通过SSH key来上传代码\n###### 1将SSH key添加到github中\n① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）\n###### 2测试设置是否成功：\n```\n$ ssh -T git@github.com\n```\n如果出现如下情况\n```\nHi username! You've successfully authenticated, but GitHub does not \nprovide shell access.\n```\n将项目中如下位置文件做出更改\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不要使用https，而是改为SSH，如下：\n```\nrepository: https://github.com/username/username.github.io.git\n```\n修改为\n```\nrepo：git@github.com:username/username.github.io.git\n```\n一般这步基本就可以部署了！！！\n如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）\n```\n删除.deploy_git\n$ hexo clean \n$ hexo g\n$ hexo d\n```\n本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！\n\n\n\n","source":"_posts/hexoDeplayBug.md","raw":"---\ntitle: hexo deplay出错\ndate: 2019-07-24 15:28:39\ntags: blog-hexo\n---\n\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n\n今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：\n\n# 当部署失败的时候，请按照以下步骤进行：\n报错内容如下：\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n# 通过SSH key来上传代码\n###### 1将SSH key添加到github中\n① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。\n\n② 登陆github，点击头像位置处 Settings ——> SSH and GPG keys ——> New SSH key，点击新建SSH key。\n\n③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）\n###### 2测试设置是否成功：\n```\n$ ssh -T git@github.com\n```\n如果出现如下情况\n```\nHi username! You've successfully authenticated, but GitHub does not \nprovide shell access.\n```\n将项目中如下位置文件做出更改\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n不要使用https，而是改为SSH，如下：\n```\nrepository: https://github.com/username/username.github.io.git\n```\n修改为\n```\nrepo：git@github.com:username/username.github.io.git\n```\n一般这步基本就可以部署了！！！\n如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）\n```\n删除.deploy_git\n$ hexo clean \n$ hexo g\n$ hexo d\n```\n本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！\n\n\n\n","slug":"hexoDeplayBug","published":1,"updated":"2019-12-04T12:50:48.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrd001f78p3o60l9bh2","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：</p>\n<h1 id=\"当部署失败的时候，请按照以下步骤进行：\"><a href=\"#当部署失败的时候，请按照以下步骤进行：\" class=\"headerlink\" title=\"当部署失败的时候，请按照以下步骤进行：\"></a>当部署失败的时候，请按照以下步骤进行：</h1><p>报错内容如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h1 id=\"通过SSH-key来上传代码\"><a href=\"#通过SSH-key来上传代码\" class=\"headerlink\" title=\"通过SSH key来上传代码\"></a>通过SSH key来上传代码</h1><h6 id=\"1将SSH-key添加到github中\"><a href=\"#1将SSH-key添加到github中\" class=\"headerlink\" title=\"1将SSH key添加到github中\"></a>1将SSH key添加到github中</h6><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）</p>\n<h6 id=\"2测试设置是否成功：\"><a href=\"#2测试设置是否成功：\" class=\"headerlink\" title=\"2测试设置是否成功：\"></a>2测试设置是否成功：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>如果出现如下情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&apos;ve successfully authenticated, but GitHub does not </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure></p>\n<p>将项目中如下位置文件做出更改<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>不要使用https，而是改为SSH，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repository: https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo：git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>一般这步基本就可以部署了！！！<br>如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除.deploy_git</span><br><span class=\"line\">$ hexo clean </span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<p>今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：</p>\n<h1 id=\"当部署失败的时候，请按照以下步骤进行：\"><a href=\"#当部署失败的时候，请按照以下步骤进行：\" class=\"headerlink\" title=\"当部署失败的时候，请按照以下步骤进行：\"></a>当部署失败的时候，请按照以下步骤进行：</h1><p>报错内容如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h1 id=\"通过SSH-key来上传代码\"><a href=\"#通过SSH-key来上传代码\" class=\"headerlink\" title=\"通过SSH key来上传代码\"></a>通过SSH key来上传代码</h1><h6 id=\"1将SSH-key添加到github中\"><a href=\"#1将SSH-key添加到github中\" class=\"headerlink\" title=\"1将SSH key添加到github中\"></a>1将SSH key添加到github中</h6><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>\n<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>\n<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）</p>\n<h6 id=\"2测试设置是否成功：\"><a href=\"#2测试设置是否成功：\" class=\"headerlink\" title=\"2测试设置是否成功：\"></a>2测试设置是否成功：</h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>如果出现如下情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi username! You&apos;ve successfully authenticated, but GitHub does not </span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure></p>\n<p>将项目中如下位置文件做出更改<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>不要使用https，而是改为SSH，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repository: https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo：git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure></p>\n<p>一般这步基本就可以部署了！！！<br>如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">删除.deploy_git</span><br><span class=\"line\">$ hexo clean </span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure></p>\n<p>本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！</p>\n"},{"title":"前端js相关面试题汇总","date":"2019-09-19T12:45:32.000Z","_content":"\n#### promise \n答案参考链接：https://lujinggirl.github.io/2019/08/26/promise/\n#### 宏任务、微任务\n答案参考链接：https://lujinggirl.github.io/2019/08/21/JS-thread/","source":"_posts/js.md","raw":"---\ntitle: 前端js相关面试题汇总\ndate: 2019-09-19 20:45:32\ntags: 前端面试题\n---\n\n#### promise \n答案参考链接：https://lujinggirl.github.io/2019/08/26/promise/\n#### 宏任务、微任务\n答案参考链接：https://lujinggirl.github.io/2019/08/21/JS-thread/","slug":"js","published":1,"updated":"2019-12-04T12:50:48.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjre001i78p308v9bbhx","content":"<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/26/promise/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/26/promise/</a></p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/21/JS-thread/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/21/JS-thread/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/26/promise/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/26/promise/</a></p>\n<h4 id=\"宏任务、微任务\"><a href=\"#宏任务、微任务\" class=\"headerlink\" title=\"宏任务、微任务\"></a>宏任务、微任务</h4><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/08/21/JS-thread/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/08/21/JS-thread/</a></p>\n"},{"title":"前端工程化工具 ---- module-alias","date":"2020-12-14T06:55:21.000Z","_content":"\n使用建议：nodejs的模块引用，使用相对路径，会造成写一堆../，非常不便。\n## 一、安装[module-alias](yihttps://www.npmjs.com/package/module-alias)\n```\nnpm install module-alias --save\n```\n## 二、使用[module-alias](yihttps://www.npmjs.com/package/module-alias)\n注：这里@root就是别名，后面引号内的内容就是原路径\n```\n\"_moduleAliases\": {\n  \"@root\": \".\",\n  \"@app\": \"app\"\n},\n```\n配置文件引入 `require(‘module-alias/register’);`\n```\nrequire('module-alias/register');\nimport BaseController from '@root/baseController';\n```\n## 三、ts做特殊映射\n在`tsconfig.json`文件中添加相应的映射\n```\n\"compilerOptions\": {\n    \"paths\": {\n      \"@root/*\": \"[\"./*\"]\",\n      \"@app/*\": [\"./app/*\"],\n    }\n```\n大功告成✌️✌️✌️\n","source":"_posts/moduleAlias.md","raw":"---\ntitle: 前端工程化工具 ---- module-alias\ndate: 2020-12-14 14:55:21\ntags: 前端工程化\n---\n\n使用建议：nodejs的模块引用，使用相对路径，会造成写一堆../，非常不便。\n## 一、安装[module-alias](yihttps://www.npmjs.com/package/module-alias)\n```\nnpm install module-alias --save\n```\n## 二、使用[module-alias](yihttps://www.npmjs.com/package/module-alias)\n注：这里@root就是别名，后面引号内的内容就是原路径\n```\n\"_moduleAliases\": {\n  \"@root\": \".\",\n  \"@app\": \"app\"\n},\n```\n配置文件引入 `require(‘module-alias/register’);`\n```\nrequire('module-alias/register');\nimport BaseController from '@root/baseController';\n```\n## 三、ts做特殊映射\n在`tsconfig.json`文件中添加相应的映射\n```\n\"compilerOptions\": {\n    \"paths\": {\n      \"@root/*\": \"[\"./*\"]\",\n      \"@app/*\": [\"./app/*\"],\n    }\n```\n大功告成✌️✌️✌️\n","slug":"moduleAlias","published":1,"updated":"2020-12-14T08:31:00.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrg001k78p3aavqsfpv","content":"<p>使用建议：nodejs的模块引用，使用相对路径，会造成写一堆../，非常不便。</p>\n<h2 id=\"一、安装module-alias\"><a href=\"#一、安装module-alias\" class=\"headerlink\" title=\"一、安装module-alias\"></a>一、安装<a href=\"yihttps://www.npmjs.com/package/module-alias\" target=\"_blank\" rel=\"noopener\">module-alias</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install module-alias --save</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、使用module-alias\"><a href=\"#二、使用module-alias\" class=\"headerlink\" title=\"二、使用module-alias\"></a>二、使用<a href=\"yihttps://www.npmjs.com/package/module-alias\" target=\"_blank\" rel=\"noopener\">module-alias</a></h2><p>注：这里@root就是别名，后面引号内的内容就是原路径<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;_moduleAliases&quot;: &#123;</span><br><span class=\"line\">  &quot;@root&quot;: &quot;.&quot;,</span><br><span class=\"line\">  &quot;@app&quot;: &quot;app&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>配置文件引入 <code>require(‘module-alias/register’);</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;module-alias/register&apos;);</span><br><span class=\"line\">import BaseController from &apos;@root/baseController&apos;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、ts做特殊映射\"><a href=\"#三、ts做特殊映射\" class=\"headerlink\" title=\"三、ts做特殊映射\"></a>三、ts做特殊映射</h2><p>在<code>tsconfig.json</code>文件中添加相应的映射<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;paths&quot;: &#123;</span><br><span class=\"line\">      &quot;@root/*&quot;: &quot;[&quot;./*&quot;]&quot;,</span><br><span class=\"line\">      &quot;@app/*&quot;: [&quot;./app/*&quot;],</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用建议：nodejs的模块引用，使用相对路径，会造成写一堆../，非常不便。</p>\n<h2 id=\"一、安装module-alias\"><a href=\"#一、安装module-alias\" class=\"headerlink\" title=\"一、安装module-alias\"></a>一、安装<a href=\"yihttps://www.npmjs.com/package/module-alias\" target=\"_blank\" rel=\"noopener\">module-alias</a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install module-alias --save</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、使用module-alias\"><a href=\"#二、使用module-alias\" class=\"headerlink\" title=\"二、使用module-alias\"></a>二、使用<a href=\"yihttps://www.npmjs.com/package/module-alias\" target=\"_blank\" rel=\"noopener\">module-alias</a></h2><p>注：这里@root就是别名，后面引号内的内容就是原路径<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;_moduleAliases&quot;: &#123;</span><br><span class=\"line\">  &quot;@root&quot;: &quot;.&quot;,</span><br><span class=\"line\">  &quot;@app&quot;: &quot;app&quot;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>配置文件引入 <code>require(‘module-alias/register’);</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;module-alias/register&apos;);</span><br><span class=\"line\">import BaseController from &apos;@root/baseController&apos;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、ts做特殊映射\"><a href=\"#三、ts做特殊映射\" class=\"headerlink\" title=\"三、ts做特殊映射\"></a>三、ts做特殊映射</h2><p>在<code>tsconfig.json</code>文件中添加相应的映射<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    &quot;paths&quot;: &#123;</span><br><span class=\"line\">      &quot;@root/*&quot;: &quot;[&quot;./*&quot;]&quot;,</span><br><span class=\"line\">      &quot;@app/*&quot;: [&quot;./app/*&quot;],</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>大功告成✌️✌️✌️</p>\n"},{"title":"模拟element-ui写message组件思路","date":"2019-08-15T08:05:21.000Z","_content":"Author: Echo\nTime: 2019-08-15 16:05:21\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 写一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 写一个 message.js\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行一下代码：\n![image](https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n再见吧！\n\n参考 连接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n","source":"_posts/message-comp.md","raw":"---\ntitle: 模拟element-ui写message组件思路\ndate: 2019-08-15 16:05:21\ntags: vue\n---\nAuthor: Echo\nTime: 2019-08-15 16:05:21\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 写一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 写一个 message.js\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行一下代码：\n![image](https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n再见吧！\n\n参考 连接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n","slug":"message-comp","published":1,"updated":"2019-12-04T12:50:48.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjri001m78p3guihpfz0","content":"<p>Author: Echo<br>Time: 2019-08-15 16:05:21</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"写一个-message-组件\"><a href=\"#写一个-message-组件\" class=\"headerlink\" title=\"写一个 message 组件\"></a>写一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"写一个-message-js\"><a href=\"#写一个-message-js\" class=\"headerlink\" title=\"写一个 message.js\"></a>写一个 message.js</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>运行一下代码：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"duration-lt-0-message一直存在\"><a href=\"#duration-lt-0-message一直存在\" class=\"headerlink\" title=\"duration &lt;= 0,message一直存在\"></a>duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>再见吧！</p>\n<p>参考 连接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-15 16:05:21</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"写一个-message-组件\"><a href=\"#写一个-message-组件\" class=\"headerlink\" title=\"写一个 message 组件\"></a>写一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"写一个-message-js\"><a href=\"#写一个-message-js\" class=\"headerlink\" title=\"写一个 message.js\"></a>写一个 message.js</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>运行一下代码：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"duration-lt-0-message一直存在\"><a href=\"#duration-lt-0-message一直存在\" class=\"headerlink\" title=\"duration &lt;= 0,message一直存在\"></a>duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>再见吧！</p>\n<p>参考 连接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n"},{"title":"node 基础知识","date":"2019-08-14T07:37:18.000Z","_content":"Author: Echo\nTime: 2019-08-14 15:37:18\n\n# 有助于理解前端工具的 node 知识\n\n## 缘起\n平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。\n想想我们是不是时常看到过这种东西：`const path = require('path');`。\n假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。\n后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。\n言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。\n ## node 初识\n#### node 是什么\n首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。\n#### node 遵循的规范\n其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：\n```\nrequire('./module')\nmodule.exports = {\n    a: 1,\n}\nexports.a = 1;\n\n```\n这就是 node 的规范，用` require` 导入、用 `module.exports` 导出。那 node 为什么不支持 ESM（就是用 `import` 导入、用 `export` 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 `require()` 字样却没有看见 `import()`就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 `require()`。\n\n这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：\n\n![16ad4be6bc803f68.png](https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## require 寻找依赖\nrequire() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：\n```\nrequire('./module'); // 带相对路径\nrequire('/module'); // 带绝对路径\nrequire('module'); // 不带路径\n```\n这种不带路径的 `require('module') `引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。\n\n另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。\n## node 模块包装\nnode 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：\n```\n(function(exports, require, module, __filename, __dirname) {\n    // module: 表示当前模块\n    // __filename: 当前模块的带有完整绝对路径的文件名\n    // __dirname: 当前模块的完整绝对路径\n    module.exports = exports = this = {};\n    // 我们的代码就在这里...\n    return module.exports;\n})()\n```\n想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。\n## node 的应用场景\n一般来说，node 主要应用于以下几个方面：\n\n* 自动化构建等工具\n* 中间层\n* 小项目\n\n第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。\n## node 的优点\n\n* 适合前端大大们\n* 基于事件驱动和无阻塞的I/O（适合处理并发请求）\n* 性能较好（别人做过性能分析）\n\n## node 内置模块\nok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。\n### http 模块\n这是 node 最最基础的功能了，我们用 `node http.js` 运行一下下面的文件就能开启一个服务器，在浏览器中输入 `http://localhost:8888` 即可访问，http.js 具体内容如下：\n```\n// http.js\nconst http = require('http');\nhttp.createServer((req, res) => { // 开启一个服务\n  console.log('请求来了'); // 如果你打开 http://localhost:8888，控制台就会打印此消息\n  res.write('hello'); // 返回给页面的值，也就是页面会显示 hello\n  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态\n}).listen(8888); // 端口号\n```\n### fs 文件系统\n\n由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 `<input type='file'>`），但是需要用户手动操作才行。\n但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：\n\n```\nconst fs = require('fs');\n\n// 写入文件：fs.writeFile(path, fileData, cb);\nfs.writeFile('./text.txt', 'hello xr!', err => {\n  if (err) {\n    console.log('写入失败', err);\n  } else {\n    console.log('写入成功');\n  }\n});\n\n// 读取文件：fs.readFile(path, cb);\nfs.readFile('./text.txt', (err, fileData) => {\n  if (err) {\n    console.log('读取失败', err);\n  } else {\n    console.log('读取成功', fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下\n  }\n});\n```\n\n需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em...就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 `toString()` 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 `toString()` 转换的话会丢失掉原始信息，所以不能乱转。二进制和 `toString` 的效果就像下面这样：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。\n## path 路径\n这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：\n```\nconst path = require('path');\n\nlet str = '/root/a/b/index.html';\nconsole.log(path.dirname(str)); // 路径\n// /root/a/b\nconsole.log(path.extname(str)); // 后缀名\n// .html\nconsole.log(path.basename(str)); // 文件名\n// index.html\n\n// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径\nlet pathOne = path.resolve('rooot/a/b', '../c', 'd', '..', 'e');\n\n// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录\nlet pathTwo = path.resolve(__dirname, 'build'); // 这个用法很常见，你应该在 webpack 中有见过\n\nconsole.log(pathOne, pathTwo, __dirname);\n// pathOne  =>  /Users/lgq/Desktop/node/rooot/a/c/e\n// pathTwo  =>  /Users/lgq/Desktop/node/build\n// __dirname  =>  /Users/lgq/Desktop/node\n```\n嗯，下次看到 path 这个东西就不会迷茫了。\n### url 模块\n\n很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：\n\n```\nconst url = require('url');\n\nlet site = 'http://www.xr.com/a/b/index.html?a=1&b=2';\nlet { pathname, query } = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象\n\nconsole.log(pathname, query);\n// /a/b/index.html  { a: '1', b: '2' }\n```\n\n### querystring 查询字符串\n\n这个主要是用来把形如这样的字符串 `a=1&b=2&c=3`（&和=可以换成别的）解析成 `{ a: '1', b: '2', c: '3' }` 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：\n\n```\nconst querystring = require('querystring');\n\nlet query = 'a=1&b=2&c=3'; // 形如这样的字符串就能被解析\nlet obj = querystring.parse(query);\nconsole.log(obj, obj.a); // { a: '1', b: '2', c: '3' }   '1'\n\nquery = 'a=1&b=2&c=3&a=3'; // 如果参数重复，其所对应的值会变成数组\nobj = querystring.parse(query);\nconsole.log(obj); // { a: [ '1', '3' ], b: '2', c: '3' }\n\n// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串\nquery = querystring.stringify(obj);\nconsole.log(query); // a=1&a=3&b=2&c=3\n```\n\n### assert 断言\n\n这个我们直接看下面代码就知道它的作用了：\n\n```\n// assert.js\nconst assert = require('assert');\n\n// assert(条件，错误消息)，条件这部分会返回一个布尔值\nassert(2 < 1, '断言失败');\n```\n\n`node assert.js` 运行一下代码就能看到如下结果：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 `false` 则阻止程序运行，并抛出一个错误，如果返回值为 `true` 则继续执行，一般用于函数中间和参数判断。\n另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：\n\n```\n// assert.js\nconst assert = require('assert');\n\nconst obj1 = { a: { b: 1 } };\nconst obj2 = { a: { b: 1 } };\nconst obj3 = { a: { b: '1' } };\n\n// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值\n// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值\n// 同样也是错误的时候抛出信息，正确的时候继续默默执行\nassert.deepEqual(obj1, obj2, '不等哦'); // true\nassert.deepEqual(obj1, obj3, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj2, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj3, '不等哦'); // false，这个会抛出错误信息\n```\n\n### stream 流\n\nstream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 `fs.readFile` 和 `fs.writeFile` 的升级版。\n我们要知道 `readFile` 和 `writeFile` 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。\n\n```\nconst fs = require('fs');\n\n// 读取流：fs.createReadStream();\n// 写入流：fs.createWriteStream();\nlet rs = fs.createReadStream('a.txt'); // 要读取的文件\nlet ws = fs.createWriteStream('a2.txt'); // 输出的文件\n\nrs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n\n```\n\n流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。\n\n### zlib 压缩\n\n这个用法简单，作用也明了，直接看下面的代码就能理解：\n\n```\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nlet rs = fs.createReadStream('tree.jpg');\nlet gz = zlib.createGzip();\nlet ws = fs.createWriteStream('tree.jpg.gz');\n\nrs.pipe(gz).pipe(ws);  // 原始文件 => 压缩 => 写入\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n```\n\n## 小结\n\nok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。\n参考作者：尤水就下\n参考链接：https://juejin.im/post/5ccacfb96fb9a03201243cb9","source":"_posts/nodeBasics.md","raw":"---\ntitle: node 基础知识\ndate: 2019-08-14 15:37:18\ntags: node\n---\nAuthor: Echo\nTime: 2019-08-14 15:37:18\n\n# 有助于理解前端工具的 node 知识\n\n## 缘起\n平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。\n想想我们是不是时常看到过这种东西：`const path = require('path');`。\n假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。\n后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。\n言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。\n ## node 初识\n#### node 是什么\n首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。\n#### node 遵循的规范\n其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：\n```\nrequire('./module')\nmodule.exports = {\n    a: 1,\n}\nexports.a = 1;\n\n```\n这就是 node 的规范，用` require` 导入、用 `module.exports` 导出。那 node 为什么不支持 ESM（就是用 `import` 导入、用 `export` 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 `require()` 字样却没有看见 `import()`就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 `require()`。\n\n这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：\n\n![16ad4be6bc803f68.png](https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## require 寻找依赖\nrequire() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：\n```\nrequire('./module'); // 带相对路径\nrequire('/module'); // 带绝对路径\nrequire('module'); // 不带路径\n```\n这种不带路径的 `require('module') `引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。\n\n另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。\n## node 模块包装\nnode 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：\n```\n(function(exports, require, module, __filename, __dirname) {\n    // module: 表示当前模块\n    // __filename: 当前模块的带有完整绝对路径的文件名\n    // __dirname: 当前模块的完整绝对路径\n    module.exports = exports = this = {};\n    // 我们的代码就在这里...\n    return module.exports;\n})()\n```\n想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。\n## node 的应用场景\n一般来说，node 主要应用于以下几个方面：\n\n* 自动化构建等工具\n* 中间层\n* 小项目\n\n第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。\n## node 的优点\n\n* 适合前端大大们\n* 基于事件驱动和无阻塞的I/O（适合处理并发请求）\n* 性能较好（别人做过性能分析）\n\n## node 内置模块\nok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。\n### http 模块\n这是 node 最最基础的功能了，我们用 `node http.js` 运行一下下面的文件就能开启一个服务器，在浏览器中输入 `http://localhost:8888` 即可访问，http.js 具体内容如下：\n```\n// http.js\nconst http = require('http');\nhttp.createServer((req, res) => { // 开启一个服务\n  console.log('请求来了'); // 如果你打开 http://localhost:8888，控制台就会打印此消息\n  res.write('hello'); // 返回给页面的值，也就是页面会显示 hello\n  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态\n}).listen(8888); // 端口号\n```\n### fs 文件系统\n\n由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 `<input type='file'>`），但是需要用户手动操作才行。\n但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：\n\n```\nconst fs = require('fs');\n\n// 写入文件：fs.writeFile(path, fileData, cb);\nfs.writeFile('./text.txt', 'hello xr!', err => {\n  if (err) {\n    console.log('写入失败', err);\n  } else {\n    console.log('写入成功');\n  }\n});\n\n// 读取文件：fs.readFile(path, cb);\nfs.readFile('./text.txt', (err, fileData) => {\n  if (err) {\n    console.log('读取失败', err);\n  } else {\n    console.log('读取成功', fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下\n  }\n});\n```\n\n需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em...就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 `toString()` 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 `toString()` 转换的话会丢失掉原始信息，所以不能乱转。二进制和 `toString` 的效果就像下面这样：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。\n## path 路径\n这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：\n```\nconst path = require('path');\n\nlet str = '/root/a/b/index.html';\nconsole.log(path.dirname(str)); // 路径\n// /root/a/b\nconsole.log(path.extname(str)); // 后缀名\n// .html\nconsole.log(path.basename(str)); // 文件名\n// index.html\n\n// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径\nlet pathOne = path.resolve('rooot/a/b', '../c', 'd', '..', 'e');\n\n// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录\nlet pathTwo = path.resolve(__dirname, 'build'); // 这个用法很常见，你应该在 webpack 中有见过\n\nconsole.log(pathOne, pathTwo, __dirname);\n// pathOne  =>  /Users/lgq/Desktop/node/rooot/a/c/e\n// pathTwo  =>  /Users/lgq/Desktop/node/build\n// __dirname  =>  /Users/lgq/Desktop/node\n```\n嗯，下次看到 path 这个东西就不会迷茫了。\n### url 模块\n\n很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：\n\n```\nconst url = require('url');\n\nlet site = 'http://www.xr.com/a/b/index.html?a=1&b=2';\nlet { pathname, query } = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象\n\nconsole.log(pathname, query);\n// /a/b/index.html  { a: '1', b: '2' }\n```\n\n### querystring 查询字符串\n\n这个主要是用来把形如这样的字符串 `a=1&b=2&c=3`（&和=可以换成别的）解析成 `{ a: '1', b: '2', c: '3' }` 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：\n\n```\nconst querystring = require('querystring');\n\nlet query = 'a=1&b=2&c=3'; // 形如这样的字符串就能被解析\nlet obj = querystring.parse(query);\nconsole.log(obj, obj.a); // { a: '1', b: '2', c: '3' }   '1'\n\nquery = 'a=1&b=2&c=3&a=3'; // 如果参数重复，其所对应的值会变成数组\nobj = querystring.parse(query);\nconsole.log(obj); // { a: [ '1', '3' ], b: '2', c: '3' }\n\n// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串\nquery = querystring.stringify(obj);\nconsole.log(query); // a=1&a=3&b=2&c=3\n```\n\n### assert 断言\n\n这个我们直接看下面代码就知道它的作用了：\n\n```\n// assert.js\nconst assert = require('assert');\n\n// assert(条件，错误消息)，条件这部分会返回一个布尔值\nassert(2 < 1, '断言失败');\n```\n\n`node assert.js` 运行一下代码就能看到如下结果：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 `false` 则阻止程序运行，并抛出一个错误，如果返回值为 `true` 则继续执行，一般用于函数中间和参数判断。\n另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：\n\n```\n// assert.js\nconst assert = require('assert');\n\nconst obj1 = { a: { b: 1 } };\nconst obj2 = { a: { b: 1 } };\nconst obj3 = { a: { b: '1' } };\n\n// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值\n// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值\n// 同样也是错误的时候抛出信息，正确的时候继续默默执行\nassert.deepEqual(obj1, obj2, '不等哦'); // true\nassert.deepEqual(obj1, obj3, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj2, '不等哦'); // true\nassert.deepStrictEqual(obj1, obj3, '不等哦'); // false，这个会抛出错误信息\n```\n\n### stream 流\n\nstream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 `fs.readFile` 和 `fs.writeFile` 的升级版。\n我们要知道 `readFile` 和 `writeFile` 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。\n\n```\nconst fs = require('fs');\n\n// 读取流：fs.createReadStream();\n// 写入流：fs.createWriteStream();\nlet rs = fs.createReadStream('a.txt'); // 要读取的文件\nlet ws = fs.createWriteStream('a2.txt'); // 输出的文件\n\nrs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n\n```\n\n流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。\n\n### zlib 压缩\n\n这个用法简单，作用也明了，直接看下面的代码就能理解：\n\n```\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nlet rs = fs.createReadStream('tree.jpg');\nlet gz = zlib.createGzip();\nlet ws = fs.createWriteStream('tree.jpg.gz');\n\nrs.pipe(gz).pipe(ws);  // 原始文件 => 压缩 => 写入\n\nrs.on('error', err => {\n  console.log(err);\n});\nws.on('finish', () => {\n  console.log('成功');\n})\n```\n\n## 小结\n\nok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。\n参考作者：尤水就下\n参考链接：https://juejin.im/post/5ccacfb96fb9a03201243cb9","slug":"nodeBasics","published":1,"updated":"2019-12-04T12:50:48.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrk001p78p3che37v2y","content":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h1 id=\"有助于理解前端工具的-node-知识\"><a href=\"#有助于理解前端工具的-node-知识\" class=\"headerlink\" title=\"有助于理解前端工具的 node 知识\"></a>有助于理解前端工具的 node 知识</h1><h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>\n<h2 id=\"node-初识\"><a href=\"#node-初识\" class=\"headerlink\" title=\"node 初识\"></a>node 初识</h2><h4 id=\"node-是什么\"><a href=\"#node-是什么\" class=\"headerlink\" title=\"node 是什么\"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>\n<h4 id=\"node-遵循的规范\"><a href=\"#node-遵循的规范\" class=\"headerlink\" title=\"node 遵循的规范\"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    a: 1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.a = 1;</span><br></pre></td></tr></table></figure></p>\n<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>\n<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"16ad4be6bc803f68.png\"></p>\n<h2 id=\"require-寻找依赖\"><a href=\"#require-寻找依赖\" class=\"headerlink\" title=\"require 寻找依赖\"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;); // 带相对路径</span><br><span class=\"line\">require(&apos;/module&apos;); // 带绝对路径</span><br><span class=\"line\">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>\n<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>\n<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>\n<h2 id=\"node-模块包装\"><a href=\"#node-模块包装\" class=\"headerlink\" title=\"node 模块包装\"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">    // module: 表示当前模块</span><br><span class=\"line\">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class=\"line\">    // __dirname: 当前模块的完整绝对路径</span><br><span class=\"line\">    module.exports = exports = this = &#123;&#125;;</span><br><span class=\"line\">    // 我们的代码就在这里...</span><br><span class=\"line\">    return module.exports;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>\n<h2 id=\"node-的应用场景\"><a href=\"#node-的应用场景\" class=\"headerlink\" title=\"node 的应用场景\"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>\n<ul>\n<li>自动化构建等工具</li>\n<li>中间层</li>\n<li>小项目</li>\n</ul>\n<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>\n<h2 id=\"node-的优点\"><a href=\"#node-的优点\" class=\"headerlink\" title=\"node 的优点\"></a>node 的优点</h2><ul>\n<li>适合前端大大们</li>\n<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>\n<li>性能较好（别人做过性能分析）</li>\n</ul>\n<h2 id=\"node-内置模块\"><a href=\"#node-内置模块\" class=\"headerlink\" title=\"node 内置模块\"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>\n<h3 id=\"http-模块\"><a href=\"#http-模块\" class=\"headerlink\" title=\"http 模块\"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http.js</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class=\"line\">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class=\"line\">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class=\"line\">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class=\"line\">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"fs-文件系统\"><a href=\"#fs-文件系统\" class=\"headerlink\" title=\"fs 文件系统\"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class=\"line\">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;写入失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;写入成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取文件：fs.readFile(path, cb);</span><br><span class=\"line\">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;读取失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>\n<h2 id=\"path-路径\"><a href=\"#path-路径\" class=\"headerlink\" title=\"path 路径\"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class=\"line\">console.log(path.dirname(str)); // 路径</span><br><span class=\"line\">// /root/a/b</span><br><span class=\"line\">console.log(path.extname(str)); // 后缀名</span><br><span class=\"line\">// .html</span><br><span class=\"line\">console.log(path.basename(str)); // 文件名</span><br><span class=\"line\">// index.html</span><br><span class=\"line\"></span><br><span class=\"line\">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class=\"line\">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class=\"line\">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathOne, pathTwo, __dirname);</span><br><span class=\"line\">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class=\"line\">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class=\"line\">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>\n<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>\n<h3 id=\"url-模块\"><a href=\"#url-模块\" class=\"headerlink\" title=\"url 模块\"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = require(&apos;url&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class=\"line\">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathname, query);</span><br><span class=\"line\">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"querystring-查询字符串\"><a href=\"#querystring-查询字符串\" class=\"headerlink\" title=\"querystring 查询字符串\"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring = require(&apos;querystring&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class=\"line\">let obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class=\"line\">obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class=\"line\">query = querystring.stringify(obj);</span><br><span class=\"line\">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert 断言\"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class=\"line\">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>\n<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class=\"line\">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class=\"line\">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class=\"line\">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"stream-流\"><a href=\"#stream-流\" class=\"headerlink\" title=\"stream 流\"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取流：fs.createReadStream();</span><br><span class=\"line\">// 写入流：fs.createWriteStream();</span><br><span class=\"line\">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>\n<h3 id=\"zlib-压缩\"><a href=\"#zlib-压缩\" class=\"headerlink\" title=\"zlib 压缩\"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const zlib = require(&apos;zlib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class=\"line\">let gz = zlib.createGzip();</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href=\"https://juejin.im/post/5ccacfb96fb9a03201243cb9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>\n<h1 id=\"有助于理解前端工具的-node-知识\"><a href=\"#有助于理解前端工具的-node-知识\" class=\"headerlink\" title=\"有助于理解前端工具的 node 知识\"></a>有助于理解前端工具的 node 知识</h1><h2 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>\n<h2 id=\"node-初识\"><a href=\"#node-初识\" class=\"headerlink\" title=\"node 初识\"></a>node 初识</h2><h4 id=\"node-是什么\"><a href=\"#node-是什么\" class=\"headerlink\" title=\"node 是什么\"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>\n<h4 id=\"node-遵循的规范\"><a href=\"#node-遵循的规范\" class=\"headerlink\" title=\"node 遵循的规范\"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    a: 1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">exports.a = 1;</span><br></pre></td></tr></table></figure></p>\n<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>\n<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"16ad4be6bc803f68.png\"></p>\n<h2 id=\"require-寻找依赖\"><a href=\"#require-寻找依赖\" class=\"headerlink\" title=\"require 寻找依赖\"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;./module&apos;); // 带相对路径</span><br><span class=\"line\">require(&apos;/module&apos;); // 带绝对路径</span><br><span class=\"line\">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>\n<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>\n<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>\n<h2 id=\"node-模块包装\"><a href=\"#node-模块包装\" class=\"headerlink\" title=\"node 模块包装\"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class=\"line\">    // module: 表示当前模块</span><br><span class=\"line\">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class=\"line\">    // __dirname: 当前模块的完整绝对路径</span><br><span class=\"line\">    module.exports = exports = this = &#123;&#125;;</span><br><span class=\"line\">    // 我们的代码就在这里...</span><br><span class=\"line\">    return module.exports;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure></p>\n<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>\n<h2 id=\"node-的应用场景\"><a href=\"#node-的应用场景\" class=\"headerlink\" title=\"node 的应用场景\"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>\n<ul>\n<li>自动化构建等工具</li>\n<li>中间层</li>\n<li>小项目</li>\n</ul>\n<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>\n<h2 id=\"node-的优点\"><a href=\"#node-的优点\" class=\"headerlink\" title=\"node 的优点\"></a>node 的优点</h2><ul>\n<li>适合前端大大们</li>\n<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>\n<li>性能较好（别人做过性能分析）</li>\n</ul>\n<h2 id=\"node-内置模块\"><a href=\"#node-内置模块\" class=\"headerlink\" title=\"node 内置模块\"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>\n<h3 id=\"http-模块\"><a href=\"#http-模块\" class=\"headerlink\" title=\"http 模块\"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// http.js</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class=\"line\">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class=\"line\">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class=\"line\">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class=\"line\">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"fs-文件系统\"><a href=\"#fs-文件系统\" class=\"headerlink\" title=\"fs 文件系统\"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class=\"line\">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;写入失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;写入成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取文件：fs.readFile(path, cb);</span><br><span class=\"line\">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class=\"line\">  if (err) &#123;</span><br><span class=\"line\">    console.log(&apos;读取失败&apos;, err);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>\n<h2 id=\"path-路径\"><a href=\"#path-路径\" class=\"headerlink\" title=\"path 路径\"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class=\"line\">console.log(path.dirname(str)); // 路径</span><br><span class=\"line\">// /root/a/b</span><br><span class=\"line\">console.log(path.extname(str)); // 后缀名</span><br><span class=\"line\">// .html</span><br><span class=\"line\">console.log(path.basename(str)); // 文件名</span><br><span class=\"line\">// index.html</span><br><span class=\"line\"></span><br><span class=\"line\">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class=\"line\">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class=\"line\">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathOne, pathTwo, __dirname);</span><br><span class=\"line\">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class=\"line\">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class=\"line\">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>\n<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>\n<h3 id=\"url-模块\"><a href=\"#url-模块\" class=\"headerlink\" title=\"url 模块\"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const url = require(&apos;url&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class=\"line\">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(pathname, query);</span><br><span class=\"line\">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"querystring-查询字符串\"><a href=\"#querystring-查询字符串\" class=\"headerlink\" title=\"querystring 查询字符串\"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const querystring = require(&apos;querystring&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class=\"line\">let obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class=\"line\">obj = querystring.parse(query);</span><br><span class=\"line\">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class=\"line\">query = querystring.stringify(obj);</span><br><span class=\"line\">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>\n<h3 id=\"assert-断言\"><a href=\"#assert-断言\" class=\"headerlink\" title=\"assert 断言\"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class=\"line\">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>\n<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// assert.js</span><br><span class=\"line\">const assert = require(&apos;assert&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class=\"line\">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class=\"line\">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class=\"line\">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class=\"line\">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class=\"line\">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"stream-流\"><a href=\"#stream-流\" class=\"headerlink\" title=\"stream 流\"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 读取流：fs.createReadStream();</span><br><span class=\"line\">// 写入流：fs.createWriteStream();</span><br><span class=\"line\">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>\n<h3 id=\"zlib-压缩\"><a href=\"#zlib-压缩\" class=\"headerlink\" title=\"zlib 压缩\"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const zlib = require(&apos;zlib&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class=\"line\">let gz = zlib.createGzip();</span><br><span class=\"line\">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class=\"line\"></span><br><span class=\"line\">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class=\"line\">  console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class=\"line\">  console.log(&apos;成功&apos;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href=\"https://juejin.im/post/5ccacfb96fb9a03201243cb9\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>\n"},{"title":"npm 部署自己的组件库","date":"2019-07-26T06:18:53.000Z","_content":"Author: Echo\nTime: 2019-07-24 15:28:39\n# 基于 vue-cli 打造属于自己的 UI 库\n\n## 写在前面\n \n## 知识前置\n我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：\n```\nimport Loading from '../components/loading'\n// 方法一：name 是组件的名字\nVue.component(Loading.name, Loading)\n// 方法二：前提是 Loading 有提供 install 这个方法\nVue.use(Loading);\n```\n# 基于vue-cli3打造组件库\n# 搭建目录\n#### 快速创建项目\n* vue-cli3\n```\nvue create projectName\n```\n### 修改目录结构\n\n*  把 src 目录名字改成 examples，这是用于展示组件示例的\n*  在根目录下新建一个 packages 文件夹，这是用来放组件的\n![1ll.png](../images/1.png)\n    你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：\n当我们水平不够的时候，模仿是一种强大的学习能力👏。\n\n### 添加配置文件\n\n小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：\n\n```\nconst path = require('path')\nmodule.exports = {\n  // 修改 pages 入口\n  pages: {\n    index: {\n      entry: 'examples/main.js', // 入口\n      template: 'public/index.html', // 模板\n      filename: 'index.html' // 输出文件\n    }\n  },\n  // 扩展 webpack 配置\n  chainWebpack: config => {\n    // @ 默认指向 src 目录，这里要改成 examples\n    // 另外也可以新增一个 ~ 指向 packages\n    config.resolve.alias\n      .set('@', path.resolve('examples'))\n      .set('~', path.resolve('packages'))\n\n    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的\n    config.module\n      .rule('js')\n      .include.add(/packages/).end()\n      .include.add(/examples/).end()\n      .use('babel')\n      .loader('babel-loader')\n      .tap(options => {\n        // 修改它的选项...\n        return options\n      })\n  }\n}\n\n```\n\n上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 [Vue Cli](https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE) 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。\n\n## 编写组件\n\n一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：\n\n![1ll.png](../images/2.png)\n\n\n```\n<!--test.vue-->\n<template>\n  <div class=\"echojoy-test\" @click=\"handleClick\">{{ num }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'EchojoyTest',\n  data () {\n    return {\n      num: 0\n    }\n  },\n  methods: {\n    handleClick () {\n      this.num++\n    }\n  }\n}\n</script>\n\n<style >\n.echojoy-test {\n  width: 100px;\n  height: 100px;\n  line-height: 100px;\n  border-radius: 50%;\n  font-size: 30px;\n  text-align: center;\n  background: #24292e;\n  color: white;\n}\n</style>\n\n\n```\n\n应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 `EchojoyTest`，到时候我们写的标签就长这样 `<echojoy-test></echojoy-test>`，就像 Element 一样，name 是 `ElButton`，用的时候就是 `<el-button></el-button>`。\n\n## 暴露组件\n\n让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：\n\n```\n// 对外提供对组件的引用，注意组件必须声明 name\nimport EchojoyTest from './src/test'\n// 为组件提供 install 安装方法，供按需引入\nEchojoyTest.install = Vue => {\n  Vue.component(EchojoyTest.name, EchojoyTest)\n}\nexport default EchojoyTest\n\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 `Vue.use()` 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：\n\n```\nimport EchojoyTest from './test'\n// 存储组件列表\nconst components = [\n  EchojoyTest\n]\n// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册\nconst install = function (Vue) {\n  // 判断是否安装\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册全局组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 判断是否是直接引入文件\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nexport default {\n  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装\n  install,\n  // 以下是具体的组件列表\n  ...components\n}\n\n\n```\n\n这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：\n\n![1ll.png](../images/3.png)\n\n因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。\n当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。\n\n## 组件测试\n\nok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：\n```\nimport EchojoyUI from './../packages'\nVue.use(EchojoyUI);\n```\n然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：\n\n![1ll.png](../images/11.png)\n\n\n好了，最后让我们运行一下项目 `npm run  serve`，看看效果，嗯，还凑合吧。\n\n## 库模式打包\n\n在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：\n\n```\n// target: 默认为构建应用，改为 lib 即可启用构建库模式\n// name: 输出文件名\n// dest: 输出目录，默认为 dist，这里我们改为 lib\n// entry: 入口文件路径\nvue-cli-service build --target lib --name lib [entry]\n\n```\n\n要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：\n\n![1ll.png](../images/5.png)\n\n\n\n接着执行 `npm run lib` 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。\n![1ll.png](../images/6.png)\n\n\n\n补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。\n\n## 发布到npm\n\n万事俱备，只欠发布。\n\n1.  完善一下 README.md 文档，这个随便写两句就好\n2.  修改一下 package.json 文件：\n\n```\n{ \n  \"name\": \"echojoy-ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"description\": \"基于 vue-cli3 的 UI 组件库\",\n  \"main\": \"lib/xr-ui.umd.min.js\",\n  \"keywords\": \"echojoy-ui\",\n  \"private\": false,\n  \"license\": \"MIT\"\n}\n\n```\n\n3.  在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：\n\n```\n# 这是复制 .gitignore 里面的\n.DS_Store\nnode_modules\n/dist\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw*\n\n# 以下是新增的\n# 要忽略目录和指定文件\nexamples/\npackages/\npublic/\nvue.config.js\nbabel.config.js\n*.map\n*.html\n\n```\n\n最后执行 `npm login` 登入 npm 账号，再执行 `npm publish` 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n## 小试牛刀\n\n终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 `vue create echojoy-ui-use` 另起一个新项目，然后 `npm i echojoy-ui -S`，可以在 node_modules 里面看到我们的包大概长这样：\n![1ll.png](../images/7.png)\n\n\n\n然后在 main.js 引入：\n\n```\nimport EchojoyUI from \"echojoy-ui\";\nimport \"echojoy-ui/lib/echojoy-ui.css\";\nVue.use(EchojoyUI);\n```\n\n这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。\n\n```\n<echojoy-test></echojoy-test>\n```\n\n# ! vue-cli3（vue-cli2）\n```\n vue init webpack projectName\n```\n![1ll.png](../images/8.png)\n\n\n####  启动项目\n`\n npm run dev\n`\n![1ll.png](../images/9.png)\n浏览器输入\n```\nhttp://localhost:8080\n```\n#### 编写组件\n\n在src的components新建组件limit：即文件夹`EchoLimit`->文件`index.vue` + 文件`index+css`\n```\n// index.vue\n<template>\n  <div class=\"echo-limit-container\" v-if=\"visible === false\">\n    <div class=\"echo-limit-container-inner\">\n      <span class=\"echo-limit-text\">\n        {{limitTip}}\n      </span>\n    </div>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    limitTip: {\n      type: String,\n      default: '没有权限！！'\n    },\n  },\n  name: \"EchoLimit\" // 这个名字很重要，它就是未来的标签名<echo-limit></echo-limit>\n};\n</script>\n<style>\n  @import \"./index\"\n</style>\n\n\n```\n   \n\n⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。\n\n#### 暴露组件\n\n* 注册单个组件\n\n在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：\n// 为组件提供 install 方法，供组件对外按需引入\n```\nimport EchoLimit from \"./EchoLimit/index.vue\";\nEchoLimit.install = Vue => {\n  Vue.component(EchoLimit.name, EchoLimit);\n};\nexport default EchoLimit;\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。\n\n* 注册全局组件\n让我们在 components 下面新建一个 index.js 文件，具体代码如下：\n```\n// index.js\nimport EchoLimit from './EchoLimit'\n// 所有组件列表\nconst components = [\n  EchoLimit\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n  // 判断是否安装，安装过就不继续往下执行\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册所有组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nconsole.log(components[0].name) // 控制台输出组件的name,方便引用组件\n\nexport default {\n  install,\n  // 所有组件，必须具有 install，才能使用 Vue.use()\n  ...components\n}\n\n```\n\n目录结构方便大家观看：\n![1ll.png](../images/4.png)\n\n#### 组件测试\n\nok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：\n\n```\nimport EchoUI from './components'\nVue.use(EchoUI)\n```\n在 HelloWorld.vue中引入组件EchoLimit.\n```\n<template>\n  <div>\n    <EchoLimit></EchoLimit>\n     <echo-limit></echo-limit>\n  </div>\n</echo-limit>\n```\n运行项目`npm run dev`,会发现成功了！！!\n![1ll.png](../images/10.png)\n\n\n过程同上！！！！！！！！！\n\n\n参考 连接：https://www.jianshu.com/p/41cc796488df\n参考 链接：https://juejin.im/post/5c95c61f6fb9a070c40acf65\n","source":"_posts/npmBuild.md","raw":"---\ntitle: npm 部署自己的组件库\ndate: 2019-07-26 14:18:53\ntags: npm \n---\nAuthor: Echo\nTime: 2019-07-24 15:28:39\n# 基于 vue-cli 打造属于自己的 UI 库\n\n## 写在前面\n \n## 知识前置\n我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：\n```\nimport Loading from '../components/loading'\n// 方法一：name 是组件的名字\nVue.component(Loading.name, Loading)\n// 方法二：前提是 Loading 有提供 install 这个方法\nVue.use(Loading);\n```\n# 基于vue-cli3打造组件库\n# 搭建目录\n#### 快速创建项目\n* vue-cli3\n```\nvue create projectName\n```\n### 修改目录结构\n\n*  把 src 目录名字改成 examples，这是用于展示组件示例的\n*  在根目录下新建一个 packages 文件夹，这是用来放组件的\n![1ll.png](../images/1.png)\n    你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：\n当我们水平不够的时候，模仿是一种强大的学习能力👏。\n\n### 添加配置文件\n\n小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：\n\n```\nconst path = require('path')\nmodule.exports = {\n  // 修改 pages 入口\n  pages: {\n    index: {\n      entry: 'examples/main.js', // 入口\n      template: 'public/index.html', // 模板\n      filename: 'index.html' // 输出文件\n    }\n  },\n  // 扩展 webpack 配置\n  chainWebpack: config => {\n    // @ 默认指向 src 目录，这里要改成 examples\n    // 另外也可以新增一个 ~ 指向 packages\n    config.resolve.alias\n      .set('@', path.resolve('examples'))\n      .set('~', path.resolve('packages'))\n\n    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的\n    config.module\n      .rule('js')\n      .include.add(/packages/).end()\n      .include.add(/examples/).end()\n      .use('babel')\n      .loader('babel-loader')\n      .tap(options => {\n        // 修改它的选项...\n        return options\n      })\n  }\n}\n\n```\n\n上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 [Vue Cli](https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE) 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。\n\n## 编写组件\n\n一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：\n\n![1ll.png](../images/2.png)\n\n\n```\n<!--test.vue-->\n<template>\n  <div class=\"echojoy-test\" @click=\"handleClick\">{{ num }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'EchojoyTest',\n  data () {\n    return {\n      num: 0\n    }\n  },\n  methods: {\n    handleClick () {\n      this.num++\n    }\n  }\n}\n</script>\n\n<style >\n.echojoy-test {\n  width: 100px;\n  height: 100px;\n  line-height: 100px;\n  border-radius: 50%;\n  font-size: 30px;\n  text-align: center;\n  background: #24292e;\n  color: white;\n}\n</style>\n\n\n```\n\n应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 `EchojoyTest`，到时候我们写的标签就长这样 `<echojoy-test></echojoy-test>`，就像 Element 一样，name 是 `ElButton`，用的时候就是 `<el-button></el-button>`。\n\n## 暴露组件\n\n让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：\n\n```\n// 对外提供对组件的引用，注意组件必须声明 name\nimport EchojoyTest from './src/test'\n// 为组件提供 install 安装方法，供按需引入\nEchojoyTest.install = Vue => {\n  Vue.component(EchojoyTest.name, EchojoyTest)\n}\nexport default EchojoyTest\n\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 `Vue.use()` 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：\n\n```\nimport EchojoyTest from './test'\n// 存储组件列表\nconst components = [\n  EchojoyTest\n]\n// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册\nconst install = function (Vue) {\n  // 判断是否安装\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册全局组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 判断是否是直接引入文件\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nexport default {\n  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装\n  install,\n  // 以下是具体的组件列表\n  ...components\n}\n\n\n```\n\n这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：\n\n![1ll.png](../images/3.png)\n\n因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。\n当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。\n\n## 组件测试\n\nok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：\n```\nimport EchojoyUI from './../packages'\nVue.use(EchojoyUI);\n```\n然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：\n\n![1ll.png](../images/11.png)\n\n\n好了，最后让我们运行一下项目 `npm run  serve`，看看效果，嗯，还凑合吧。\n\n## 库模式打包\n\n在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：\n\n```\n// target: 默认为构建应用，改为 lib 即可启用构建库模式\n// name: 输出文件名\n// dest: 输出目录，默认为 dist，这里我们改为 lib\n// entry: 入口文件路径\nvue-cli-service build --target lib --name lib [entry]\n\n```\n\n要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：\n\n![1ll.png](../images/5.png)\n\n\n\n接着执行 `npm run lib` 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。\n![1ll.png](../images/6.png)\n\n\n\n补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。\n\n## 发布到npm\n\n万事俱备，只欠发布。\n\n1.  完善一下 README.md 文档，这个随便写两句就好\n2.  修改一下 package.json 文件：\n\n```\n{ \n  \"name\": \"echojoy-ui\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"description\": \"基于 vue-cli3 的 UI 组件库\",\n  \"main\": \"lib/xr-ui.umd.min.js\",\n  \"keywords\": \"echojoy-ui\",\n  \"private\": false,\n  \"license\": \"MIT\"\n}\n\n```\n\n3.  在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：\n\n```\n# 这是复制 .gitignore 里面的\n.DS_Store\nnode_modules\n/dist\n\n# local env files\n.env.local\n.env.*.local\n\n# Log files\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Editor directories and files\n.idea\n.vscode\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw*\n\n# 以下是新增的\n# 要忽略目录和指定文件\nexamples/\npackages/\npublic/\nvue.config.js\nbabel.config.js\n*.map\n*.html\n\n```\n\n最后执行 `npm login` 登入 npm 账号，再执行 `npm publish` 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n## 小试牛刀\n\n终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 `vue create echojoy-ui-use` 另起一个新项目，然后 `npm i echojoy-ui -S`，可以在 node_modules 里面看到我们的包大概长这样：\n![1ll.png](../images/7.png)\n\n\n\n然后在 main.js 引入：\n\n```\nimport EchojoyUI from \"echojoy-ui\";\nimport \"echojoy-ui/lib/echojoy-ui.css\";\nVue.use(EchojoyUI);\n```\n\n这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。\n\n```\n<echojoy-test></echojoy-test>\n```\n\n# ! vue-cli3（vue-cli2）\n```\n vue init webpack projectName\n```\n![1ll.png](../images/8.png)\n\n\n####  启动项目\n`\n npm run dev\n`\n![1ll.png](../images/9.png)\n浏览器输入\n```\nhttp://localhost:8080\n```\n#### 编写组件\n\n在src的components新建组件limit：即文件夹`EchoLimit`->文件`index.vue` + 文件`index+css`\n```\n// index.vue\n<template>\n  <div class=\"echo-limit-container\" v-if=\"visible === false\">\n    <div class=\"echo-limit-container-inner\">\n      <span class=\"echo-limit-text\">\n        {{limitTip}}\n      </span>\n    </div>\n  </div>\n</template>\n\n<script>\n\nexport default {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    limitTip: {\n      type: String,\n      default: '没有权限！！'\n    },\n  },\n  name: \"EchoLimit\" // 这个名字很重要，它就是未来的标签名<echo-limit></echo-limit>\n};\n</script>\n<style>\n  @import \"./index\"\n</style>\n\n\n```\n   \n\n⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。\n\n#### 暴露组件\n\n* 注册单个组件\n\n在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：\n// 为组件提供 install 方法，供组件对外按需引入\n```\nimport EchoLimit from \"./EchoLimit/index.vue\";\nEchoLimit.install = Vue => {\n  Vue.component(EchoLimit.name, EchoLimit);\n};\nexport default EchoLimit;\n```\n\n这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。\n\n* 注册全局组件\n让我们在 components 下面新建一个 index.js 文件，具体代码如下：\n```\n// index.js\nimport EchoLimit from './EchoLimit'\n// 所有组件列表\nconst components = [\n  EchoLimit\n]\n// 定义 install 方法，接收 Vue 作为参数\nconst install = function (Vue) {\n  // 判断是否安装，安装过就不继续往下执行\n  if (install.installed) return\n  install.installed = true\n  // 遍历注册所有组件\n  components.map(component => Vue.component(component.name, component))\n  // 下面这个写法也可以\n  // components.map(component => Vue.use(component))\n}\n\n// 检测到 Vue 才执行，毕竟我们是基于 Vue 的\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nconsole.log(components[0].name) // 控制台输出组件的name,方便引用组件\n\nexport default {\n  install,\n  // 所有组件，必须具有 install，才能使用 Vue.use()\n  ...components\n}\n\n```\n\n目录结构方便大家观看：\n![1ll.png](../images/4.png)\n\n#### 组件测试\n\nok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：\n\n```\nimport EchoUI from './components'\nVue.use(EchoUI)\n```\n在 HelloWorld.vue中引入组件EchoLimit.\n```\n<template>\n  <div>\n    <EchoLimit></EchoLimit>\n     <echo-limit></echo-limit>\n  </div>\n</echo-limit>\n```\n运行项目`npm run dev`,会发现成功了！！!\n![1ll.png](../images/10.png)\n\n\n过程同上！！！！！！！！！\n\n\n参考 连接：https://www.jianshu.com/p/41cc796488df\n参考 链接：https://juejin.im/post/5c95c61f6fb9a070c40acf65\n","slug":"npmBuild","published":1,"updated":"2020-01-14T03:08:21.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrl001r78p3ejxoug8v","content":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<h1 id=\"基于-vue-cli-打造属于自己的-UI-库\"><a href=\"#基于-vue-cli-打造属于自己的-UI-库\" class=\"headerlink\" title=\"基于 vue-cli 打造属于自己的 UI 库\"></a>基于 vue-cli 打造属于自己的 UI 库</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><h2 id=\"知识前置\"><a href=\"#知识前置\" class=\"headerlink\" title=\"知识前置\"></a>知识前置</h2><p>我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Loading from &apos;../components/loading&apos;</span><br><span class=\"line\">// 方法一：name 是组件的名字</span><br><span class=\"line\">Vue.component(Loading.name, Loading)</span><br><span class=\"line\">// 方法二：前提是 Loading 有提供 install 这个方法</span><br><span class=\"line\">Vue.use(Loading);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基于vue-cli3打造组件库\"><a href=\"#基于vue-cli3打造组件库\" class=\"headerlink\" title=\"基于vue-cli3打造组件库\"></a>基于vue-cli3打造组件库</h1><h1 id=\"搭建目录\"><a href=\"#搭建目录\" class=\"headerlink\" title=\"搭建目录\"></a>搭建目录</h1><h4 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h4><ul>\n<li>vue-cli3<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create projectName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改目录结构\"><a href=\"#修改目录结构\" class=\"headerlink\" title=\"修改目录结构\"></a>修改目录结构</h3><ul>\n<li>把 src 目录名字改成 examples，这是用于展示组件示例的</li>\n<li>在根目录下新建一个 packages 文件夹，这是用来放组件的<br><img src=\"../images/1.png\" alt=\"1ll.png\"><br> 你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：<br>当我们水平不够的时候，模仿是一种强大的学习能力👏。</li>\n</ul>\n<h3 id=\"添加配置文件\"><a href=\"#添加配置文件\" class=\"headerlink\" title=\"添加配置文件\"></a>添加配置文件</h3><p>小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 修改 pages 入口</span><br><span class=\"line\">  pages: &#123;</span><br><span class=\"line\">    index: &#123;</span><br><span class=\"line\">      entry: &apos;examples/main.js&apos;, // 入口</span><br><span class=\"line\">      template: &apos;public/index.html&apos;, // 模板</span><br><span class=\"line\">      filename: &apos;index.html&apos; // 输出文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 扩展 webpack 配置</span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    // @ 默认指向 src 目录，这里要改成 examples</span><br><span class=\"line\">    // 另外也可以新增一个 ~ 指向 packages</span><br><span class=\"line\">    config.resolve.alias</span><br><span class=\"line\">      .set(&apos;@&apos;, path.resolve(&apos;examples&apos;))</span><br><span class=\"line\">      .set(&apos;~&apos;, path.resolve(&apos;packages&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(&apos;js&apos;)</span><br><span class=\"line\">      .include.add(/packages/).end()</span><br><span class=\"line\">      .include.add(/examples/).end()</span><br><span class=\"line\">      .use(&apos;babel&apos;)</span><br><span class=\"line\">      .loader(&apos;babel-loader&apos;)</span><br><span class=\"line\">      .tap(options =&gt; &#123;</span><br><span class=\"line\">        // 修改它的选项...</span><br><span class=\"line\">        return options</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE\" target=\"_blank\" rel=\"noopener\">Vue Cli</a> 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。</p>\n<h2 id=\"编写组件\"><a href=\"#编写组件\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h2><p>一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：</p>\n<p><img src=\"../images/2.png\" alt=\"1ll.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--test.vue--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-test&quot; @click=&quot;handleClick&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;EchojoyTest&apos;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      num: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick () &#123;</span><br><span class=\"line\">      this.num++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style &gt;</span><br><span class=\"line\">.echojoy-test &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100px;</span><br><span class=\"line\">  line-height: 100px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  font-size: 30px;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  background: #24292e;</span><br><span class=\"line\">  color: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 <code>EchojoyTest</code>，到时候我们写的标签就长这样 <code>&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</code>，就像 Element 一样，name 是 <code>ElButton</code>，用的时候就是 <code>&lt;el-button&gt;&lt;/el-button&gt;</code>。</p>\n<h2 id=\"暴露组件\"><a href=\"#暴露组件\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h2><p>让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对外提供对组件的引用，注意组件必须声明 name</span><br><span class=\"line\">import EchojoyTest from &apos;./src/test&apos;</span><br><span class=\"line\">// 为组件提供 install 安装方法，供按需引入</span><br><span class=\"line\">EchojoyTest.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchojoyTest.name, EchojoyTest)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default EchojoyTest</span><br></pre></td></tr></table></figure>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 <code>Vue.use()</code> 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyTest from &apos;./test&apos;</span><br><span class=\"line\">// 存储组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchojoyTest</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册全局组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是直接引入文件</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 以下是具体的组件列表</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：</p>\n<p><img src=\"../images/3.png\" alt=\"1ll.png\"></p>\n<p>因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。<br>当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。</p>\n<h2 id=\"组件测试\"><a href=\"#组件测试\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h2><p>ok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &apos;./../packages&apos;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure></p>\n<p>然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：</p>\n<p><img src=\"../images/11.png\" alt=\"1ll.png\"></p>\n<p>好了，最后让我们运行一下项目 <code>npm run  serve</code>，看看效果，嗯，还凑合吧。</p>\n<h2 id=\"库模式打包\"><a href=\"#库模式打包\" class=\"headerlink\" title=\"库模式打包\"></a>库模式打包</h2><p>在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// target: 默认为构建应用，改为 lib 即可启用构建库模式</span><br><span class=\"line\">// name: 输出文件名</span><br><span class=\"line\">// dest: 输出目录，默认为 dist，这里我们改为 lib</span><br><span class=\"line\">// entry: 入口文件路径</span><br><span class=\"line\">vue-cli-service build --target lib --name lib [entry]</span><br></pre></td></tr></table></figure>\n<p>要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：</p>\n<p><img src=\"../images/5.png\" alt=\"1ll.png\"></p>\n<p>接着执行 <code>npm run lib</code> 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。<br><img src=\"../images/6.png\" alt=\"1ll.png\"></p>\n<p>补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。</p>\n<h2 id=\"发布到npm\"><a href=\"#发布到npm\" class=\"headerlink\" title=\"发布到npm\"></a>发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ol>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>修改一下 package.json 文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  &quot;name&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;description&quot;: &quot;基于 vue-cli3 的 UI 组件库&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;lib/xr-ui.umd.min.js&quot;,</span><br><span class=\"line\">  &quot;keywords&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;private&quot;: false,</span><br><span class=\"line\">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是复制 .gitignore 里面的</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">/dist</span><br><span class=\"line\"></span><br><span class=\"line\"># local env files</span><br><span class=\"line\">.env.local</span><br><span class=\"line\">.env.*.local</span><br><span class=\"line\"></span><br><span class=\"line\"># Log files</span><br><span class=\"line\">npm-debug.log*</span><br><span class=\"line\">yarn-debug.log*</span><br><span class=\"line\">yarn-error.log*</span><br><span class=\"line\"></span><br><span class=\"line\"># Editor directories and files</span><br><span class=\"line\">.idea</span><br><span class=\"line\">.vscode</span><br><span class=\"line\">*.suo</span><br><span class=\"line\">*.ntvs*</span><br><span class=\"line\">*.njsproj</span><br><span class=\"line\">*.sln</span><br><span class=\"line\">*.sw*</span><br><span class=\"line\"></span><br><span class=\"line\"># 以下是新增的</span><br><span class=\"line\"># 要忽略目录和指定文件</span><br><span class=\"line\">examples/</span><br><span class=\"line\">packages/</span><br><span class=\"line\">public/</span><br><span class=\"line\">vue.config.js</span><br><span class=\"line\">babel.config.js</span><br><span class=\"line\">*.map</span><br><span class=\"line\">*.html</span><br></pre></td></tr></table></figure>\n<p>最后执行 <code>npm login</code> 登入 npm 账号，再执行 <code>npm publish</code> 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</p>\n<h2 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h2><p>终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 <code>vue create echojoy-ui-use</code> 另起一个新项目，然后 <code>npm i echojoy-ui -S</code>，可以在 node_modules 里面看到我们的包大概长这样：<br><img src=\"../images/7.png\" alt=\"1ll.png\"></p>\n<p>然后在 main.js 引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &quot;echojoy-ui&quot;;</span><br><span class=\"line\">import &quot;echojoy-ui/lib/echojoy-ui.css&quot;;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure>\n<p>这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli3（vue-cli2）\"><a href=\"#vue-cli3（vue-cli2）\" class=\"headerlink\" title=\"! vue-cli3（vue-cli2）\"></a>! vue-cli3（vue-cli2）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack projectName</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/8.png\" alt=\"1ll.png\"></p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><code>npm run dev</code><br><img src=\"../images/9.png\" alt=\"1ll.png\"><br>浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写组件-1\"><a href=\"#编写组件-1\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h4><p>在src的components新建组件limit：即文件夹<code>EchoLimit</code>-&gt;文件<code>index.vue</code> + 文件<code>index+css</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echo-limit-container&quot; v-if=&quot;visible === false&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;echo-limit-container-inner&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;echo-limit-text&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;limitTip&#125;&#125;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    visible: &#123;</span><br><span class=\"line\">      type: Boolean,</span><br><span class=\"line\">      default: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    limitTip: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &apos;没有权限！！&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: &quot;EchoLimit&quot; // 这个名字很重要，它就是未来的标签名&lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  @import &quot;./index&quot;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。</p>\n<h4 id=\"暴露组件-1\"><a href=\"#暴露组件-1\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h4><ul>\n<li>注册单个组件</li>\n</ul>\n<p>在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：<br>// 为组件提供 install 方法，供组件对外按需引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoLimit from &quot;./EchoLimit/index.vue&quot;;</span><br><span class=\"line\">EchoLimit.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchoLimit.name, EchoLimit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default EchoLimit;</span><br></pre></td></tr></table></figure></p>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。</p>\n<ul>\n<li>注册全局组件<br>让我们在 components 下面新建一个 index.js 文件，具体代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.js</span><br><span class=\"line\">import EchoLimit from &apos;./EchoLimit&apos;</span><br><span class=\"line\">// 所有组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchoLimit</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装，安装过就不继续往下执行</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册所有组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检测到 Vue 才执行，毕竟我们是基于 Vue 的</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(components[0].name) // 控制台输出组件的name,方便引用组件</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 所有组件，必须具有 install，才能使用 Vue.use()</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>目录结构方便大家观看：<br><img src=\"../images/4.png\" alt=\"1ll.png\"></p>\n<h4 id=\"组件测试-1\"><a href=\"#组件测试-1\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h4><p>ok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoUI from &apos;./components&apos;</span><br><span class=\"line\">Vue.use(EchoUI)</span><br></pre></td></tr></table></figure>\n<p>在 HelloWorld.vue中引入组件EchoLimit.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;EchoLimit&gt;&lt;/EchoLimit&gt;</span><br><span class=\"line\">     &lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/echo-limit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行项目<code>npm run dev</code>,会发现成功了！！!<br><img src=\"../images/10.png\" alt=\"1ll.png\"></p>\n<p>过程同上！！！！！！！！！</p>\n<p>参考 连接：<a href=\"https://www.jianshu.com/p/41cc796488df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/41cc796488df</a><br>参考 链接：<a href=\"https://juejin.im/post/5c95c61f6fb9a070c40acf65\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c95c61f6fb9a070c40acf65</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>\n<h1 id=\"基于-vue-cli-打造属于自己的-UI-库\"><a href=\"#基于-vue-cli-打造属于自己的-UI-库\" class=\"headerlink\" title=\"基于 vue-cli 打造属于自己的 UI 库\"></a>基于 vue-cli 打造属于自己的 UI 库</h1><h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><h2 id=\"知识前置\"><a href=\"#知识前置\" class=\"headerlink\" title=\"知识前置\"></a>知识前置</h2><p>我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Loading from &apos;../components/loading&apos;</span><br><span class=\"line\">// 方法一：name 是组件的名字</span><br><span class=\"line\">Vue.component(Loading.name, Loading)</span><br><span class=\"line\">// 方法二：前提是 Loading 有提供 install 这个方法</span><br><span class=\"line\">Vue.use(Loading);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"基于vue-cli3打造组件库\"><a href=\"#基于vue-cli3打造组件库\" class=\"headerlink\" title=\"基于vue-cli3打造组件库\"></a>基于vue-cli3打造组件库</h1><h1 id=\"搭建目录\"><a href=\"#搭建目录\" class=\"headerlink\" title=\"搭建目录\"></a>搭建目录</h1><h4 id=\"快速创建项目\"><a href=\"#快速创建项目\" class=\"headerlink\" title=\"快速创建项目\"></a>快速创建项目</h4><ul>\n<li>vue-cli3<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue create projectName</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"修改目录结构\"><a href=\"#修改目录结构\" class=\"headerlink\" title=\"修改目录结构\"></a>修改目录结构</h3><ul>\n<li>把 src 目录名字改成 examples，这是用于展示组件示例的</li>\n<li>在根目录下新建一个 packages 文件夹，这是用来放组件的<br><img src=\"../images/1.png\" alt=\"1ll.png\"><br> 你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：<br>当我们水平不够的时候，模仿是一种强大的学习能力👏。</li>\n</ul>\n<h3 id=\"添加配置文件\"><a href=\"#添加配置文件\" class=\"headerlink\" title=\"添加配置文件\"></a>添加配置文件</h3><p>小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path = require(&apos;path&apos;)</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  // 修改 pages 入口</span><br><span class=\"line\">  pages: &#123;</span><br><span class=\"line\">    index: &#123;</span><br><span class=\"line\">      entry: &apos;examples/main.js&apos;, // 入口</span><br><span class=\"line\">      template: &apos;public/index.html&apos;, // 模板</span><br><span class=\"line\">      filename: &apos;index.html&apos; // 输出文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 扩展 webpack 配置</span><br><span class=\"line\">  chainWebpack: config =&gt; &#123;</span><br><span class=\"line\">    // @ 默认指向 src 目录，这里要改成 examples</span><br><span class=\"line\">    // 另外也可以新增一个 ~ 指向 packages</span><br><span class=\"line\">    config.resolve.alias</span><br><span class=\"line\">      .set(&apos;@&apos;, path.resolve(&apos;examples&apos;))</span><br><span class=\"line\">      .set(&apos;~&apos;, path.resolve(&apos;packages&apos;))</span><br><span class=\"line\"></span><br><span class=\"line\">    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的</span><br><span class=\"line\">    config.module</span><br><span class=\"line\">      .rule(&apos;js&apos;)</span><br><span class=\"line\">      .include.add(/packages/).end()</span><br><span class=\"line\">      .include.add(/examples/).end()</span><br><span class=\"line\">      .use(&apos;babel&apos;)</span><br><span class=\"line\">      .loader(&apos;babel-loader&apos;)</span><br><span class=\"line\">      .tap(options =&gt; &#123;</span><br><span class=\"line\">        // 修改它的选项...</span><br><span class=\"line\">        return options</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE\" target=\"_blank\" rel=\"noopener\">Vue Cli</a> 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。</p>\n<h2 id=\"编写组件\"><a href=\"#编写组件\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h2><p>一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：</p>\n<p><img src=\"../images/2.png\" alt=\"1ll.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--test.vue--&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-test&quot; @click=&quot;handleClick&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;EchojoyTest&apos;,</span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      num: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    handleClick () &#123;</span><br><span class=\"line\">      this.num++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style &gt;</span><br><span class=\"line\">.echojoy-test &#123;</span><br><span class=\"line\">  width: 100px;</span><br><span class=\"line\">  height: 100px;</span><br><span class=\"line\">  line-height: 100px;</span><br><span class=\"line\">  border-radius: 50%;</span><br><span class=\"line\">  font-size: 30px;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  background: #24292e;</span><br><span class=\"line\">  color: white;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 <code>EchojoyTest</code>，到时候我们写的标签就长这样 <code>&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</code>，就像 Element 一样，name 是 <code>ElButton</code>，用的时候就是 <code>&lt;el-button&gt;&lt;/el-button&gt;</code>。</p>\n<h2 id=\"暴露组件\"><a href=\"#暴露组件\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h2><p>让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对外提供对组件的引用，注意组件必须声明 name</span><br><span class=\"line\">import EchojoyTest from &apos;./src/test&apos;</span><br><span class=\"line\">// 为组件提供 install 安装方法，供按需引入</span><br><span class=\"line\">EchojoyTest.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchojoyTest.name, EchojoyTest)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default EchojoyTest</span><br></pre></td></tr></table></figure>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 <code>Vue.use()</code> 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyTest from &apos;./test&apos;</span><br><span class=\"line\">// 存储组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchojoyTest</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册全局组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否是直接引入文件</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 以下是具体的组件列表</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：</p>\n<p><img src=\"../images/3.png\" alt=\"1ll.png\"></p>\n<p>因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。<br>当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。</p>\n<h2 id=\"组件测试\"><a href=\"#组件测试\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h2><p>ok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &apos;./../packages&apos;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure></p>\n<p>然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：</p>\n<p><img src=\"../images/11.png\" alt=\"1ll.png\"></p>\n<p>好了，最后让我们运行一下项目 <code>npm run  serve</code>，看看效果，嗯，还凑合吧。</p>\n<h2 id=\"库模式打包\"><a href=\"#库模式打包\" class=\"headerlink\" title=\"库模式打包\"></a>库模式打包</h2><p>在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// target: 默认为构建应用，改为 lib 即可启用构建库模式</span><br><span class=\"line\">// name: 输出文件名</span><br><span class=\"line\">// dest: 输出目录，默认为 dist，这里我们改为 lib</span><br><span class=\"line\">// entry: 入口文件路径</span><br><span class=\"line\">vue-cli-service build --target lib --name lib [entry]</span><br></pre></td></tr></table></figure>\n<p>要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：</p>\n<p><img src=\"../images/5.png\" alt=\"1ll.png\"></p>\n<p>接着执行 <code>npm run lib</code> 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。<br><img src=\"../images/6.png\" alt=\"1ll.png\"></p>\n<p>补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。</p>\n<h2 id=\"发布到npm\"><a href=\"#发布到npm\" class=\"headerlink\" title=\"发布到npm\"></a>发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ol>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>修改一下 package.json 文件：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  &quot;name&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;description&quot;: &quot;基于 vue-cli3 的 UI 组件库&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;lib/xr-ui.umd.min.js&quot;,</span><br><span class=\"line\">  &quot;keywords&quot;: &quot;echojoy-ui&quot;,</span><br><span class=\"line\">  &quot;private&quot;: false,</span><br><span class=\"line\">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 这是复制 .gitignore 里面的</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\">node_modules</span><br><span class=\"line\">/dist</span><br><span class=\"line\"></span><br><span class=\"line\"># local env files</span><br><span class=\"line\">.env.local</span><br><span class=\"line\">.env.*.local</span><br><span class=\"line\"></span><br><span class=\"line\"># Log files</span><br><span class=\"line\">npm-debug.log*</span><br><span class=\"line\">yarn-debug.log*</span><br><span class=\"line\">yarn-error.log*</span><br><span class=\"line\"></span><br><span class=\"line\"># Editor directories and files</span><br><span class=\"line\">.idea</span><br><span class=\"line\">.vscode</span><br><span class=\"line\">*.suo</span><br><span class=\"line\">*.ntvs*</span><br><span class=\"line\">*.njsproj</span><br><span class=\"line\">*.sln</span><br><span class=\"line\">*.sw*</span><br><span class=\"line\"></span><br><span class=\"line\"># 以下是新增的</span><br><span class=\"line\"># 要忽略目录和指定文件</span><br><span class=\"line\">examples/</span><br><span class=\"line\">packages/</span><br><span class=\"line\">public/</span><br><span class=\"line\">vue.config.js</span><br><span class=\"line\">babel.config.js</span><br><span class=\"line\">*.map</span><br><span class=\"line\">*.html</span><br></pre></td></tr></table></figure>\n<p>最后执行 <code>npm login</code> 登入 npm 账号，再执行 <code>npm publish</code> 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</p>\n<h2 id=\"小试牛刀\"><a href=\"#小试牛刀\" class=\"headerlink\" title=\"小试牛刀\"></a>小试牛刀</h2><p>终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 <code>vue create echojoy-ui-use</code> 另起一个新项目，然后 <code>npm i echojoy-ui -S</code>，可以在 node_modules 里面看到我们的包大概长这样：<br><img src=\"../images/7.png\" alt=\"1ll.png\"></p>\n<p>然后在 main.js 引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyUI from &quot;echojoy-ui&quot;;</span><br><span class=\"line\">import &quot;echojoy-ui/lib/echojoy-ui.css&quot;;</span><br><span class=\"line\">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure>\n<p>这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vue-cli3（vue-cli2）\"><a href=\"#vue-cli3（vue-cli2）\" class=\"headerlink\" title=\"! vue-cli3（vue-cli2）\"></a>! vue-cli3（vue-cli2）</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue init webpack projectName</span><br></pre></td></tr></table></figure>\n<p><img src=\"../images/8.png\" alt=\"1ll.png\"></p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p><code>npm run dev</code><br><img src=\"../images/9.png\" alt=\"1ll.png\"><br>浏览器输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"编写组件-1\"><a href=\"#编写组件-1\" class=\"headerlink\" title=\"编写组件\"></a>编写组件</h4><p>在src的components新建组件limit：即文件夹<code>EchoLimit</code>-&gt;文件<code>index.vue</code> + 文件<code>index+css</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.vue</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echo-limit-container&quot; v-if=&quot;visible === false&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;echo-limit-container-inner&quot;&gt;</span><br><span class=\"line\">      &lt;span class=&quot;echo-limit-text&quot;&gt;</span><br><span class=\"line\">        &#123;&#123;limitTip&#125;&#125;</span><br><span class=\"line\">      &lt;/span&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    visible: &#123;</span><br><span class=\"line\">      type: Boolean,</span><br><span class=\"line\">      default: false</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    limitTip: &#123;</span><br><span class=\"line\">      type: String,</span><br><span class=\"line\">      default: &apos;没有权限！！&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  name: &quot;EchoLimit&quot; // 这个名字很重要，它就是未来的标签名&lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">  @import &quot;./index&quot;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>\n<p>⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。</p>\n<h4 id=\"暴露组件-1\"><a href=\"#暴露组件-1\" class=\"headerlink\" title=\"暴露组件\"></a>暴露组件</h4><ul>\n<li>注册单个组件</li>\n</ul>\n<p>在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：<br>// 为组件提供 install 方法，供组件对外按需引入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoLimit from &quot;./EchoLimit/index.vue&quot;;</span><br><span class=\"line\">EchoLimit.install = Vue =&gt; &#123;</span><br><span class=\"line\">  Vue.component(EchoLimit.name, EchoLimit);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default EchoLimit;</span><br></pre></td></tr></table></figure></p>\n<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。</p>\n<ul>\n<li>注册全局组件<br>让我们在 components 下面新建一个 index.js 文件，具体代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index.js</span><br><span class=\"line\">import EchoLimit from &apos;./EchoLimit&apos;</span><br><span class=\"line\">// 所有组件列表</span><br><span class=\"line\">const components = [</span><br><span class=\"line\">  EchoLimit</span><br><span class=\"line\">]</span><br><span class=\"line\">// 定义 install 方法，接收 Vue 作为参数</span><br><span class=\"line\">const install = function (Vue) &#123;</span><br><span class=\"line\">  // 判断是否安装，安装过就不继续往下执行</span><br><span class=\"line\">  if (install.installed) return</span><br><span class=\"line\">  install.installed = true</span><br><span class=\"line\">  // 遍历注册所有组件</span><br><span class=\"line\">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class=\"line\">  // 下面这个写法也可以</span><br><span class=\"line\">  // components.map(component =&gt; Vue.use(component))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 检测到 Vue 才执行，毕竟我们是基于 Vue 的</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  install(window.Vue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(components[0].name) // 控制台输出组件的name,方便引用组件</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  // 所有组件，必须具有 install，才能使用 Vue.use()</span><br><span class=\"line\">  ...components</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>目录结构方便大家观看：<br><img src=\"../images/4.png\" alt=\"1ll.png\"></p>\n<h4 id=\"组件测试-1\"><a href=\"#组件测试-1\" class=\"headerlink\" title=\"组件测试\"></a>组件测试</h4><p>ok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchoUI from &apos;./components&apos;</span><br><span class=\"line\">Vue.use(EchoUI)</span><br></pre></td></tr></table></figure>\n<p>在 HelloWorld.vue中引入组件EchoLimit.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;EchoLimit&gt;&lt;/EchoLimit&gt;</span><br><span class=\"line\">     &lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/echo-limit&gt;</span><br></pre></td></tr></table></figure></p>\n<p>运行项目<code>npm run dev</code>,会发现成功了！！!<br><img src=\"../images/10.png\" alt=\"1ll.png\"></p>\n<p>过程同上！！！！！！！！！</p>\n<p>参考 连接：<a href=\"https://www.jianshu.com/p/41cc796488df\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/41cc796488df</a><br>参考 链接：<a href=\"https://juejin.im/post/5c95c61f6fb9a070c40acf65\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c95c61f6fb9a070c40acf65</a></p>\n"},{"title":"优化项目的实用技巧","date":"2020-05-08T07:20:06.000Z","_content":"\n\n\n## 一些有意思的loader 和 plugins\n---\n\n#### 如何自动加载\n`require.context`：根据自定的规则获取需要的内容。\n\n> 解决困扰：新增或减少页面每次需要更改路由配置？\n\n* 以vue项目为例，实现动态配置路由。\n\n在vue的component中按照如下格式配置页面。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> mode (模块名称)\n>> index.routes.js (该模块下路由解析配置)\n>> pages (文件统一名称)\n>>> mode.index.vue (模块下默认页面)\n>>> mode.resource.vue  (模块下其他页面)\n\n在mode中的index.routes.js中配置路由解析代码,会自动生成routes\n```\n// 第1个参数： 路径\n// 第2个参数: 是否遍历1参数下面的子文件夹\n// 第3个参数： 正则匹配对应后缀的文件\n\nlet r = require.context('./pages', false, /.vue/);\n// r是一个func,直接调用会报错。\nlet routesArr = [];\nr.keys().forEach((key) => {\n  console.log(r(key))\n  let _keyArr = key.split('.');\n  if (key.indexOf('index') != -1) {\n    routesArr.push ({\n      path: _keyArr[1],\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  } else {\n    routesArr.push ({\n      path: `${_keyArr[1]}/${_keyArr[2]}`,\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  }\n})\nexport default routesArr\n```\n在总路由地址下引用各个模块下面的路由：\n\n在router > index.js配置如下代码。\n```\nlet r = require.context('./components', true, /\\.routes\\.js/);\nlet routesArr: any[] = [];\nr.keys().forEach((key) => {\n  console.log(r(key));\n  routesArr = routesArr.concat(r(key).defalut);\n})\nexport const routes = [\n  {\n    path: \"/\",\n    name: 'Home',\n    components:Home\n  },\n  ...routesArr\n];\n```\n缺点： \n  1.不能按需引入\n  2.不能实现动态路由。\n优点：\n  1.规范项目结构+文件命名+路由命名\n  2.减少配置路由的困扰\n\n## 如何优化打包\n---\n\n\n#### Dll优化\n原理： 减少处理内容和步骤\njs - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)\n\n步骤： 预处理第三方库 -> 打包其他文件。\n\n* 以vue项目为例，封装Dll优化。\n\n在vue项目的bulid文件下新建webpack.dll.js文件\n```\nvar path = require('path')\nvar webpack = require('webpack')\nvar config = require('../config')\n\nmodule.exports = {\n  entry: {\n    // 定义提前处理的文件\n    vendor: ['vue/dist/vue.esm.js', 'vue-router']\n  },\n  output: {\n    // 将预处理打包好的文件资源，放在静态文件夹中。\n    path: path.join(__dirname, '../static/js'),\n    filename: '[name].dll.js',\n    library: '[name]_library'\n  },\n  plugins: [\n    // 在当前目录下生成一个通知，命名为[name]_manifest.json\n    new webpack.DllPlugin({\n      path:path.join(__dirname,'.', '[name]-manifest.json'),\n      name: '[name]_library' // 对应output中的library\n\n    })\n  ]\n}\n```\n在package.json 的 `scripts`中配置npm run dll 命令\n```\n\"dll\": \"webpack --config build/webpack.dll.js\"\n```\n\n然后执行`npm run dll`命令看一下打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后在执行一下`npm run build` 命令查看一下原始打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n执行`npm run dll `命令之后会发现在`bulid`文件夹下生成了\n`vendor-manifest.json`,在`static/js`下生成了`vendor.dll.js`。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在`bulid/webpack.prod.conf.js`中配置正常打包下的文件。\n\n```\nplugins: [\n    new webpack.DllReferencePlugin({\n      //context: 在html中引入的路径。\n      context: path.join(__dirname, '..'),\n      manifest: require('./vendor-manifest.json')\n    })\n]\n```\n最后在执行一下`npm run build` 命令查看一下dll处理之后打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n很完美的节约了一些时间，时间就是金钱，时间就是生命。\n#### 如何开发插件与loader\n---\n\n> 示例问题：项目vuex过大，导致打包结果过大。\n> 处理： 按组件异步加载vuex\n\n在src/store文件夹下index文件中存储首屏加载的vuex数据;\n在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在src下新建vuePlugins/index封装插件\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n示例代码如下：\n```\nlet a = {\n  install:function(vue) {\n    vue.mixin({\n      beforeCreate:function(){\n        if (this.$options.isVuex) {\n          // 在对应页面中配置store\n          // store中存储需要按需加载的vuex相关的js文件\n          let store = this.$options.store;\n          // 动态引入vuex\n          // 注意：import的参数不能传入变量。\n          import('../store/model/'+ store).then((res) => {\n            // registerModul方法是vuex的方法;\n            this.$store.registerModule(store, res.default);\n          });\n        }\n      }\n    })\n  }\n}\nexport default a;\n```\n在main.js引入插件\n```\nimport Vuepl from \"./vuePlugins\";\nVue.use(Vuepl);\n```\n在需要懒加载vuex的页面配置\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nisVuex:true;\nstore: 'modelIndex';\n```\n\n👌了！以上就是vuex实现按需加载的栗子。\n\n","source":"_posts/optimizaProject.md","raw":"---\ntitle: 优化项目的实用技巧\ndate: 2020-05-08 15:20:06\ntags:\n---\n\n\n\n## 一些有意思的loader 和 plugins\n---\n\n#### 如何自动加载\n`require.context`：根据自定的规则获取需要的内容。\n\n> 解决困扰：新增或减少页面每次需要更改路由配置？\n\n* 以vue项目为例，实现动态配置路由。\n\n在vue的component中按照如下格式配置页面。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> mode (模块名称)\n>> index.routes.js (该模块下路由解析配置)\n>> pages (文件统一名称)\n>>> mode.index.vue (模块下默认页面)\n>>> mode.resource.vue  (模块下其他页面)\n\n在mode中的index.routes.js中配置路由解析代码,会自动生成routes\n```\n// 第1个参数： 路径\n// 第2个参数: 是否遍历1参数下面的子文件夹\n// 第3个参数： 正则匹配对应后缀的文件\n\nlet r = require.context('./pages', false, /.vue/);\n// r是一个func,直接调用会报错。\nlet routesArr = [];\nr.keys().forEach((key) => {\n  console.log(r(key))\n  let _keyArr = key.split('.');\n  if (key.indexOf('index') != -1) {\n    routesArr.push ({\n      path: _keyArr[1],\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  } else {\n    routesArr.push ({\n      path: `${_keyArr[1]}/${_keyArr[2]}`,\n      name: _keyArr[1],\n      component: r(key).default\n    })\n  }\n})\nexport default routesArr\n```\n在总路由地址下引用各个模块下面的路由：\n\n在router > index.js配置如下代码。\n```\nlet r = require.context('./components', true, /\\.routes\\.js/);\nlet routesArr: any[] = [];\nr.keys().forEach((key) => {\n  console.log(r(key));\n  routesArr = routesArr.concat(r(key).defalut);\n})\nexport const routes = [\n  {\n    path: \"/\",\n    name: 'Home',\n    components:Home\n  },\n  ...routesArr\n];\n```\n缺点： \n  1.不能按需引入\n  2.不能实现动态路由。\n优点：\n  1.规范项目结构+文件命名+路由命名\n  2.减少配置路由的困扰\n\n## 如何优化打包\n---\n\n\n#### Dll优化\n原理： 减少处理内容和步骤\njs - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)\n\n步骤： 预处理第三方库 -> 打包其他文件。\n\n* 以vue项目为例，封装Dll优化。\n\n在vue项目的bulid文件下新建webpack.dll.js文件\n```\nvar path = require('path')\nvar webpack = require('webpack')\nvar config = require('../config')\n\nmodule.exports = {\n  entry: {\n    // 定义提前处理的文件\n    vendor: ['vue/dist/vue.esm.js', 'vue-router']\n  },\n  output: {\n    // 将预处理打包好的文件资源，放在静态文件夹中。\n    path: path.join(__dirname, '../static/js'),\n    filename: '[name].dll.js',\n    library: '[name]_library'\n  },\n  plugins: [\n    // 在当前目录下生成一个通知，命名为[name]_manifest.json\n    new webpack.DllPlugin({\n      path:path.join(__dirname,'.', '[name]-manifest.json'),\n      name: '[name]_library' // 对应output中的library\n\n    })\n  ]\n}\n```\n在package.json 的 `scripts`中配置npm run dll 命令\n```\n\"dll\": \"webpack --config build/webpack.dll.js\"\n```\n\n然后执行`npm run dll`命令看一下打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后在执行一下`npm run build` 命令查看一下原始打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n执行`npm run dll `命令之后会发现在`bulid`文件夹下生成了\n`vendor-manifest.json`,在`static/js`下生成了`vendor.dll.js`。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后在`bulid/webpack.prod.conf.js`中配置正常打包下的文件。\n\n```\nplugins: [\n    new webpack.DllReferencePlugin({\n      //context: 在html中引入的路径。\n      context: path.join(__dirname, '..'),\n      manifest: require('./vendor-manifest.json')\n    })\n]\n```\n最后在执行一下`npm run build` 命令查看一下dll处理之后打包所需要的时间\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n很完美的节约了一些时间，时间就是金钱，时间就是生命。\n#### 如何开发插件与loader\n---\n\n> 示例问题：项目vuex过大，导致打包结果过大。\n> 处理： 按组件异步加载vuex\n\n在src/store文件夹下index文件中存储首屏加载的vuex数据;\n在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在src下新建vuePlugins/index封装插件\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n示例代码如下：\n```\nlet a = {\n  install:function(vue) {\n    vue.mixin({\n      beforeCreate:function(){\n        if (this.$options.isVuex) {\n          // 在对应页面中配置store\n          // store中存储需要按需加载的vuex相关的js文件\n          let store = this.$options.store;\n          // 动态引入vuex\n          // 注意：import的参数不能传入变量。\n          import('../store/model/'+ store).then((res) => {\n            // registerModul方法是vuex的方法;\n            this.$store.registerModule(store, res.default);\n          });\n        }\n      }\n    })\n  }\n}\nexport default a;\n```\n在main.js引入插件\n```\nimport Vuepl from \"./vuePlugins\";\nVue.use(Vuepl);\n```\n在需要懒加载vuex的页面配置\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nisVuex:true;\nstore: 'modelIndex';\n```\n\n👌了！以上就是vuex实现按需加载的栗子。\n\n","slug":"optimizaProject","published":1,"updated":"2020-05-08T07:21:23.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrm001u78p3d9s1z14v","content":"<h2 id=\"一些有意思的loader-和-plugins\"><a href=\"#一些有意思的loader-和-plugins\" class=\"headerlink\" title=\"一些有意思的loader 和 plugins\"></a>一些有意思的loader 和 plugins</h2><hr>\n<h4 id=\"如何自动加载\"><a href=\"#如何自动加载\" class=\"headerlink\" title=\"如何自动加载\"></a>如何自动加载</h4><p><code>require.context</code>：根据自定的规则获取需要的内容。</p>\n<blockquote>\n<p>解决困扰：新增或减少页面每次需要更改路由配置？</p>\n</blockquote>\n<ul>\n<li>以vue项目为例，实现动态配置路由。</li>\n</ul>\n<p>在vue的component中按照如下格式配置页面。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<blockquote>\n<p>mode (模块名称)</p>\n<blockquote>\n<p>index.routes.js (该模块下路由解析配置)<br>pages (文件统一名称)</p>\n<blockquote>\n<p>mode.index.vue (模块下默认页面)<br>mode.resource.vue  (模块下其他页面)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>在mode中的index.routes.js中配置路由解析代码,会自动生成routes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第1个参数： 路径</span><br><span class=\"line\">// 第2个参数: 是否遍历1参数下面的子文件夹</span><br><span class=\"line\">// 第3个参数： 正则匹配对应后缀的文件</span><br><span class=\"line\"></span><br><span class=\"line\">let r = require.context(&apos;./pages&apos;, false, /.vue/);</span><br><span class=\"line\">// r是一个func,直接调用会报错。</span><br><span class=\"line\">let routesArr = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key))</span><br><span class=\"line\">  let _keyArr = key.split(&apos;.&apos;);</span><br><span class=\"line\">  if (key.indexOf(&apos;index&apos;) != -1) &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: _keyArr[1],</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: `$&#123;_keyArr[1]&#125;/$&#123;_keyArr[2]&#125;`,</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export default routesArr</span><br></pre></td></tr></table></figure></p>\n<p>在总路由地址下引用各个模块下面的路由：</p>\n<p>在router &gt; index.js配置如下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let r = require.context(&apos;./components&apos;, true, /\\.routes\\.js/);</span><br><span class=\"line\">let routesArr: any[] = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key));</span><br><span class=\"line\">  routesArr = routesArr.concat(r(key).defalut);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &quot;/&quot;,</span><br><span class=\"line\">    name: &apos;Home&apos;,</span><br><span class=\"line\">    components:Home</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...routesArr</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure></p>\n<p>缺点：<br>  1.不能按需引入<br>  2.不能实现动态路由。<br>优点：<br>  1.规范项目结构+文件命名+路由命名<br>  2.减少配置路由的困扰</p>\n<h2 id=\"如何优化打包\"><a href=\"#如何优化打包\" class=\"headerlink\" title=\"如何优化打包\"></a>如何优化打包</h2><hr>\n<h4 id=\"Dll优化\"><a href=\"#Dll优化\" class=\"headerlink\" title=\"Dll优化\"></a>Dll优化</h4><p>原理： 减少处理内容和步骤<br>js - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)</p>\n<p>步骤： 预处理第三方库 -&gt; 打包其他文件。</p>\n<ul>\n<li>以vue项目为例，封装Dll优化。</li>\n</ul>\n<p>在vue项目的bulid文件下新建webpack.dll.js文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;)</span><br><span class=\"line\">var webpack = require(&apos;webpack&apos;)</span><br><span class=\"line\">var config = require(&apos;../config&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    // 定义提前处理的文件</span><br><span class=\"line\">    vendor: [&apos;vue/dist/vue.esm.js&apos;, &apos;vue-router&apos;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 将预处理打包好的文件资源，放在静态文件夹中。</span><br><span class=\"line\">    path: path.join(__dirname, &apos;../static/js&apos;),</span><br><span class=\"line\">    filename: &apos;[name].dll.js&apos;,</span><br><span class=\"line\">    library: &apos;[name]_library&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 在当前目录下生成一个通知，命名为[name]_manifest.json</span><br><span class=\"line\">    new webpack.DllPlugin(&#123;</span><br><span class=\"line\">      path:path.join(__dirname,&apos;.&apos;, &apos;[name]-manifest.json&apos;),</span><br><span class=\"line\">      name: &apos;[name]_library&apos; // 对应output中的library</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在package.json 的 <code>scripts</code>中配置npm run dll 命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dll&quot;: &quot;webpack --config build/webpack.dll.js&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后执行<code>npm run dll</code>命令看一下打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在执行一下<code>npm run build</code> 命令查看一下原始打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>执行<code>npm run dll</code>命令之后会发现在<code>bulid</code>文件夹下生成了<br><code>vendor-manifest.json</code>,在<code>static/js</code>下生成了<code>vendor.dll.js</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在<code>bulid/webpack.prod.conf.js</code>中配置正常打包下的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      //context: 在html中引入的路径。</span><br><span class=\"line\">      context: path.join(__dirname, &apos;..&apos;),</span><br><span class=\"line\">      manifest: require(&apos;./vendor-manifest.json&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>最后在执行一下<code>npm run build</code> 命令查看一下dll处理之后打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>很完美的节约了一些时间，时间就是金钱，时间就是生命。</p>\n<h4 id=\"如何开发插件与loader\"><a href=\"#如何开发插件与loader\" class=\"headerlink\" title=\"如何开发插件与loader\"></a>如何开发插件与loader</h4><hr>\n<blockquote>\n<p>示例问题：项目vuex过大，导致打包结果过大。<br>处理： 按组件异步加载vuex</p>\n</blockquote>\n<p>在src/store文件夹下index文件中存储首屏加载的vuex数据;<br>在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>在src下新建vuePlugins/index封装插件<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>示例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  install:function(vue) &#123;</span><br><span class=\"line\">    vue.mixin(&#123;</span><br><span class=\"line\">      beforeCreate:function()&#123;</span><br><span class=\"line\">        if (this.$options.isVuex) &#123;</span><br><span class=\"line\">          // 在对应页面中配置store</span><br><span class=\"line\">          // store中存储需要按需加载的vuex相关的js文件</span><br><span class=\"line\">          let store = this.$options.store;</span><br><span class=\"line\">          // 动态引入vuex</span><br><span class=\"line\">          // 注意：import的参数不能传入变量。</span><br><span class=\"line\">          import(&apos;../store/model/&apos;+ store).then((res) =&gt; &#123;</span><br><span class=\"line\">            // registerModul方法是vuex的方法;</span><br><span class=\"line\">            this.$store.registerModule(store, res.default);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default a;</span><br></pre></td></tr></table></figure></p>\n<p>在main.js引入插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vuepl from &quot;./vuePlugins&quot;;</span><br><span class=\"line\">Vue.use(Vuepl);</span><br></pre></td></tr></table></figure></p>\n<p>在需要懒加载vuex的页面配置<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isVuex:true;</span><br><span class=\"line\">store: &apos;modelIndex&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>👌了！以上就是vuex实现按需加载的栗子。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一些有意思的loader-和-plugins\"><a href=\"#一些有意思的loader-和-plugins\" class=\"headerlink\" title=\"一些有意思的loader 和 plugins\"></a>一些有意思的loader 和 plugins</h2><hr>\n<h4 id=\"如何自动加载\"><a href=\"#如何自动加载\" class=\"headerlink\" title=\"如何自动加载\"></a>如何自动加载</h4><p><code>require.context</code>：根据自定的规则获取需要的内容。</p>\n<blockquote>\n<p>解决困扰：新增或减少页面每次需要更改路由配置？</p>\n</blockquote>\n<ul>\n<li>以vue项目为例，实现动态配置路由。</li>\n</ul>\n<p>在vue的component中按照如下格式配置页面。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<blockquote>\n<p>mode (模块名称)</p>\n<blockquote>\n<p>index.routes.js (该模块下路由解析配置)<br>pages (文件统一名称)</p>\n<blockquote>\n<p>mode.index.vue (模块下默认页面)<br>mode.resource.vue  (模块下其他页面)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>在mode中的index.routes.js中配置路由解析代码,会自动生成routes<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第1个参数： 路径</span><br><span class=\"line\">// 第2个参数: 是否遍历1参数下面的子文件夹</span><br><span class=\"line\">// 第3个参数： 正则匹配对应后缀的文件</span><br><span class=\"line\"></span><br><span class=\"line\">let r = require.context(&apos;./pages&apos;, false, /.vue/);</span><br><span class=\"line\">// r是一个func,直接调用会报错。</span><br><span class=\"line\">let routesArr = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key))</span><br><span class=\"line\">  let _keyArr = key.split(&apos;.&apos;);</span><br><span class=\"line\">  if (key.indexOf(&apos;index&apos;) != -1) &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: _keyArr[1],</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    routesArr.push (&#123;</span><br><span class=\"line\">      path: `$&#123;_keyArr[1]&#125;/$&#123;_keyArr[2]&#125;`,</span><br><span class=\"line\">      name: _keyArr[1],</span><br><span class=\"line\">      component: r(key).default</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export default routesArr</span><br></pre></td></tr></table></figure></p>\n<p>在总路由地址下引用各个模块下面的路由：</p>\n<p>在router &gt; index.js配置如下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let r = require.context(&apos;./components&apos;, true, /\\.routes\\.js/);</span><br><span class=\"line\">let routesArr: any[] = [];</span><br><span class=\"line\">r.keys().forEach((key) =&gt; &#123;</span><br><span class=\"line\">  console.log(r(key));</span><br><span class=\"line\">  routesArr = routesArr.concat(r(key).defalut);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export const routes = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: &quot;/&quot;,</span><br><span class=\"line\">    name: &apos;Home&apos;,</span><br><span class=\"line\">    components:Home</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...routesArr</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure></p>\n<p>缺点：<br>  1.不能按需引入<br>  2.不能实现动态路由。<br>优点：<br>  1.规范项目结构+文件命名+路由命名<br>  2.减少配置路由的困扰</p>\n<h2 id=\"如何优化打包\"><a href=\"#如何优化打包\" class=\"headerlink\" title=\"如何优化打包\"></a>如何优化打包</h2><hr>\n<h4 id=\"Dll优化\"><a href=\"#Dll优化\" class=\"headerlink\" title=\"Dll优化\"></a>Dll优化</h4><p>原理： 减少处理内容和步骤<br>js - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)</p>\n<p>步骤： 预处理第三方库 -&gt; 打包其他文件。</p>\n<ul>\n<li>以vue项目为例，封装Dll优化。</li>\n</ul>\n<p>在vue项目的bulid文件下新建webpack.dll.js文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var path = require(&apos;path&apos;)</span><br><span class=\"line\">var webpack = require(&apos;webpack&apos;)</span><br><span class=\"line\">var config = require(&apos;../config&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    // 定义提前处理的文件</span><br><span class=\"line\">    vendor: [&apos;vue/dist/vue.esm.js&apos;, &apos;vue-router&apos;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 将预处理打包好的文件资源，放在静态文件夹中。</span><br><span class=\"line\">    path: path.join(__dirname, &apos;../static/js&apos;),</span><br><span class=\"line\">    filename: &apos;[name].dll.js&apos;,</span><br><span class=\"line\">    library: &apos;[name]_library&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 在当前目录下生成一个通知，命名为[name]_manifest.json</span><br><span class=\"line\">    new webpack.DllPlugin(&#123;</span><br><span class=\"line\">      path:path.join(__dirname,&apos;.&apos;, &apos;[name]-manifest.json&apos;),</span><br><span class=\"line\">      name: &apos;[name]_library&apos; // 对应output中的library</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在package.json 的 <code>scripts</code>中配置npm run dll 命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;dll&quot;: &quot;webpack --config build/webpack.dll.js&quot;</span><br></pre></td></tr></table></figure></p>\n<p>然后执行<code>npm run dll</code>命令看一下打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在执行一下<code>npm run build</code> 命令查看一下原始打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>执行<code>npm run dll</code>命令之后会发现在<code>bulid</code>文件夹下生成了<br><code>vendor-manifest.json</code>,在<code>static/js</code>下生成了<code>vendor.dll.js</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>然后在<code>bulid/webpack.prod.conf.js</code>中配置正常打包下的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">    new webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">      //context: 在html中引入的路径。</span><br><span class=\"line\">      context: path.join(__dirname, &apos;..&apos;),</span><br><span class=\"line\">      manifest: require(&apos;./vendor-manifest.json&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>最后在执行一下<code>npm run build</code> 命令查看一下dll处理之后打包所需要的时间<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>很完美的节约了一些时间，时间就是金钱，时间就是生命。</p>\n<h4 id=\"如何开发插件与loader\"><a href=\"#如何开发插件与loader\" class=\"headerlink\" title=\"如何开发插件与loader\"></a>如何开发插件与loader</h4><hr>\n<blockquote>\n<p>示例问题：项目vuex过大，导致打包结果过大。<br>处理： 按组件异步加载vuex</p>\n</blockquote>\n<p>在src/store文件夹下index文件中存储首屏加载的vuex数据;<br>在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>在src下新建vuePlugins/index封装插件<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>示例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = &#123;</span><br><span class=\"line\">  install:function(vue) &#123;</span><br><span class=\"line\">    vue.mixin(&#123;</span><br><span class=\"line\">      beforeCreate:function()&#123;</span><br><span class=\"line\">        if (this.$options.isVuex) &#123;</span><br><span class=\"line\">          // 在对应页面中配置store</span><br><span class=\"line\">          // store中存储需要按需加载的vuex相关的js文件</span><br><span class=\"line\">          let store = this.$options.store;</span><br><span class=\"line\">          // 动态引入vuex</span><br><span class=\"line\">          // 注意：import的参数不能传入变量。</span><br><span class=\"line\">          import(&apos;../store/model/&apos;+ store).then((res) =&gt; &#123;</span><br><span class=\"line\">            // registerModul方法是vuex的方法;</span><br><span class=\"line\">            this.$store.registerModule(store, res.default);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default a;</span><br></pre></td></tr></table></figure></p>\n<p>在main.js引入插件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vuepl from &quot;./vuePlugins&quot;;</span><br><span class=\"line\">Vue.use(Vuepl);</span><br></pre></td></tr></table></figure></p>\n<p>在需要懒加载vuex的页面配置<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isVuex:true;</span><br><span class=\"line\">store: &apos;modelIndex&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>👌了！以上就是vuex实现按需加载的栗子。</p>\n"},{"title":"使用react搭建组件库：react+typescript+storybook","date":"2020-06-08T13:12:16.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 一、 安装组件库\n执行安装命令\n ```\nnpx create-react-app echo-rui  --typescript\n```\n## 二、 组件库配置eslint\n* 配置ESlint\n新建`.eslintrc.json`文件\n```\n{\n  \"extends\": \"react-app\"\n}\n```\n新建 `.vscode/settings.json`文件\n```\n{\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    { \"language\": \"typescript\", \"autoFix\": true },\n    { \"language\": \"typescriptreact\", \"autoFix\": true }\n  ]\n}\n```\n## 三、 引入依赖\n在组件中使用 `classname`：[https://github.com/jedWatson/classnames](https://github.com/jedWatson/classnames)\n执行安装命令\n```\nnpm install classnames -D\nnpm install @types/classnames -D\nnpm install node-sass -D\n```\n使用方法示例：\n如果对象的key值是变化的，可以采用下面的中括号的形式：[`btn-${btnType}`]\n```\n// btn, btn-lg, btn-primary\nconst classes = classNames('btn', className, {\n   [`btn-${btnType}`]: btnType,\n   [`btn-${size}`]: size,\n   'disabled': (btnType === 'link') && disabled\n})\n```\n## 四、 编写组件\n* 新建 `src/components/Button/button.tsx`\n\n```\nimport React,{FC,ButtonHTMLAttributes,AnchorHTMLAttributes} from \"react\";\nimport classnames from \"classnames\";\n\n\n// 按钮大小\nexport type ButtonSize = \"lg\" | \"sm\";\n\nexport type ButtonType = \"primary\" | \"default\" | \"danger\" | \"link\";\n\ninterface BaseButtonProps {\n  /** 自定义类名 */\n  className?: string;\n  /** 设置Button 的禁用 */\n  disabled?: boolean;\n  /** 设置Button 的大小 */\n  size?: ButtonSize;\n  /** 设置Button 的类型 */\n  btnType?: ButtonType;\n  children: React.ReactNode;\n  /** 当btnType为link时，必填 */\n  href?: string;\n}\n\n// 并集\ntype NativeButtonProps = BaseButtonProps &\n  ButtonHTMLAttributes<HTMLElement>;\ntype AnchorButtonProps = BaseButtonProps &\n  AnchorHTMLAttributes<HTMLElement>;\n\n// Partial：typescript全局函数，将属性全部变成可选的\nexport type ButtonProps = Partial<NativeButtonProps & AnchorButtonProps>;\n\n// 使用react-docgen-typescript-loader的bug，只能使用FC，不能React.FC\nexport const Button: FC<ButtonProps> = (props) => {\n  const {\n    disabled,\n    size,\n    btnType,\n    children,\n    href,\n    className,\n    ...resetProps\n  } = props;\n\n  const classes = classnames(\"echo-btn\", className, {\n    [`echo-btn-${btnType}`]: btnType,\n    [`echo-btn-${size}`]: size,\n    \"echo-button-disabled\": btnType === \"link\" && disabled,\n  });\n  if (btnType === \"link\" && href) {\n    return (\n      <a href={href} className={classes} {...resetProps}>\n        {children}\n      </a>\n    );\n  } else {\n    return (\n      <button className={classes} disabled={disabled} {...resetProps}>\n        {children}\n      </button>\n    );\n  }\n};\n\nButton.defaultProps = {\n  disabled: false,\n  btnType: \"default\",\n};\n\nexport default Button;\n\n\n\n```\n* 新建 `src/components/Button/index.tsx`\n```\nimport Button from \"./button\";\n\nexport default Button;\n```\n* 新建 `src/components/Button/_style.scss`\n```\n@import \"../../styles/variables/button\";\n@import \"../../styles/mixin/button\";\n.echo-btn {\n  position: relative;\n  display: inline-block;\n  font-weight: $btn-font-weight;\n  line-height: $btn-line-height;\n  color: $body-color;\n  white-space: nowrap;\n  text-align: center;\n  vertical-align: middle;\n  background-image: none;\n  border: $btn-border-width solid transparent;\n  @include button-size(\n    $btn-padding-y,\n    $btn-padding-x,\n    $btn-font-size,\n    $btn-border-radius\n  );\n  box-shadow: $btn-box-shadow;\n  cursor: pointer;\n  transition: $btn-transition;\n  &.echo-button-disabled\n  &[disabled] {\n    cursor: not-allowed;\n    opacity: $btn-disabled-opacity;\n    box-shadow: none;\n    > * {\n      pointer-events: none;\n    }\n  }\n}\n\n.echo-btn-lg {\n  @include button-size(\n    $btn-padding-y-lg,\n    $btn-padding-x-lg,\n    $btn-font-size-lg,\n    $btn-border-radius-lg\n  );\n}\n\n.echo-btn-sm {\n  @include button-size(\n    $btn-padding-y-sm,\n    $btn-padding-x-sm,\n    $btn-font-size-sm,\n    $btn-border-radius-sm\n  );\n}\n\n.echo-btn-primary {\n  @include button-style($primary, $primary, $white);\n}\n\n.echo-btn-danger {\n  @include button-style($danger, $danger, $white);\n}\n\n.echo-btn-default {\n  @include button-style(\n    $white,\n    $gray-400,\n    $body-color,\n    $white,\n    $primary,\n    $primary\n  );\n}\n\n.echo-btn-link {\n  font-weight: $font-weight-normal;\n  color: $btn-link-color;\n  text-decoration: $link-decoration;\n  box-shadow: none;\n  &:hover {\n    color: $btn-link-hover-color;\n    text-decoration: $link-hover-decoration;\n  }\n  &:focus {\n    text-decoration: $link-hover-decoration;\n    box-shadow: none;\n  }\n  &:disabled,\n  &.echo-button-disabled {\n    color: $btn-link-disabled-color;\n    pointer-events: none;\n  }\n}\n```\n* 新建 `styles/variables/button.scss`文件\n```\n@import \"./common\";\n// 按钮基本属性\n$btn-font-weight: 400;\n$btn-padding-y: 0.375rem !default;\n$btn-padding-x: 0.75rem !default;\n$btn-font-family: $font-family-base !default;\n$btn-font-size: $font-size-base !default;\n$btn-line-height: $line-height-base !default;\n...\n...\n```\n* 新建 styles/mixin/button.scss`文件\n```\n@mixin button-size($padding-y, $padding-x, $font-size, $border-raduis) {\n  padding: $padding-y $padding-x;\n  font-size: $font-size;\n  border-radius: $border-raduis;\n}\n\n@mixin button-style(\n  $background,\n  $border,\n  $color,\n  // lghten,sass内置函数，比$background颜色要浅上7.5%\n    $hover-background: lighten($background, 7.5%),\n  $hover-border: lighten($border, 10%),\n  $hover-color: $color\n) \n...\n...\n```\n* 在 `src/styles/index.scss`文件中引入组件样式\n```\n// index文件主要是引入所有组件的样式。\n// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化\n\n// 按钮样式\n@import \"../components/Button/style\";\n\n```\n* 新建 `src/styles/index.scss`文件\n```\n// index文件主要是引入所有组件的样式。\n// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化\n\n// 按钮样式\n@import \"../components/Button/style\";\n...\n\n```\n## 五、 删除多余文件+引用组件\n* 删除`src/App.css` + `src/logo.svg` + `src/index.css` + `src/App.test.js` + `serviceWorker.ts`文件\n* 修改`App.tsx`文件\n```\nimport React from \"react\";\nimport \"./styles/index.scss\";\nimport Button, { ButtonType, ButtonSize } from \"./components/Button/button\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Button>hello</Button>\n      <Button disabled>hello</Button>\n      <Button btnType=\"primary\" size=\"sm\">\n        hello\n      </Button>\n      <Button\n        btnType=\"danger\"\n        size=\"lg\"\n        onClick={() => {\n          alert(111);\n        }}\n      >\n        hello\n      </Button>\n     <Button\n        btnType=\"link\"\n        href=\"http://www.baidu.com\"\n        target=\"_blank\"\n      >\n        hello\n      </Button>\n      <Button disabled btnType=\"link\" href=\"http://www.baidu.com\">\n        hello\n      </Button>\n    </div>\n  );\n}\nexport default App;\n```\n* 修改`src/index.tsx`文件\n```\nexport { default as Button } from \"./components/Button\";\n```\n## 六、 运行项目\n执行命令\n```\nnpm start\n```\n访问项目 可以看到button组件成功了！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8690603021ebd620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 七、单元测试\n新建`src/Button/button.test.tsx`文件\n```\nimport React from \"react\";\nimport { render, fireEvent } from \"@testing-library/react\";\nimport Button, { ButtonProps } from \"./button\";\n\ndescribe(\"Button 组件\", () => {\n  it('默认Button', () => {\n    const testProps: ButtonProps = {\n      onClick: jest.fn(),\n    }\n    const wrapper = render(<Button {...testProps}>hello</Button>);\n    const element = wrapper.getByText('hello')as HTMLButtonElement;\n    // 元素是否被渲染在文档中\n    expect(element).toBeInTheDocument();\n    // 判断标签名\n    expect(element.tagName).toEqual(\"BUTTON\");\n     // 判断是否有类名\n     expect(element).toHaveClass(\"echo-btn-default\");\n     expect(element).not.toHaveClass(\"echo-disabled\");\n     //   触发点击事件\n    fireEvent.click(element);\n    expect(testProps.onClick).toHaveBeenCalled();\n    expect(element.disabled).toBeFalsy();\n  })\n  it(\"测试传入不同属性的情况\", () => {\n    const testProps: ButtonProps = {\n      btnType: \"primary\",\n      size: \"lg\",\n      className: \"test-name\",\n    };\n    const wrapper = render(<Button {...testProps}>hello</Button>);\n    const element = wrapper.getByText(\"hello\") as HTMLButtonElement;\n    expect(element).toBeInTheDocument();\n    expect(element).toHaveClass(\"echo-btn-primary\");\n    expect(element).toHaveClass(\"echo-btn-lg\");\n    expect(element).toHaveClass(\"test-name\");\n  });\n\n  it(\"测试当btnType为link和href存在的情况\", () => {\n    const testProps: ButtonProps = {\n      btnType: \"link\",\n      href: \"http://www.baidu.com\",\n    };\n    const wrapper = render(<Button {...testProps}>Link</Button>);\n    const element = wrapper.getByText(\"Link\") as HTMLAnchorElement;\n    expect(element).toBeInTheDocument();\n    expect(element.tagName).toEqual(\"A\");\n    expect(element).toHaveClass(\"echo-btn-link\");\n  });\n\n  it(\"测试禁用的情况\", () => {\n    const testProps: ButtonProps = {\n      onClick: jest.fn(),\n      disabled: true,\n    };\n    const wrapper = render(<Button {...testProps}>Disabled</Button>);\n    const element = wrapper.getByText(\"Disabled\") as HTMLButtonElement;\n    expect(element).toBeInTheDocument();\n    expect(element.disabled).toBeTruthy();\n    fireEvent.click(element);\n    expect(testProps.onClick).not.toHaveBeenCalled();\n  });\n});\n```\n执行命令\n```\nnpm test\n```\n可以看到单元测试成功通过！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-04f6282ff0e82886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 八、组件库实现按需加载\n* 安装依赖\n```\n$npm install node-cmd -D\n```\n* 新建 `buildScss.js`文件\n```\nconst cmd = require(\"node-cmd\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst entryDir = path.resolve(__dirname, \"./src/components\");\nconst outputDir = path.resolve(__dirname, \"./dist/components\");\nfunction getScssEntry() {\n  let entryMap = {};\n  fs.readdirSync(entryDir).forEach(function (pathName) {\n    const entryName = path.resolve(entryDir, pathName);\n    const outputName = path.resolve(outputDir, pathName);\n    let entryFileName = path.resolve(entryName, \"_style.scss\");\n    let outputFileName = path.resolve(outputName, \"style/index.css\");\n\n    entryMap[pathName] = {};\n    entryMap[pathName].entry = entryFileName;\n    entryMap[pathName].output = outputFileName;\n  });\n\n  return entryMap;\n}\nconst entry = getScssEntry();\nlet buildArr = [];\nfor (const key in entry) {\n  const promise = new Promise((resolve, reject) => {\n    cmd.get(`npx node-sass ${entry[key].entry} ${entry[key].output}`, function (\n      err,\n      data,\n      stderr\n    ) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      console.log(\"the current working dir is : \", data);\n      fs.writeFileSync(\n        path.join(__dirname, `./dist/components/${key}/style/css.js`),\n        \"import './index.css'\"\n      );\n      resolve();\n    });\n  });\n  buildArr.push(promise);\n}\n\nPromise.all(buildArr)\n  .then(() => {\n    console.log(\"build success\");\n  })\n  .catch((e) => {\n    console.log(e);\n  });\n\n\n```\n* 新建 `_babel.config.js`文件\nlibraryName:需要加载的库，我这里的是echo-rui\nlibraryDirectory：需要加载的组件库所在的目录，当前的组件是存放在dist/components下的\nstyle：加载的css类型，当前项目只有css，没有less，所以这里写css即可，如需配置less,请看注释\n```\nmodule.exports = {\n  presets: [\"react-app\"],\n  plugins: [\n    [\n      \"import\",\n      {\n        libraryName: \"echo-rui\", \n        camel2DashComponentName: false, // 是否需要驼峰转短线\n        camel2UnderlineComponentName: false, // 是否需要驼峰转下划线\n        libraryDirectory: \"dist/components\",\n        style: \"css\",\n      },\n    ],\n    // [\"import\", {\n    //   \"libraryName\": \"antd\",\n    //   \"libraryDirectory\": \"es\",\n    //   \"style\": \"css\" // `style: true` 会加载 less 文件\n    // }]\n  ],\n};\n\n```\n⚠️⚠️⚠️重要说明：在开发的时候，每个组件目录下面必须有一个`_style.scss`样式文件，即使他是个空文件也必须有，否则会在按需引入的时候报错找不到css文件⚠️⚠️\n\n## 九、storybook文档生成\n1. 初始化storyBook\n```\nnpx -p @storybook/cli sb init\n```\n2. 添加依赖和插件\n```\nnpm install @storybook/addon-info --save-dev\n```\n3. 添加npm脚本\n```\n \"scripts\": {\n    ...\n    \"storybook\": \"start-storybook -p 9009 -s public\",\n    \"build-storybook\": \"build-storybook -s public\"\n  },\n```\n4. 配置storybook，支持typescript\n```\nnpm install react-docgen-typescript-loader -D\n```\n5. 添加storybook配置文件\n* 新建`.storybook/webpack.config.js`文件\n`shouldExtractLiteralValuesFromEnum`：storybook爬取组件属性的时候会自动把type类型的属性自动展开。\n `propFilter`：过滤掉不需要爬取的属性的来源。\n```\nmodule.exports = ({ config }) => {\n  config.module.rules.push({\n    test: /\\.tsx?$/,\n    use: [\n      {\n        loader: require.resolve(\"babel-loader\"),\n        options: {\n          presets: [require.resolve(\"babel-preset-react-app\")]\n        }\n      }, \n      {\n        loader: require.resolve(\"react-docgen-typescript-loader\"),\n        options: {\n          shouldExtractLiteralValuesFromEnum: true,\n          propFilter: (prop) => {\n            if (prop.parent) {\n              return !prop.parent.fileName.includes('node_modules')\n            }\n            return true            \n          }\n        }\n      }\n    ]\n  });\n\n  config.resolve.extensions.push(\".ts\", \".tsx\");\n\n  return config;\n};\n```\n* 新建`.storybook/style.scss`文件\n```\n// 这个文件主要是对storybook文档样式的配置\n```\n* 新建`.storybook/config.tsx`文件\n配置插件以及需要加载的文件\n```\nimport { configure,addDecorator,addParameters } from '@storybook/react';\nimport { withInfo } from '@storybook/addon-info'\n\n\nimport '../src/styles/index.scss'\nimport './style.scss'\nimport React from 'react'\n\nconst wrapperStyle: React.CSSProperties = {\n  padding: '20px 40px'\n}\n\nconst storyWrapper = (stroyFn: any) => (\n  <div style={wrapperStyle}>\n    <h3>组件演示</h3>\n    {stroyFn()}\n  </div>\n)\naddDecorator(storyWrapper)\naddDecorator(withInfo)\naddParameters({info: { inline: true, header: false}})\n\n\nconst loaderFn = () => {\n    const allExports = [];\n    const req = require.context('../src/components', true, /\\.stories\\.tsx$/);\n    req.keys().forEach(fname => allExports.push(req(fname)));\n    return allExports;\n  };\n\nconfigure(loaderFn, module);\n\n```\n\n6. 在每个组件目录下面新建一个`.stories.tsx`结尾的文件\n* button组件下新建`button.stories.tsx`文件\n```\nimport React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\n\nimport Button from './button'\n\nconst defaultButton = () => (\n    <div>\n        <Button onClick={action('default button')}>default button</Button>\n    </div>\n)\n\nconst buttonWithSize = () => (\n    <div>\n        <Button size='lg' btnType='primary' onClick={action('lg button')}>lg button</Button>\n        <Button className='ml-20' size='sm' btnType='danger' onClick={action('sm button')}>sm button</Button>\n    </div>\n)\n\n\nconst buttonWithType = () => (\n    <div>\n        <Button onClick={action('danger button')} btnType='danger'>danger button</Button>\n        <Button onClick={action('primary button')} className='ml-20' btnType='primary'>primary button</Button>\n        <Button onClick={action('link')} className='ml-20' btnType='link' href='https://www.baidu.com/'>link</Button>\n    </div>\n)\n\nconst buttonWithDisabled = () => (\n    <div>\n        <Button onClick={action('disabled button')} btnType='danger' disabled={true}>disabled button</Button>\n        <Button onClick={action('unDisabled button')} className='ml-20' btnType='primary'>unDisabled button</Button>\n    </div>\n)\n\n// storiesOf('Button组件', module)\n// .addDecorator(withInfo)\n// .addParameters({\n//     info:{\n//         text:`\n//         这是默认组件\n//         ~~~js\n//         const a = 12\n//         ~~~\n//         `,\n//         inline:true\n//     }\n// })\n//   .add('默认 Button', defaultButton)\n//   .add('不同尺寸 Button', buttonWithSize,{info:{inline:false}})\n//   .add('不同类型 Button', buttonWithType)\n\nstoriesOf('Button 按钮', module)\n    .addParameters({\n        info: {\n            text: `\n        ## 引用方法\n        ~~~js\n        import {Button} from ecoh-rui\n        ~~~\n        `\n        }\n    })\n    .add('默认 Button', defaultButton)\n    .add('不同尺寸 Button', buttonWithSize)\n    .add('不同类型 Button', buttonWithType)\n    .add('禁用的 Button',buttonWithDisabled)\n\n```\n7.执行命令\n```\nnpm run storybook\n```\n在终端可以看到\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8b43e51f15d70e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n浏览器打开`http://localhost:9009/`,可以看到组件库文档生成了。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-151907d5b1ed9637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 十、 typescript编译配置\n新建`tsconfig.build.json`文件\n```\n\n{\n  \"compilerOptions\": {\n    // 输出路径\n    \"outDir\": \"dist\",\n    // 打包模块规范\n    \"module\": \"esnext\",\n    // 构建目标\n    \"target\": \"es5\",\n    // 生成定义文件d.ts\n    \"declaration\": true,\n    \"jsx\": \"react\",\n    // 模块引入策略\n    \"moduleResolution\": \"Node\",\n    // 允许import React from 'react'这样导包\n    \"allowSyntheticDefaultImports\": true\n  },\n  // 需要编译的目录\n  \"include\": [\"src\"],\n  // 不需要编译的\n  \"exclude\": [\"src/**/*.test.tsx\", \"src/**/*.stories.tsx\", \"src/setupTests.ts\"]\n}\n\n```\n## 十一、 package.json相关配置\n* 将依赖包从dependencies搬到devDependencie\n>为什么要这么做？\n一、是防止发布组件库之后别人使用了跟我们不一样的react版本造成冲突\n二、是我们在开发的时候还需要使用到react和react-dom，所以不能删除，只能搬到devDependencies\n三、还有一些跟发布后的组件库不相关的依赖都需要搬到devDependencies，例如storybook等\n```\n// 嘿嘿，移动之后，发现为空了，重新install 了一下\n// 运行了npm start 和npm run test 和npm run storybook发现一切正常，开心一下！！\n\"dependencies\": {},\n```\n* 添加npm发布相关配置\n```\n\"description\": \"react components library\",\n\"author\": \"echo\",\n\"private\": false,\n// 主入口\n\"main\": \"dist/index.js\",\n// 模块入口\n\"module\": \"dist/index.js\",\n// 类型文件声明\n\"types\": \"dist/index.d.ts\",\n\"license\": \"MIT\",\n// 关键词\n\"keywords\": [\n    \"React\",\n    \"UI\",\n    \"Component\",\n    \"typescript\"\n  ],\n// 首页你的github地址\n  \"homepage\": \"https://github.com/.../echo-rui\",\n// 仓库地址\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/.../echo-ruii\"\n  },\n  // 需要上传的文件，不写就默认以.gitignore为准\n  \"files\": [\n    \"dist\"\n  ],\n```\n* 代码提交git前检查。这里使用husky这个工具\n```\n\"husky\": {\n    \"hooks\": {\n    // 用git提交代码之前\n      \"pre-commit\": \"npm run test:nowatch && npm run lint\"\n    }\n  },\n\"scripts\": {\n   ...\n    \"lint\": \"eslint --ext js,ts,tsx src --fix --max-warnings 5\",\n    \"test:nowatch\": \"cross-env CI=true react-scripts test\",\n   ... \n```\n* 添加打包发布相关配置\n```\n\"scripts\": {\n   ...\n    \"clean\": \"rimraf ./dist\",\n    \"build-ts\": \"tsc -p tsconfig.build.json\",\n    \"build-css\": \"node-sass ./src/styles/index.scss ./dist/index.css\",\n    \"build\": \"npm run clean && npm run build-ts && npm run build-css && node ./buildScss.js\",\n    \"prepublishOnly\": \"npm run lint && npm run build\"\n  \n   ... \n```\n此时执行打包命令，就可以成功根据配置打包了。\n## 十二、 发布到npm\n万事俱备，只欠发布。\n* 完善一下 README.md 文档，这个随便写两句就好\n* 在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多\n最后执行 npm login 登入 npm 账号，再执行 npm publish 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n大功告成✌️✌️✌️","source":"_posts/npmReactBuild.md","raw":"---\ntitle: 使用react搭建组件库：react+typescript+storybook\ndate: 2020-06-08 21:12:16\ntags: React\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n## 一、 安装组件库\n执行安装命令\n ```\nnpx create-react-app echo-rui  --typescript\n```\n## 二、 组件库配置eslint\n* 配置ESlint\n新建`.eslintrc.json`文件\n```\n{\n  \"extends\": \"react-app\"\n}\n```\n新建 `.vscode/settings.json`文件\n```\n{\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    { \"language\": \"typescript\", \"autoFix\": true },\n    { \"language\": \"typescriptreact\", \"autoFix\": true }\n  ]\n}\n```\n## 三、 引入依赖\n在组件中使用 `classname`：[https://github.com/jedWatson/classnames](https://github.com/jedWatson/classnames)\n执行安装命令\n```\nnpm install classnames -D\nnpm install @types/classnames -D\nnpm install node-sass -D\n```\n使用方法示例：\n如果对象的key值是变化的，可以采用下面的中括号的形式：[`btn-${btnType}`]\n```\n// btn, btn-lg, btn-primary\nconst classes = classNames('btn', className, {\n   [`btn-${btnType}`]: btnType,\n   [`btn-${size}`]: size,\n   'disabled': (btnType === 'link') && disabled\n})\n```\n## 四、 编写组件\n* 新建 `src/components/Button/button.tsx`\n\n```\nimport React,{FC,ButtonHTMLAttributes,AnchorHTMLAttributes} from \"react\";\nimport classnames from \"classnames\";\n\n\n// 按钮大小\nexport type ButtonSize = \"lg\" | \"sm\";\n\nexport type ButtonType = \"primary\" | \"default\" | \"danger\" | \"link\";\n\ninterface BaseButtonProps {\n  /** 自定义类名 */\n  className?: string;\n  /** 设置Button 的禁用 */\n  disabled?: boolean;\n  /** 设置Button 的大小 */\n  size?: ButtonSize;\n  /** 设置Button 的类型 */\n  btnType?: ButtonType;\n  children: React.ReactNode;\n  /** 当btnType为link时，必填 */\n  href?: string;\n}\n\n// 并集\ntype NativeButtonProps = BaseButtonProps &\n  ButtonHTMLAttributes<HTMLElement>;\ntype AnchorButtonProps = BaseButtonProps &\n  AnchorHTMLAttributes<HTMLElement>;\n\n// Partial：typescript全局函数，将属性全部变成可选的\nexport type ButtonProps = Partial<NativeButtonProps & AnchorButtonProps>;\n\n// 使用react-docgen-typescript-loader的bug，只能使用FC，不能React.FC\nexport const Button: FC<ButtonProps> = (props) => {\n  const {\n    disabled,\n    size,\n    btnType,\n    children,\n    href,\n    className,\n    ...resetProps\n  } = props;\n\n  const classes = classnames(\"echo-btn\", className, {\n    [`echo-btn-${btnType}`]: btnType,\n    [`echo-btn-${size}`]: size,\n    \"echo-button-disabled\": btnType === \"link\" && disabled,\n  });\n  if (btnType === \"link\" && href) {\n    return (\n      <a href={href} className={classes} {...resetProps}>\n        {children}\n      </a>\n    );\n  } else {\n    return (\n      <button className={classes} disabled={disabled} {...resetProps}>\n        {children}\n      </button>\n    );\n  }\n};\n\nButton.defaultProps = {\n  disabled: false,\n  btnType: \"default\",\n};\n\nexport default Button;\n\n\n\n```\n* 新建 `src/components/Button/index.tsx`\n```\nimport Button from \"./button\";\n\nexport default Button;\n```\n* 新建 `src/components/Button/_style.scss`\n```\n@import \"../../styles/variables/button\";\n@import \"../../styles/mixin/button\";\n.echo-btn {\n  position: relative;\n  display: inline-block;\n  font-weight: $btn-font-weight;\n  line-height: $btn-line-height;\n  color: $body-color;\n  white-space: nowrap;\n  text-align: center;\n  vertical-align: middle;\n  background-image: none;\n  border: $btn-border-width solid transparent;\n  @include button-size(\n    $btn-padding-y,\n    $btn-padding-x,\n    $btn-font-size,\n    $btn-border-radius\n  );\n  box-shadow: $btn-box-shadow;\n  cursor: pointer;\n  transition: $btn-transition;\n  &.echo-button-disabled\n  &[disabled] {\n    cursor: not-allowed;\n    opacity: $btn-disabled-opacity;\n    box-shadow: none;\n    > * {\n      pointer-events: none;\n    }\n  }\n}\n\n.echo-btn-lg {\n  @include button-size(\n    $btn-padding-y-lg,\n    $btn-padding-x-lg,\n    $btn-font-size-lg,\n    $btn-border-radius-lg\n  );\n}\n\n.echo-btn-sm {\n  @include button-size(\n    $btn-padding-y-sm,\n    $btn-padding-x-sm,\n    $btn-font-size-sm,\n    $btn-border-radius-sm\n  );\n}\n\n.echo-btn-primary {\n  @include button-style($primary, $primary, $white);\n}\n\n.echo-btn-danger {\n  @include button-style($danger, $danger, $white);\n}\n\n.echo-btn-default {\n  @include button-style(\n    $white,\n    $gray-400,\n    $body-color,\n    $white,\n    $primary,\n    $primary\n  );\n}\n\n.echo-btn-link {\n  font-weight: $font-weight-normal;\n  color: $btn-link-color;\n  text-decoration: $link-decoration;\n  box-shadow: none;\n  &:hover {\n    color: $btn-link-hover-color;\n    text-decoration: $link-hover-decoration;\n  }\n  &:focus {\n    text-decoration: $link-hover-decoration;\n    box-shadow: none;\n  }\n  &:disabled,\n  &.echo-button-disabled {\n    color: $btn-link-disabled-color;\n    pointer-events: none;\n  }\n}\n```\n* 新建 `styles/variables/button.scss`文件\n```\n@import \"./common\";\n// 按钮基本属性\n$btn-font-weight: 400;\n$btn-padding-y: 0.375rem !default;\n$btn-padding-x: 0.75rem !default;\n$btn-font-family: $font-family-base !default;\n$btn-font-size: $font-size-base !default;\n$btn-line-height: $line-height-base !default;\n...\n...\n```\n* 新建 styles/mixin/button.scss`文件\n```\n@mixin button-size($padding-y, $padding-x, $font-size, $border-raduis) {\n  padding: $padding-y $padding-x;\n  font-size: $font-size;\n  border-radius: $border-raduis;\n}\n\n@mixin button-style(\n  $background,\n  $border,\n  $color,\n  // lghten,sass内置函数，比$background颜色要浅上7.5%\n    $hover-background: lighten($background, 7.5%),\n  $hover-border: lighten($border, 10%),\n  $hover-color: $color\n) \n...\n...\n```\n* 在 `src/styles/index.scss`文件中引入组件样式\n```\n// index文件主要是引入所有组件的样式。\n// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化\n\n// 按钮样式\n@import \"../components/Button/style\";\n\n```\n* 新建 `src/styles/index.scss`文件\n```\n// index文件主要是引入所有组件的样式。\n// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化\n\n// 按钮样式\n@import \"../components/Button/style\";\n...\n\n```\n## 五、 删除多余文件+引用组件\n* 删除`src/App.css` + `src/logo.svg` + `src/index.css` + `src/App.test.js` + `serviceWorker.ts`文件\n* 修改`App.tsx`文件\n```\nimport React from \"react\";\nimport \"./styles/index.scss\";\nimport Button, { ButtonType, ButtonSize } from \"./components/Button/button\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Button>hello</Button>\n      <Button disabled>hello</Button>\n      <Button btnType=\"primary\" size=\"sm\">\n        hello\n      </Button>\n      <Button\n        btnType=\"danger\"\n        size=\"lg\"\n        onClick={() => {\n          alert(111);\n        }}\n      >\n        hello\n      </Button>\n     <Button\n        btnType=\"link\"\n        href=\"http://www.baidu.com\"\n        target=\"_blank\"\n      >\n        hello\n      </Button>\n      <Button disabled btnType=\"link\" href=\"http://www.baidu.com\">\n        hello\n      </Button>\n    </div>\n  );\n}\nexport default App;\n```\n* 修改`src/index.tsx`文件\n```\nexport { default as Button } from \"./components/Button\";\n```\n## 六、 运行项目\n执行命令\n```\nnpm start\n```\n访问项目 可以看到button组件成功了！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8690603021ebd620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 七、单元测试\n新建`src/Button/button.test.tsx`文件\n```\nimport React from \"react\";\nimport { render, fireEvent } from \"@testing-library/react\";\nimport Button, { ButtonProps } from \"./button\";\n\ndescribe(\"Button 组件\", () => {\n  it('默认Button', () => {\n    const testProps: ButtonProps = {\n      onClick: jest.fn(),\n    }\n    const wrapper = render(<Button {...testProps}>hello</Button>);\n    const element = wrapper.getByText('hello')as HTMLButtonElement;\n    // 元素是否被渲染在文档中\n    expect(element).toBeInTheDocument();\n    // 判断标签名\n    expect(element.tagName).toEqual(\"BUTTON\");\n     // 判断是否有类名\n     expect(element).toHaveClass(\"echo-btn-default\");\n     expect(element).not.toHaveClass(\"echo-disabled\");\n     //   触发点击事件\n    fireEvent.click(element);\n    expect(testProps.onClick).toHaveBeenCalled();\n    expect(element.disabled).toBeFalsy();\n  })\n  it(\"测试传入不同属性的情况\", () => {\n    const testProps: ButtonProps = {\n      btnType: \"primary\",\n      size: \"lg\",\n      className: \"test-name\",\n    };\n    const wrapper = render(<Button {...testProps}>hello</Button>);\n    const element = wrapper.getByText(\"hello\") as HTMLButtonElement;\n    expect(element).toBeInTheDocument();\n    expect(element).toHaveClass(\"echo-btn-primary\");\n    expect(element).toHaveClass(\"echo-btn-lg\");\n    expect(element).toHaveClass(\"test-name\");\n  });\n\n  it(\"测试当btnType为link和href存在的情况\", () => {\n    const testProps: ButtonProps = {\n      btnType: \"link\",\n      href: \"http://www.baidu.com\",\n    };\n    const wrapper = render(<Button {...testProps}>Link</Button>);\n    const element = wrapper.getByText(\"Link\") as HTMLAnchorElement;\n    expect(element).toBeInTheDocument();\n    expect(element.tagName).toEqual(\"A\");\n    expect(element).toHaveClass(\"echo-btn-link\");\n  });\n\n  it(\"测试禁用的情况\", () => {\n    const testProps: ButtonProps = {\n      onClick: jest.fn(),\n      disabled: true,\n    };\n    const wrapper = render(<Button {...testProps}>Disabled</Button>);\n    const element = wrapper.getByText(\"Disabled\") as HTMLButtonElement;\n    expect(element).toBeInTheDocument();\n    expect(element.disabled).toBeTruthy();\n    fireEvent.click(element);\n    expect(testProps.onClick).not.toHaveBeenCalled();\n  });\n});\n```\n执行命令\n```\nnpm test\n```\n可以看到单元测试成功通过！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-04f6282ff0e82886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 八、组件库实现按需加载\n* 安装依赖\n```\n$npm install node-cmd -D\n```\n* 新建 `buildScss.js`文件\n```\nconst cmd = require(\"node-cmd\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst entryDir = path.resolve(__dirname, \"./src/components\");\nconst outputDir = path.resolve(__dirname, \"./dist/components\");\nfunction getScssEntry() {\n  let entryMap = {};\n  fs.readdirSync(entryDir).forEach(function (pathName) {\n    const entryName = path.resolve(entryDir, pathName);\n    const outputName = path.resolve(outputDir, pathName);\n    let entryFileName = path.resolve(entryName, \"_style.scss\");\n    let outputFileName = path.resolve(outputName, \"style/index.css\");\n\n    entryMap[pathName] = {};\n    entryMap[pathName].entry = entryFileName;\n    entryMap[pathName].output = outputFileName;\n  });\n\n  return entryMap;\n}\nconst entry = getScssEntry();\nlet buildArr = [];\nfor (const key in entry) {\n  const promise = new Promise((resolve, reject) => {\n    cmd.get(`npx node-sass ${entry[key].entry} ${entry[key].output}`, function (\n      err,\n      data,\n      stderr\n    ) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      console.log(\"the current working dir is : \", data);\n      fs.writeFileSync(\n        path.join(__dirname, `./dist/components/${key}/style/css.js`),\n        \"import './index.css'\"\n      );\n      resolve();\n    });\n  });\n  buildArr.push(promise);\n}\n\nPromise.all(buildArr)\n  .then(() => {\n    console.log(\"build success\");\n  })\n  .catch((e) => {\n    console.log(e);\n  });\n\n\n```\n* 新建 `_babel.config.js`文件\nlibraryName:需要加载的库，我这里的是echo-rui\nlibraryDirectory：需要加载的组件库所在的目录，当前的组件是存放在dist/components下的\nstyle：加载的css类型，当前项目只有css，没有less，所以这里写css即可，如需配置less,请看注释\n```\nmodule.exports = {\n  presets: [\"react-app\"],\n  plugins: [\n    [\n      \"import\",\n      {\n        libraryName: \"echo-rui\", \n        camel2DashComponentName: false, // 是否需要驼峰转短线\n        camel2UnderlineComponentName: false, // 是否需要驼峰转下划线\n        libraryDirectory: \"dist/components\",\n        style: \"css\",\n      },\n    ],\n    // [\"import\", {\n    //   \"libraryName\": \"antd\",\n    //   \"libraryDirectory\": \"es\",\n    //   \"style\": \"css\" // `style: true` 会加载 less 文件\n    // }]\n  ],\n};\n\n```\n⚠️⚠️⚠️重要说明：在开发的时候，每个组件目录下面必须有一个`_style.scss`样式文件，即使他是个空文件也必须有，否则会在按需引入的时候报错找不到css文件⚠️⚠️\n\n## 九、storybook文档生成\n1. 初始化storyBook\n```\nnpx -p @storybook/cli sb init\n```\n2. 添加依赖和插件\n```\nnpm install @storybook/addon-info --save-dev\n```\n3. 添加npm脚本\n```\n \"scripts\": {\n    ...\n    \"storybook\": \"start-storybook -p 9009 -s public\",\n    \"build-storybook\": \"build-storybook -s public\"\n  },\n```\n4. 配置storybook，支持typescript\n```\nnpm install react-docgen-typescript-loader -D\n```\n5. 添加storybook配置文件\n* 新建`.storybook/webpack.config.js`文件\n`shouldExtractLiteralValuesFromEnum`：storybook爬取组件属性的时候会自动把type类型的属性自动展开。\n `propFilter`：过滤掉不需要爬取的属性的来源。\n```\nmodule.exports = ({ config }) => {\n  config.module.rules.push({\n    test: /\\.tsx?$/,\n    use: [\n      {\n        loader: require.resolve(\"babel-loader\"),\n        options: {\n          presets: [require.resolve(\"babel-preset-react-app\")]\n        }\n      }, \n      {\n        loader: require.resolve(\"react-docgen-typescript-loader\"),\n        options: {\n          shouldExtractLiteralValuesFromEnum: true,\n          propFilter: (prop) => {\n            if (prop.parent) {\n              return !prop.parent.fileName.includes('node_modules')\n            }\n            return true            \n          }\n        }\n      }\n    ]\n  });\n\n  config.resolve.extensions.push(\".ts\", \".tsx\");\n\n  return config;\n};\n```\n* 新建`.storybook/style.scss`文件\n```\n// 这个文件主要是对storybook文档样式的配置\n```\n* 新建`.storybook/config.tsx`文件\n配置插件以及需要加载的文件\n```\nimport { configure,addDecorator,addParameters } from '@storybook/react';\nimport { withInfo } from '@storybook/addon-info'\n\n\nimport '../src/styles/index.scss'\nimport './style.scss'\nimport React from 'react'\n\nconst wrapperStyle: React.CSSProperties = {\n  padding: '20px 40px'\n}\n\nconst storyWrapper = (stroyFn: any) => (\n  <div style={wrapperStyle}>\n    <h3>组件演示</h3>\n    {stroyFn()}\n  </div>\n)\naddDecorator(storyWrapper)\naddDecorator(withInfo)\naddParameters({info: { inline: true, header: false}})\n\n\nconst loaderFn = () => {\n    const allExports = [];\n    const req = require.context('../src/components', true, /\\.stories\\.tsx$/);\n    req.keys().forEach(fname => allExports.push(req(fname)));\n    return allExports;\n  };\n\nconfigure(loaderFn, module);\n\n```\n\n6. 在每个组件目录下面新建一个`.stories.tsx`结尾的文件\n* button组件下新建`button.stories.tsx`文件\n```\nimport React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\n\nimport Button from './button'\n\nconst defaultButton = () => (\n    <div>\n        <Button onClick={action('default button')}>default button</Button>\n    </div>\n)\n\nconst buttonWithSize = () => (\n    <div>\n        <Button size='lg' btnType='primary' onClick={action('lg button')}>lg button</Button>\n        <Button className='ml-20' size='sm' btnType='danger' onClick={action('sm button')}>sm button</Button>\n    </div>\n)\n\n\nconst buttonWithType = () => (\n    <div>\n        <Button onClick={action('danger button')} btnType='danger'>danger button</Button>\n        <Button onClick={action('primary button')} className='ml-20' btnType='primary'>primary button</Button>\n        <Button onClick={action('link')} className='ml-20' btnType='link' href='https://www.baidu.com/'>link</Button>\n    </div>\n)\n\nconst buttonWithDisabled = () => (\n    <div>\n        <Button onClick={action('disabled button')} btnType='danger' disabled={true}>disabled button</Button>\n        <Button onClick={action('unDisabled button')} className='ml-20' btnType='primary'>unDisabled button</Button>\n    </div>\n)\n\n// storiesOf('Button组件', module)\n// .addDecorator(withInfo)\n// .addParameters({\n//     info:{\n//         text:`\n//         这是默认组件\n//         ~~~js\n//         const a = 12\n//         ~~~\n//         `,\n//         inline:true\n//     }\n// })\n//   .add('默认 Button', defaultButton)\n//   .add('不同尺寸 Button', buttonWithSize,{info:{inline:false}})\n//   .add('不同类型 Button', buttonWithType)\n\nstoriesOf('Button 按钮', module)\n    .addParameters({\n        info: {\n            text: `\n        ## 引用方法\n        ~~~js\n        import {Button} from ecoh-rui\n        ~~~\n        `\n        }\n    })\n    .add('默认 Button', defaultButton)\n    .add('不同尺寸 Button', buttonWithSize)\n    .add('不同类型 Button', buttonWithType)\n    .add('禁用的 Button',buttonWithDisabled)\n\n```\n7.执行命令\n```\nnpm run storybook\n```\n在终端可以看到\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8b43e51f15d70e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n浏览器打开`http://localhost:9009/`,可以看到组件库文档生成了。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-151907d5b1ed9637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 十、 typescript编译配置\n新建`tsconfig.build.json`文件\n```\n\n{\n  \"compilerOptions\": {\n    // 输出路径\n    \"outDir\": \"dist\",\n    // 打包模块规范\n    \"module\": \"esnext\",\n    // 构建目标\n    \"target\": \"es5\",\n    // 生成定义文件d.ts\n    \"declaration\": true,\n    \"jsx\": \"react\",\n    // 模块引入策略\n    \"moduleResolution\": \"Node\",\n    // 允许import React from 'react'这样导包\n    \"allowSyntheticDefaultImports\": true\n  },\n  // 需要编译的目录\n  \"include\": [\"src\"],\n  // 不需要编译的\n  \"exclude\": [\"src/**/*.test.tsx\", \"src/**/*.stories.tsx\", \"src/setupTests.ts\"]\n}\n\n```\n## 十一、 package.json相关配置\n* 将依赖包从dependencies搬到devDependencie\n>为什么要这么做？\n一、是防止发布组件库之后别人使用了跟我们不一样的react版本造成冲突\n二、是我们在开发的时候还需要使用到react和react-dom，所以不能删除，只能搬到devDependencies\n三、还有一些跟发布后的组件库不相关的依赖都需要搬到devDependencies，例如storybook等\n```\n// 嘿嘿，移动之后，发现为空了，重新install 了一下\n// 运行了npm start 和npm run test 和npm run storybook发现一切正常，开心一下！！\n\"dependencies\": {},\n```\n* 添加npm发布相关配置\n```\n\"description\": \"react components library\",\n\"author\": \"echo\",\n\"private\": false,\n// 主入口\n\"main\": \"dist/index.js\",\n// 模块入口\n\"module\": \"dist/index.js\",\n// 类型文件声明\n\"types\": \"dist/index.d.ts\",\n\"license\": \"MIT\",\n// 关键词\n\"keywords\": [\n    \"React\",\n    \"UI\",\n    \"Component\",\n    \"typescript\"\n  ],\n// 首页你的github地址\n  \"homepage\": \"https://github.com/.../echo-rui\",\n// 仓库地址\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/.../echo-ruii\"\n  },\n  // 需要上传的文件，不写就默认以.gitignore为准\n  \"files\": [\n    \"dist\"\n  ],\n```\n* 代码提交git前检查。这里使用husky这个工具\n```\n\"husky\": {\n    \"hooks\": {\n    // 用git提交代码之前\n      \"pre-commit\": \"npm run test:nowatch && npm run lint\"\n    }\n  },\n\"scripts\": {\n   ...\n    \"lint\": \"eslint --ext js,ts,tsx src --fix --max-warnings 5\",\n    \"test:nowatch\": \"cross-env CI=true react-scripts test\",\n   ... \n```\n* 添加打包发布相关配置\n```\n\"scripts\": {\n   ...\n    \"clean\": \"rimraf ./dist\",\n    \"build-ts\": \"tsc -p tsconfig.build.json\",\n    \"build-css\": \"node-sass ./src/styles/index.scss ./dist/index.css\",\n    \"build\": \"npm run clean && npm run build-ts && npm run build-css && node ./buildScss.js\",\n    \"prepublishOnly\": \"npm run lint && npm run build\"\n  \n   ... \n```\n此时执行打包命令，就可以成功根据配置打包了。\n## 十二、 发布到npm\n万事俱备，只欠发布。\n* 完善一下 README.md 文档，这个随便写两句就好\n* 在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多\n最后执行 npm login 登入 npm 账号，再执行 npm publish 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。\n\n大功告成✌️✌️✌️","slug":"npmReactBuild","published":1,"updated":"2020-12-14T10:42:22.624Z","_id":"ckioehjro001w78p3qh8o9cm9","comments":1,"layout":"post","photos":[],"link":"","content":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h2 id=\"一、-安装组件库\"><a href=\"#一、-安装组件库\" class=\"headerlink\" title=\"一、 安装组件库\"></a>一、 安装组件库</h2><p>执行安装命令<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx create-react-app echo-rui  --typescript</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、-组件库配置eslint\"><a href=\"#二、-组件库配置eslint\" class=\"headerlink\" title=\"二、 组件库配置eslint\"></a>二、 组件库配置eslint</h2><ul>\n<li>配置ESlint<br>新建<code>.eslintrc.json</code>文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extends&quot;: &quot;react-app&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>新建 <code>.vscode/settings.json</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;eslint.validate&quot;: [</span><br><span class=\"line\">    &quot;javascript&quot;,</span><br><span class=\"line\">    &quot;javascriptreact&quot;,</span><br><span class=\"line\">    &#123; &quot;language&quot;: &quot;typescript&quot;, &quot;autoFix&quot;: true &#125;,</span><br><span class=\"line\">    &#123; &quot;language&quot;: &quot;typescriptreact&quot;, &quot;autoFix&quot;: true &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、-引入依赖\"><a href=\"#三、-引入依赖\" class=\"headerlink\" title=\"三、 引入依赖\"></a>三、 引入依赖</h2><p>在组件中使用 <code>classname</code>：<a href=\"https://github.com/jedWatson/classnames\" target=\"_blank\" rel=\"noopener\">https://github.com/jedWatson/classnames</a><br>执行安装命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install classnames -D</span><br><span class=\"line\">npm install @types/classnames -D</span><br><span class=\"line\">npm install node-sass -D</span><br></pre></td></tr></table></figure></p>\n<p>使用方法示例：<br>如果对象的key值是变化的，可以采用下面的中括号的形式：[<code>btn-${btnType}</code>]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// btn, btn-lg, btn-primary</span><br><span class=\"line\">const classes = classNames(&apos;btn&apos;, className, &#123;</span><br><span class=\"line\">   [`btn-$&#123;btnType&#125;`]: btnType,</span><br><span class=\"line\">   [`btn-$&#123;size&#125;`]: size,</span><br><span class=\"line\">   &apos;disabled&apos;: (btnType === &apos;link&apos;) &amp;&amp; disabled</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"四、-编写组件\"><a href=\"#四、-编写组件\" class=\"headerlink\" title=\"四、 编写组件\"></a>四、 编写组件</h2><ul>\n<li>新建 <code>src/components/Button/button.tsx</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;FC,ButtonHTMLAttributes,AnchorHTMLAttributes&#125; from &quot;react&quot;;</span><br><span class=\"line\">import classnames from &quot;classnames&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 按钮大小</span><br><span class=\"line\">export type ButtonSize = &quot;lg&quot; | &quot;sm&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export type ButtonType = &quot;primary&quot; | &quot;default&quot; | &quot;danger&quot; | &quot;link&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface BaseButtonProps &#123;</span><br><span class=\"line\">  /** 自定义类名 */</span><br><span class=\"line\">  className?: string;</span><br><span class=\"line\">  /** 设置Button 的禁用 */</span><br><span class=\"line\">  disabled?: boolean;</span><br><span class=\"line\">  /** 设置Button 的大小 */</span><br><span class=\"line\">  size?: ButtonSize;</span><br><span class=\"line\">  /** 设置Button 的类型 */</span><br><span class=\"line\">  btnType?: ButtonType;</span><br><span class=\"line\">  children: React.ReactNode;</span><br><span class=\"line\">  /** 当btnType为link时，必填 */</span><br><span class=\"line\">  href?: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 并集</span><br><span class=\"line\">type NativeButtonProps = BaseButtonProps &amp;</span><br><span class=\"line\">  ButtonHTMLAttributes&lt;HTMLElement&gt;;</span><br><span class=\"line\">type AnchorButtonProps = BaseButtonProps &amp;</span><br><span class=\"line\">  AnchorHTMLAttributes&lt;HTMLElement&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Partial：typescript全局函数，将属性全部变成可选的</span><br><span class=\"line\">export type ButtonProps = Partial&lt;NativeButtonProps &amp; AnchorButtonProps&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用react-docgen-typescript-loader的bug，只能使用FC，不能React.FC</span><br><span class=\"line\">export const Button: FC&lt;ButtonProps&gt; = (props) =&gt; &#123;</span><br><span class=\"line\">  const &#123;</span><br><span class=\"line\">    disabled,</span><br><span class=\"line\">    size,</span><br><span class=\"line\">    btnType,</span><br><span class=\"line\">    children,</span><br><span class=\"line\">    href,</span><br><span class=\"line\">    className,</span><br><span class=\"line\">    ...resetProps</span><br><span class=\"line\">  &#125; = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  const classes = classnames(&quot;echo-btn&quot;, className, &#123;</span><br><span class=\"line\">    [`echo-btn-$&#123;btnType&#125;`]: btnType,</span><br><span class=\"line\">    [`echo-btn-$&#123;size&#125;`]: size,</span><br><span class=\"line\">    &quot;echo-button-disabled&quot;: btnType === &quot;link&quot; &amp;&amp; disabled,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  if (btnType === &quot;link&quot; &amp;&amp; href) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;a href=&#123;href&#125; className=&#123;classes&#125; &#123;...resetProps&#125;&gt;</span><br><span class=\"line\">        &#123;children&#125;</span><br><span class=\"line\">      &lt;/a&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;button className=&#123;classes&#125; disabled=&#123;disabled&#125; &#123;...resetProps&#125;&gt;</span><br><span class=\"line\">        &#123;children&#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Button.defaultProps = &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  btnType: &quot;default&quot;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Button;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>新建 <code>src/components/Button/index.tsx</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Button from &quot;./button&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Button;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>src/components/Button/_style.scss</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/button&quot;;</span><br><span class=\"line\">@import &quot;../../styles/mixin/button&quot;;</span><br><span class=\"line\">.echo-btn &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  font-weight: $btn-font-weight;</span><br><span class=\"line\">  line-height: $btn-line-height;</span><br><span class=\"line\">  color: $body-color;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  vertical-align: middle;</span><br><span class=\"line\">  background-image: none;</span><br><span class=\"line\">  border: $btn-border-width solid transparent;</span><br><span class=\"line\">  @include button-size(</span><br><span class=\"line\">    $btn-padding-y,</span><br><span class=\"line\">    $btn-padding-x,</span><br><span class=\"line\">    $btn-font-size,</span><br><span class=\"line\">    $btn-border-radius</span><br><span class=\"line\">  );</span><br><span class=\"line\">  box-shadow: $btn-box-shadow;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">  transition: $btn-transition;</span><br><span class=\"line\">  &amp;.echo-button-disabled</span><br><span class=\"line\">  &amp;[disabled] &#123;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">    opacity: $btn-disabled-opacity;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">    &gt; * &#123;</span><br><span class=\"line\">      pointer-events: none;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-lg &#123;</span><br><span class=\"line\">  @include button-size(</span><br><span class=\"line\">    $btn-padding-y-lg,</span><br><span class=\"line\">    $btn-padding-x-lg,</span><br><span class=\"line\">    $btn-font-size-lg,</span><br><span class=\"line\">    $btn-border-radius-lg</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-sm &#123;</span><br><span class=\"line\">  @include button-size(</span><br><span class=\"line\">    $btn-padding-y-sm,</span><br><span class=\"line\">    $btn-padding-x-sm,</span><br><span class=\"line\">    $btn-font-size-sm,</span><br><span class=\"line\">    $btn-border-radius-sm</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-primary &#123;</span><br><span class=\"line\">  @include button-style($primary, $primary, $white);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-danger &#123;</span><br><span class=\"line\">  @include button-style($danger, $danger, $white);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-default &#123;</span><br><span class=\"line\">  @include button-style(</span><br><span class=\"line\">    $white,</span><br><span class=\"line\">    $gray-400,</span><br><span class=\"line\">    $body-color,</span><br><span class=\"line\">    $white,</span><br><span class=\"line\">    $primary,</span><br><span class=\"line\">    $primary</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-link &#123;</span><br><span class=\"line\">  font-weight: $font-weight-normal;</span><br><span class=\"line\">  color: $btn-link-color;</span><br><span class=\"line\">  text-decoration: $link-decoration;</span><br><span class=\"line\">  box-shadow: none;</span><br><span class=\"line\">  &amp;:hover &#123;</span><br><span class=\"line\">    color: $btn-link-hover-color;</span><br><span class=\"line\">    text-decoration: $link-hover-decoration;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;:focus &#123;</span><br><span class=\"line\">    text-decoration: $link-hover-decoration;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;:disabled,</span><br><span class=\"line\">  &amp;.echo-button-disabled &#123;</span><br><span class=\"line\">    color: $btn-link-disabled-color;</span><br><span class=\"line\">    pointer-events: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>styles/variables/button.scss</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;./common&quot;;</span><br><span class=\"line\">// 按钮基本属性</span><br><span class=\"line\">$btn-font-weight: 400;</span><br><span class=\"line\">$btn-padding-y: 0.375rem !default;</span><br><span class=\"line\">$btn-padding-x: 0.75rem !default;</span><br><span class=\"line\">$btn-font-family: $font-family-base !default;</span><br><span class=\"line\">$btn-font-size: $font-size-base !default;</span><br><span class=\"line\">$btn-line-height: $line-height-base !default;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 styles/mixin/button.scss`文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@mixin button-size($padding-y, $padding-x, $font-size, $border-raduis) &#123;</span><br><span class=\"line\">  padding: $padding-y $padding-x;</span><br><span class=\"line\">  font-size: $font-size;</span><br><span class=\"line\">  border-radius: $border-raduis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@mixin button-style(</span><br><span class=\"line\">  $background,</span><br><span class=\"line\">  $border,</span><br><span class=\"line\">  $color,</span><br><span class=\"line\">  // lghten,sass内置函数，比$background颜色要浅上7.5%</span><br><span class=\"line\">    $hover-background: lighten($background, 7.5%),</span><br><span class=\"line\">  $hover-border: lighten($border, 10%),</span><br><span class=\"line\">  $hover-color: $color</span><br><span class=\"line\">) </span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 <code>src/styles/index.scss</code>文件中引入组件样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index文件主要是引入所有组件的样式。</span><br><span class=\"line\">// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化</span><br><span class=\"line\"></span><br><span class=\"line\">// 按钮样式</span><br><span class=\"line\">@import &quot;../components/Button/style&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>src/styles/index.scss</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index文件主要是引入所有组件的样式。</span><br><span class=\"line\">// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化</span><br><span class=\"line\"></span><br><span class=\"line\">// 按钮样式</span><br><span class=\"line\">@import &quot;../components/Button/style&quot;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"五、-删除多余文件-引用组件\"><a href=\"#五、-删除多余文件-引用组件\" class=\"headerlink\" title=\"五、 删除多余文件+引用组件\"></a>五、 删除多余文件+引用组件</h2><ul>\n<li>删除<code>src/App.css</code> + <code>src/logo.svg</code> + <code>src/index.css</code> + <code>src/App.test.js</code> + <code>serviceWorker.ts</code>文件</li>\n<li><p>修改<code>App.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import &quot;./styles/index.scss&quot;;</span><br><span class=\"line\">import Button, &#123; ButtonType, ButtonSize &#125; from &quot;./components/Button/button&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div className=&quot;App&quot;&gt;</span><br><span class=\"line\">      &lt;Button&gt;hello&lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button disabled&gt;hello&lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button btnType=&quot;primary&quot; size=&quot;sm&quot;&gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button</span><br><span class=\"line\">        btnType=&quot;danger&quot;</span><br><span class=\"line\">        size=&quot;lg&quot;</span><br><span class=\"line\">        onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">          alert(111);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">     &lt;Button</span><br><span class=\"line\">        btnType=&quot;link&quot;</span><br><span class=\"line\">        href=&quot;http://www.baidu.com&quot;</span><br><span class=\"line\">        target=&quot;_blank&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button disabled btnType=&quot;link&quot; href=&quot;http://www.baidu.com&quot;&gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>src/index.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as Button &#125; from &quot;./components/Button&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"六、-运行项目\"><a href=\"#六、-运行项目\" class=\"headerlink\" title=\"六、 运行项目\"></a>六、 运行项目</h2><p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm start</span><br></pre></td></tr></table></figure></p>\n<p>访问项目 可以看到button组件成功了！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8690603021ebd620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"七、单元测试\"><a href=\"#七、单元测试\" class=\"headerlink\" title=\"七、单元测试\"></a>七、单元测试</h2><p>新建<code>src/Button/button.test.tsx</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import &#123; render, fireEvent &#125; from &quot;@testing-library/react&quot;;</span><br><span class=\"line\">import Button, &#123; ButtonProps &#125; from &quot;./button&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&quot;Button 组件&quot;, () =&gt; &#123;</span><br><span class=\"line\">  it(&apos;默认Button&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      onClick: jest.fn(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;hello&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&apos;hello&apos;)as HTMLButtonElement;</span><br><span class=\"line\">    // 元素是否被渲染在文档中</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    // 判断标签名</span><br><span class=\"line\">    expect(element.tagName).toEqual(&quot;BUTTON&quot;);</span><br><span class=\"line\">     // 判断是否有类名</span><br><span class=\"line\">     expect(element).toHaveClass(&quot;echo-btn-default&quot;);</span><br><span class=\"line\">     expect(element).not.toHaveClass(&quot;echo-disabled&quot;);</span><br><span class=\"line\">     //   触发点击事件</span><br><span class=\"line\">    fireEvent.click(element);</span><br><span class=\"line\">    expect(testProps.onClick).toHaveBeenCalled();</span><br><span class=\"line\">    expect(element.disabled).toBeFalsy();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  it(&quot;测试传入不同属性的情况&quot;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      btnType: &quot;primary&quot;,</span><br><span class=\"line\">      size: &quot;lg&quot;,</span><br><span class=\"line\">      className: &quot;test-name&quot;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;hello&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&quot;hello&quot;) as HTMLButtonElement;</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;echo-btn-primary&quot;);</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;echo-btn-lg&quot;);</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;test-name&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;测试当btnType为link和href存在的情况&quot;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      btnType: &quot;link&quot;,</span><br><span class=\"line\">      href: &quot;http://www.baidu.com&quot;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;Link&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&quot;Link&quot;) as HTMLAnchorElement;</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    expect(element.tagName).toEqual(&quot;A&quot;);</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;echo-btn-link&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;测试禁用的情况&quot;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      onClick: jest.fn(),</span><br><span class=\"line\">      disabled: true,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;Disabled&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&quot;Disabled&quot;) as HTMLButtonElement;</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    expect(element.disabled).toBeTruthy();</span><br><span class=\"line\">    fireEvent.click(element);</span><br><span class=\"line\">    expect(testProps.onClick).not.toHaveBeenCalled();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm test</span><br></pre></td></tr></table></figure></p>\n<p>可以看到单元测试成功通过！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-04f6282ff0e82886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"八、组件库实现按需加载\"><a href=\"#八、组件库实现按需加载\" class=\"headerlink\" title=\"八、组件库实现按需加载\"></a>八、组件库实现按需加载</h2><ul>\n<li><p>安装依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$npm install node-cmd -D</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>buildScss.js</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cmd = require(&quot;node-cmd&quot;);</span><br><span class=\"line\">const path = require(&quot;path&quot;);</span><br><span class=\"line\">const fs = require(&quot;fs&quot;);</span><br><span class=\"line\">const entryDir = path.resolve(__dirname, &quot;./src/components&quot;);</span><br><span class=\"line\">const outputDir = path.resolve(__dirname, &quot;./dist/components&quot;);</span><br><span class=\"line\">function getScssEntry() &#123;</span><br><span class=\"line\">  let entryMap = &#123;&#125;;</span><br><span class=\"line\">  fs.readdirSync(entryDir).forEach(function (pathName) &#123;</span><br><span class=\"line\">    const entryName = path.resolve(entryDir, pathName);</span><br><span class=\"line\">    const outputName = path.resolve(outputDir, pathName);</span><br><span class=\"line\">    let entryFileName = path.resolve(entryName, &quot;_style.scss&quot;);</span><br><span class=\"line\">    let outputFileName = path.resolve(outputName, &quot;style/index.css&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    entryMap[pathName] = &#123;&#125;;</span><br><span class=\"line\">    entryMap[pathName].entry = entryFileName;</span><br><span class=\"line\">    entryMap[pathName].output = outputFileName;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return entryMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const entry = getScssEntry();</span><br><span class=\"line\">let buildArr = [];</span><br><span class=\"line\">for (const key in entry) &#123;</span><br><span class=\"line\">  const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    cmd.get(`npx node-sass $&#123;entry[key].entry&#125; $&#123;entry[key].output&#125;`, function (</span><br><span class=\"line\">      err,</span><br><span class=\"line\">      data,</span><br><span class=\"line\">      stderr</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(&quot;the current working dir is : &quot;, data);</span><br><span class=\"line\">      fs.writeFileSync(</span><br><span class=\"line\">        path.join(__dirname, `./dist/components/$&#123;key&#125;/style/css.js`),</span><br><span class=\"line\">        &quot;import &apos;./index.css&apos;&quot;</span><br><span class=\"line\">      );</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  buildArr.push(promise);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all(buildArr)</span><br><span class=\"line\">  .then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;build success&quot;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch((e) =&gt; &#123;</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>_babel.config.js</code>文件<br>libraryName:需要加载的库，我这里的是echo-rui<br>libraryDirectory：需要加载的组件库所在的目录，当前的组件是存放在dist/components下的<br>style：加载的css类型，当前项目只有css，没有less，所以这里写css即可，如需配置less,请看注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  presets: [&quot;react-app&quot;],</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;import&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        libraryName: &quot;echo-rui&quot;, </span><br><span class=\"line\">        camel2DashComponentName: false, // 是否需要驼峰转短线</span><br><span class=\"line\">        camel2UnderlineComponentName: false, // 是否需要驼峰转下划线</span><br><span class=\"line\">        libraryDirectory: &quot;dist/components&quot;,</span><br><span class=\"line\">        style: &quot;css&quot;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    // [&quot;import&quot;, &#123;</span><br><span class=\"line\">    //   &quot;libraryName&quot;: &quot;antd&quot;,</span><br><span class=\"line\">    //   &quot;libraryDirectory&quot;: &quot;es&quot;,</span><br><span class=\"line\">    //   &quot;style&quot;: &quot;css&quot; // `style: true` 会加载 less 文件</span><br><span class=\"line\">    // &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>⚠️⚠️⚠️重要说明：在开发的时候，每个组件目录下面必须有一个<code>_style.scss</code>样式文件，即使他是个空文件也必须有，否则会在按需引入的时候报错找不到css文件⚠️⚠️</p>\n<h2 id=\"九、storybook文档生成\"><a href=\"#九、storybook文档生成\" class=\"headerlink\" title=\"九、storybook文档生成\"></a>九、storybook文档生成</h2><ol>\n<li><p>初始化storyBook</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx -p @storybook/cli sb init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加依赖和插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @storybook/addon-info --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加npm脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   &quot;storybook&quot;: &quot;start-storybook -p 9009 -s public&quot;,</span><br><span class=\"line\">   &quot;build-storybook&quot;: &quot;build-storybook -s public&quot;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置storybook，支持typescript</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-docgen-typescript-loader -D</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加storybook配置文件</p>\n</li>\n</ol>\n<ul>\n<li><p>新建<code>.storybook/webpack.config.js</code>文件<br><code>shouldExtractLiteralValuesFromEnum</code>：storybook爬取组件属性的时候会自动把type类型的属性自动展开。<br><code>propFilter</code>：过滤掉不需要爬取的属性的来源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = (&#123; config &#125;) =&gt; &#123;</span><br><span class=\"line\">  config.module.rules.push(&#123;</span><br><span class=\"line\">    test: /\\.tsx?$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: require.resolve(&quot;babel-loader&quot;),</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          presets: [require.resolve(&quot;babel-preset-react-app&quot;)]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, </span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: require.resolve(&quot;react-docgen-typescript-loader&quot;),</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          shouldExtractLiteralValuesFromEnum: true,</span><br><span class=\"line\">          propFilter: (prop) =&gt; &#123;</span><br><span class=\"line\">            if (prop.parent) &#123;</span><br><span class=\"line\">              return !prop.parent.fileName.includes(&apos;node_modules&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return true            </span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  config.resolve.extensions.push(&quot;.ts&quot;, &quot;.tsx&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return config;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建<code>.storybook/style.scss</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这个文件主要是对storybook文档样式的配置</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建<code>.storybook/config.tsx</code>文件<br>配置插件以及需要加载的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; configure,addDecorator,addParameters &#125; from &apos;@storybook/react&apos;;</span><br><span class=\"line\">import &#123; withInfo &#125; from &apos;@storybook/addon-info&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import &apos;../src/styles/index.scss&apos;</span><br><span class=\"line\">import &apos;./style.scss&apos;</span><br><span class=\"line\">import React from &apos;react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const wrapperStyle: React.CSSProperties = &#123;</span><br><span class=\"line\">  padding: &apos;20px 40px&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const storyWrapper = (stroyFn: any) =&gt; (</span><br><span class=\"line\">  &lt;div style=&#123;wrapperStyle&#125;&gt;</span><br><span class=\"line\">    &lt;h3&gt;组件演示&lt;/h3&gt;</span><br><span class=\"line\">    &#123;stroyFn()&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\">addDecorator(storyWrapper)</span><br><span class=\"line\">addDecorator(withInfo)</span><br><span class=\"line\">addParameters(&#123;info: &#123; inline: true, header: false&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const loaderFn = () =&gt; &#123;</span><br><span class=\"line\">    const allExports = [];</span><br><span class=\"line\">    const req = require.context(&apos;../src/components&apos;, true, /\\.stories\\.tsx$/);</span><br><span class=\"line\">    req.keys().forEach(fname =&gt; allExports.push(req(fname)));</span><br><span class=\"line\">    return allExports;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">configure(loaderFn, module);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"6\">\n<li>在每个组件目录下面新建一个<code>.stories.tsx</code>结尾的文件</li>\n</ol>\n<ul>\n<li>button组件下新建<code>button.stories.tsx</code>文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; storiesOf &#125; from &apos;@storybook/react&apos;;</span><br><span class=\"line\">import &#123; action &#125; from &apos;@storybook/addon-actions&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">import Button from &apos;./button&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const defaultButton = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;default button&apos;)&#125;&gt;default button&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const buttonWithSize = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button size=&apos;lg&apos; btnType=&apos;primary&apos; onClick=&#123;action(&apos;lg button&apos;)&#125;&gt;lg button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button className=&apos;ml-20&apos; size=&apos;sm&apos; btnType=&apos;danger&apos; onClick=&#123;action(&apos;sm button&apos;)&#125;&gt;sm button&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buttonWithType = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;danger button&apos;)&#125; btnType=&apos;danger&apos;&gt;danger button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;primary button&apos;)&#125; className=&apos;ml-20&apos; btnType=&apos;primary&apos;&gt;primary button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;link&apos;)&#125; className=&apos;ml-20&apos; btnType=&apos;link&apos; href=&apos;https://www.baidu.com/&apos;&gt;link&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const buttonWithDisabled = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;disabled button&apos;)&#125; btnType=&apos;danger&apos; disabled=&#123;true&#125;&gt;disabled button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;unDisabled button&apos;)&#125; className=&apos;ml-20&apos; btnType=&apos;primary&apos;&gt;unDisabled button&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// storiesOf(&apos;Button组件&apos;, module)</span><br><span class=\"line\">// .addDecorator(withInfo)</span><br><span class=\"line\">// .addParameters(&#123;</span><br><span class=\"line\">//     info:&#123;</span><br><span class=\"line\">//         text:`</span><br><span class=\"line\">//         这是默认组件</span><br><span class=\"line\">//         ~~~js</span><br><span class=\"line\">//         const a = 12</span><br><span class=\"line\">//         ~~~</span><br><span class=\"line\">//         `,</span><br><span class=\"line\">//         inline:true</span><br><span class=\"line\">//     &#125;</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">//   .add(&apos;默认 Button&apos;, defaultButton)</span><br><span class=\"line\">//   .add(&apos;不同尺寸 Button&apos;, buttonWithSize,&#123;info:&#123;inline:false&#125;&#125;)</span><br><span class=\"line\">//   .add(&apos;不同类型 Button&apos;, buttonWithType)</span><br><span class=\"line\"></span><br><span class=\"line\">storiesOf(&apos;Button 按钮&apos;, module)</span><br><span class=\"line\">    .addParameters(&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">        ## 引用方法</span><br><span class=\"line\">        ~~~js</span><br><span class=\"line\">        import &#123;Button&#125; from ecoh-rui</span><br><span class=\"line\">        ~~~</span><br><span class=\"line\">        `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .add(&apos;默认 Button&apos;, defaultButton)</span><br><span class=\"line\">    .add(&apos;不同尺寸 Button&apos;, buttonWithSize)</span><br><span class=\"line\">    .add(&apos;不同类型 Button&apos;, buttonWithType)</span><br><span class=\"line\">    .add(&apos;禁用的 Button&apos;,buttonWithDisabled)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run storybook</span><br></pre></td></tr></table></figure></p>\n<p>在终端可以看到<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8b43e51f15d70e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>浏览器打开<code>http://localhost:9009/</code>,可以看到组件库文档生成了。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-151907d5b1ed9637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"十、-typescript编译配置\"><a href=\"#十、-typescript编译配置\" class=\"headerlink\" title=\"十、 typescript编译配置\"></a>十、 typescript编译配置</h2><p>新建<code>tsconfig.build.json</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    // 输出路径</span><br><span class=\"line\">    &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class=\"line\">    // 打包模块规范</span><br><span class=\"line\">    &quot;module&quot;: &quot;esnext&quot;,</span><br><span class=\"line\">    // 构建目标</span><br><span class=\"line\">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class=\"line\">    // 生成定义文件d.ts</span><br><span class=\"line\">    &quot;declaration&quot;: true,</span><br><span class=\"line\">    &quot;jsx&quot;: &quot;react&quot;,</span><br><span class=\"line\">    // 模块引入策略</span><br><span class=\"line\">    &quot;moduleResolution&quot;: &quot;Node&quot;,</span><br><span class=\"line\">    // 允许import React from &apos;react&apos;这样导包</span><br><span class=\"line\">    &quot;allowSyntheticDefaultImports&quot;: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 需要编译的目录</span><br><span class=\"line\">  &quot;include&quot;: [&quot;src&quot;],</span><br><span class=\"line\">  // 不需要编译的</span><br><span class=\"line\">  &quot;exclude&quot;: [&quot;src/**/*.test.tsx&quot;, &quot;src/**/*.stories.tsx&quot;, &quot;src/setupTests.ts&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"十一、-package-json相关配置\"><a href=\"#十一、-package-json相关配置\" class=\"headerlink\" title=\"十一、 package.json相关配置\"></a>十一、 package.json相关配置</h2><ul>\n<li><p>将依赖包从dependencies搬到devDependencie</p>\n<blockquote>\n<p>为什么要这么做？<br>一、是防止发布组件库之后别人使用了跟我们不一样的react版本造成冲突<br>二、是我们在开发的时候还需要使用到react和react-dom，所以不能删除，只能搬到devDependencies<br>三、还有一些跟发布后的组件库不相关的依赖都需要搬到devDependencies，例如storybook等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 嘿嘿，移动之后，发现为空了，重新install 了一下</span><br><span class=\"line\">// 运行了npm start 和npm run test 和npm run storybook发现一切正常，开心一下！！</span><br><span class=\"line\">&quot;dependencies&quot;: &#123;&#125;,</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>添加npm发布相关配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;description&quot;: &quot;react components library&quot;,</span><br><span class=\"line\">&quot;author&quot;: &quot;echo&quot;,</span><br><span class=\"line\">&quot;private&quot;: false,</span><br><span class=\"line\">// 主入口</span><br><span class=\"line\">&quot;main&quot;: &quot;dist/index.js&quot;,</span><br><span class=\"line\">// 模块入口</span><br><span class=\"line\">&quot;module&quot;: &quot;dist/index.js&quot;,</span><br><span class=\"line\">// 类型文件声明</span><br><span class=\"line\">&quot;types&quot;: &quot;dist/index.d.ts&quot;,</span><br><span class=\"line\">&quot;license&quot;: &quot;MIT&quot;,</span><br><span class=\"line\">// 关键词</span><br><span class=\"line\">&quot;keywords&quot;: [</span><br><span class=\"line\">    &quot;React&quot;,</span><br><span class=\"line\">    &quot;UI&quot;,</span><br><span class=\"line\">    &quot;Component&quot;,</span><br><span class=\"line\">    &quot;typescript&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">// 首页你的github地址</span><br><span class=\"line\">  &quot;homepage&quot;: &quot;https://github.com/.../echo-rui&quot;,</span><br><span class=\"line\">// 仓库地址</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;https://github.com/.../echo-ruii&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 需要上传的文件，不写就默认以.gitignore为准</span><br><span class=\"line\">  &quot;files&quot;: [</span><br><span class=\"line\">    &quot;dist&quot;</span><br><span class=\"line\">  ],</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码提交git前检查。这里使用husky这个工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">    &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    // 用git提交代码之前</span><br><span class=\"line\">      &quot;pre-commit&quot;: &quot;npm run test:nowatch &amp;&amp; npm run lint&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">    &quot;lint&quot;: &quot;eslint --ext js,ts,tsx src --fix --max-warnings 5&quot;,</span><br><span class=\"line\">    &quot;test:nowatch&quot;: &quot;cross-env CI=true react-scripts test&quot;,</span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加打包发布相关配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">    &quot;clean&quot;: &quot;rimraf ./dist&quot;,</span><br><span class=\"line\">    &quot;build-ts&quot;: &quot;tsc -p tsconfig.build.json&quot;,</span><br><span class=\"line\">    &quot;build-css&quot;: &quot;node-sass ./src/styles/index.scss ./dist/index.css&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;npm run clean &amp;&amp; npm run build-ts &amp;&amp; npm run build-css &amp;&amp; node ./buildScss.js&quot;,</span><br><span class=\"line\">    &quot;prepublishOnly&quot;: &quot;npm run lint &amp;&amp; npm run build&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此时执行打包命令，就可以成功根据配置打包了。</p>\n<h2 id=\"十二、-发布到npm\"><a href=\"#十二、-发布到npm\" class=\"headerlink\" title=\"十二、 发布到npm\"></a>十二、 发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ul>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多<br>最后执行 npm login 登入 npm 账号，再执行 npm publish 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</li>\n</ul>\n<p>大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<meta name=\"referrer\" content=\"no-referrer\">\n\n<h2 id=\"一、-安装组件库\"><a href=\"#一、-安装组件库\" class=\"headerlink\" title=\"一、 安装组件库\"></a>一、 安装组件库</h2><p>执行安装命令<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx create-react-app echo-rui  --typescript</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"二、-组件库配置eslint\"><a href=\"#二、-组件库配置eslint\" class=\"headerlink\" title=\"二、 组件库配置eslint\"></a>二、 组件库配置eslint</h2><ul>\n<li>配置ESlint<br>新建<code>.eslintrc.json</code>文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;extends&quot;: &quot;react-app&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>新建 <code>.vscode/settings.json</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;eslint.validate&quot;: [</span><br><span class=\"line\">    &quot;javascript&quot;,</span><br><span class=\"line\">    &quot;javascriptreact&quot;,</span><br><span class=\"line\">    &#123; &quot;language&quot;: &quot;typescript&quot;, &quot;autoFix&quot;: true &#125;,</span><br><span class=\"line\">    &#123; &quot;language&quot;: &quot;typescriptreact&quot;, &quot;autoFix&quot;: true &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"三、-引入依赖\"><a href=\"#三、-引入依赖\" class=\"headerlink\" title=\"三、 引入依赖\"></a>三、 引入依赖</h2><p>在组件中使用 <code>classname</code>：<a href=\"https://github.com/jedWatson/classnames\" target=\"_blank\" rel=\"noopener\">https://github.com/jedWatson/classnames</a><br>执行安装命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install classnames -D</span><br><span class=\"line\">npm install @types/classnames -D</span><br><span class=\"line\">npm install node-sass -D</span><br></pre></td></tr></table></figure></p>\n<p>使用方法示例：<br>如果对象的key值是变化的，可以采用下面的中括号的形式：[<code>btn-${btnType}</code>]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// btn, btn-lg, btn-primary</span><br><span class=\"line\">const classes = classNames(&apos;btn&apos;, className, &#123;</span><br><span class=\"line\">   [`btn-$&#123;btnType&#125;`]: btnType,</span><br><span class=\"line\">   [`btn-$&#123;size&#125;`]: size,</span><br><span class=\"line\">   &apos;disabled&apos;: (btnType === &apos;link&apos;) &amp;&amp; disabled</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"四、-编写组件\"><a href=\"#四、-编写组件\" class=\"headerlink\" title=\"四、 编写组件\"></a>四、 编写组件</h2><ul>\n<li>新建 <code>src/components/Button/button.tsx</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;FC,ButtonHTMLAttributes,AnchorHTMLAttributes&#125; from &quot;react&quot;;</span><br><span class=\"line\">import classnames from &quot;classnames&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 按钮大小</span><br><span class=\"line\">export type ButtonSize = &quot;lg&quot; | &quot;sm&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export type ButtonType = &quot;primary&quot; | &quot;default&quot; | &quot;danger&quot; | &quot;link&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">interface BaseButtonProps &#123;</span><br><span class=\"line\">  /** 自定义类名 */</span><br><span class=\"line\">  className?: string;</span><br><span class=\"line\">  /** 设置Button 的禁用 */</span><br><span class=\"line\">  disabled?: boolean;</span><br><span class=\"line\">  /** 设置Button 的大小 */</span><br><span class=\"line\">  size?: ButtonSize;</span><br><span class=\"line\">  /** 设置Button 的类型 */</span><br><span class=\"line\">  btnType?: ButtonType;</span><br><span class=\"line\">  children: React.ReactNode;</span><br><span class=\"line\">  /** 当btnType为link时，必填 */</span><br><span class=\"line\">  href?: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 并集</span><br><span class=\"line\">type NativeButtonProps = BaseButtonProps &amp;</span><br><span class=\"line\">  ButtonHTMLAttributes&lt;HTMLElement&gt;;</span><br><span class=\"line\">type AnchorButtonProps = BaseButtonProps &amp;</span><br><span class=\"line\">  AnchorHTMLAttributes&lt;HTMLElement&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Partial：typescript全局函数，将属性全部变成可选的</span><br><span class=\"line\">export type ButtonProps = Partial&lt;NativeButtonProps &amp; AnchorButtonProps&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用react-docgen-typescript-loader的bug，只能使用FC，不能React.FC</span><br><span class=\"line\">export const Button: FC&lt;ButtonProps&gt; = (props) =&gt; &#123;</span><br><span class=\"line\">  const &#123;</span><br><span class=\"line\">    disabled,</span><br><span class=\"line\">    size,</span><br><span class=\"line\">    btnType,</span><br><span class=\"line\">    children,</span><br><span class=\"line\">    href,</span><br><span class=\"line\">    className,</span><br><span class=\"line\">    ...resetProps</span><br><span class=\"line\">  &#125; = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  const classes = classnames(&quot;echo-btn&quot;, className, &#123;</span><br><span class=\"line\">    [`echo-btn-$&#123;btnType&#125;`]: btnType,</span><br><span class=\"line\">    [`echo-btn-$&#123;size&#125;`]: size,</span><br><span class=\"line\">    &quot;echo-button-disabled&quot;: btnType === &quot;link&quot; &amp;&amp; disabled,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  if (btnType === &quot;link&quot; &amp;&amp; href) &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;a href=&#123;href&#125; className=&#123;classes&#125; &#123;...resetProps&#125;&gt;</span><br><span class=\"line\">        &#123;children&#125;</span><br><span class=\"line\">      &lt;/a&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;button className=&#123;classes&#125; disabled=&#123;disabled&#125; &#123;...resetProps&#125;&gt;</span><br><span class=\"line\">        &#123;children&#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Button.defaultProps = &#123;</span><br><span class=\"line\">  disabled: false,</span><br><span class=\"line\">  btnType: &quot;default&quot;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Button;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>新建 <code>src/components/Button/index.tsx</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Button from &quot;./button&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Button;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>src/components/Button/_style.scss</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/button&quot;;</span><br><span class=\"line\">@import &quot;../../styles/mixin/button&quot;;</span><br><span class=\"line\">.echo-btn &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  font-weight: $btn-font-weight;</span><br><span class=\"line\">  line-height: $btn-line-height;</span><br><span class=\"line\">  color: $body-color;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  vertical-align: middle;</span><br><span class=\"line\">  background-image: none;</span><br><span class=\"line\">  border: $btn-border-width solid transparent;</span><br><span class=\"line\">  @include button-size(</span><br><span class=\"line\">    $btn-padding-y,</span><br><span class=\"line\">    $btn-padding-x,</span><br><span class=\"line\">    $btn-font-size,</span><br><span class=\"line\">    $btn-border-radius</span><br><span class=\"line\">  );</span><br><span class=\"line\">  box-shadow: $btn-box-shadow;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">  transition: $btn-transition;</span><br><span class=\"line\">  &amp;.echo-button-disabled</span><br><span class=\"line\">  &amp;[disabled] &#123;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">    opacity: $btn-disabled-opacity;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">    &gt; * &#123;</span><br><span class=\"line\">      pointer-events: none;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-lg &#123;</span><br><span class=\"line\">  @include button-size(</span><br><span class=\"line\">    $btn-padding-y-lg,</span><br><span class=\"line\">    $btn-padding-x-lg,</span><br><span class=\"line\">    $btn-font-size-lg,</span><br><span class=\"line\">    $btn-border-radius-lg</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-sm &#123;</span><br><span class=\"line\">  @include button-size(</span><br><span class=\"line\">    $btn-padding-y-sm,</span><br><span class=\"line\">    $btn-padding-x-sm,</span><br><span class=\"line\">    $btn-font-size-sm,</span><br><span class=\"line\">    $btn-border-radius-sm</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-primary &#123;</span><br><span class=\"line\">  @include button-style($primary, $primary, $white);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-danger &#123;</span><br><span class=\"line\">  @include button-style($danger, $danger, $white);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-default &#123;</span><br><span class=\"line\">  @include button-style(</span><br><span class=\"line\">    $white,</span><br><span class=\"line\">    $gray-400,</span><br><span class=\"line\">    $body-color,</span><br><span class=\"line\">    $white,</span><br><span class=\"line\">    $primary,</span><br><span class=\"line\">    $primary</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.echo-btn-link &#123;</span><br><span class=\"line\">  font-weight: $font-weight-normal;</span><br><span class=\"line\">  color: $btn-link-color;</span><br><span class=\"line\">  text-decoration: $link-decoration;</span><br><span class=\"line\">  box-shadow: none;</span><br><span class=\"line\">  &amp;:hover &#123;</span><br><span class=\"line\">    color: $btn-link-hover-color;</span><br><span class=\"line\">    text-decoration: $link-hover-decoration;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;:focus &#123;</span><br><span class=\"line\">    text-decoration: $link-hover-decoration;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;:disabled,</span><br><span class=\"line\">  &amp;.echo-button-disabled &#123;</span><br><span class=\"line\">    color: $btn-link-disabled-color;</span><br><span class=\"line\">    pointer-events: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>styles/variables/button.scss</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;./common&quot;;</span><br><span class=\"line\">// 按钮基本属性</span><br><span class=\"line\">$btn-font-weight: 400;</span><br><span class=\"line\">$btn-padding-y: 0.375rem !default;</span><br><span class=\"line\">$btn-padding-x: 0.75rem !default;</span><br><span class=\"line\">$btn-font-family: $font-family-base !default;</span><br><span class=\"line\">$btn-font-size: $font-size-base !default;</span><br><span class=\"line\">$btn-line-height: $line-height-base !default;</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 styles/mixin/button.scss`文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@mixin button-size($padding-y, $padding-x, $font-size, $border-raduis) &#123;</span><br><span class=\"line\">  padding: $padding-y $padding-x;</span><br><span class=\"line\">  font-size: $font-size;</span><br><span class=\"line\">  border-radius: $border-raduis;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@mixin button-style(</span><br><span class=\"line\">  $background,</span><br><span class=\"line\">  $border,</span><br><span class=\"line\">  $color,</span><br><span class=\"line\">  // lghten,sass内置函数，比$background颜色要浅上7.5%</span><br><span class=\"line\">    $hover-background: lighten($background, 7.5%),</span><br><span class=\"line\">  $hover-border: lighten($border, 10%),</span><br><span class=\"line\">  $hover-color: $color</span><br><span class=\"line\">) </span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 <code>src/styles/index.scss</code>文件中引入组件样式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index文件主要是引入所有组件的样式。</span><br><span class=\"line\">// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化</span><br><span class=\"line\"></span><br><span class=\"line\">// 按钮样式</span><br><span class=\"line\">@import &quot;../components/Button/style&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>src/styles/index.scss</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// index文件主要是引入所有组件的样式。</span><br><span class=\"line\">// 不需要写_，这是sass的一种写法，告诉sass这些样式不打包到css中，只能做导入，也是一种模块化</span><br><span class=\"line\"></span><br><span class=\"line\">// 按钮样式</span><br><span class=\"line\">@import &quot;../components/Button/style&quot;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"五、-删除多余文件-引用组件\"><a href=\"#五、-删除多余文件-引用组件\" class=\"headerlink\" title=\"五、 删除多余文件+引用组件\"></a>五、 删除多余文件+引用组件</h2><ul>\n<li>删除<code>src/App.css</code> + <code>src/logo.svg</code> + <code>src/index.css</code> + <code>src/App.test.js</code> + <code>serviceWorker.ts</code>文件</li>\n<li><p>修改<code>App.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import &quot;./styles/index.scss&quot;;</span><br><span class=\"line\">import Button, &#123; ButtonType, ButtonSize &#125; from &quot;./components/Button/button&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">function App() &#123;</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;div className=&quot;App&quot;&gt;</span><br><span class=\"line\">      &lt;Button&gt;hello&lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button disabled&gt;hello&lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button btnType=&quot;primary&quot; size=&quot;sm&quot;&gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button</span><br><span class=\"line\">        btnType=&quot;danger&quot;</span><br><span class=\"line\">        size=&quot;lg&quot;</span><br><span class=\"line\">        onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">          alert(111);</span><br><span class=\"line\">        &#125;&#125;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">     &lt;Button</span><br><span class=\"line\">        btnType=&quot;link&quot;</span><br><span class=\"line\">        href=&quot;http://www.baidu.com&quot;</span><br><span class=\"line\">        target=&quot;_blank&quot;</span><br><span class=\"line\">      &gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">      &lt;Button disabled btnType=&quot;link&quot; href=&quot;http://www.baidu.com&quot;&gt;</span><br><span class=\"line\">        hello</span><br><span class=\"line\">      &lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default App;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>src/index.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as Button &#125; from &quot;./components/Button&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"六、-运行项目\"><a href=\"#六、-运行项目\" class=\"headerlink\" title=\"六、 运行项目\"></a>六、 运行项目</h2><p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm start</span><br></pre></td></tr></table></figure></p>\n<p>访问项目 可以看到button组件成功了！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8690603021ebd620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"七、单元测试\"><a href=\"#七、单元测试\" class=\"headerlink\" title=\"七、单元测试\"></a>七、单元测试</h2><p>新建<code>src/Button/button.test.tsx</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &quot;react&quot;;</span><br><span class=\"line\">import &#123; render, fireEvent &#125; from &quot;@testing-library/react&quot;;</span><br><span class=\"line\">import Button, &#123; ButtonProps &#125; from &quot;./button&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&quot;Button 组件&quot;, () =&gt; &#123;</span><br><span class=\"line\">  it(&apos;默认Button&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      onClick: jest.fn(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;hello&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&apos;hello&apos;)as HTMLButtonElement;</span><br><span class=\"line\">    // 元素是否被渲染在文档中</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    // 判断标签名</span><br><span class=\"line\">    expect(element.tagName).toEqual(&quot;BUTTON&quot;);</span><br><span class=\"line\">     // 判断是否有类名</span><br><span class=\"line\">     expect(element).toHaveClass(&quot;echo-btn-default&quot;);</span><br><span class=\"line\">     expect(element).not.toHaveClass(&quot;echo-disabled&quot;);</span><br><span class=\"line\">     //   触发点击事件</span><br><span class=\"line\">    fireEvent.click(element);</span><br><span class=\"line\">    expect(testProps.onClick).toHaveBeenCalled();</span><br><span class=\"line\">    expect(element.disabled).toBeFalsy();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  it(&quot;测试传入不同属性的情况&quot;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      btnType: &quot;primary&quot;,</span><br><span class=\"line\">      size: &quot;lg&quot;,</span><br><span class=\"line\">      className: &quot;test-name&quot;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;hello&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&quot;hello&quot;) as HTMLButtonElement;</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;echo-btn-primary&quot;);</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;echo-btn-lg&quot;);</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;test-name&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;测试当btnType为link和href存在的情况&quot;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      btnType: &quot;link&quot;,</span><br><span class=\"line\">      href: &quot;http://www.baidu.com&quot;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;Link&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&quot;Link&quot;) as HTMLAnchorElement;</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    expect(element.tagName).toEqual(&quot;A&quot;);</span><br><span class=\"line\">    expect(element).toHaveClass(&quot;echo-btn-link&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;测试禁用的情况&quot;, () =&gt; &#123;</span><br><span class=\"line\">    const testProps: ButtonProps = &#123;</span><br><span class=\"line\">      onClick: jest.fn(),</span><br><span class=\"line\">      disabled: true,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;Disabled&lt;/Button&gt;);</span><br><span class=\"line\">    const element = wrapper.getByText(&quot;Disabled&quot;) as HTMLButtonElement;</span><br><span class=\"line\">    expect(element).toBeInTheDocument();</span><br><span class=\"line\">    expect(element.disabled).toBeTruthy();</span><br><span class=\"line\">    fireEvent.click(element);</span><br><span class=\"line\">    expect(testProps.onClick).not.toHaveBeenCalled();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm test</span><br></pre></td></tr></table></figure></p>\n<p>可以看到单元测试成功通过！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-04f6282ff0e82886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"八、组件库实现按需加载\"><a href=\"#八、组件库实现按需加载\" class=\"headerlink\" title=\"八、组件库实现按需加载\"></a>八、组件库实现按需加载</h2><ul>\n<li><p>安装依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$npm install node-cmd -D</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>buildScss.js</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const cmd = require(&quot;node-cmd&quot;);</span><br><span class=\"line\">const path = require(&quot;path&quot;);</span><br><span class=\"line\">const fs = require(&quot;fs&quot;);</span><br><span class=\"line\">const entryDir = path.resolve(__dirname, &quot;./src/components&quot;);</span><br><span class=\"line\">const outputDir = path.resolve(__dirname, &quot;./dist/components&quot;);</span><br><span class=\"line\">function getScssEntry() &#123;</span><br><span class=\"line\">  let entryMap = &#123;&#125;;</span><br><span class=\"line\">  fs.readdirSync(entryDir).forEach(function (pathName) &#123;</span><br><span class=\"line\">    const entryName = path.resolve(entryDir, pathName);</span><br><span class=\"line\">    const outputName = path.resolve(outputDir, pathName);</span><br><span class=\"line\">    let entryFileName = path.resolve(entryName, &quot;_style.scss&quot;);</span><br><span class=\"line\">    let outputFileName = path.resolve(outputName, &quot;style/index.css&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    entryMap[pathName] = &#123;&#125;;</span><br><span class=\"line\">    entryMap[pathName].entry = entryFileName;</span><br><span class=\"line\">    entryMap[pathName].output = outputFileName;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return entryMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const entry = getScssEntry();</span><br><span class=\"line\">let buildArr = [];</span><br><span class=\"line\">for (const key in entry) &#123;</span><br><span class=\"line\">  const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    cmd.get(`npx node-sass $&#123;entry[key].entry&#125; $&#123;entry[key].output&#125;`, function (</span><br><span class=\"line\">      err,</span><br><span class=\"line\">      data,</span><br><span class=\"line\">      stderr</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      if (err) &#123;</span><br><span class=\"line\">        reject(err);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      console.log(&quot;the current working dir is : &quot;, data);</span><br><span class=\"line\">      fs.writeFileSync(</span><br><span class=\"line\">        path.join(__dirname, `./dist/components/$&#123;key&#125;/style/css.js`),</span><br><span class=\"line\">        &quot;import &apos;./index.css&apos;&quot;</span><br><span class=\"line\">      );</span><br><span class=\"line\">      resolve();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  buildArr.push(promise);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all(buildArr)</span><br><span class=\"line\">  .then(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;build success&quot;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch((e) =&gt; &#123;</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 <code>_babel.config.js</code>文件<br>libraryName:需要加载的库，我这里的是echo-rui<br>libraryDirectory：需要加载的组件库所在的目录，当前的组件是存放在dist/components下的<br>style：加载的css类型，当前项目只有css，没有less，所以这里写css即可，如需配置less,请看注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  presets: [&quot;react-app&quot;],</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    [</span><br><span class=\"line\">      &quot;import&quot;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        libraryName: &quot;echo-rui&quot;, </span><br><span class=\"line\">        camel2DashComponentName: false, // 是否需要驼峰转短线</span><br><span class=\"line\">        camel2UnderlineComponentName: false, // 是否需要驼峰转下划线</span><br><span class=\"line\">        libraryDirectory: &quot;dist/components&quot;,</span><br><span class=\"line\">        style: &quot;css&quot;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    // [&quot;import&quot;, &#123;</span><br><span class=\"line\">    //   &quot;libraryName&quot;: &quot;antd&quot;,</span><br><span class=\"line\">    //   &quot;libraryDirectory&quot;: &quot;es&quot;,</span><br><span class=\"line\">    //   &quot;style&quot;: &quot;css&quot; // `style: true` 会加载 less 文件</span><br><span class=\"line\">    // &#125;]</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>⚠️⚠️⚠️重要说明：在开发的时候，每个组件目录下面必须有一个<code>_style.scss</code>样式文件，即使他是个空文件也必须有，否则会在按需引入的时候报错找不到css文件⚠️⚠️</p>\n<h2 id=\"九、storybook文档生成\"><a href=\"#九、storybook文档生成\" class=\"headerlink\" title=\"九、storybook文档生成\"></a>九、storybook文档生成</h2><ol>\n<li><p>初始化storyBook</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx -p @storybook/cli sb init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加依赖和插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @storybook/addon-info --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加npm脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   &quot;storybook&quot;: &quot;start-storybook -p 9009 -s public&quot;,</span><br><span class=\"line\">   &quot;build-storybook&quot;: &quot;build-storybook -s public&quot;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置storybook，支持typescript</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install react-docgen-typescript-loader -D</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加storybook配置文件</p>\n</li>\n</ol>\n<ul>\n<li><p>新建<code>.storybook/webpack.config.js</code>文件<br><code>shouldExtractLiteralValuesFromEnum</code>：storybook爬取组件属性的时候会自动把type类型的属性自动展开。<br><code>propFilter</code>：过滤掉不需要爬取的属性的来源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = (&#123; config &#125;) =&gt; &#123;</span><br><span class=\"line\">  config.module.rules.push(&#123;</span><br><span class=\"line\">    test: /\\.tsx?$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: require.resolve(&quot;babel-loader&quot;),</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          presets: [require.resolve(&quot;babel-preset-react-app&quot;)]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, </span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        loader: require.resolve(&quot;react-docgen-typescript-loader&quot;),</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          shouldExtractLiteralValuesFromEnum: true,</span><br><span class=\"line\">          propFilter: (prop) =&gt; &#123;</span><br><span class=\"line\">            if (prop.parent) &#123;</span><br><span class=\"line\">              return !prop.parent.fileName.includes(&apos;node_modules&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return true            </span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  config.resolve.extensions.push(&quot;.ts&quot;, &quot;.tsx&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return config;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建<code>.storybook/style.scss</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这个文件主要是对storybook文档样式的配置</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建<code>.storybook/config.tsx</code>文件<br>配置插件以及需要加载的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; configure,addDecorator,addParameters &#125; from &apos;@storybook/react&apos;;</span><br><span class=\"line\">import &#123; withInfo &#125; from &apos;@storybook/addon-info&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">import &apos;../src/styles/index.scss&apos;</span><br><span class=\"line\">import &apos;./style.scss&apos;</span><br><span class=\"line\">import React from &apos;react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const wrapperStyle: React.CSSProperties = &#123;</span><br><span class=\"line\">  padding: &apos;20px 40px&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const storyWrapper = (stroyFn: any) =&gt; (</span><br><span class=\"line\">  &lt;div style=&#123;wrapperStyle&#125;&gt;</span><br><span class=\"line\">    &lt;h3&gt;组件演示&lt;/h3&gt;</span><br><span class=\"line\">    &#123;stroyFn()&#125;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\">addDecorator(storyWrapper)</span><br><span class=\"line\">addDecorator(withInfo)</span><br><span class=\"line\">addParameters(&#123;info: &#123; inline: true, header: false&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const loaderFn = () =&gt; &#123;</span><br><span class=\"line\">    const allExports = [];</span><br><span class=\"line\">    const req = require.context(&apos;../src/components&apos;, true, /\\.stories\\.tsx$/);</span><br><span class=\"line\">    req.keys().forEach(fname =&gt; allExports.push(req(fname)));</span><br><span class=\"line\">    return allExports;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">configure(loaderFn, module);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"6\">\n<li>在每个组件目录下面新建一个<code>.stories.tsx</code>结尾的文件</li>\n</ol>\n<ul>\n<li>button组件下新建<code>button.stories.tsx</code>文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; storiesOf &#125; from &apos;@storybook/react&apos;;</span><br><span class=\"line\">import &#123; action &#125; from &apos;@storybook/addon-actions&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">import Button from &apos;./button&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const defaultButton = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;default button&apos;)&#125;&gt;default button&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const buttonWithSize = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button size=&apos;lg&apos; btnType=&apos;primary&apos; onClick=&#123;action(&apos;lg button&apos;)&#125;&gt;lg button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button className=&apos;ml-20&apos; size=&apos;sm&apos; btnType=&apos;danger&apos; onClick=&#123;action(&apos;sm button&apos;)&#125;&gt;sm button&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const buttonWithType = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;danger button&apos;)&#125; btnType=&apos;danger&apos;&gt;danger button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;primary button&apos;)&#125; className=&apos;ml-20&apos; btnType=&apos;primary&apos;&gt;primary button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;link&apos;)&#125; className=&apos;ml-20&apos; btnType=&apos;link&apos; href=&apos;https://www.baidu.com/&apos;&gt;link&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const buttonWithDisabled = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;disabled button&apos;)&#125; btnType=&apos;danger&apos; disabled=&#123;true&#125;&gt;disabled button&lt;/Button&gt;</span><br><span class=\"line\">        &lt;Button onClick=&#123;action(&apos;unDisabled button&apos;)&#125; className=&apos;ml-20&apos; btnType=&apos;primary&apos;&gt;unDisabled button&lt;/Button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// storiesOf(&apos;Button组件&apos;, module)</span><br><span class=\"line\">// .addDecorator(withInfo)</span><br><span class=\"line\">// .addParameters(&#123;</span><br><span class=\"line\">//     info:&#123;</span><br><span class=\"line\">//         text:`</span><br><span class=\"line\">//         这是默认组件</span><br><span class=\"line\">//         ~~~js</span><br><span class=\"line\">//         const a = 12</span><br><span class=\"line\">//         ~~~</span><br><span class=\"line\">//         `,</span><br><span class=\"line\">//         inline:true</span><br><span class=\"line\">//     &#125;</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">//   .add(&apos;默认 Button&apos;, defaultButton)</span><br><span class=\"line\">//   .add(&apos;不同尺寸 Button&apos;, buttonWithSize,&#123;info:&#123;inline:false&#125;&#125;)</span><br><span class=\"line\">//   .add(&apos;不同类型 Button&apos;, buttonWithType)</span><br><span class=\"line\"></span><br><span class=\"line\">storiesOf(&apos;Button 按钮&apos;, module)</span><br><span class=\"line\">    .addParameters(&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">        ## 引用方法</span><br><span class=\"line\">        ~~~js</span><br><span class=\"line\">        import &#123;Button&#125; from ecoh-rui</span><br><span class=\"line\">        ~~~</span><br><span class=\"line\">        `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .add(&apos;默认 Button&apos;, defaultButton)</span><br><span class=\"line\">    .add(&apos;不同尺寸 Button&apos;, buttonWithSize)</span><br><span class=\"line\">    .add(&apos;不同类型 Button&apos;, buttonWithType)</span><br><span class=\"line\">    .add(&apos;禁用的 Button&apos;,buttonWithDisabled)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run storybook</span><br></pre></td></tr></table></figure></p>\n<p>在终端可以看到<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8b43e51f15d70e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>浏览器打开<code>http://localhost:9009/</code>,可以看到组件库文档生成了。<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-151907d5b1ed9637.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"十、-typescript编译配置\"><a href=\"#十、-typescript编译配置\" class=\"headerlink\" title=\"十、 typescript编译配置\"></a>十、 typescript编译配置</h2><p>新建<code>tsconfig.build.json</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;</span><br><span class=\"line\">    // 输出路径</span><br><span class=\"line\">    &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class=\"line\">    // 打包模块规范</span><br><span class=\"line\">    &quot;module&quot;: &quot;esnext&quot;,</span><br><span class=\"line\">    // 构建目标</span><br><span class=\"line\">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class=\"line\">    // 生成定义文件d.ts</span><br><span class=\"line\">    &quot;declaration&quot;: true,</span><br><span class=\"line\">    &quot;jsx&quot;: &quot;react&quot;,</span><br><span class=\"line\">    // 模块引入策略</span><br><span class=\"line\">    &quot;moduleResolution&quot;: &quot;Node&quot;,</span><br><span class=\"line\">    // 允许import React from &apos;react&apos;这样导包</span><br><span class=\"line\">    &quot;allowSyntheticDefaultImports&quot;: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 需要编译的目录</span><br><span class=\"line\">  &quot;include&quot;: [&quot;src&quot;],</span><br><span class=\"line\">  // 不需要编译的</span><br><span class=\"line\">  &quot;exclude&quot;: [&quot;src/**/*.test.tsx&quot;, &quot;src/**/*.stories.tsx&quot;, &quot;src/setupTests.ts&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"十一、-package-json相关配置\"><a href=\"#十一、-package-json相关配置\" class=\"headerlink\" title=\"十一、 package.json相关配置\"></a>十一、 package.json相关配置</h2><ul>\n<li><p>将依赖包从dependencies搬到devDependencie</p>\n<blockquote>\n<p>为什么要这么做？<br>一、是防止发布组件库之后别人使用了跟我们不一样的react版本造成冲突<br>二、是我们在开发的时候还需要使用到react和react-dom，所以不能删除，只能搬到devDependencies<br>三、还有一些跟发布后的组件库不相关的依赖都需要搬到devDependencies，例如storybook等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 嘿嘿，移动之后，发现为空了，重新install 了一下</span><br><span class=\"line\">// 运行了npm start 和npm run test 和npm run storybook发现一切正常，开心一下！！</span><br><span class=\"line\">&quot;dependencies&quot;: &#123;&#125;,</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>添加npm发布相关配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;description&quot;: &quot;react components library&quot;,</span><br><span class=\"line\">&quot;author&quot;: &quot;echo&quot;,</span><br><span class=\"line\">&quot;private&quot;: false,</span><br><span class=\"line\">// 主入口</span><br><span class=\"line\">&quot;main&quot;: &quot;dist/index.js&quot;,</span><br><span class=\"line\">// 模块入口</span><br><span class=\"line\">&quot;module&quot;: &quot;dist/index.js&quot;,</span><br><span class=\"line\">// 类型文件声明</span><br><span class=\"line\">&quot;types&quot;: &quot;dist/index.d.ts&quot;,</span><br><span class=\"line\">&quot;license&quot;: &quot;MIT&quot;,</span><br><span class=\"line\">// 关键词</span><br><span class=\"line\">&quot;keywords&quot;: [</span><br><span class=\"line\">    &quot;React&quot;,</span><br><span class=\"line\">    &quot;UI&quot;,</span><br><span class=\"line\">    &quot;Component&quot;,</span><br><span class=\"line\">    &quot;typescript&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">// 首页你的github地址</span><br><span class=\"line\">  &quot;homepage&quot;: &quot;https://github.com/.../echo-rui&quot;,</span><br><span class=\"line\">// 仓库地址</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;https://github.com/.../echo-ruii&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 需要上传的文件，不写就默认以.gitignore为准</span><br><span class=\"line\">  &quot;files&quot;: [</span><br><span class=\"line\">    &quot;dist&quot;</span><br><span class=\"line\">  ],</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码提交git前检查。这里使用husky这个工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">    &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    // 用git提交代码之前</span><br><span class=\"line\">      &quot;pre-commit&quot;: &quot;npm run test:nowatch &amp;&amp; npm run lint&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">    &quot;lint&quot;: &quot;eslint --ext js,ts,tsx src --fix --max-warnings 5&quot;,</span><br><span class=\"line\">    &quot;test:nowatch&quot;: &quot;cross-env CI=true react-scripts test&quot;,</span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加打包发布相关配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">    &quot;clean&quot;: &quot;rimraf ./dist&quot;,</span><br><span class=\"line\">    &quot;build-ts&quot;: &quot;tsc -p tsconfig.build.json&quot;,</span><br><span class=\"line\">    &quot;build-css&quot;: &quot;node-sass ./src/styles/index.scss ./dist/index.css&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;npm run clean &amp;&amp; npm run build-ts &amp;&amp; npm run build-css &amp;&amp; node ./buildScss.js&quot;,</span><br><span class=\"line\">    &quot;prepublishOnly&quot;: &quot;npm run lint &amp;&amp; npm run build&quot;</span><br><span class=\"line\">  </span><br><span class=\"line\">   ...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此时执行打包命令，就可以成功根据配置打包了。</p>\n<h2 id=\"十二、-发布到npm\"><a href=\"#十二、-发布到npm\" class=\"headerlink\" title=\"十二、 发布到npm\"></a>十二、 发布到npm</h2><p>万事俱备，只欠发布。</p>\n<ul>\n<li>完善一下 README.md 文档，这个随便写两句就好</li>\n<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多<br>最后执行 npm login 登入 npm 账号，再执行 npm publish 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</li>\n</ul>\n<p>大功告成✌️✌️✌️</p>\n"},{"title":"前端自动化构建工具 ---- Plop","date":"2020-12-14T02:32:08.000Z","_content":"<meta name=\"referrer\" content=\"no-referrer\"/>\n[plop](https://plopjs.com/documentation/#what-is-plop-):可以通过命令行去生成、处理文件模板代码等.\n使用条件参考：项目的每个模块的结构骨架都非常相似，引入模版内容相同就可以使用Plop来实现自动化了，Plop旨在根据模板文件自动化创建组件。\n## 一、安装plop\n* 安装到项目\n```\n  npm install --save-dev plop\n```\n* 全局安装plop（可选，建议安装方便使用）\n```\nnpm install -g plop\n```\n如果没有全局安装plop，那么要在package.json中的script中增加脚本命令：\n```\n\"scripts\": {\n    \"p\": \"plop\"\n },\n```\n\n#### 二、创建路由Generator\n\n**1、** 根目录创建一个`plop-template`文件夹，并创建一个`router`目录作为路由的`generator`,并创建`generator`的`js`文件和hbs模板（[Handlebars模板语法](https://handlebarsjs.com/zh/guide/#%E4%BB%80%E4%B9%88%E6%98%AF-handlebars%EF%BC%9F)）\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-eaca3ce1d5a18c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##三、 generator之plop.js编写\n* !!`plop.js`即`prompt.js`文件\n```\nconst {notEmpty} = require('../util.js');\n\nmodule.exports = {\n    description: 'generate a controller', //描述这个generate的作用\n    prompts: [{\n        type: 'input', // 问题的类型\n        name: 'pathName', // 问题对应得到答案的变量名，可以在acitons中使用该变量\n        message: '文件名称', // 在命令行中的问题\n        validate: notEmpty('pathName')\n    }],\n    actions: (data) => {// 这里可以通过data获取输入的pathname\n        let name = data.pathName.split('/');\n        name = name[name.length - 1];\n        name[0] = name[0].toLocaleUpperCase();\n        const actions = [\n            {\n                type: 'add', // 操作类型 添加文件\n                path: `app/controller/${data.pathName}.ts`, //添加的文件的路径\n                templateFile: 'dev-scripts/plop-templates/router/index.hbs', //模版文件的路径\n                data: {\n                    name\n                }\n            }\n        ];\n\n        return actions;\n    }\n};\n```\n* hbs模板文件\n!!模版文件作用：编写生成文件的模版内容，可自己根据项目需求进行定义。\n```\nrequire('module-alias/register');\nimport BaseController from '@base/baseController';\nimport { AController } from '@lib/aRouter';\n\nexport default class {{ name }}Controller extends BaseController {\n}\n```\n## 四、plop使用\n在项目的根目录下创建plopfile.js文件\n\n*  设置到plopfile.js\n```\nconst routerGenerator = require('./dev-scripts/plop-templates/router/prompt');\n\nmodule.exports = function (plop) {\n    plop.setGenerator('router', routerGenerator);\n};\n```\n##五、 运行plop、生成文件\n* 执行步骤一、的脚本命令\n```\n$ npm run p\n```\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-7757ee07e09cb588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 输入文件名\n!!在配置的路径下生成对应的文件\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f4864eb0598a116d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* 生成文件即是模版的内容\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-65892955b9098465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2814dec9f30b593b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n大功告成✌️✌️✌️\n\n\n\n\n\n","source":"_posts/plop.md","raw":"---\ntitle: 前端自动化构建工具 ---- Plop\ndate: 2020-12-14 10:32:08\ntags: 前端工程化\n---\n<meta name=\"referrer\" content=\"no-referrer\"/>\n[plop](https://plopjs.com/documentation/#what-is-plop-):可以通过命令行去生成、处理文件模板代码等.\n使用条件参考：项目的每个模块的结构骨架都非常相似，引入模版内容相同就可以使用Plop来实现自动化了，Plop旨在根据模板文件自动化创建组件。\n## 一、安装plop\n* 安装到项目\n```\n  npm install --save-dev plop\n```\n* 全局安装plop（可选，建议安装方便使用）\n```\nnpm install -g plop\n```\n如果没有全局安装plop，那么要在package.json中的script中增加脚本命令：\n```\n\"scripts\": {\n    \"p\": \"plop\"\n },\n```\n\n#### 二、创建路由Generator\n\n**1、** 根目录创建一个`plop-template`文件夹，并创建一个`router`目录作为路由的`generator`,并创建`generator`的`js`文件和hbs模板（[Handlebars模板语法](https://handlebarsjs.com/zh/guide/#%E4%BB%80%E4%B9%88%E6%98%AF-handlebars%EF%BC%9F)）\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-eaca3ce1d5a18c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##三、 generator之plop.js编写\n* !!`plop.js`即`prompt.js`文件\n```\nconst {notEmpty} = require('../util.js');\n\nmodule.exports = {\n    description: 'generate a controller', //描述这个generate的作用\n    prompts: [{\n        type: 'input', // 问题的类型\n        name: 'pathName', // 问题对应得到答案的变量名，可以在acitons中使用该变量\n        message: '文件名称', // 在命令行中的问题\n        validate: notEmpty('pathName')\n    }],\n    actions: (data) => {// 这里可以通过data获取输入的pathname\n        let name = data.pathName.split('/');\n        name = name[name.length - 1];\n        name[0] = name[0].toLocaleUpperCase();\n        const actions = [\n            {\n                type: 'add', // 操作类型 添加文件\n                path: `app/controller/${data.pathName}.ts`, //添加的文件的路径\n                templateFile: 'dev-scripts/plop-templates/router/index.hbs', //模版文件的路径\n                data: {\n                    name\n                }\n            }\n        ];\n\n        return actions;\n    }\n};\n```\n* hbs模板文件\n!!模版文件作用：编写生成文件的模版内容，可自己根据项目需求进行定义。\n```\nrequire('module-alias/register');\nimport BaseController from '@base/baseController';\nimport { AController } from '@lib/aRouter';\n\nexport default class {{ name }}Controller extends BaseController {\n}\n```\n## 四、plop使用\n在项目的根目录下创建plopfile.js文件\n\n*  设置到plopfile.js\n```\nconst routerGenerator = require('./dev-scripts/plop-templates/router/prompt');\n\nmodule.exports = function (plop) {\n    plop.setGenerator('router', routerGenerator);\n};\n```\n##五、 运行plop、生成文件\n* 执行步骤一、的脚本命令\n```\n$ npm run p\n```\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-7757ee07e09cb588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 输入文件名\n!!在配置的路径下生成对应的文件\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f4864eb0598a116d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* 生成文件即是模版的内容\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-65892955b9098465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2814dec9f30b593b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n大功告成✌️✌️✌️\n\n\n\n\n\n","slug":"plop","published":1,"updated":"2020-12-14T07:47:54.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrq001y78p31nvq3kk4","content":"<p><meta name=\"referrer\" content=\"no-referrer\"><br><a href=\"https://plopjs.com/documentation/#what-is-plop-\" target=\"_blank\" rel=\"noopener\">plop</a>:可以通过命令行去生成、处理文件模板代码等.<br>使用条件参考：项目的每个模块的结构骨架都非常相似，引入模版内容相同就可以使用Plop来实现自动化了，Plop旨在根据模板文件自动化创建组件。</p>\n<h2 id=\"一、安装plop\"><a href=\"#一、安装plop\" class=\"headerlink\" title=\"一、安装plop\"></a>一、安装plop</h2><ul>\n<li><p>安装到项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev plop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>全局安装plop（可选，建议安装方便使用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g plop</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果没有全局安装plop，那么要在package.json中的script中增加脚本命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;p&quot;: &quot;plop&quot;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二、创建路由Generator\"><a href=\"#二、创建路由Generator\" class=\"headerlink\" title=\"二、创建路由Generator\"></a>二、创建路由Generator</h4><p><strong>1、</strong> 根目录创建一个<code>plop-template</code>文件夹，并创建一个<code>router</code>目录作为路由的<code>generator</code>,并创建<code>generator</code>的<code>js</code>文件和hbs模板（<a href=\"https://handlebarsjs.com/zh/guide/#%E4%BB%80%E4%B9%88%E6%98%AF-handlebars%EF%BC%9F\" target=\"_blank\" rel=\"noopener\">Handlebars模板语法</a>）<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-eaca3ce1d5a18c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>##三、 generator之plop.js编写</p>\n<ul>\n<li><p>!!<code>plop.js</code>即<code>prompt.js</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;notEmpty&#125; = require(&apos;../util.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    description: &apos;generate a controller&apos;, //描述这个generate的作用</span><br><span class=\"line\">    prompts: [&#123;</span><br><span class=\"line\">        type: &apos;input&apos;, // 问题的类型</span><br><span class=\"line\">        name: &apos;pathName&apos;, // 问题对应得到答案的变量名，可以在acitons中使用该变量</span><br><span class=\"line\">        message: &apos;文件名称&apos;, // 在命令行中的问题</span><br><span class=\"line\">        validate: notEmpty(&apos;pathName&apos;)</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    actions: (data) =&gt; &#123;// 这里可以通过data获取输入的pathname</span><br><span class=\"line\">        let name = data.pathName.split(&apos;/&apos;);</span><br><span class=\"line\">        name = name[name.length - 1];</span><br><span class=\"line\">        name[0] = name[0].toLocaleUpperCase();</span><br><span class=\"line\">        const actions = [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                type: &apos;add&apos;, // 操作类型 添加文件</span><br><span class=\"line\">                path: `app/controller/$&#123;data.pathName&#125;.ts`, //添加的文件的路径</span><br><span class=\"line\">                templateFile: &apos;dev-scripts/plop-templates/router/index.hbs&apos;, //模版文件的路径</span><br><span class=\"line\">                data: &#123;</span><br><span class=\"line\">                    name</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ];</span><br><span class=\"line\"></span><br><span class=\"line\">        return actions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>hbs模板文件<br>!!模版文件作用：编写生成文件的模版内容，可自己根据项目需求进行定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;module-alias/register&apos;);</span><br><span class=\"line\">import BaseController from &apos;@base/baseController&apos;;</span><br><span class=\"line\">import &#123; AController &#125; from &apos;@lib/aRouter&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class &#123;&#123; name &#125;&#125;Controller extends BaseController &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"四、plop使用\"><a href=\"#四、plop使用\" class=\"headerlink\" title=\"四、plop使用\"></a>四、plop使用</h2><p>在项目的根目录下创建plopfile.js文件</p>\n<ul>\n<li>设置到plopfile.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routerGenerator = require(&apos;./dev-scripts/plop-templates/router/prompt&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function (plop) &#123;</span><br><span class=\"line\">    plop.setGenerator(&apos;router&apos;, routerGenerator);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>##五、 运行plop、生成文件</p>\n<ul>\n<li>执行步骤一、的脚本命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run p</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-7757ee07e09cb588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li><p>输入文件名<br>!!在配置的路径下生成对应的文件<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f4864eb0598a116d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n</li>\n<li><p>生成文件即是模版的内容<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-65892955b9098465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2814dec9f30b593b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<p><meta name=\"referrer\" content=\"no-referrer\"><br><a href=\"https://plopjs.com/documentation/#what-is-plop-\" target=\"_blank\" rel=\"noopener\">plop</a>:可以通过命令行去生成、处理文件模板代码等.<br>使用条件参考：项目的每个模块的结构骨架都非常相似，引入模版内容相同就可以使用Plop来实现自动化了，Plop旨在根据模板文件自动化创建组件。</p>\n<h2 id=\"一、安装plop\"><a href=\"#一、安装plop\" class=\"headerlink\" title=\"一、安装plop\"></a>一、安装plop</h2><ul>\n<li><p>安装到项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev plop</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>全局安装plop（可选，建议安装方便使用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g plop</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果没有全局安装plop，那么要在package.json中的script中增加脚本命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;p&quot;: &quot;plop&quot;</span><br><span class=\"line\"> &#125;,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二、创建路由Generator\"><a href=\"#二、创建路由Generator\" class=\"headerlink\" title=\"二、创建路由Generator\"></a>二、创建路由Generator</h4><p><strong>1、</strong> 根目录创建一个<code>plop-template</code>文件夹，并创建一个<code>router</code>目录作为路由的<code>generator</code>,并创建<code>generator</code>的<code>js</code>文件和hbs模板（<a href=\"https://handlebarsjs.com/zh/guide/#%E4%BB%80%E4%B9%88%E6%98%AF-handlebars%EF%BC%9F\" target=\"_blank\" rel=\"noopener\">Handlebars模板语法</a>）<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-eaca3ce1d5a18c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>##三、 generator之plop.js编写</p>\n<ul>\n<li><p>!!<code>plop.js</code>即<code>prompt.js</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;notEmpty&#125; = require(&apos;../util.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    description: &apos;generate a controller&apos;, //描述这个generate的作用</span><br><span class=\"line\">    prompts: [&#123;</span><br><span class=\"line\">        type: &apos;input&apos;, // 问题的类型</span><br><span class=\"line\">        name: &apos;pathName&apos;, // 问题对应得到答案的变量名，可以在acitons中使用该变量</span><br><span class=\"line\">        message: &apos;文件名称&apos;, // 在命令行中的问题</span><br><span class=\"line\">        validate: notEmpty(&apos;pathName&apos;)</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    actions: (data) =&gt; &#123;// 这里可以通过data获取输入的pathname</span><br><span class=\"line\">        let name = data.pathName.split(&apos;/&apos;);</span><br><span class=\"line\">        name = name[name.length - 1];</span><br><span class=\"line\">        name[0] = name[0].toLocaleUpperCase();</span><br><span class=\"line\">        const actions = [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                type: &apos;add&apos;, // 操作类型 添加文件</span><br><span class=\"line\">                path: `app/controller/$&#123;data.pathName&#125;.ts`, //添加的文件的路径</span><br><span class=\"line\">                templateFile: &apos;dev-scripts/plop-templates/router/index.hbs&apos;, //模版文件的路径</span><br><span class=\"line\">                data: &#123;</span><br><span class=\"line\">                    name</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ];</span><br><span class=\"line\"></span><br><span class=\"line\">        return actions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>hbs模板文件<br>!!模版文件作用：编写生成文件的模版内容，可自己根据项目需求进行定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&apos;module-alias/register&apos;);</span><br><span class=\"line\">import BaseController from &apos;@base/baseController&apos;;</span><br><span class=\"line\">import &#123; AController &#125; from &apos;@lib/aRouter&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class &#123;&#123; name &#125;&#125;Controller extends BaseController &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"四、plop使用\"><a href=\"#四、plop使用\" class=\"headerlink\" title=\"四、plop使用\"></a>四、plop使用</h2><p>在项目的根目录下创建plopfile.js文件</p>\n<ul>\n<li>设置到plopfile.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const routerGenerator = require(&apos;./dev-scripts/plop-templates/router/prompt&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = function (plop) &#123;</span><br><span class=\"line\">    plop.setGenerator(&apos;router&apos;, routerGenerator);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>##五、 运行plop、生成文件</p>\n<ul>\n<li>执行步骤一、的脚本命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run p</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-7757ee07e09cb588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<ul>\n<li><p>输入文件名<br>!!在配置的路径下生成对应的文件<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f4864eb0598a116d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n</li>\n<li><p>生成文件即是模版的内容<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-65892955b9098465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2814dec9f30b593b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br>大功告成✌️✌️✌️</p>\n"},{"title":"使用react搭建组件库--icon组件","date":"2020-07-27T09:16:46.000Z","_content":"\n## 前言\n你应该需要：[使用react搭建组件库：react+typescript+storybook]([https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc)\n)\n## 一、安装依赖\n在组件中使用 `fortawesome`： [一套绝佳的图标字体库和CSS框架](http://www.fontawesome.com.cn)\n\n```\nnpm install @fortawesome/fontawesome-svg-core\nnpm install @fortawesome/free-solid-svg-icons\nnpm install @fortawesome/react-fontawesome\n```\n## 二、编写组件\n* 新建 `src/components/Icon/icon.tsx`\n```\nimport React, { FC } from \"react\";\nimport classnames from \"classnames\";\nimport { library } from \"@fortawesome/fontawesome-svg-core\";\nimport { fas } from \"@fortawesome/free-solid-svg-icons\";\n\nimport {\n  FontAwesomeIconProps,\n  FontAwesomeIcon,\n} from \"@fortawesome/react-fontawesome\";\n\nlibrary.add(fas);\n\nexport type theme = \n| \"primary\"\n| \"secondary\"\n| \"success\"\n| \"info\"\n| \"warning\"\n| \"danger\"\n| \"light\"\n| \"dark\";\n\nexport interface IconProps extends FontAwesomeIconProps {\n  /** 主题颜色 */\n  theme?: theme;\n}\n\nexport const Icon: FC<IconProps> = (props) => {\n  const { className, theme, ...restProps } = props;\n  const classes = classnames(\"lin-icon\", className, {\n    [`lin-icon-${theme}`]: theme,\n  });\n\n  return <FontAwesomeIcon className={classes} {...restProps} />;\n};\n\nexport default Icon;\n```\n* 新建 src/components/Icon/index.tsx\n ```\nimport Icon from \"./icon\";\n\nexport default Icon;\n```\n* 新建 src/components/Icon/_style.scss\n```\n@import \"../../styles/variables/icon\";\n// 循环\n@each $key, $val in $icon-theme-color {\n  .lin-icon-#{$key} {\n    color: $val;\n  }\n}\n```\n\n* 新建 styles/variables/_icon.scss文件\n```\n@import \"./common\";\n\n$icon-theme-color: (\n  \"primary\": $primary,\n  \"secondary\": $secondary,\n  \"success\": $success,\n  \"info\": $info,\n  \"warning\": $warning,\n  \"danger\": $danger,\n  \"light\": $light,\n  \"dark\": $dark,\n);\n```\n* 新建 src/styles/index.scss文件\n```\n// icon样式\n@import \"../components/Icon/style\";\n```\n* 修改App.tsx文件\n！！ 对于`fortawesome`： [一套绝佳的图标字体库和CSS框架]中的图标都可以使用\n```\n// 增加\nimport Icon from \"./components/Icon/icon\";\n<Icon icon=\"coffee\" size=\"5x\" theme=\"danger\" />\n<Icon icon=\"arrow-down\" size=\"5x\" />\n```\n* 修改index.tsx文件\n```\nexport { default as Icon } from \"./components/Icon\";\n```\n## 三、运行项目\n 执行命令\n```\n$ npm start\n```\n访问项目 可以看到Icon组件成功了！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8c703c6cd972d3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 四、编写storybook文档\n* 新建`src/Icon/icon.stories.tsx`文件\n```\nimport React from 'react'\n\nimport { storiesOf } from '@storybook/react'\n\nimport Icon from './icon'\n\n\n\nconst defaultIcon = () => {\n    return (\n        <div>\n            <Icon\n                icon=\"check\"\n                size=\"3x\"\n            />\n            <Icon\n                icon=\"times\"\n                size=\"3x\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"anchor\"\n                size=\"3x\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"trash\"\n                size=\"3x\"\n                className='ml-20'\n            />\n        </div>\n    )\n}\n\nconst iconWithTheme = () => {\n    return (\n        <div>\n            <Icon\n                icon=\"check\"\n                size=\"3x\"\n                theme=\"success\"\n            />\n            <Icon\n                icon=\"times\"\n                size=\"3x\"\n                theme=\"danger\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"anchor\"\n                size=\"3x\"\n                theme=\"primary\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"exclamation-circle\"\n                size=\"3x\"\n                theme=\"warning\"\n                className='ml-20'\n            />\n        </div>\n    )\n}\n\nconst iconWithOther = () => {\n    return (\n        <div>\n            <Icon\n                icon=\"spinner\"\n                size=\"3x\"\n                spin\n                theme=\"primary\"\n            />\n            <Icon\n                icon=\"spinner\"\n                pulse\n                size=\"3x\"\n                theme=\"success\"\n                className='ml-20'\n            />\n        </div>\n    )\n}\n\n\nstoriesOf('Icon 组件', module)\n    .addParameters({\n        info: {\n            text: `\n            ## 引用方法\n            ~~~js\n            import {Icon} from 'lin-react-ui\n            ~~~\n            `\n        }\n    })\n    .add('默认的 Icon', defaultIcon)\n    .add('不同主题的 Icon', iconWithTheme)\n    .add('更多行为的 Icon', iconWithOther,{\n        info: {\n            text: `\n            ## 引用方法\n            ~~~js\n            import {Icon} from 'lin-react-ui\n            ~~~\n            更多例子请参见：https://github.com/FortAwesome/react-fontawesome#basic\n            `\n        }\n    })\n```\n* 执行命令\n```\n$ npm run storybook\n```\n浏览器打开http://localhost:9009/,可以看到组件库文档生成了。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f5e3bf4ef4168c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 五、 发布到npm\n ✅ ✅ ✅ ✅ ✅\n\n 大功告成✌️✌️✌️\n\n\n","source":"_posts/reactCom1.md","raw":"---\ntitle: 使用react搭建组件库--icon组件\ndate: 2020-07-27 17:16:46\ntags: React\n---\n\n## 前言\n你应该需要：[使用react搭建组件库：react+typescript+storybook]([https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc)\n)\n## 一、安装依赖\n在组件中使用 `fortawesome`： [一套绝佳的图标字体库和CSS框架](http://www.fontawesome.com.cn)\n\n```\nnpm install @fortawesome/fontawesome-svg-core\nnpm install @fortawesome/free-solid-svg-icons\nnpm install @fortawesome/react-fontawesome\n```\n## 二、编写组件\n* 新建 `src/components/Icon/icon.tsx`\n```\nimport React, { FC } from \"react\";\nimport classnames from \"classnames\";\nimport { library } from \"@fortawesome/fontawesome-svg-core\";\nimport { fas } from \"@fortawesome/free-solid-svg-icons\";\n\nimport {\n  FontAwesomeIconProps,\n  FontAwesomeIcon,\n} from \"@fortawesome/react-fontawesome\";\n\nlibrary.add(fas);\n\nexport type theme = \n| \"primary\"\n| \"secondary\"\n| \"success\"\n| \"info\"\n| \"warning\"\n| \"danger\"\n| \"light\"\n| \"dark\";\n\nexport interface IconProps extends FontAwesomeIconProps {\n  /** 主题颜色 */\n  theme?: theme;\n}\n\nexport const Icon: FC<IconProps> = (props) => {\n  const { className, theme, ...restProps } = props;\n  const classes = classnames(\"lin-icon\", className, {\n    [`lin-icon-${theme}`]: theme,\n  });\n\n  return <FontAwesomeIcon className={classes} {...restProps} />;\n};\n\nexport default Icon;\n```\n* 新建 src/components/Icon/index.tsx\n ```\nimport Icon from \"./icon\";\n\nexport default Icon;\n```\n* 新建 src/components/Icon/_style.scss\n```\n@import \"../../styles/variables/icon\";\n// 循环\n@each $key, $val in $icon-theme-color {\n  .lin-icon-#{$key} {\n    color: $val;\n  }\n}\n```\n\n* 新建 styles/variables/_icon.scss文件\n```\n@import \"./common\";\n\n$icon-theme-color: (\n  \"primary\": $primary,\n  \"secondary\": $secondary,\n  \"success\": $success,\n  \"info\": $info,\n  \"warning\": $warning,\n  \"danger\": $danger,\n  \"light\": $light,\n  \"dark\": $dark,\n);\n```\n* 新建 src/styles/index.scss文件\n```\n// icon样式\n@import \"../components/Icon/style\";\n```\n* 修改App.tsx文件\n！！ 对于`fortawesome`： [一套绝佳的图标字体库和CSS框架]中的图标都可以使用\n```\n// 增加\nimport Icon from \"./components/Icon/icon\";\n<Icon icon=\"coffee\" size=\"5x\" theme=\"danger\" />\n<Icon icon=\"arrow-down\" size=\"5x\" />\n```\n* 修改index.tsx文件\n```\nexport { default as Icon } from \"./components/Icon\";\n```\n## 三、运行项目\n 执行命令\n```\n$ npm start\n```\n访问项目 可以看到Icon组件成功了！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-8c703c6cd972d3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 四、编写storybook文档\n* 新建`src/Icon/icon.stories.tsx`文件\n```\nimport React from 'react'\n\nimport { storiesOf } from '@storybook/react'\n\nimport Icon from './icon'\n\n\n\nconst defaultIcon = () => {\n    return (\n        <div>\n            <Icon\n                icon=\"check\"\n                size=\"3x\"\n            />\n            <Icon\n                icon=\"times\"\n                size=\"3x\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"anchor\"\n                size=\"3x\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"trash\"\n                size=\"3x\"\n                className='ml-20'\n            />\n        </div>\n    )\n}\n\nconst iconWithTheme = () => {\n    return (\n        <div>\n            <Icon\n                icon=\"check\"\n                size=\"3x\"\n                theme=\"success\"\n            />\n            <Icon\n                icon=\"times\"\n                size=\"3x\"\n                theme=\"danger\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"anchor\"\n                size=\"3x\"\n                theme=\"primary\"\n                className='ml-20'\n            />\n            <Icon\n                icon=\"exclamation-circle\"\n                size=\"3x\"\n                theme=\"warning\"\n                className='ml-20'\n            />\n        </div>\n    )\n}\n\nconst iconWithOther = () => {\n    return (\n        <div>\n            <Icon\n                icon=\"spinner\"\n                size=\"3x\"\n                spin\n                theme=\"primary\"\n            />\n            <Icon\n                icon=\"spinner\"\n                pulse\n                size=\"3x\"\n                theme=\"success\"\n                className='ml-20'\n            />\n        </div>\n    )\n}\n\n\nstoriesOf('Icon 组件', module)\n    .addParameters({\n        info: {\n            text: `\n            ## 引用方法\n            ~~~js\n            import {Icon} from 'lin-react-ui\n            ~~~\n            `\n        }\n    })\n    .add('默认的 Icon', defaultIcon)\n    .add('不同主题的 Icon', iconWithTheme)\n    .add('更多行为的 Icon', iconWithOther,{\n        info: {\n            text: `\n            ## 引用方法\n            ~~~js\n            import {Icon} from 'lin-react-ui\n            ~~~\n            更多例子请参见：https://github.com/FortAwesome/react-fontawesome#basic\n            `\n        }\n    })\n```\n* 执行命令\n```\n$ npm run storybook\n```\n浏览器打开http://localhost:9009/,可以看到组件库文档生成了。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-f5e3bf4ef4168c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 五、 发布到npm\n ✅ ✅ ✅ ✅ ✅\n\n 大功告成✌️✌️✌️\n\n\n","slug":"reactCom1","published":1,"updated":"2020-12-14T10:13:21.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrs002078p3djo9j9mk","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>你应该需要：<a href=\"[https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc\">使用react搭建组件库：react+typescript+storybook</a><br>)</p>\n<h2 id=\"一、安装依赖\"><a href=\"#一、安装依赖\" class=\"headerlink\" title=\"一、安装依赖\"></a>一、安装依赖</h2><p>在组件中使用 <code>fortawesome</code>： <a href=\"http://www.fontawesome.com.cn\" target=\"_blank\" rel=\"noopener\">一套绝佳的图标字体库和CSS框架</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @fortawesome/fontawesome-svg-core</span><br><span class=\"line\">npm install @fortawesome/free-solid-svg-icons</span><br><span class=\"line\">npm install @fortawesome/react-fontawesome</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、编写组件\"><a href=\"#二、编写组件\" class=\"headerlink\" title=\"二、编写组件\"></a>二、编写组件</h2><ul>\n<li><p>新建 <code>src/components/Icon/icon.tsx</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; FC &#125; from &quot;react&quot;;</span><br><span class=\"line\">import classnames from &quot;classnames&quot;;</span><br><span class=\"line\">import &#123; library &#125; from &quot;@fortawesome/fontawesome-svg-core&quot;;</span><br><span class=\"line\">import &#123; fas &#125; from &quot;@fortawesome/free-solid-svg-icons&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  FontAwesomeIconProps,</span><br><span class=\"line\">  FontAwesomeIcon,</span><br><span class=\"line\">&#125; from &quot;@fortawesome/react-fontawesome&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">library.add(fas);</span><br><span class=\"line\"></span><br><span class=\"line\">export type theme = </span><br><span class=\"line\">| &quot;primary&quot;</span><br><span class=\"line\">| &quot;secondary&quot;</span><br><span class=\"line\">| &quot;success&quot;</span><br><span class=\"line\">| &quot;info&quot;</span><br><span class=\"line\">| &quot;warning&quot;</span><br><span class=\"line\">| &quot;danger&quot;</span><br><span class=\"line\">| &quot;light&quot;</span><br><span class=\"line\">| &quot;dark&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export interface IconProps extends FontAwesomeIconProps &#123;</span><br><span class=\"line\">  /** 主题颜色 */</span><br><span class=\"line\">  theme?: theme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export const Icon: FC&lt;IconProps&gt; = (props) =&gt; &#123;</span><br><span class=\"line\">  const &#123; className, theme, ...restProps &#125; = props;</span><br><span class=\"line\">  const classes = classnames(&quot;lin-icon&quot;, className, &#123;</span><br><span class=\"line\">    [`lin-icon-$&#123;theme&#125;`]: theme,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;FontAwesomeIcon className=&#123;classes&#125; &#123;...restProps&#125; /&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Icon;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Icon/index.tsx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Icon from &quot;./icon&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Icon;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Icon/_style.scss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/icon&quot;;</span><br><span class=\"line\">// 循环</span><br><span class=\"line\">@each $key, $val in $icon-theme-color &#123;</span><br><span class=\"line\">  .lin-icon-#&#123;$key&#125; &#123;</span><br><span class=\"line\">    color: $val;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 styles/variables/_icon.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;./common&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">$icon-theme-color: (</span><br><span class=\"line\">  &quot;primary&quot;: $primary,</span><br><span class=\"line\">  &quot;secondary&quot;: $secondary,</span><br><span class=\"line\">  &quot;success&quot;: $success,</span><br><span class=\"line\">  &quot;info&quot;: $info,</span><br><span class=\"line\">  &quot;warning&quot;: $warning,</span><br><span class=\"line\">  &quot;danger&quot;: $danger,</span><br><span class=\"line\">  &quot;light&quot;: $light,</span><br><span class=\"line\">  &quot;dark&quot;: $dark,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/styles/index.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// icon样式</span><br><span class=\"line\">@import &quot;../components/Icon/style&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改App.tsx文件<br>！！ 对于<code>fortawesome</code>： [一套绝佳的图标字体库和CSS框架]中的图标都可以使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 增加</span><br><span class=\"line\">import Icon from &quot;./components/Icon/icon&quot;;</span><br><span class=\"line\">&lt;Icon icon=&quot;coffee&quot; size=&quot;5x&quot; theme=&quot;danger&quot; /&gt;</span><br><span class=\"line\">&lt;Icon icon=&quot;arrow-down&quot; size=&quot;5x&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改index.tsx文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as Icon &#125; from &quot;./components/Icon&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"三、运行项目\"><a href=\"#三、运行项目\" class=\"headerlink\" title=\"三、运行项目\"></a>三、运行项目</h2><p> 执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p>访问项目 可以看到Icon组件成功了！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8c703c6cd972d3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"四、编写storybook文档\"><a href=\"#四、编写storybook文档\" class=\"headerlink\" title=\"四、编写storybook文档\"></a>四、编写storybook文档</h2><ul>\n<li><p>新建<code>src/Icon/icon.stories.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; storiesOf &#125; from &apos;@storybook/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import Icon from &apos;./icon&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const defaultIcon = () =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;check&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;times&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;anchor&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;trash&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const iconWithTheme = () =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;check&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;success&quot;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;times&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;danger&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;anchor&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;primary&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;exclamation-circle&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;warning&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const iconWithOther = () =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;spinner&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                spin</span><br><span class=\"line\">                theme=&quot;primary&quot;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;spinner&quot;</span><br><span class=\"line\">                pulse</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;success&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">storiesOf(&apos;Icon 组件&apos;, module)</span><br><span class=\"line\">    .addParameters(&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">            ## 引用方法</span><br><span class=\"line\">            ~~~js</span><br><span class=\"line\">            import &#123;Icon&#125; from &apos;lin-react-ui</span><br><span class=\"line\">            ~~~</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .add(&apos;默认的 Icon&apos;, defaultIcon)</span><br><span class=\"line\">    .add(&apos;不同主题的 Icon&apos;, iconWithTheme)</span><br><span class=\"line\">    .add(&apos;更多行为的 Icon&apos;, iconWithOther,&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">            ## 引用方法</span><br><span class=\"line\">            ~~~js</span><br><span class=\"line\">            import &#123;Icon&#125; from &apos;lin-react-ui</span><br><span class=\"line\">            ~~~</span><br><span class=\"line\">            更多例子请参见：https://github.com/FortAwesome/react-fontawesome#basic</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run storybook</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>浏览器打开<a href=\"http://localhost:9009/,可以看到组件库文档生成了。\" target=\"_blank\" rel=\"noopener\">http://localhost:9009/,可以看到组件库文档生成了。</a><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f5e3bf4ef4168c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"五、-发布到npm\"><a href=\"#五、-发布到npm\" class=\"headerlink\" title=\"五、 发布到npm\"></a>五、 发布到npm</h2><p> ✅ ✅ ✅ ✅ ✅</p>\n<p> 大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>你应该需要：<a href=\"[https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc\">使用react搭建组件库：react+typescript+storybook</a><br>)</p>\n<h2 id=\"一、安装依赖\"><a href=\"#一、安装依赖\" class=\"headerlink\" title=\"一、安装依赖\"></a>一、安装依赖</h2><p>在组件中使用 <code>fortawesome</code>： <a href=\"http://www.fontawesome.com.cn\" target=\"_blank\" rel=\"noopener\">一套绝佳的图标字体库和CSS框架</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @fortawesome/fontawesome-svg-core</span><br><span class=\"line\">npm install @fortawesome/free-solid-svg-icons</span><br><span class=\"line\">npm install @fortawesome/react-fontawesome</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、编写组件\"><a href=\"#二、编写组件\" class=\"headerlink\" title=\"二、编写组件\"></a>二、编写组件</h2><ul>\n<li><p>新建 <code>src/components/Icon/icon.tsx</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; FC &#125; from &quot;react&quot;;</span><br><span class=\"line\">import classnames from &quot;classnames&quot;;</span><br><span class=\"line\">import &#123; library &#125; from &quot;@fortawesome/fontawesome-svg-core&quot;;</span><br><span class=\"line\">import &#123; fas &#125; from &quot;@fortawesome/free-solid-svg-icons&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  FontAwesomeIconProps,</span><br><span class=\"line\">  FontAwesomeIcon,</span><br><span class=\"line\">&#125; from &quot;@fortawesome/react-fontawesome&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">library.add(fas);</span><br><span class=\"line\"></span><br><span class=\"line\">export type theme = </span><br><span class=\"line\">| &quot;primary&quot;</span><br><span class=\"line\">| &quot;secondary&quot;</span><br><span class=\"line\">| &quot;success&quot;</span><br><span class=\"line\">| &quot;info&quot;</span><br><span class=\"line\">| &quot;warning&quot;</span><br><span class=\"line\">| &quot;danger&quot;</span><br><span class=\"line\">| &quot;light&quot;</span><br><span class=\"line\">| &quot;dark&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export interface IconProps extends FontAwesomeIconProps &#123;</span><br><span class=\"line\">  /** 主题颜色 */</span><br><span class=\"line\">  theme?: theme;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export const Icon: FC&lt;IconProps&gt; = (props) =&gt; &#123;</span><br><span class=\"line\">  const &#123; className, theme, ...restProps &#125; = props;</span><br><span class=\"line\">  const classes = classnames(&quot;lin-icon&quot;, className, &#123;</span><br><span class=\"line\">    [`lin-icon-$&#123;theme&#125;`]: theme,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  return &lt;FontAwesomeIcon className=&#123;classes&#125; &#123;...restProps&#125; /&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Icon;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Icon/index.tsx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Icon from &quot;./icon&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Icon;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Icon/_style.scss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/icon&quot;;</span><br><span class=\"line\">// 循环</span><br><span class=\"line\">@each $key, $val in $icon-theme-color &#123;</span><br><span class=\"line\">  .lin-icon-#&#123;$key&#125; &#123;</span><br><span class=\"line\">    color: $val;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 styles/variables/_icon.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;./common&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">$icon-theme-color: (</span><br><span class=\"line\">  &quot;primary&quot;: $primary,</span><br><span class=\"line\">  &quot;secondary&quot;: $secondary,</span><br><span class=\"line\">  &quot;success&quot;: $success,</span><br><span class=\"line\">  &quot;info&quot;: $info,</span><br><span class=\"line\">  &quot;warning&quot;: $warning,</span><br><span class=\"line\">  &quot;danger&quot;: $danger,</span><br><span class=\"line\">  &quot;light&quot;: $light,</span><br><span class=\"line\">  &quot;dark&quot;: $dark,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/styles/index.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// icon样式</span><br><span class=\"line\">@import &quot;../components/Icon/style&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改App.tsx文件<br>！！ 对于<code>fortawesome</code>： [一套绝佳的图标字体库和CSS框架]中的图标都可以使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 增加</span><br><span class=\"line\">import Icon from &quot;./components/Icon/icon&quot;;</span><br><span class=\"line\">&lt;Icon icon=&quot;coffee&quot; size=&quot;5x&quot; theme=&quot;danger&quot; /&gt;</span><br><span class=\"line\">&lt;Icon icon=&quot;arrow-down&quot; size=&quot;5x&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改index.tsx文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as Icon &#125; from &quot;./components/Icon&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"三、运行项目\"><a href=\"#三、运行项目\" class=\"headerlink\" title=\"三、运行项目\"></a>三、运行项目</h2><p> 执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p>访问项目 可以看到Icon组件成功了！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8c703c6cd972d3e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"四、编写storybook文档\"><a href=\"#四、编写storybook文档\" class=\"headerlink\" title=\"四、编写storybook文档\"></a>四、编写storybook文档</h2><ul>\n<li><p>新建<code>src/Icon/icon.stories.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; storiesOf &#125; from &apos;@storybook/react&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">import Icon from &apos;./icon&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const defaultIcon = () =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;check&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;times&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;anchor&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;trash&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const iconWithTheme = () =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;check&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;success&quot;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;times&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;danger&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;anchor&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;primary&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;exclamation-circle&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;warning&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const iconWithOther = () =&gt; &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;spinner&quot;</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                spin</span><br><span class=\"line\">                theme=&quot;primary&quot;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">            &lt;Icon</span><br><span class=\"line\">                icon=&quot;spinner&quot;</span><br><span class=\"line\">                pulse</span><br><span class=\"line\">                size=&quot;3x&quot;</span><br><span class=\"line\">                theme=&quot;success&quot;</span><br><span class=\"line\">                className=&apos;ml-20&apos;</span><br><span class=\"line\">            /&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">storiesOf(&apos;Icon 组件&apos;, module)</span><br><span class=\"line\">    .addParameters(&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">            ## 引用方法</span><br><span class=\"line\">            ~~~js</span><br><span class=\"line\">            import &#123;Icon&#125; from &apos;lin-react-ui</span><br><span class=\"line\">            ~~~</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .add(&apos;默认的 Icon&apos;, defaultIcon)</span><br><span class=\"line\">    .add(&apos;不同主题的 Icon&apos;, iconWithTheme)</span><br><span class=\"line\">    .add(&apos;更多行为的 Icon&apos;, iconWithOther,&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">            ## 引用方法</span><br><span class=\"line\">            ~~~js</span><br><span class=\"line\">            import &#123;Icon&#125; from &apos;lin-react-ui</span><br><span class=\"line\">            ~~~</span><br><span class=\"line\">            更多例子请参见：https://github.com/FortAwesome/react-fontawesome#basic</span><br><span class=\"line\">            `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run storybook</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>浏览器打开<a href=\"http://localhost:9009/,可以看到组件库文档生成了。\" target=\"_blank\" rel=\"noopener\">http://localhost:9009/,可以看到组件库文档生成了。</a><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-f5e3bf4ef4168c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"五、-发布到npm\"><a href=\"#五、-发布到npm\" class=\"headerlink\" title=\"五、 发布到npm\"></a>五、 发布到npm</h2><p> ✅ ✅ ✅ ✅ ✅</p>\n<p> 大功告成✌️✌️✌️</p>\n"},{"title":"Promise","date":"2019-08-26T02:44:24.000Z","_content":"\nAuthor: Echo\nTime: 2019-08-26 10:44:24\n\n# 理解【ES6】Promise\n\n## 什么是Promise\n\nPromise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。\n\n* 从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。\n\n## 代码书写比较\n\n首先封装一个支持Promise的ajax方法：\n```\nfunction request(url,data = {}){\n    return new Promise((resolve,reject)=>{\n        $.ajax({\n            url,\n            data,\n            success:function (data) {\n                resolve(data);\n            },\n            error:function (error) {\n                reject(error);\n            }\n        })\n    });\n}。\n```\n用 request 方法实现多个互相依赖的网络请求\n```\nlet url1 = 'http://xxx.xxx.1';\nlet url2 = 'http://xxx.xxx.2';\nlet url3 = 'http://xxx.xxx.3';\nrequest(url1)\n    .then((data)=>{\n        console.log(data);\n        return request(url2,data)\n    })\n    .then((data)=>{\n        console.log(data);\n        return request(url3,data)\n    })\n    .then((data)=>{\n        console.log(data)\n    })\n    .catch((error)=>{\n        console.log(error);\n    });\n```\n\n## Promise 的特性\n\n### Promise 的状态、\n\n* pending (等待态)\n* fulfilled (完成态)\n* rejected (拒绝态)\n\n### 终值与拒因\n* 终值： 指的是promise被解决时传递给解决回掉的值\n* 拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因\n\n### 状态与状态关系，状态与终值和拒因的关系\n\n* pending可以迁移至fulfilled或rejected\n* fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值\n* rejected 不能迁移至其他状态，必须拥有一个不可变的据因\n\n## Promise 的使用\n\n### 构造函数\nPromise 是一个构造函数，使用new操作符返回一个promise对象\n\n构造函数接收一个 excutor函数作为参数\n\nexcutor函数有两个函数类型的参数resolve和reject\n\n```\nlet p = new Promise((resolve,reject)=>{\n     // 在 excutor 函数中执行异步操作\n     // 当异步操作完成后，调用 resolve 函数或 reject 函数\n});\n```\n\n* 构造函数在调用时，excutor函数会作为同步代码立即执行\n* 我们通常在excutor函数中执行我们的异步操作\n* 未调用resolve、reject函数时，promise对象的状态为pending\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p1');\n    },1000);\n});\n// p1 的状态一直为 pending\n```\n* 当调用resolve函数，resolve的参数为非promise对象，非thenable对象\n1. resolve 函数的参数，作为 promise 对象的终值\n2. promise 对象的状态变为 fulfilled\n\n```\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p2');\n        resolve('我是p2的终值')\n    },1000);\n});\n// 代码执行，1000ms内，p2 的状态为 pending\n// 代码执行，1000ms后，p2 的状态为 fulfilled\n// 代码执行，1000ms后，p2 的终值为 '我是p2的终值'\n\n```\n* 当调用 resolve 函数, resolve 的参数为 promise 对象\n1. promise 对象的状态、终值、拒因与传入的 promise 对象同步\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('error')\n})\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(p)\n})\n// p1 的状态为 rejected ，拒因为 error\n```\n\n* 当调用 resolve 函数, resolve 的参数为 thenable 对象\n1. 会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet thenable3 = {\n    then:function(resolve,reject){\n        throw new Error(3)\n    }\n}\nlet thenable4 = {\n    then:function(fn1,fn2){\n        //不调用 fn1 fn2\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(thenable1);\n})\nlet p2 = new Promise((resolve,reject)=>{\n    resolve(thenable2);\n})\nlet p3 = new Promise((resolve,reject)=>{\n    resolve(thenable3);\n})\nlet p4 = new Promise((resolve,reject)=>{\n    resolve(thenable4);\n})\n// p1 的状态为 fulfilled 终值为 1\n// p2 的状态为 rejected  终值为 2\n// p3 的状态为 rejected  拒因为 Error：3\n// p4 的状态为 pending\n```\n* 当调用reject函数，reject函数的参数，作为promise对象的拒因\n* promise对象的状态变为rejected\n\n```\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p3');\n        reject('我是p3的拒因')\n    },1000);\n});\n// 代码执行，1000ms内，p3 的状态为 pending\n// 代码执行，1000ms后，p3 的状态为 rejected\n// 代码执行，1000ms后，p3 的拒因为 '我是p3的拒因'\n```\n\n## Promise对象上的方法\n### then方法\npromise提供一个then方法，用于访问其终值和拒因。\npromise的then 方法接受两个参数：\n```\npromise.then(onFulfilled, onRejected)\n```\n\n* onFulfilled函数用于当promise状态变为fulfilled时，接收终值。\n* onRejected函数用于当promise状态变为rejected时，接收拒因\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('异步任务获取的数据')\n    },50)\n}).then((data)=>{\n    console.log(data)\n})\n// 异步任务获取的数据\n\n```\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        reject(new Error('异步任务异常'))\n    },50)\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 异步任务异常\n```\n```\nnew Promise((resolve,reject)=>{\n    throw new Error('抛出一个异常');\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 抛出一个异常\n```\n### onFulfilled 和 onRejected 参数可选\n\n* 如果 onFulfilled 不是函数，其必须被忽略\n* 如果 onRejected 不是函数，其必须被忽略\n\n#### onFulfilled 的特性\n如果onFulfilled是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的终值\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onRejected 的特性\n如果onRejected是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的拒因\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onFulfilled 和 onRejected 的调用时机\n\n* 当 promise 对象的状态变为 fulfilled 或 rejected 时调用\n* onFulfilled、onRejected 永远都是异步调用\n* onFulfilled、onRejected 在事件队列中作为微任务来处理\n\n```\nconsole.log(1);\nsetTimeout(function(){\n    console.log(2)\n},0)\nnew Promise((resolve,reject)=>{\n    resolve(3);\n}).then((data)=>{\n    console.log(data);\n})\nconsole.log(4)\n// print: 1 4 3 2\n```\n#### onFulfilled 和 onRejected 的调用要求\n* onFulfilled 和 onRejected 必须被作为函数调用\n* 非严格模式下，this 为全局对象\n* 严格模式下，this 为 undefined\n```\nfunction fn1(){\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfunction fn2(){\n    \"use strict\";\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfn1(); // print: window\nfn2(); // print: undefined\n```\n## then方法的多次调用\n\n* then方法可以被同一个promise对象多次调用\n* then方法会返回一个新的promise对象\n* 当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调\n* 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调\n```\nlet p = new Promise((resolve)=>{\n    resolve()\n});\nlet p1 = p.then(()=>{\n    console.log('异步执行，第一个onFulfilled');\n});\nlet p2 = p.then(()=>{\n    console.log('异步执行，第二个onFulfilled');\n});\nconsole.log(p1.constructor === Promise);\nconsole.log(p === p1);\nconsole.log(p === p2);\nconsole.log(p1 === p2);\n// print: true\n// print: false\n// print: false\n// print: false\n// print: 异步执行，第一个onFulfilled\n// print: 异步执行，第二个onFulfilled\n```\n#### then方法的返回值\nthen方法返回一个promise对象\n```\npromise2 = promise1.then(onFulfilled, onRejected);   \n```\n* 若onFulfilled 、onRejected 返回一个非promise\n对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x\n```\nlet p = new Promise((resolve,reject)=>{\n    throw new Error();\n});\nlet p1 = p.then(null,(data)=>{\n    return '我是p2的终值'\n});\np1.then((data)=>{\n    console.log(data)\n});\n// print: 我是p2的终值\n```\n* 若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\nlet p3 = new Promise((resolve)=>{\n    resolve()\n})\nlet p4 = p3.then(()=>{\n    return p1;\n})\nlet p5 = p3.then(()=>{\n    return p2;\n})\n// p4 的状态为 fulfilled 终值为 1\n// p5 的状态为 rejected  拒因为 2\n\n```\n* 若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve()\n})\nlet p2 = p1.then(()=>{\n    return thenable1;\n})\nlet p3 = p1.then(()=>{\n    return thenable2;\n})\n// p2 的状态为 fulfilled 终值为 1\n// p3 的状态为 rejected  拒因为 2\n```\n* 若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve();\n});\nlet p1 = p.then((data)=>{\n    throw new Error('error')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:&emsp;Error: error\n```\n* 若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p1的终值');\n});\nlet p1 = p.then(null,null);\np1.then((data)=>{\n    console.log(data);\n});\n// print:&emsp;我是p1的终值\n```\n* 若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('我是p1的拒因');\n});\nlet p1 = p.then(null,null);\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:我是p1的拒因\n```\n* 若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p的终值');\n});\nlet p1 = p.then((data)=>{\n    throw new Error('异常')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:Error: 异常\n```\n### 终值和拒因的穿透特性\n\n* 如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled\n\n1. then 方法返回的 promise 对象的状态变为 fulfilled\n2. then 方法返回的 promise 对象的终值与原 promise 对象的终值相同\n\n\n* 如果 promise 的状态变为 rejected，then 方法没有注册 onRejected\n\n1. then 方法返回的 promise 对象的状态变为 rejected\n2. then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\n\nlet p3 = p1.then(null,null);\nlet p4 = p2.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n\n\np5 = p3.then(null,null);\np6 = p4.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n```\n\n* 穿透特性主要用于异常处理\n```\nlet fn1 = function(){}\nlet fn2 = function(){}\nlet fn3 = function(){}\nlet fn4 = function(){}\nlet fn5 = function(){}\nlet onError = function(){};\nnew Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject()\n    })\n})\n.then(fn1)\n.then(fn2)\n.then(fn3)\n.then(fn4)\n.then(fn5)\n.then(null,onError)\n```\nfn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误\n\n### catch方法：\ncatch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同\n```\nnew Promise((resolve,reject)=>{\n    reject()\n}).then(null,function(error){\n\n})\n// 等同于\nnew Promise((resolve,reject)=>{\n    reject()\n}).catch(function(error){\n\n})\n```\n## Promise 的静态方法\n### Promise.resolve\nPromise.resolve 方法用于将现有数据转换为 promise 对象\n\n* 若入参为 promise 对象\n\n返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步\n\n* 若入参为 thenable 对象\n\n会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n* 若入参为非 promise 非 thenable 对象\n\n1.返回的 promise 对象的状态为 fulfilled\n2.返回的 promise 对象的终值为 Promise.resolve 方法的入参\n\n```\nlet p = Promise.resolve(x)\n// 等价于\nlet p = new Promise((resolve)=>{\n    resolve(x)\n})\n\n```\n\n### Promise.reject\n* Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象\n```\n\nlet p = Promise.reject(x)\n// 等价于\nlet p = new Promise((resolve,reject)=>{\n    reject(x)\n})\n```\n### Promise.all\n* Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.all([p1, p2, p3]);\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\np 的状态由 p1、p2、p3 决定\n\n* 当 p1、p2、p3 的状态都变成 fulfilled\n\np 的状态为 fulfilled\n此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值\n\n* 当 p1、p2、p3 的状态有一个变成 rejected\n\np 的状态变为 rejected\n此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因\n```\nlet p1 = Promise.resolve(1);\nlet p2 = Promise.resolve(2);\nlet p3 = 3;\n\nPromise.all([p1,p2,p3]).then((data)=>{\n    console.log(data); // print: [1,2,3]\n})\n```\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.all([p1,p2,p3]).catch((error)=>{\n    console.log(error); // print: p3 error\n})\n```\n### Promise.race\n* Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.race([p1, p2, p3]);\n\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\n* p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定\n* p 的终值或拒因由最先变更状态的 promise 对象所决定\n\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: 1\n```\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        resolve(1)\n    },1000)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },800)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\n\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: p3 error\n```\n## Promise 的错误捕获\n当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误\n```\n// node 环境下\nprocess.on('unhandledRejection', error => {\n    console.log('unhandledRejection', error);\n});\n// 浏览器下\nwindow.addEventListener('unhandledrejection',(e)=>{\n    e.preventDefault();\n    console.log(e);\n});\n\n```\n## Promise 的问题\n\n* 无法取消Promise，若没有状态变更，也无法停止 promise 的等待\n* 不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获\n* 未完成状态时，无法得知是刚开始，还是即将完成\n\n参考链接：https://juejin.im/post/5d06e9c76fb9a07ee4636235","source":"_posts/promise.md","raw":"---\ntitle: Promise\ndate: 2019-08-26 10:44:24\ntags: es6\n---\n\nAuthor: Echo\nTime: 2019-08-26 10:44:24\n\n# 理解【ES6】Promise\n\n## 什么是Promise\n\nPromise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。\n\n* 从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。\n\n## 代码书写比较\n\n首先封装一个支持Promise的ajax方法：\n```\nfunction request(url,data = {}){\n    return new Promise((resolve,reject)=>{\n        $.ajax({\n            url,\n            data,\n            success:function (data) {\n                resolve(data);\n            },\n            error:function (error) {\n                reject(error);\n            }\n        })\n    });\n}。\n```\n用 request 方法实现多个互相依赖的网络请求\n```\nlet url1 = 'http://xxx.xxx.1';\nlet url2 = 'http://xxx.xxx.2';\nlet url3 = 'http://xxx.xxx.3';\nrequest(url1)\n    .then((data)=>{\n        console.log(data);\n        return request(url2,data)\n    })\n    .then((data)=>{\n        console.log(data);\n        return request(url3,data)\n    })\n    .then((data)=>{\n        console.log(data)\n    })\n    .catch((error)=>{\n        console.log(error);\n    });\n```\n\n## Promise 的特性\n\n### Promise 的状态、\n\n* pending (等待态)\n* fulfilled (完成态)\n* rejected (拒绝态)\n\n### 终值与拒因\n* 终值： 指的是promise被解决时传递给解决回掉的值\n* 拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因\n\n### 状态与状态关系，状态与终值和拒因的关系\n\n* pending可以迁移至fulfilled或rejected\n* fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值\n* rejected 不能迁移至其他状态，必须拥有一个不可变的据因\n\n## Promise 的使用\n\n### 构造函数\nPromise 是一个构造函数，使用new操作符返回一个promise对象\n\n构造函数接收一个 excutor函数作为参数\n\nexcutor函数有两个函数类型的参数resolve和reject\n\n```\nlet p = new Promise((resolve,reject)=>{\n     // 在 excutor 函数中执行异步操作\n     // 当异步操作完成后，调用 resolve 函数或 reject 函数\n});\n```\n\n* 构造函数在调用时，excutor函数会作为同步代码立即执行\n* 我们通常在excutor函数中执行我们的异步操作\n* 未调用resolve、reject函数时，promise对象的状态为pending\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p1');\n    },1000);\n});\n// p1 的状态一直为 pending\n```\n* 当调用resolve函数，resolve的参数为非promise对象，非thenable对象\n1. resolve 函数的参数，作为 promise 对象的终值\n2. promise 对象的状态变为 fulfilled\n\n```\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p2');\n        resolve('我是p2的终值')\n    },1000);\n});\n// 代码执行，1000ms内，p2 的状态为 pending\n// 代码执行，1000ms后，p2 的状态为 fulfilled\n// 代码执行，1000ms后，p2 的终值为 '我是p2的终值'\n\n```\n* 当调用 resolve 函数, resolve 的参数为 promise 对象\n1. promise 对象的状态、终值、拒因与传入的 promise 对象同步\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('error')\n})\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(p)\n})\n// p1 的状态为 rejected ，拒因为 error\n```\n\n* 当调用 resolve 函数, resolve 的参数为 thenable 对象\n1. 会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet thenable3 = {\n    then:function(resolve,reject){\n        throw new Error(3)\n    }\n}\nlet thenable4 = {\n    then:function(fn1,fn2){\n        //不调用 fn1 fn2\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(thenable1);\n})\nlet p2 = new Promise((resolve,reject)=>{\n    resolve(thenable2);\n})\nlet p3 = new Promise((resolve,reject)=>{\n    resolve(thenable3);\n})\nlet p4 = new Promise((resolve,reject)=>{\n    resolve(thenable4);\n})\n// p1 的状态为 fulfilled 终值为 1\n// p2 的状态为 rejected  终值为 2\n// p3 的状态为 rejected  拒因为 Error：3\n// p4 的状态为 pending\n```\n* 当调用reject函数，reject函数的参数，作为promise对象的拒因\n* promise对象的状态变为rejected\n\n```\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        console.log('p3');\n        reject('我是p3的拒因')\n    },1000);\n});\n// 代码执行，1000ms内，p3 的状态为 pending\n// 代码执行，1000ms后，p3 的状态为 rejected\n// 代码执行，1000ms后，p3 的拒因为 '我是p3的拒因'\n```\n\n## Promise对象上的方法\n### then方法\npromise提供一个then方法，用于访问其终值和拒因。\npromise的then 方法接受两个参数：\n```\npromise.then(onFulfilled, onRejected)\n```\n\n* onFulfilled函数用于当promise状态变为fulfilled时，接收终值。\n* onRejected函数用于当promise状态变为rejected时，接收拒因\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('异步任务获取的数据')\n    },50)\n}).then((data)=>{\n    console.log(data)\n})\n// 异步任务获取的数据\n\n```\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        reject(new Error('异步任务异常'))\n    },50)\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 异步任务异常\n```\n```\nnew Promise((resolve,reject)=>{\n    throw new Error('抛出一个异常');\n}).then(null,(error)=>{\n    console.log(error)\n})\n// Error: 抛出一个异常\n```\n### onFulfilled 和 onRejected 参数可选\n\n* 如果 onFulfilled 不是函数，其必须被忽略\n* 如果 onRejected 不是函数，其必须被忽略\n\n#### onFulfilled 的特性\n如果onFulfilled是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的终值\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onRejected 的特性\n如果onRejected是函数：\n* 当promise执行结束后其必须被调用，其第一个参数为promise的拒因\n* 当promise执行结束前其不可被调用\n* 其调用次数不可超过1次\n#### onFulfilled 和 onRejected 的调用时机\n\n* 当 promise 对象的状态变为 fulfilled 或 rejected 时调用\n* onFulfilled、onRejected 永远都是异步调用\n* onFulfilled、onRejected 在事件队列中作为微任务来处理\n\n```\nconsole.log(1);\nsetTimeout(function(){\n    console.log(2)\n},0)\nnew Promise((resolve,reject)=>{\n    resolve(3);\n}).then((data)=>{\n    console.log(data);\n})\nconsole.log(4)\n// print: 1 4 3 2\n```\n#### onFulfilled 和 onRejected 的调用要求\n* onFulfilled 和 onRejected 必须被作为函数调用\n* 非严格模式下，this 为全局对象\n* 严格模式下，this 为 undefined\n```\nfunction fn1(){\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfunction fn2(){\n    \"use strict\";\n    new Promise((resolve)=>{\n        resolve();\n    }).then(function(){\n        console.log(this)\n    })\n}\nfn1(); // print: window\nfn2(); // print: undefined\n```\n## then方法的多次调用\n\n* then方法可以被同一个promise对象多次调用\n* then方法会返回一个新的promise对象\n* 当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调\n* 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调\n```\nlet p = new Promise((resolve)=>{\n    resolve()\n});\nlet p1 = p.then(()=>{\n    console.log('异步执行，第一个onFulfilled');\n});\nlet p2 = p.then(()=>{\n    console.log('异步执行，第二个onFulfilled');\n});\nconsole.log(p1.constructor === Promise);\nconsole.log(p === p1);\nconsole.log(p === p2);\nconsole.log(p1 === p2);\n// print: true\n// print: false\n// print: false\n// print: false\n// print: 异步执行，第一个onFulfilled\n// print: 异步执行，第二个onFulfilled\n```\n#### then方法的返回值\nthen方法返回一个promise对象\n```\npromise2 = promise1.then(onFulfilled, onRejected);   \n```\n* 若onFulfilled 、onRejected 返回一个非promise\n对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x\n```\nlet p = new Promise((resolve,reject)=>{\n    throw new Error();\n});\nlet p1 = p.then(null,(data)=>{\n    return '我是p2的终值'\n});\np1.then((data)=>{\n    console.log(data)\n});\n// print: 我是p2的终值\n```\n* 若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\nlet p3 = new Promise((resolve)=>{\n    resolve()\n})\nlet p4 = p3.then(()=>{\n    return p1;\n})\nlet p5 = p3.then(()=>{\n    return p2;\n})\n// p4 的状态为 fulfilled 终值为 1\n// p5 的状态为 rejected  拒因为 2\n\n```\n* 若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n```\nlet thenable1 = {\n    then:function(resolve,reject){\n        resolve(1)\n    }\n}\nlet thenable2 = {\n    then:function(resolve,reject){\n        reject(2)\n    }\n}\nlet p1 = new Promise((resolve,reject)=>{\n    resolve()\n})\nlet p2 = p1.then(()=>{\n    return thenable1;\n})\nlet p3 = p1.then(()=>{\n    return thenable2;\n})\n// p2 的状态为 fulfilled 终值为 1\n// p3 的状态为 rejected  拒因为 2\n```\n* 若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve();\n});\nlet p1 = p.then((data)=>{\n    throw new Error('error')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:&emsp;Error: error\n```\n* 若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p1的终值');\n});\nlet p1 = p.then(null,null);\np1.then((data)=>{\n    console.log(data);\n});\n// print:&emsp;我是p1的终值\n```\n* 若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因\n```\nlet p = new Promise((resolve,reject)=>{\n    reject('我是p1的拒因');\n});\nlet p1 = p.then(null,null);\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:我是p1的拒因\n```\n* 若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常\n```\nlet p = new Promise((resolve,reject)=>{\n    resolve('我是p的终值');\n});\nlet p1 = p.then((data)=>{\n    throw new Error('异常')\n});\np1.then(null,(err)=>{\n    console.log(err);\n});\n// print:Error: 异常\n```\n### 终值和拒因的穿透特性\n\n* 如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled\n\n1. then 方法返回的 promise 对象的状态变为 fulfilled\n2. then 方法返回的 promise 对象的终值与原 promise 对象的终值相同\n\n\n* 如果 promise 的状态变为 rejected，then 方法没有注册 onRejected\n\n1. then 方法返回的 promise 对象的状态变为 rejected\n2. then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同\n\n```\nlet p1 = new Promise((resolve,reject)=>{\n    resolve(1)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    reject(2)\n})\n\nlet p3 = p1.then(null,null);\nlet p4 = p2.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n\n\np5 = p3.then(null,null);\np6 = p4.then(null,null);\n// p3 的状态是 fulfilled 终值 1\n// p4 的状态是 rejected  拒因 2\n```\n\n* 穿透特性主要用于异常处理\n```\nlet fn1 = function(){}\nlet fn2 = function(){}\nlet fn3 = function(){}\nlet fn4 = function(){}\nlet fn5 = function(){}\nlet onError = function(){};\nnew Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject()\n    })\n})\n.then(fn1)\n.then(fn2)\n.then(fn3)\n.then(fn4)\n.then(fn5)\n.then(null,onError)\n```\nfn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误\n\n### catch方法：\ncatch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同\n```\nnew Promise((resolve,reject)=>{\n    reject()\n}).then(null,function(error){\n\n})\n// 等同于\nnew Promise((resolve,reject)=>{\n    reject()\n}).catch(function(error){\n\n})\n```\n## Promise 的静态方法\n### Promise.resolve\nPromise.resolve 方法用于将现有数据转换为 promise 对象\n\n* 若入参为 promise 对象\n\n返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步\n\n* 若入参为 thenable 对象\n\n会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果\n\n* 若入参为非 promise 非 thenable 对象\n\n1.返回的 promise 对象的状态为 fulfilled\n2.返回的 promise 对象的终值为 Promise.resolve 方法的入参\n\n```\nlet p = Promise.resolve(x)\n// 等价于\nlet p = new Promise((resolve)=>{\n    resolve(x)\n})\n\n```\n\n### Promise.reject\n* Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象\n```\n\nlet p = Promise.reject(x)\n// 等价于\nlet p = new Promise((resolve,reject)=>{\n    reject(x)\n})\n```\n### Promise.all\n* Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.all([p1, p2, p3]);\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\np 的状态由 p1、p2、p3 决定\n\n* 当 p1、p2、p3 的状态都变成 fulfilled\n\np 的状态为 fulfilled\n此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值\n\n* 当 p1、p2、p3 的状态有一个变成 rejected\n\np 的状态变为 rejected\n此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因\n```\nlet p1 = Promise.resolve(1);\nlet p2 = Promise.resolve(2);\nlet p3 = 3;\n\nPromise.all([p1,p2,p3]).then((data)=>{\n    console.log(data); // print: [1,2,3]\n})\n```\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.all([p1,p2,p3]).catch((error)=>{\n    console.log(error); // print: p3 error\n})\n```\n### Promise.race\n* Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象\n```\nconst p = Promise.race([p1, p2, p3]);\n\n```\n* p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象\n* p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定\n* p 的终值或拒因由最先变更状态的 promise 对象所决定\n\n```\nlet p1 = Promise.resolve(1);\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },1000)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: 1\n```\n```\nlet p1 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        resolve(1)\n    },1000)\n})\nlet p2 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p2 error')\n    },800)\n})\nlet p3 = new Promise((resolve,reject)=>{\n    setTimeout(function(){\n        reject('p3 error')\n    },500)\n})\n\nPromise.race([p1,p2,p3]).then(data=>{\n    console.log(data);\n}).catch(error=>{\n    console.log(error);\n})\n// print: p3 error\n```\n## Promise 的错误捕获\n当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误\n```\n// node 环境下\nprocess.on('unhandledRejection', error => {\n    console.log('unhandledRejection', error);\n});\n// 浏览器下\nwindow.addEventListener('unhandledrejection',(e)=>{\n    e.preventDefault();\n    console.log(e);\n});\n\n```\n## Promise 的问题\n\n* 无法取消Promise，若没有状态变更，也无法停止 promise 的等待\n* 不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获\n* 未完成状态时，无法得知是刚开始，还是即将完成\n\n参考链接：https://juejin.im/post/5d06e9c76fb9a07ee4636235","slug":"promise","published":1,"updated":"2019-12-04T12:50:48.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrt002378p3dk902e0o","content":"<p>Author: Echo<br>Time: 2019-08-26 10:44:24</p>\n<h1 id=\"理解【ES6】Promise\"><a href=\"#理解【ES6】Promise\" class=\"headerlink\" title=\"理解【ES6】Promise\"></a>理解【ES6】Promise</h1><h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h2><p>Promise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>\n<ul>\n<li>从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。</li>\n</ul>\n<h2 id=\"代码书写比较\"><a href=\"#代码书写比较\" class=\"headerlink\" title=\"代码书写比较\"></a>代码书写比较</h2><p>首先封装一个支持Promise的ajax方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function request(url,data = &#123;&#125;)&#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url,</span><br><span class=\"line\">            data,</span><br><span class=\"line\">            success:function (data) &#123;</span><br><span class=\"line\">                resolve(data);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error:function (error) &#123;</span><br><span class=\"line\">                reject(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;。</span><br></pre></td></tr></table></figure></p>\n<p>用 request 方法实现多个互相依赖的网络请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let url1 = &apos;http://xxx.xxx.1&apos;;</span><br><span class=\"line\">let url2 = &apos;http://xxx.xxx.2&apos;;</span><br><span class=\"line\">let url3 = &apos;http://xxx.xxx.3&apos;;</span><br><span class=\"line\">request(url1)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url2,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url3,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch((error)=&gt;&#123;</span><br><span class=\"line\">        console.log(error);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的特性\"><a href=\"#Promise-的特性\" class=\"headerlink\" title=\"Promise 的特性\"></a>Promise 的特性</h2><h3 id=\"Promise-的状态、\"><a href=\"#Promise-的状态、\" class=\"headerlink\" title=\"Promise 的状态、\"></a>Promise 的状态、</h3><ul>\n<li>pending (等待态)</li>\n<li>fulfilled (完成态)</li>\n<li>rejected (拒绝态)</li>\n</ul>\n<h3 id=\"终值与拒因\"><a href=\"#终值与拒因\" class=\"headerlink\" title=\"终值与拒因\"></a>终值与拒因</h3><ul>\n<li>终值： 指的是promise被解决时传递给解决回掉的值</li>\n<li>拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因</li>\n</ul>\n<h3 id=\"状态与状态关系，状态与终值和拒因的关系\"><a href=\"#状态与状态关系，状态与终值和拒因的关系\" class=\"headerlink\" title=\"状态与状态关系，状态与终值和拒因的关系\"></a>状态与状态关系，状态与终值和拒因的关系</h3><ul>\n<li>pending可以迁移至fulfilled或rejected</li>\n<li>fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值</li>\n<li>rejected 不能迁移至其他状态，必须拥有一个不可变的据因</li>\n</ul>\n<h2 id=\"Promise-的使用\"><a href=\"#Promise-的使用\" class=\"headerlink\" title=\"Promise 的使用\"></a>Promise 的使用</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>Promise 是一个构造函数，使用new操作符返回一个promise对象</p>\n<p>构造函数接收一个 excutor函数作为参数</p>\n<p>excutor函数有两个函数类型的参数resolve和reject</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">     // 在 excutor 函数中执行异步操作</span><br><span class=\"line\">     // 当异步操作完成后，调用 resolve 函数或 reject 函数</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数在调用时，excutor函数会作为同步代码立即执行</li>\n<li>我们通常在excutor函数中执行我们的异步操作</li>\n<li>未调用resolve、reject函数时，promise对象的状态为pending</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p1&apos;);</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// p1 的状态一直为 pending</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用resolve函数，resolve的参数为非promise对象，非thenable对象</li>\n</ul>\n<ol>\n<li>resolve 函数的参数，作为 promise 对象的终值</li>\n<li>promise 对象的状态变为 fulfilled</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p2&apos;);</span><br><span class=\"line\">        resolve(&apos;我是p2的终值&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p2 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的状态为 fulfilled</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的终值为 &apos;我是p2的终值&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 promise 对象</li>\n</ul>\n<ol>\n<li>promise 对象的状态、终值、拒因与传入的 promise 对象同步<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;error&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(p)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 rejected ，拒因为 error</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 thenable 对象</li>\n</ul>\n<ol>\n<li>会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable3 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        throw new Error(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable4 = &#123;</span><br><span class=\"line\">    then:function(fn1,fn2)&#123;</span><br><span class=\"line\">        //不调用 fn1 fn2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable1);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable2);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable3);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable4);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p2 的状态为 rejected  终值为 2</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 Error：3</span><br><span class=\"line\">// p4 的状态为 pending</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用reject函数，reject函数的参数，作为promise对象的拒因</li>\n<li>promise对象的状态变为rejected</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p3&apos;);</span><br><span class=\"line\">        reject(&apos;我是p3的拒因&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p3 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的状态为 rejected</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的拒因为 &apos;我是p3的拒因&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise对象上的方法\"><a href=\"#Promise对象上的方法\" class=\"headerlink\" title=\"Promise对象上的方法\"></a>Promise对象上的方法</h2><h3 id=\"then方法\"><a href=\"#then方法\" class=\"headerlink\" title=\"then方法\"></a>then方法</h3><p>promise提供一个then方法，用于访问其终值和拒因。<br>promise的then 方法接受两个参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>onFulfilled函数用于当promise状态变为fulfilled时，接收终值。</li>\n<li>onRejected函数用于当promise状态变为rejected时，接收拒因<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;异步任务获取的数据&apos;)</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 异步任务获取的数据</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        reject(new Error(&apos;异步任务异常&apos;))</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 异步任务异常</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;抛出一个异常&apos;);</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 抛出一个异常</span><br></pre></td></tr></table></figure>\n<h3 id=\"onFulfilled-和-onRejected-参数可选\"><a href=\"#onFulfilled-和-onRejected-参数可选\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 参数可选\"></a>onFulfilled 和 onRejected 参数可选</h3><ul>\n<li>如果 onFulfilled 不是函数，其必须被忽略</li>\n<li>如果 onRejected 不是函数，其必须被忽略</li>\n</ul>\n<h4 id=\"onFulfilled-的特性\"><a href=\"#onFulfilled-的特性\" class=\"headerlink\" title=\"onFulfilled 的特性\"></a>onFulfilled 的特性</h4><p>如果onFulfilled是函数：</p>\n<ul>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的终值</li>\n<li>当promise执行结束前其不可被调用</li>\n<li>其调用次数不可超过1次<h4 id=\"onRejected-的特性\"><a href=\"#onRejected-的特性\" class=\"headerlink\" title=\"onRejected 的特性\"></a>onRejected 的特性</h4>如果onRejected是函数：</li>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的拒因</li>\n<li>当promise执行结束前其不可被调用</li>\n<li><p>其调用次数不可超过1次</p>\n<h4 id=\"onFulfilled-和-onRejected-的调用时机\"><a href=\"#onFulfilled-和-onRejected-的调用时机\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用时机\"></a>onFulfilled 和 onRejected 的调用时机</h4></li>\n<li><p>当 promise 对象的状态变为 fulfilled 或 rejected 时调用</p>\n</li>\n<li>onFulfilled、onRejected 永远都是异步调用</li>\n<li>onFulfilled、onRejected 在事件队列中作为微任务来处理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;,0)</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(3);</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(4)</span><br><span class=\"line\">// print: 1 4 3 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"onFulfilled-和-onRejected-的调用要求\"><a href=\"#onFulfilled-和-onRejected-的调用要求\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用要求\"></a>onFulfilled 和 onRejected 的调用要求</h4><ul>\n<li>onFulfilled 和 onRejected 必须被作为函数调用</li>\n<li>非严格模式下，this 为全局对象</li>\n<li>严格模式下，this 为 undefined<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\">    &quot;use strict&quot;;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1(); // print: window</span><br><span class=\"line\">fn2(); // print: undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"then方法的多次调用\"><a href=\"#then方法的多次调用\" class=\"headerlink\" title=\"then方法的多次调用\"></a>then方法的多次调用</h2><ul>\n<li>then方法可以被同一个promise对象多次调用</li>\n<li>then方法会返回一个新的promise对象</li>\n<li>当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调</li>\n<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第一个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p2 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第二个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1.constructor === Promise);</span><br><span class=\"line\">console.log(p === p1);</span><br><span class=\"line\">console.log(p === p2);</span><br><span class=\"line\">console.log(p1 === p2);</span><br><span class=\"line\">// print: true</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: 异步执行，第一个onFulfilled</span><br><span class=\"line\">// print: 异步执行，第二个onFulfilled</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"then方法的返回值\"><a href=\"#then方法的返回值\" class=\"headerlink\" title=\"then方法的返回值\"></a>then方法的返回值</h4><p>then方法返回一个promise对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>若onFulfilled 、onRejected 返回一个非promise<br>对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,(data)=&gt;&#123;</span><br><span class=\"line\">    return &apos;我是p2的终值&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print: 我是p2的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p5 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p4 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p5 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p2 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;error&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;Error: error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p1的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;我是p1的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;我是p1的拒因&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:我是p1的拒因</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;异常&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:Error: 异常</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"终值和拒因的穿透特性\"><a href=\"#终值和拒因的穿透特性\" class=\"headerlink\" title=\"终值和拒因的穿透特性\"></a>终值和拒因的穿透特性</h3><ul>\n<li>如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 fulfilled</li>\n<li>then 方法返回的 promise 对象的终值与原 promise 对象的终值相同</li>\n</ol>\n<ul>\n<li>如果 promise 的状态变为 rejected，then 方法没有注册 onRejected</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 rejected</li>\n<li>then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">let p3 = p1.then(null,null);</span><br><span class=\"line\">let p4 = p2.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p5 = p3.then(null,null);</span><br><span class=\"line\">p6 = p4.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>穿透特性主要用于异常处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn1 = function()&#123;&#125;</span><br><span class=\"line\">let fn2 = function()&#123;&#125;</span><br><span class=\"line\">let fn3 = function()&#123;&#125;</span><br><span class=\"line\">let fn4 = function()&#123;&#125;</span><br><span class=\"line\">let fn5 = function()&#123;&#125;</span><br><span class=\"line\">let onError = function()&#123;&#125;;</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(fn1)</span><br><span class=\"line\">.then(fn2)</span><br><span class=\"line\">.then(fn3)</span><br><span class=\"line\">.then(fn4)</span><br><span class=\"line\">.then(fn5)</span><br><span class=\"line\">.then(null,onError)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>fn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误</p>\n<h3 id=\"catch方法：\"><a href=\"#catch方法：\" class=\"headerlink\" title=\"catch方法：\"></a>catch方法：</h3><p>catch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).then(null,function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).catch(function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的静态方法\"><a href=\"#Promise-的静态方法\" class=\"headerlink\" title=\"Promise 的静态方法\"></a>Promise 的静态方法</h2><h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p>Promise.resolve 方法用于将现有数据转换为 promise 对象</p>\n<ul>\n<li>若入参为 promise 对象</li>\n</ul>\n<p>返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步</p>\n<ul>\n<li>若入参为 thenable 对象</li>\n</ul>\n<p>会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</p>\n<ul>\n<li>若入参为非 promise 非 thenable 对象</li>\n</ul>\n<p>1.返回的 promise 对象的状态为 fulfilled<br>2.返回的 promise 对象的终值为 Promise.resolve 方法的入参</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = Promise.resolve(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><ul>\n<li>Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let p = Promise.reject(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><ul>\n<li><p>Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象<br>p 的状态由 p1、p2、p3 决定</p>\n</li>\n<li><p>当 p1、p2、p3 的状态都变成 fulfilled</p>\n</li>\n</ul>\n<p>p 的状态为 fulfilled<br>此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值</p>\n<ul>\n<li>当 p1、p2、p3 的状态有一个变成 rejected</li>\n</ul>\n<p>p 的状态变为 rejected<br>此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = Promise.resolve(2);</span><br><span class=\"line\">let p3 = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p3]).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data); // print: [1,2,3]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.all([p1,p2,p3]).catch((error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error); // print: p3 error</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><ul>\n<li><p>Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象</p>\n</li>\n<li>p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定</li>\n<li>p 的终值或拒因由最先变更状态的 promise 对象所决定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,800)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: p3 error</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise-的错误捕获\"><a href=\"#Promise-的错误捕获\" class=\"headerlink\" title=\"Promise 的错误捕获\"></a>Promise 的错误捕获</h2><p>当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// node 环境下</span><br><span class=\"line\">process.on(&apos;unhandledRejection&apos;, error =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;unhandledRejection&apos;, error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 浏览器下</span><br><span class=\"line\">window.addEventListener(&apos;unhandledrejection&apos;,(e)=&gt;&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的问题\"><a href=\"#Promise-的问题\" class=\"headerlink\" title=\"Promise 的问题\"></a>Promise 的问题</h2><ul>\n<li>无法取消Promise，若没有状态变更，也无法停止 promise 的等待</li>\n<li>不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获</li>\n<li>未完成状态时，无法得知是刚开始，还是即将完成</li>\n</ul>\n<p>参考链接：<a href=\"https://juejin.im/post/5d06e9c76fb9a07ee4636235\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d06e9c76fb9a07ee4636235</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-26 10:44:24</p>\n<h1 id=\"理解【ES6】Promise\"><a href=\"#理解【ES6】Promise\" class=\"headerlink\" title=\"理解【ES6】Promise\"></a>理解【ES6】Promise</h1><h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h2><p>Promise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>\n<ul>\n<li>从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。</li>\n</ul>\n<h2 id=\"代码书写比较\"><a href=\"#代码书写比较\" class=\"headerlink\" title=\"代码书写比较\"></a>代码书写比较</h2><p>首先封装一个支持Promise的ajax方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function request(url,data = &#123;&#125;)&#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url,</span><br><span class=\"line\">            data,</span><br><span class=\"line\">            success:function (data) &#123;</span><br><span class=\"line\">                resolve(data);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error:function (error) &#123;</span><br><span class=\"line\">                reject(error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;。</span><br></pre></td></tr></table></figure></p>\n<p>用 request 方法实现多个互相依赖的网络请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let url1 = &apos;http://xxx.xxx.1&apos;;</span><br><span class=\"line\">let url2 = &apos;http://xxx.xxx.2&apos;;</span><br><span class=\"line\">let url3 = &apos;http://xxx.xxx.3&apos;;</span><br><span class=\"line\">request(url1)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url2,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data);</span><br><span class=\"line\">        return request(url3,data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then((data)=&gt;&#123;</span><br><span class=\"line\">        console.log(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch((error)=&gt;&#123;</span><br><span class=\"line\">        console.log(error);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的特性\"><a href=\"#Promise-的特性\" class=\"headerlink\" title=\"Promise 的特性\"></a>Promise 的特性</h2><h3 id=\"Promise-的状态、\"><a href=\"#Promise-的状态、\" class=\"headerlink\" title=\"Promise 的状态、\"></a>Promise 的状态、</h3><ul>\n<li>pending (等待态)</li>\n<li>fulfilled (完成态)</li>\n<li>rejected (拒绝态)</li>\n</ul>\n<h3 id=\"终值与拒因\"><a href=\"#终值与拒因\" class=\"headerlink\" title=\"终值与拒因\"></a>终值与拒因</h3><ul>\n<li>终值： 指的是promise被解决时传递给解决回掉的值</li>\n<li>拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因</li>\n</ul>\n<h3 id=\"状态与状态关系，状态与终值和拒因的关系\"><a href=\"#状态与状态关系，状态与终值和拒因的关系\" class=\"headerlink\" title=\"状态与状态关系，状态与终值和拒因的关系\"></a>状态与状态关系，状态与终值和拒因的关系</h3><ul>\n<li>pending可以迁移至fulfilled或rejected</li>\n<li>fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值</li>\n<li>rejected 不能迁移至其他状态，必须拥有一个不可变的据因</li>\n</ul>\n<h2 id=\"Promise-的使用\"><a href=\"#Promise-的使用\" class=\"headerlink\" title=\"Promise 的使用\"></a>Promise 的使用</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>Promise 是一个构造函数，使用new操作符返回一个promise对象</p>\n<p>构造函数接收一个 excutor函数作为参数</p>\n<p>excutor函数有两个函数类型的参数resolve和reject</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">     // 在 excutor 函数中执行异步操作</span><br><span class=\"line\">     // 当异步操作完成后，调用 resolve 函数或 reject 函数</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>构造函数在调用时，excutor函数会作为同步代码立即执行</li>\n<li>我们通常在excutor函数中执行我们的异步操作</li>\n<li>未调用resolve、reject函数时，promise对象的状态为pending</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p1&apos;);</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// p1 的状态一直为 pending</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用resolve函数，resolve的参数为非promise对象，非thenable对象</li>\n</ul>\n<ol>\n<li>resolve 函数的参数，作为 promise 对象的终值</li>\n<li>promise 对象的状态变为 fulfilled</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p2&apos;);</span><br><span class=\"line\">        resolve(&apos;我是p2的终值&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p2 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的状态为 fulfilled</span><br><span class=\"line\">// 代码执行，1000ms后，p2 的终值为 &apos;我是p2的终值&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 promise 对象</li>\n</ul>\n<ol>\n<li>promise 对象的状态、终值、拒因与传入的 promise 对象同步<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;error&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(p)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 rejected ，拒因为 error</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用 resolve 函数, resolve 的参数为 thenable 对象</li>\n</ul>\n<ol>\n<li>会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable3 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        throw new Error(3)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable4 = &#123;</span><br><span class=\"line\">    then:function(fn1,fn2)&#123;</span><br><span class=\"line\">        //不调用 fn1 fn2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable1);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable2);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable3);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(thenable4);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p1 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p2 的状态为 rejected  终值为 2</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 Error：3</span><br><span class=\"line\">// p4 的状态为 pending</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>当调用reject函数，reject函数的参数，作为promise对象的拒因</li>\n<li>promise对象的状态变为rejected</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        console.log(&apos;p3&apos;);</span><br><span class=\"line\">        reject(&apos;我是p3的拒因&apos;)</span><br><span class=\"line\">    &#125;,1000);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 代码执行，1000ms内，p3 的状态为 pending</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的状态为 rejected</span><br><span class=\"line\">// 代码执行，1000ms后，p3 的拒因为 &apos;我是p3的拒因&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise对象上的方法\"><a href=\"#Promise对象上的方法\" class=\"headerlink\" title=\"Promise对象上的方法\"></a>Promise对象上的方法</h2><h3 id=\"then方法\"><a href=\"#then方法\" class=\"headerlink\" title=\"then方法\"></a>then方法</h3><p>promise提供一个then方法，用于访问其终值和拒因。<br>promise的then 方法接受两个参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>onFulfilled函数用于当promise状态变为fulfilled时，接收终值。</li>\n<li>onRejected函数用于当promise状态变为rejected时，接收拒因<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;异步任务获取的数据&apos;)</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 异步任务获取的数据</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        reject(new Error(&apos;异步任务异常&apos;))</span><br><span class=\"line\">    &#125;,50)</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 异步任务异常</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;抛出一个异常&apos;);</span><br><span class=\"line\">&#125;).then(null,(error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// Error: 抛出一个异常</span><br></pre></td></tr></table></figure>\n<h3 id=\"onFulfilled-和-onRejected-参数可选\"><a href=\"#onFulfilled-和-onRejected-参数可选\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 参数可选\"></a>onFulfilled 和 onRejected 参数可选</h3><ul>\n<li>如果 onFulfilled 不是函数，其必须被忽略</li>\n<li>如果 onRejected 不是函数，其必须被忽略</li>\n</ul>\n<h4 id=\"onFulfilled-的特性\"><a href=\"#onFulfilled-的特性\" class=\"headerlink\" title=\"onFulfilled 的特性\"></a>onFulfilled 的特性</h4><p>如果onFulfilled是函数：</p>\n<ul>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的终值</li>\n<li>当promise执行结束前其不可被调用</li>\n<li>其调用次数不可超过1次<h4 id=\"onRejected-的特性\"><a href=\"#onRejected-的特性\" class=\"headerlink\" title=\"onRejected 的特性\"></a>onRejected 的特性</h4>如果onRejected是函数：</li>\n<li>当promise执行结束后其必须被调用，其第一个参数为promise的拒因</li>\n<li>当promise执行结束前其不可被调用</li>\n<li><p>其调用次数不可超过1次</p>\n<h4 id=\"onFulfilled-和-onRejected-的调用时机\"><a href=\"#onFulfilled-和-onRejected-的调用时机\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用时机\"></a>onFulfilled 和 onRejected 的调用时机</h4></li>\n<li><p>当 promise 对象的状态变为 fulfilled 或 rejected 时调用</p>\n</li>\n<li>onFulfilled、onRejected 永远都是异步调用</li>\n<li>onFulfilled、onRejected 在事件队列中作为微任务来处理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1);</span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;,0)</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(3);</span><br><span class=\"line\">&#125;).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(4)</span><br><span class=\"line\">// print: 1 4 3 2</span><br></pre></td></tr></table></figure>\n<h4 id=\"onFulfilled-和-onRejected-的调用要求\"><a href=\"#onFulfilled-和-onRejected-的调用要求\" class=\"headerlink\" title=\"onFulfilled 和 onRejected 的调用要求\"></a>onFulfilled 和 onRejected 的调用要求</h4><ul>\n<li>onFulfilled 和 onRejected 必须被作为函数调用</li>\n<li>非严格模式下，this 为全局对象</li>\n<li>严格模式下，this 为 undefined<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\">    &quot;use strict&quot;;</span><br><span class=\"line\">    new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function()&#123;</span><br><span class=\"line\">        console.log(this)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn1(); // print: window</span><br><span class=\"line\">fn2(); // print: undefined</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"then方法的多次调用\"><a href=\"#then方法的多次调用\" class=\"headerlink\" title=\"then方法的多次调用\"></a>then方法的多次调用</h2><ul>\n<li>then方法可以被同一个promise对象多次调用</li>\n<li>then方法会返回一个新的promise对象</li>\n<li>当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调</li>\n<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第一个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p2 = p.then(()=&gt;&#123;</span><br><span class=\"line\">    console.log(&apos;异步执行，第二个onFulfilled&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1.constructor === Promise);</span><br><span class=\"line\">console.log(p === p1);</span><br><span class=\"line\">console.log(p === p2);</span><br><span class=\"line\">console.log(p1 === p2);</span><br><span class=\"line\">// print: true</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: false</span><br><span class=\"line\">// print: 异步执行，第一个onFulfilled</span><br><span class=\"line\">// print: 异步执行，第二个onFulfilled</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"then方法的返回值\"><a href=\"#then方法的返回值\" class=\"headerlink\" title=\"then方法的返回值\"></a>then方法的返回值</h4><p>then方法返回一个promise对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>若onFulfilled 、onRejected 返回一个非promise<br>对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    throw new Error();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,(data)=&gt;&#123;</span><br><span class=\"line\">    return &apos;我是p2的终值&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print: 我是p2的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p4 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p5 = p3.then(()=&gt;&#123;</span><br><span class=\"line\">    return p2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p4 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p5 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable1 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let thenable2 = &#123;</span><br><span class=\"line\">    then:function(resolve,reject)&#123;</span><br><span class=\"line\">        reject(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable1;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = p1.then(()=&gt;&#123;</span><br><span class=\"line\">    return thenable2;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// p2 的状态为 fulfilled 终值为 1</span><br><span class=\"line\">// p3 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;error&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;Error: error</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p1的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:&amp;emsp;我是p1的终值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(&apos;我是p1的拒因&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then(null,null);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:我是p1的拒因</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(&apos;我是p的终值&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">let p1 = p.then((data)=&gt;&#123;</span><br><span class=\"line\">    throw new Error(&apos;异常&apos;)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p1.then(null,(err)=&gt;&#123;</span><br><span class=\"line\">    console.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// print:Error: 异常</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"终值和拒因的穿透特性\"><a href=\"#终值和拒因的穿透特性\" class=\"headerlink\" title=\"终值和拒因的穿透特性\"></a>终值和拒因的穿透特性</h3><ul>\n<li>如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 fulfilled</li>\n<li>then 方法返回的 promise 对象的终值与原 promise 对象的终值相同</li>\n</ol>\n<ul>\n<li>如果 promise 的状态变为 rejected，then 方法没有注册 onRejected</li>\n</ul>\n<ol>\n<li>then 方法返回的 promise 对象的状态变为 rejected</li>\n<li>then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(2)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">let p3 = p1.then(null,null);</span><br><span class=\"line\">let p4 = p2.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p5 = p3.then(null,null);</span><br><span class=\"line\">p6 = p4.then(null,null);</span><br><span class=\"line\">// p3 的状态是 fulfilled 终值 1</span><br><span class=\"line\">// p4 的状态是 rejected  拒因 2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>穿透特性主要用于异常处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fn1 = function()&#123;&#125;</span><br><span class=\"line\">let fn2 = function()&#123;&#125;</span><br><span class=\"line\">let fn3 = function()&#123;&#125;</span><br><span class=\"line\">let fn4 = function()&#123;&#125;</span><br><span class=\"line\">let fn5 = function()&#123;&#125;</span><br><span class=\"line\">let onError = function()&#123;&#125;;</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(fn1)</span><br><span class=\"line\">.then(fn2)</span><br><span class=\"line\">.then(fn3)</span><br><span class=\"line\">.then(fn4)</span><br><span class=\"line\">.then(fn5)</span><br><span class=\"line\">.then(null,onError)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>fn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误</p>\n<h3 id=\"catch方法：\"><a href=\"#catch方法：\" class=\"headerlink\" title=\"catch方法：\"></a>catch方法：</h3><p>catch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).then(null,function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject()</span><br><span class=\"line\">&#125;).catch(function(error)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的静态方法\"><a href=\"#Promise-的静态方法\" class=\"headerlink\" title=\"Promise 的静态方法\"></a>Promise 的静态方法</h2><h3 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve\"></a>Promise.resolve</h3><p>Promise.resolve 方法用于将现有数据转换为 promise 对象</p>\n<ul>\n<li>若入参为 promise 对象</li>\n</ul>\n<p>返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步</p>\n<ul>\n<li>若入参为 thenable 对象</li>\n</ul>\n<p>会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</p>\n<ul>\n<li>若入参为非 promise 非 thenable 对象</li>\n</ul>\n<p>1.返回的 promise 对象的状态为 fulfilled<br>2.返回的 promise 对象的终值为 Promise.resolve 方法的入参</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p = Promise.resolve(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve)=&gt;&#123;</span><br><span class=\"line\">    resolve(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject\"></a>Promise.reject</h3><ul>\n<li>Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">let p = Promise.reject(x)</span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    reject(x)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><ul>\n<li><p>Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象<br>p 的状态由 p1、p2、p3 决定</p>\n</li>\n<li><p>当 p1、p2、p3 的状态都变成 fulfilled</p>\n</li>\n</ul>\n<p>p 的状态为 fulfilled<br>此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值</p>\n<ul>\n<li>当 p1、p2、p3 的状态有一个变成 rejected</li>\n</ul>\n<p>p 的状态变为 rejected<br>此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = Promise.resolve(2);</span><br><span class=\"line\">let p3 = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([p1,p2,p3]).then((data)=&gt;&#123;</span><br><span class=\"line\">    console.log(data); // print: [1,2,3]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.all([p1,p2,p3]).catch((error)=&gt;&#123;</span><br><span class=\"line\">    console.log(error); // print: p3 error</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race\"></a>Promise.race</h3><ul>\n<li><p>Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象</p>\n</li>\n<li>p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定</li>\n<li>p 的终值或拒因由最先变更状态的 promise 对象所决定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = Promise.resolve(1);</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: 1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        resolve(1)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p2 error&apos;)</span><br><span class=\"line\">    &#125;,800)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(function()&#123;</span><br><span class=\"line\">        reject(&apos;p3 error&apos;)</span><br><span class=\"line\">    &#125;,500)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class=\"line\">    console.log(data);</span><br><span class=\"line\">&#125;).catch(error=&gt;&#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// print: p3 error</span><br></pre></td></tr></table></figure>\n<h2 id=\"Promise-的错误捕获\"><a href=\"#Promise-的错误捕获\" class=\"headerlink\" title=\"Promise 的错误捕获\"></a>Promise 的错误捕获</h2><p>当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// node 环境下</span><br><span class=\"line\">process.on(&apos;unhandledRejection&apos;, error =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;unhandledRejection&apos;, error);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 浏览器下</span><br><span class=\"line\">window.addEventListener(&apos;unhandledrejection&apos;,(e)=&gt;&#123;</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">    console.log(e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise-的问题\"><a href=\"#Promise-的问题\" class=\"headerlink\" title=\"Promise 的问题\"></a>Promise 的问题</h2><ul>\n<li>无法取消Promise，若没有状态变更，也无法停止 promise 的等待</li>\n<li>不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获</li>\n<li>未完成状态时，无法得知是刚开始，还是即将完成</li>\n</ul>\n<p>参考链接：<a href=\"https://juejin.im/post/5d06e9c76fb9a07ee4636235\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5d06e9c76fb9a07ee4636235</a></p>\n"},{"title":"Vue响应式原理解析","date":"2020-03-30T08:55:06.000Z","_content":"### vue从改变一个数据到发生改变的过程\n* 数据改变触发set\n* Set部分触发notify(更新和通知) -> Get部分收集依赖\n* 更改对应的虚拟dom\n* 重新render\n#### vue2\n* defineProperty\ndefineProperty不仅仅用来做响应式，他的作用可以用来给对象中的属性配置操作权限。其中get和set实现了响应式原理。\n\n```\nlet ob = {\n  a:1\n}\n\bObject.defineProperty(ob, 'a', {\n  writable:false, // 属性值是否可写\n  enumerable: false, // 属性值是否可循环\n  configurable: false //属性值是否可以delete\n})\n\n\bObject.getOwn\bPropertyDescriptor(ob, 'a'); // 读取对象的属性值\n```\n* get & set \n```\nlet _value = ob.a;\n// 如果想要使用get&set方法实现读取和存储，必须将属性值重新赋值给新的变量，来实现储存和中转，这也是defineProperty不优雅的一点。\n// get & set 必须配合return方法使用。\n\bObject.defineProperty(ob, 'a', {\n  get () {\n    return _value;\n  },\n  set (newValue) {\n    _value = newValue\n    return _value;\n  }\n})\n```\n\n\n```\n// 实现vue简易版的双向原理\nfunction Vue () {\n  this.$data = {a:1};\n  this.el = document.getElementById('app');\n  this.vritualDom = '';\n  this.observer(this.$data); //注册监听\n  this.render();\n}\n// 注册get和set\nVue.prototype.observer = function (obj) {\n  var value;\n  var self = this;\n  for (var key in obj) {\n    value = obj[key];\n    if (typeof value === 'object') {\n      this.observer(value);\n    } else {\n      Object.defineProperty(obj, key, {\n        get(){\n          // 进行依赖收集\n          // 为什么要收集依赖？\n          // 数据可能只在局部位置使用，找到对应依赖，只更新依赖于变量的组件。\n          return value;\n        },\n        set(newvalue){\n          value = newvalue;\n          self.render()\n          return value;\n        }\n      })\n    }\n  }\n};\n\nVue.prototype.render = function (obj) {\n  this.vritualDom = 'i am' + this.$data.a;\n  this.el.innerHTML = this.vritualDom;\n}\n```\n\n\n### defineProperty中的get和set是对象的属性，对数组如何实现处理？\n\n```\n// 数组的双向绑定就是做了一个设计者模式；\n// 取出数组的原型链并拷贝;\nvar arraypro = Array.prototype;\nvar arrob =Object.create(arraypro);\nvar arrFun = ['push', 'pop', 'shift'];\n\narrFun.forEach((method .index) => {\n  arrob[method] = function () {\n    var ret = arraypro[method].apply(this, arguments);\n    dep.notify() // 触发试图更新\n  }\n})\n```\n### vue3\n* Proxy对象用于定义基本操作的自定义行为（和defineProperty类似，用法不同）\n```\nlet obj = {\n  a:1,\n}\nvar obj = new Proxy(ob, {\n  get (target, key, receiver) {\n    return target[key];\n  },\n  set (target, key, value, receiver) {\n    return Reflect.set(target, key, value)\n    // return target[key] = value;\n  }\n})\n```\n\n\n\n```\n// vue简易版的实现双向原理\nfunction Vue () {\n  var self = this;\n  this.$data = new Proxy(this.$data, {\n    get (target, key, receiver) {\n      return target[key];\n    },\n    set (target, key, value, receiver) {\n      target[key] = value;\n      self.render();\n      return target[key];\n    }\n  })\n}\n\n```\n\n\n#### proxy的其他作用？\n* 校验类型\n // 创建一个对象，对象有name和age两个属性;name是中文 age是数字且大于18;\n```\nvar validtor = {\n  // 策略模式\n  name: function (value) {\n    var reg = /^[\\u4E00-\\u9FA5]+$/;\n    if (typeof value == 'string' && reg.test(value)) {\n      return true;\n    }\n    return false;\n  },\n  age: function (value) {\n    if (typeof value == 'number' && value >= 18) {\n      return true;\n    }\n    return false;\n  },\n}\nfunction preson (age, name) {\n  this.age = age;\n  this.name = name;\n  return new Proxy(this, {\n    get (target, key) {\n      return targe[key]\n    },\n    set (target, key, value) {\n      if (validtor[key](value)) {\n        return Reflect.set(target, key, value);\n      } else {\n        throw new Error(key + 'is not right')\n      }\n    }\n  })\n};\n```\n* 真正私有属性\n\n#### defineProperty 和 Proxy的区别\n1. defineProperty只能监听对象的某个属性，不能监听全对象；\n2. 可以省去defineProperty 中的for in 循环，节省性能\n3. 可以监听数组，不需要再去单独的对数组进行特异性处理；\n4. 不需要借助外部变量实现存储和读取（完善了vue2中defineProperty的不优雅的地方）\n3. 不会污染原对象(proxy对原对象进行代理，生成新的代理对象)\n\n","source":"_posts/reactive.md","raw":"---\ntitle: Vue响应式原理解析\ndate: 2020-03-30 16:55:06\ntags: vue\n---\n### vue从改变一个数据到发生改变的过程\n* 数据改变触发set\n* Set部分触发notify(更新和通知) -> Get部分收集依赖\n* 更改对应的虚拟dom\n* 重新render\n#### vue2\n* defineProperty\ndefineProperty不仅仅用来做响应式，他的作用可以用来给对象中的属性配置操作权限。其中get和set实现了响应式原理。\n\n```\nlet ob = {\n  a:1\n}\n\bObject.defineProperty(ob, 'a', {\n  writable:false, // 属性值是否可写\n  enumerable: false, // 属性值是否可循环\n  configurable: false //属性值是否可以delete\n})\n\n\bObject.getOwn\bPropertyDescriptor(ob, 'a'); // 读取对象的属性值\n```\n* get & set \n```\nlet _value = ob.a;\n// 如果想要使用get&set方法实现读取和存储，必须将属性值重新赋值给新的变量，来实现储存和中转，这也是defineProperty不优雅的一点。\n// get & set 必须配合return方法使用。\n\bObject.defineProperty(ob, 'a', {\n  get () {\n    return _value;\n  },\n  set (newValue) {\n    _value = newValue\n    return _value;\n  }\n})\n```\n\n\n```\n// 实现vue简易版的双向原理\nfunction Vue () {\n  this.$data = {a:1};\n  this.el = document.getElementById('app');\n  this.vritualDom = '';\n  this.observer(this.$data); //注册监听\n  this.render();\n}\n// 注册get和set\nVue.prototype.observer = function (obj) {\n  var value;\n  var self = this;\n  for (var key in obj) {\n    value = obj[key];\n    if (typeof value === 'object') {\n      this.observer(value);\n    } else {\n      Object.defineProperty(obj, key, {\n        get(){\n          // 进行依赖收集\n          // 为什么要收集依赖？\n          // 数据可能只在局部位置使用，找到对应依赖，只更新依赖于变量的组件。\n          return value;\n        },\n        set(newvalue){\n          value = newvalue;\n          self.render()\n          return value;\n        }\n      })\n    }\n  }\n};\n\nVue.prototype.render = function (obj) {\n  this.vritualDom = 'i am' + this.$data.a;\n  this.el.innerHTML = this.vritualDom;\n}\n```\n\n\n### defineProperty中的get和set是对象的属性，对数组如何实现处理？\n\n```\n// 数组的双向绑定就是做了一个设计者模式；\n// 取出数组的原型链并拷贝;\nvar arraypro = Array.prototype;\nvar arrob =Object.create(arraypro);\nvar arrFun = ['push', 'pop', 'shift'];\n\narrFun.forEach((method .index) => {\n  arrob[method] = function () {\n    var ret = arraypro[method].apply(this, arguments);\n    dep.notify() // 触发试图更新\n  }\n})\n```\n### vue3\n* Proxy对象用于定义基本操作的自定义行为（和defineProperty类似，用法不同）\n```\nlet obj = {\n  a:1,\n}\nvar obj = new Proxy(ob, {\n  get (target, key, receiver) {\n    return target[key];\n  },\n  set (target, key, value, receiver) {\n    return Reflect.set(target, key, value)\n    // return target[key] = value;\n  }\n})\n```\n\n\n\n```\n// vue简易版的实现双向原理\nfunction Vue () {\n  var self = this;\n  this.$data = new Proxy(this.$data, {\n    get (target, key, receiver) {\n      return target[key];\n    },\n    set (target, key, value, receiver) {\n      target[key] = value;\n      self.render();\n      return target[key];\n    }\n  })\n}\n\n```\n\n\n#### proxy的其他作用？\n* 校验类型\n // 创建一个对象，对象有name和age两个属性;name是中文 age是数字且大于18;\n```\nvar validtor = {\n  // 策略模式\n  name: function (value) {\n    var reg = /^[\\u4E00-\\u9FA5]+$/;\n    if (typeof value == 'string' && reg.test(value)) {\n      return true;\n    }\n    return false;\n  },\n  age: function (value) {\n    if (typeof value == 'number' && value >= 18) {\n      return true;\n    }\n    return false;\n  },\n}\nfunction preson (age, name) {\n  this.age = age;\n  this.name = name;\n  return new Proxy(this, {\n    get (target, key) {\n      return targe[key]\n    },\n    set (target, key, value) {\n      if (validtor[key](value)) {\n        return Reflect.set(target, key, value);\n      } else {\n        throw new Error(key + 'is not right')\n      }\n    }\n  })\n};\n```\n* 真正私有属性\n\n#### defineProperty 和 Proxy的区别\n1. defineProperty只能监听对象的某个属性，不能监听全对象；\n2. 可以省去defineProperty 中的for in 循环，节省性能\n3. 可以监听数组，不需要再去单独的对数组进行特异性处理；\n4. 不需要借助外部变量实现存储和读取（完善了vue2中defineProperty的不优雅的地方）\n3. 不会污染原对象(proxy对原对象进行代理，生成新的代理对象)\n\n","slug":"reactive","published":1,"updated":"2020-05-08T11:09:28.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjru002578p384o6339h","content":"<h3 id=\"vue从改变一个数据到发生改变的过程\"><a href=\"#vue从改变一个数据到发生改变的过程\" class=\"headerlink\" title=\"vue从改变一个数据到发生改变的过程\"></a>vue从改变一个数据到发生改变的过程</h3><ul>\n<li>数据改变触发set</li>\n<li>Set部分触发notify(更新和通知) -&gt; Get部分收集依赖</li>\n<li>更改对应的虚拟dom</li>\n<li>重新render<h4 id=\"vue2\"><a href=\"#vue2\" class=\"headerlink\" title=\"vue2\"></a>vue2</h4></li>\n<li>defineProperty<br>defineProperty不仅仅用来做响应式，他的作用可以用来给对象中的属性配置操作权限。其中get和set实现了响应式原理。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ob = &#123;</span><br><span class=\"line\">  a:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\bObject.defineProperty(ob, &apos;a&apos;, &#123;</span><br><span class=\"line\">  writable:false, // 属性值是否可写</span><br><span class=\"line\">  enumerable: false, // 属性值是否可循环</span><br><span class=\"line\">  configurable: false //属性值是否可以delete</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\bObject.getOwn\bPropertyDescriptor(ob, &apos;a&apos;); // 读取对象的属性值</span><br></pre></td></tr></table></figure>\n<ul>\n<li>get &amp; set <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let _value = ob.a;</span><br><span class=\"line\">// 如果想要使用get&amp;set方法实现读取和存储，必须将属性值重新赋值给新的变量，来实现储存和中转，这也是defineProperty不优雅的一点。</span><br><span class=\"line\">// get &amp; set 必须配合return方法使用。</span><br><span class=\"line\">\bObject.defineProperty(ob, &apos;a&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    return _value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set (newValue) &#123;</span><br><span class=\"line\">    _value = newValue</span><br><span class=\"line\">    return _value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现vue简易版的双向原理</span><br><span class=\"line\">function Vue () &#123;</span><br><span class=\"line\">  this.$data = &#123;a:1&#125;;</span><br><span class=\"line\">  this.el = document.getElementById(&apos;app&apos;);</span><br><span class=\"line\">  this.vritualDom = &apos;&apos;;</span><br><span class=\"line\">  this.observer(this.$data); //注册监听</span><br><span class=\"line\">  this.render();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 注册get和set</span><br><span class=\"line\">Vue.prototype.observer = function (obj) &#123;</span><br><span class=\"line\">  var value;</span><br><span class=\"line\">  var self = this;</span><br><span class=\"line\">  for (var key in obj) &#123;</span><br><span class=\"line\">    value = obj[key];</span><br><span class=\"line\">    if (typeof value === &apos;object&apos;) &#123;</span><br><span class=\"line\">      this.observer(value);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">        get()&#123;</span><br><span class=\"line\">          // 进行依赖收集</span><br><span class=\"line\">          // 为什么要收集依赖？</span><br><span class=\"line\">          // 数据可能只在局部位置使用，找到对应依赖，只更新依赖于变量的组件。</span><br><span class=\"line\">          return value;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set(newvalue)&#123;</span><br><span class=\"line\">          value = newvalue;</span><br><span class=\"line\">          self.render()</span><br><span class=\"line\">          return value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.prototype.render = function (obj) &#123;</span><br><span class=\"line\">  this.vritualDom = &apos;i am&apos; + this.$data.a;</span><br><span class=\"line\">  this.el.innerHTML = this.vritualDom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"defineProperty中的get和set是对象的属性，对数组如何实现处理？\"><a href=\"#defineProperty中的get和set是对象的属性，对数组如何实现处理？\" class=\"headerlink\" title=\"defineProperty中的get和set是对象的属性，对数组如何实现处理？\"></a>defineProperty中的get和set是对象的属性，对数组如何实现处理？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 数组的双向绑定就是做了一个设计者模式；</span><br><span class=\"line\">// 取出数组的原型链并拷贝;</span><br><span class=\"line\">var arraypro = Array.prototype;</span><br><span class=\"line\">var arrob =Object.create(arraypro);</span><br><span class=\"line\">var arrFun = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">arrFun.forEach((method .index) =&gt; &#123;</span><br><span class=\"line\">  arrob[method] = function () &#123;</span><br><span class=\"line\">    var ret = arraypro[method].apply(this, arguments);</span><br><span class=\"line\">    dep.notify() // 触发试图更新</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"vue3\"><a href=\"#vue3\" class=\"headerlink\" title=\"vue3\"></a>vue3</h3><ul>\n<li>Proxy对象用于定义基本操作的自定义行为（和defineProperty类似，用法不同）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a:1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = new Proxy(ob, &#123;</span><br><span class=\"line\">  get (target, key, receiver) &#123;</span><br><span class=\"line\">    return target[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set (target, key, value, receiver) &#123;</span><br><span class=\"line\">    return Reflect.set(target, key, value)</span><br><span class=\"line\">    // return target[key] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue简易版的实现双向原理</span><br><span class=\"line\">function Vue () &#123;</span><br><span class=\"line\">  var self = this;</span><br><span class=\"line\">  this.$data = new Proxy(this.$data, &#123;</span><br><span class=\"line\">    get (target, key, receiver) &#123;</span><br><span class=\"line\">      return target[key];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set (target, key, value, receiver) &#123;</span><br><span class=\"line\">      target[key] = value;</span><br><span class=\"line\">      self.render();</span><br><span class=\"line\">      return target[key];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"proxy的其他作用？\"><a href=\"#proxy的其他作用？\" class=\"headerlink\" title=\"proxy的其他作用？\"></a>proxy的其他作用？</h4><ul>\n<li><p>校验类型<br>// 创建一个对象，对象有name和age两个属性;name是中文 age是数字且大于18;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var validtor = &#123;</span><br><span class=\"line\">  // 策略模式</span><br><span class=\"line\">  name: function (value) &#123;</span><br><span class=\"line\">    var reg = /^[\\u4E00-\\u9FA5]+$/;</span><br><span class=\"line\">    if (typeof value == &apos;string&apos; &amp;&amp; reg.test(value)) &#123;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: function (value) &#123;</span><br><span class=\"line\">    if (typeof value == &apos;number&apos; &amp;&amp; value &gt;= 18) &#123;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function preson (age, name) &#123;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  return new Proxy(this, &#123;</span><br><span class=\"line\">    get (target, key) &#123;</span><br><span class=\"line\">      return targe[key]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set (target, key, value) &#123;</span><br><span class=\"line\">      if (validtor[key](value)) &#123;</span><br><span class=\"line\">        return Reflect.set(target, key, value);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        throw new Error(key + &apos;is not right&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>真正私有属性</p>\n</li>\n</ul>\n<h4 id=\"defineProperty-和-Proxy的区别\"><a href=\"#defineProperty-和-Proxy的区别\" class=\"headerlink\" title=\"defineProperty 和 Proxy的区别\"></a>defineProperty 和 Proxy的区别</h4><ol>\n<li>defineProperty只能监听对象的某个属性，不能监听全对象；</li>\n<li>可以省去defineProperty 中的for in 循环，节省性能</li>\n<li>可以监听数组，不需要再去单独的对数组进行特异性处理；</li>\n<li>不需要借助外部变量实现存储和读取（完善了vue2中defineProperty的不优雅的地方）</li>\n<li>不会污染原对象(proxy对原对象进行代理，生成新的代理对象)</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue从改变一个数据到发生改变的过程\"><a href=\"#vue从改变一个数据到发生改变的过程\" class=\"headerlink\" title=\"vue从改变一个数据到发生改变的过程\"></a>vue从改变一个数据到发生改变的过程</h3><ul>\n<li>数据改变触发set</li>\n<li>Set部分触发notify(更新和通知) -&gt; Get部分收集依赖</li>\n<li>更改对应的虚拟dom</li>\n<li>重新render<h4 id=\"vue2\"><a href=\"#vue2\" class=\"headerlink\" title=\"vue2\"></a>vue2</h4></li>\n<li>defineProperty<br>defineProperty不仅仅用来做响应式，他的作用可以用来给对象中的属性配置操作权限。其中get和set实现了响应式原理。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ob = &#123;</span><br><span class=\"line\">  a:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\bObject.defineProperty(ob, &apos;a&apos;, &#123;</span><br><span class=\"line\">  writable:false, // 属性值是否可写</span><br><span class=\"line\">  enumerable: false, // 属性值是否可循环</span><br><span class=\"line\">  configurable: false //属性值是否可以delete</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\bObject.getOwn\bPropertyDescriptor(ob, &apos;a&apos;); // 读取对象的属性值</span><br></pre></td></tr></table></figure>\n<ul>\n<li>get &amp; set <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let _value = ob.a;</span><br><span class=\"line\">// 如果想要使用get&amp;set方法实现读取和存储，必须将属性值重新赋值给新的变量，来实现储存和中转，这也是defineProperty不优雅的一点。</span><br><span class=\"line\">// get &amp; set 必须配合return方法使用。</span><br><span class=\"line\">\bObject.defineProperty(ob, &apos;a&apos;, &#123;</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    return _value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set (newValue) &#123;</span><br><span class=\"line\">    _value = newValue</span><br><span class=\"line\">    return _value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现vue简易版的双向原理</span><br><span class=\"line\">function Vue () &#123;</span><br><span class=\"line\">  this.$data = &#123;a:1&#125;;</span><br><span class=\"line\">  this.el = document.getElementById(&apos;app&apos;);</span><br><span class=\"line\">  this.vritualDom = &apos;&apos;;</span><br><span class=\"line\">  this.observer(this.$data); //注册监听</span><br><span class=\"line\">  this.render();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 注册get和set</span><br><span class=\"line\">Vue.prototype.observer = function (obj) &#123;</span><br><span class=\"line\">  var value;</span><br><span class=\"line\">  var self = this;</span><br><span class=\"line\">  for (var key in obj) &#123;</span><br><span class=\"line\">    value = obj[key];</span><br><span class=\"line\">    if (typeof value === &apos;object&apos;) &#123;</span><br><span class=\"line\">      this.observer(value);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">        get()&#123;</span><br><span class=\"line\">          // 进行依赖收集</span><br><span class=\"line\">          // 为什么要收集依赖？</span><br><span class=\"line\">          // 数据可能只在局部位置使用，找到对应依赖，只更新依赖于变量的组件。</span><br><span class=\"line\">          return value;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set(newvalue)&#123;</span><br><span class=\"line\">          value = newvalue;</span><br><span class=\"line\">          self.render()</span><br><span class=\"line\">          return value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.prototype.render = function (obj) &#123;</span><br><span class=\"line\">  this.vritualDom = &apos;i am&apos; + this.$data.a;</span><br><span class=\"line\">  this.el.innerHTML = this.vritualDom;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"defineProperty中的get和set是对象的属性，对数组如何实现处理？\"><a href=\"#defineProperty中的get和set是对象的属性，对数组如何实现处理？\" class=\"headerlink\" title=\"defineProperty中的get和set是对象的属性，对数组如何实现处理？\"></a>defineProperty中的get和set是对象的属性，对数组如何实现处理？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 数组的双向绑定就是做了一个设计者模式；</span><br><span class=\"line\">// 取出数组的原型链并拷贝;</span><br><span class=\"line\">var arraypro = Array.prototype;</span><br><span class=\"line\">var arrob =Object.create(arraypro);</span><br><span class=\"line\">var arrFun = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">arrFun.forEach((method .index) =&gt; &#123;</span><br><span class=\"line\">  arrob[method] = function () &#123;</span><br><span class=\"line\">    var ret = arraypro[method].apply(this, arguments);</span><br><span class=\"line\">    dep.notify() // 触发试图更新</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"vue3\"><a href=\"#vue3\" class=\"headerlink\" title=\"vue3\"></a>vue3</h3><ul>\n<li>Proxy对象用于定义基本操作的自定义行为（和defineProperty类似，用法不同）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">  a:1,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = new Proxy(ob, &#123;</span><br><span class=\"line\">  get (target, key, receiver) &#123;</span><br><span class=\"line\">    return target[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set (target, key, value, receiver) &#123;</span><br><span class=\"line\">    return Reflect.set(target, key, value)</span><br><span class=\"line\">    // return target[key] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// vue简易版的实现双向原理</span><br><span class=\"line\">function Vue () &#123;</span><br><span class=\"line\">  var self = this;</span><br><span class=\"line\">  this.$data = new Proxy(this.$data, &#123;</span><br><span class=\"line\">    get (target, key, receiver) &#123;</span><br><span class=\"line\">      return target[key];</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set (target, key, value, receiver) &#123;</span><br><span class=\"line\">      target[key] = value;</span><br><span class=\"line\">      self.render();</span><br><span class=\"line\">      return target[key];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"proxy的其他作用？\"><a href=\"#proxy的其他作用？\" class=\"headerlink\" title=\"proxy的其他作用？\"></a>proxy的其他作用？</h4><ul>\n<li><p>校验类型<br>// 创建一个对象，对象有name和age两个属性;name是中文 age是数字且大于18;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var validtor = &#123;</span><br><span class=\"line\">  // 策略模式</span><br><span class=\"line\">  name: function (value) &#123;</span><br><span class=\"line\">    var reg = /^[\\u4E00-\\u9FA5]+$/;</span><br><span class=\"line\">    if (typeof value == &apos;string&apos; &amp;&amp; reg.test(value)) &#123;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  age: function (value) &#123;</span><br><span class=\"line\">    if (typeof value == &apos;number&apos; &amp;&amp; value &gt;= 18) &#123;</span><br><span class=\"line\">      return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function preson (age, name) &#123;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  return new Proxy(this, &#123;</span><br><span class=\"line\">    get (target, key) &#123;</span><br><span class=\"line\">      return targe[key]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set (target, key, value) &#123;</span><br><span class=\"line\">      if (validtor[key](value)) &#123;</span><br><span class=\"line\">        return Reflect.set(target, key, value);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        throw new Error(key + &apos;is not right&apos;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>真正私有属性</p>\n</li>\n</ul>\n<h4 id=\"defineProperty-和-Proxy的区别\"><a href=\"#defineProperty-和-Proxy的区别\" class=\"headerlink\" title=\"defineProperty 和 Proxy的区别\"></a>defineProperty 和 Proxy的区别</h4><ol>\n<li>defineProperty只能监听对象的某个属性，不能监听全对象；</li>\n<li>可以省去defineProperty 中的for in 循环，节省性能</li>\n<li>可以监听数组，不需要再去单独的对数组进行特异性处理；</li>\n<li>不需要借助外部变量实现存储和读取（完善了vue2中defineProperty的不优雅的地方）</li>\n<li>不会污染原对象(proxy对原对象进行代理，生成新的代理对象)</li>\n</ol>\n"},{"title":"使用react搭建组件库--radio组件","date":"2020-07-27T09:17:30.000Z","_content":"\n## 前言\n你应该需要：[使用react搭建组件库：react+typescript+storybook]([https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc)\n)\n## 一、 安装依赖\n在组件中使用 `rc-checkbox`： [react rc-checkbox component](https://www.npmjs.com/package/rc-checkbox)\n\n```\nnpm install rc-checkbox\n```\n## 二、 编写组件\n* 新建 `src/components/Radio/radio.tsx`\n```\nimport * as React from 'react';\nimport RcCheckbox from 'rc-checkbox';\nimport classNames from 'classnames';\nimport { RadioProps, RadioChangeEvent } from './interface';\nimport { ConfigContext } from '../config-provider';\nimport RadioGroupContext from './context';\nimport { composeRef } from '../_util/ref';\nconst InternalRadio: React.ForwardRefRenderFunction<unknown, RadioProps> = (props, ref) => {\n  const context = React.useContext(RadioGroupContext);\n  const { getPrefixCls, direction } = React.useContext(ConfigContext);\n  const innerRef = React.useRef<HTMLElement>();\n  const mergedRef = composeRef(ref, innerRef);\n  \n  const onChange = (e: RadioChangeEvent) => {\n    if (props.onChange) {\n      props.onChange(e);\n    }\n    if (context?.onChange) {\n      context.onChange(e);\n    }\n  };\n\n  const { prefixCls: customizePrefixCls, className, children, style, ...restProps } = props;\n  const prefixCls = getPrefixCls('radio', customizePrefixCls);\n  console.log(prefixCls, customizePrefixCls)\n  const radioProps: RadioProps = { ...restProps };\n  if (context) {\n    radioProps.name = context.name;\n    radioProps.onChange = onChange;\n    radioProps.checked = props.value === context.value;\n    radioProps.disabled = props.disabled || context.disabled;\n  }\n  const wrapperClassString = classNames(className, {\n    [`${prefixCls}-wrapper`]: true,\n    [`${prefixCls}-wrapper-checked`]: radioProps.checked,\n    [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,\n    [`${prefixCls}-wrapper-rtl`]: direction === 'rtl',\n  });\n  return (\n    <label\n      className={wrapperClassString}\n      style={style}\n      onMouseEnter={props.onMouseEnter}\n      onMouseLeave={props.onMouseLeave}\n    >\n      <RcCheckbox {...radioProps} prefixCls={prefixCls as string} ref={mergedRef as any} />\n      {children !== undefined ? <span>{children}</span> : null}\n    </label>\n  );\n}\nconst Radio = React.forwardRef<unknown, RadioProps>(InternalRadio);\nRadio.displayName = 'Radio';\n\nRadio.defaultProps = {\n  type: 'radio',\n};\n\nexport default Radio;\n```\n* 新建 src/components/Radio/interface.tsx\n```\nexport interface AbstractCheckboxProps<T> {\n  prefixCls?: string;\n  className?: string;\n  defaultChecked?: boolean;\n  checked?: boolean;\n  style?: React.CSSProperties;\n  disabled?: boolean;\n  onChange?: (e: T) => void;\n  onClick?: React.MouseEventHandler<HTMLElement>;\n  onMouseEnter?: React.MouseEventHandler<HTMLElement>;\n  onMouseLeave?: React.MouseEventHandler<HTMLElement>;\n  onKeyPress?: React.KeyboardEventHandler<HTMLElement>;\n  onKeyDown?: React.KeyboardEventHandler<HTMLElement>;\n  value?: any;\n  tabIndex?: number;\n  name?: string;\n  children?: React.ReactNode;\n  id?: string;\n  autoFocus?: boolean;\n  type?: string;\n}\nexport type RadioProps = AbstractCheckboxProps<RadioChangeEvent>;\nexport interface RadioChangeEventTarget extends RadioProps {\n  checked: boolean;\n}\nexport interface RadioChangeEvent {\n  target: RadioChangeEventTarget;\n  stopPropagation: () => void;\n  preventDefault: () => void;\n  nativeEvent: MouseEvent;\n}\n\nexport interface RadioGroupContextProps {\n  onChange: (e: RadioChangeEvent) => void;\n  value: any;\n  disabled?: boolean;\n  name?: string;\n}\n```\n* 新建 src/components/config-provider/context.tsx: 为组件库提供共享状态\n```\nimport * as React from 'react';\nexport interface ConfigConsumerProps {\n  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) => string;\n  direction?: 'ltr' | 'rtl';\n}\nexport const ConfigContext = React.createContext<ConfigConsumerProps>({\n  // We provide a default function for Context without provider\n  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) => {\n    if (customizePrefixCls) return customizePrefixCls;\n\n    return suffixCls ? `echo-${suffixCls}` : 'echo';\n  },\n});\n\nexport const ConfigConsumer = ConfigContext.Consumer;\n```\n\n* 新建 src/components/config-provider/index.tsx: 为组件库提供共享状态\n```\nimport { ConfigContext, ConfigConsumer } from './context';\nexport { ConfigContext, ConfigConsumer};\n```\n* 新建 src/components/config-provider/SizeContext.tsx: 为组件库提供大小共享状态\n```\nimport * as React from 'react';\nexport type SizeType = 'small' | 'middle' | 'large' | undefined;\nconst SizeContext = React.createContext<SizeType>(undefined);\nexport default SizeContext;\n```\n* 新建 src/components/Radio/context.tsx: 为Radio相关组件提供共享状态\n```\nimport * as React from 'react';\nimport { RadioGroupContextProps } from './interface';\nconst RadioGroupContext = React.createContext<RadioGroupContextProps | null>(null);\nexport const RadioGroupContextProvider = RadioGroupContext.Provider;\nexport default RadioGroupContext;\n```\n* 新建 src/components/_util/ref.tsx:组件库通用方法\n```\nimport * as React from 'react';\n\nexport function fillRef<T>(ref: React.Ref<T>, node: T) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else if (typeof ref === 'object' && ref && 'current' in ref) {\n    (ref as any).current = node;\n  }\n}\n\nexport function composeRef<T>(...refs: React.Ref<T>[]): React.Ref<T> {\n  return (node: T) => {\n    refs.forEach(ref => {\n      fillRef(ref, node);\n    });\n  };\n}\n```\n* 新建 src/components/Radio/index.tsx\n\n ```\nimport Radio from \"./radio\";\nexport default Radio;\n```\n* 新建 src/components/Radio/_rtl.scss\n```\n@import \"../../styles/variables/radio\";\n\n\n$radio-prefix-cls: 'echo-radio';\n$radio-group-prefix-cls: '#{$radio-prefix-cls}-group';\n$radio-prefix-cls-button-wrapper: '#{$radio-prefix-cls}-button-wrapper';\n.#{$radio-group-prefix-cls}{\n  &-rtl {\n    direction: rtl;\n  }\n}\n\n// 一般状态\n.#{$radio-prefix-cls}-wrapper {\n  &-rtl {\n    margin-right: 0;\n    margin-left: $radio-wrapper-margin-right;\n    direction: rtl;\n  }\n}\n\n.#{$radio-prefix-cls-button-wrapper} {\n  &-rtl {\n    border-right-width: 0;\n    border-left-width: $border-width-base;\n  }\n\n  &:not(:first-child) {\n    &::before {\n      .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n        right: -1px;\n        left: 0;\n      }\n    }\n  }\n\n  &:first-child {\n    .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n      border-right: $border-width-base $border-style-base $border-color-base;\n      border-radius: 0 $border-radius-base $border-radius-base 0;\n    }\n    .#{$radio-prefix-cls-button-wrapper}-checked:not([class*=\"'#{$radio-prefix-cls}-button-wrapper-disabled'\"]) & {\n      border-right-color:lighten($primary, 10%);\n    }\n  }\n\n  &:last-child {\n    .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n      border-radius: $border-radius-base 0 0 $border-radius-base;\n    }\n  }\n\n  &-disabled {\n    &:first-child {\n      .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n        border-right-color: $border-color-base;\n      }\n    }\n  }\n}\n\n\n```\n* 新建 src/components/Icon/_style.scss\n```\n@import \"../../styles/variables/radio\";\n@import \"./rtl\";\n\n$radio-prefix-cls: 'echo-radio';\n$radio-group-prefix-cls: '#{$radio-prefix-cls}-group';\n$radio-inner-prefix-cls: '#{radio-prefix-cls}-inner';\n$radio-duration: 0.3s;\n$radio-focus-shadow: 0 0 0 3px fade($primary, 8%);\n$radio-button-focus-shadow: $radio-focus-shadow;\n\n.#{$radio-group-prefix-cls} {\n  @include reset-component;\n\n  display: inline-block;\n  font-size: 0;\n  line-height: unset;\n\n  .echo-badge-count {\n    z-index: 1;\n  }\n\n  .echo-badge:not(:first-child) .#{$radio-prefix-cls}-button-wrapper {\n    border-left: none;\n  }\n}\n\n// 一般状态\n.#{$radio-prefix-cls}-wrapper {\n  @include reset-component;\n\n  position: relative;\n  display: inline-block;\n  margin-right: $radio-wrapper-margin-right;\n  white-space: nowrap;\n  cursor: pointer;\n}\n\n.#{$radio-prefix-cls} {\n  @include reset-component;\n\n  position: relative;\n  top: -3px;\n  display: inline-block;\n  line-height: 1;\n  white-space: nowrap;\n  vertical-align: sub;\n  outline: none;\n  cursor: pointer;\n\n  .#{$radio-prefix-cls}-wrapper:hover &,\n  &:hover .#{$radio-inner-prefix-cls},\n  &-input:focus + .#{$radio-inner-prefix-cls} {\n    border-color: $radio-dot-color;\n  }\n\n  &-input:focus + .#{$radio-inner-prefix-cls} {\n    box-shadow: $radio-focus-shadow;\n  }\n\n  &-checked::after {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    border: 1px solid $radio-dot-color;\n    border-radius: 50%;\n    visibility: hidden;\n    animation: antRadioEffect 0.36s ease-in-out;\n    animation-fill-mode: both;\n    content: '';\n  }\n\n  &:hover::after,\n  .#{$radio-prefix-cls}-wrapper:hover &::after {\n    visibility: visible;\n  }\n\n  &-inner {\n    &::after {\n      $radio-dot-size: $radio-size - 8px;\n\n      position: absolute;\n      top: ($radio-size - $radio-dot-size) / 2 - 1px;\n      left: ($radio-size - $radio-dot-size) / 2 - 1px;\n      display: table;\n      width: $radio-dot-size;\n      height: $radio-dot-size;\n      background-color: $radio-dot-color;\n      border-top: 0;\n      border-left: 0;\n      border-radius: $radio-dot-size;\n      transform: scale(0);\n      opacity: 0;\n      transition: all $radio-duration $ease-in-out-circ;\n      content: ' ';\n    }\n  }\n}\n\n// 选中状态\n.#{$radio-prefix-cls}-checked {\n  .#{$radio-inner-prefix-cls} {\n    border-color: $radio-dot-color;\n    &::after {\n      transform: scale(1);\n      opacity: 1;\n      transition: all $radio-duration $ease-in-out-circ;\n    }\n  }\n}\n\n.#{$radio-prefix-cls}-disabled {\n  .#{$radio-inner-prefix-cls} {\n    background-color: $disabled-color;\n    border-color: $border-color-base !important;\n    cursor: not-allowed;\n    &::after {\n      background-color: $radio-dot-disabled-color;\n    }\n  }\n\n  .#{$radio-prefix-cls}-input {\n    cursor: not-allowed;\n  }\n\n  & + span {\n    color: $disabled-color;\n    cursor: not-allowed;\n  }\n}\n\nspan.#{$radio-prefix-cls} + * {\n  padding-right: 8px;\n  padding-left: 4px;\n}\n\n.#{$radio-prefix-cls}-button-wrapper {\n  position: relative;\n  display: inline-block;\n  height: $height-base;\n  margin: 0;\n  padding: 0 $padding-md - 1px;\n  color: $radio-button-color;\n  font-size: $font-size-base;\n  line-height: $height-base - 2px;\n  background: $radio-button-bg;\n  border: $border-width-base $border-style-base $border-color-base;\n  // strange align fix for chrome but works\n  // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif\n  border-top-width: $border-width-base + 0.02px;\n  border-left-width: 0;\n  cursor: pointer;\n  transition: color 0.3s, background 0.3s, border-color 0.3s, box-shadow 0.3s;\n\n  a {\n    color: $radio-button-color;\n  }\n\n  > .#{$radio-prefix-cls}-button {\n    display: block;\n    width: 0;\n    height: 0;\n    margin-left: 0;\n  }\n\n  .#{$radio-group-prefix-cls}-large & {\n    height: $height-lg;\n    font-size: $font-size-lg;\n    line-height: $height-lg - 2px;\n  }\n\n  .#{$radio-group-prefix-cls}-small & {\n    height: $height-sm;\n    padding: 0 $control-padding-horizontal-sm - 1px;\n    line-height: $height-sm - 2px;\n  }\n\n  &:not(:first-child) {\n    &::before {\n      position: absolute;\n      top: $border-width-base * -1;\n      left: -1px;\n      display: block;\n      box-sizing: content-box;\n      width: 1px;\n      height: 100%;\n      padding: $border-width-base 0;\n      background-color: $border-color-base;\n      transition: background-color 0.3s;\n      content: '';\n    }\n  }\n\n  &:first-child {\n    border-left: $border-width-base $border-style-base $border-color-base;\n    border-radius: $border-radius-base 0 0 $border-radius-base;\n  }\n\n  &:last-child {\n    border-radius: 0 $border-radius-base $border-radius-base 0;\n  }\n\n  &:first-child:last-child {\n    border-radius: $border-radius-base;\n  }\n\n  &:hover {\n    position: relative;\n    color: $radio-dot-color;\n  }\n\n  &:focus-within {\n    box-shadow: $radio-button-focus-shadow;\n  }\n\n  .#{$radio-prefix-cls}-inner,\n  input[type='checkbox'],\n  input[type='radio'] {\n    width: 0;\n    height: 0;\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  &-checked:not(&-disabled) {\n    z-index: 1;\n    color: $radio-dot-color;\n    background: $radio-button-checked-bg;\n    border-color: $radio-dot-color;\n\n    &::before {\n      background-color: $radio-dot-color;\n    }\n\n    &:first-child {\n      border-color: $radio-dot-color;\n    }\n\n    &:hover {\n      color: $radio-button-hover-color;\n      border-color: $radio-button-hover-color;\n      &::before {\n        background-color: $radio-button-hover-color;\n      }\n    }\n\n    &:active {\n      color: $radio-button-active-color;\n      border-color: $radio-button-active-color;\n      &::before {\n        background-color: $radio-button-active-color;\n      }\n    }\n\n    &:focus-within {\n      box-shadow: $radio-button-focus-shadow;\n    }\n  }\n\n  .#{$radio-group-prefix-cls}-solid &-checked:not(&-disabled) {\n    color: $radio-solid-checked-color;\n    background: $radio-dot-color;\n    border-color: $radio-dot-color;\n    &:hover {\n      color: $radio-solid-checked-color;\n      background: $radio-button-hover-color;\n      border-color: $radio-button-hover-color;\n    }\n    &:active {\n      color: $radio-solid-checked-color;\n      background: $radio-button-active-color;\n      border-color: $radio-button-active-color;\n    }\n    &:focus-within {\n      box-shadow: $radio-button-focus-shadow;\n    }\n  }\n\n  &-disabled {\n    color: $disabled-color;\n    background-color: $disabled-bg;;\n    border-color: $border-color-base;\n    cursor: not-allowed;\n\n    &:first-child,\n    &:hover {\n      color: $disabled-color;\n      background-color: $disabled-bg;;\n      border-color: $border-color-base;\n    }\n    &:first-child {\n      border-left-color: $border-color-base;\n    }\n  }\n\n  &-disabled &-checked {\n    color: $radio-disabled-button-checked-color;\n    background-color: $radio-disabled-button-checked-bg;\n    border-color: $border-color-base;\n    box-shadow: none;\n  }\n}\n\n@keyframes antRadioEffect {\n  0% {\n    transform: scale(1);\n    opacity: 0.5;\n  }\n  100% {\n    transform: scale(1.6);\n    opacity: 0;\n  }\n}\n\n// Firefox hack\n@supports (-moz-appearance: meterbar) and (background-blend-mode: difference, normal) {\n  .#{$radio-prefix-cls} {\n    vertical-align: text-bottom;\n  }\n}\n\n```\n\n* 新建 styles/variables/_radio.scss文件\n```\n@import \"./common\";\n// $font-size-base\n$radio-wrapper-margin-right: 8px;\n```\n* 新建 src/styles/index.scss文件\n```\n// radio样式\n@import \"../components/Radio/style\";\n```\n* 接下来[[Typescript] 为第三方库添加声明文件 .d.ts](https://www.jianshu.com/p/1e262b487f26)\n* 新建src/typings/index.d.ts文件\n```\n/// <reference path=\"custom-typings.d.ts\" />\n```\n* 新建src/typings/custom-typings.d.ts文件\n```\ndeclare module 'rc-checkbox';\n\n```\n* 修改App.tsx文件\n```\n// 增加\nimport Radio from \"./components/Radio/radio\";\n<Radio name=\"111\">Radio</Radio>\n<Radio name=\"111\" disabled={true}>Radio2</Radio>\n```\n* 修改index.tsx文件\n```\nexport { default as Radio } from \"./components/Radio\";\n```\n## 三、 运行项目\n 执行命令\n```\n$ npm start\n```\n访问项目 可以看到Radio组件成功了！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-7fc5a5e3af91ee81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 四、 单元测试\n新建src/Radio/radio.test.tsx文件·\n```\nimport React from 'react';\nimport { mount, render } from 'enzyme';\nimport Radio, { Group, Button } from '..';\nimport focusTest from '../../../tests/shared/focusTest';\nimport mountTest from '../../../tests/shared/mountTest';\nimport rtlTest from '../../../tests/shared/rtlTest';\n\ndescribe('Radio', () => {\n  focusTest(Radio, { refFocus: true });\n  mountTest(Radio);\n  mountTest(Group);\n  mountTest(Button);\n\n  rtlTest(Radio);\n  rtlTest(Group);\n  rtlTest(Button);\n\n  it('should render correctly', () => {\n    const wrapper = render(<Radio className=\"customized\">Test</Radio>);\n    expect(wrapper).toMatchSnapshot();\n  });\n\n  it('responses hover events', () => {\n    const onMouseEnter = jest.fn();\n    const onMouseLeave = jest.fn();\n\n    const wrapper = mount(<Radio onMouseEnter={onMouseEnter} onMouseLeave={onMouseLeave} />);\n\n    wrapper.find('label').simulate('mouseenter');\n    expect(onMouseEnter).toHaveBeenCalled();\n\n    wrapper.find('label').simulate('mouseleave');\n    expect(onMouseLeave).toHaveBeenCalled();\n  });\n});\n\n```\n执行命令\n```\n$ npm test\n```\n可以看到单元测试成功通过！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-44fe42fa111d9409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 五、编写storybook文档\n* 新建`src/Radio/radio.stories.tsx`文件\n```\nimport React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\n\nimport Radio from './radio'\n\nconst defaultRadio = () => (\n    <div>\n        <Radio onClick={action('default Radio')}>default radio</Radio>\n    </div>\n)\n\nconst radioWithDisabled = () => (\n    <div>\n        <Radio onClick={action('disabled radio')}   disabled={true}>disabled radio</Radio>\n        <Radio onClick={action('unDisabled radio')}  >unDisabled radio</Radio>\n    </div>\n)\n\n\nstoriesOf('Radio 按钮', module)\n    .addParameters({\n        info: {\n            text: `\n        ## 引用方法\n        ~~~js\n        import {Radio} from 'echo-rui\n        ~~~\n        `\n        }\n    })\n    .add('默认 Radio', defaultRadio)\n    .add('禁用的 Radio',radioWithDisabled)\n```\n* 执行命令\n```\n$ npm run storybook\n```\n浏览器打开http://localhost:9009/,可以看到组件库文档生成了。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-88eb962e94583778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 六、 发布到npm\n ✅ ✅ ✅ ✅ ✅\n\n 大功告成✌️✌️✌️\n\n\n\n","source":"_posts/reactCom2.md","raw":"---\ntitle: 使用react搭建组件库--radio组件\ndate: 2020-07-27 17:17:30\ntags: React\n---\n\n## 前言\n你应该需要：[使用react搭建组件库：react+typescript+storybook]([https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc)\n)\n## 一、 安装依赖\n在组件中使用 `rc-checkbox`： [react rc-checkbox component](https://www.npmjs.com/package/rc-checkbox)\n\n```\nnpm install rc-checkbox\n```\n## 二、 编写组件\n* 新建 `src/components/Radio/radio.tsx`\n```\nimport * as React from 'react';\nimport RcCheckbox from 'rc-checkbox';\nimport classNames from 'classnames';\nimport { RadioProps, RadioChangeEvent } from './interface';\nimport { ConfigContext } from '../config-provider';\nimport RadioGroupContext from './context';\nimport { composeRef } from '../_util/ref';\nconst InternalRadio: React.ForwardRefRenderFunction<unknown, RadioProps> = (props, ref) => {\n  const context = React.useContext(RadioGroupContext);\n  const { getPrefixCls, direction } = React.useContext(ConfigContext);\n  const innerRef = React.useRef<HTMLElement>();\n  const mergedRef = composeRef(ref, innerRef);\n  \n  const onChange = (e: RadioChangeEvent) => {\n    if (props.onChange) {\n      props.onChange(e);\n    }\n    if (context?.onChange) {\n      context.onChange(e);\n    }\n  };\n\n  const { prefixCls: customizePrefixCls, className, children, style, ...restProps } = props;\n  const prefixCls = getPrefixCls('radio', customizePrefixCls);\n  console.log(prefixCls, customizePrefixCls)\n  const radioProps: RadioProps = { ...restProps };\n  if (context) {\n    radioProps.name = context.name;\n    radioProps.onChange = onChange;\n    radioProps.checked = props.value === context.value;\n    radioProps.disabled = props.disabled || context.disabled;\n  }\n  const wrapperClassString = classNames(className, {\n    [`${prefixCls}-wrapper`]: true,\n    [`${prefixCls}-wrapper-checked`]: radioProps.checked,\n    [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,\n    [`${prefixCls}-wrapper-rtl`]: direction === 'rtl',\n  });\n  return (\n    <label\n      className={wrapperClassString}\n      style={style}\n      onMouseEnter={props.onMouseEnter}\n      onMouseLeave={props.onMouseLeave}\n    >\n      <RcCheckbox {...radioProps} prefixCls={prefixCls as string} ref={mergedRef as any} />\n      {children !== undefined ? <span>{children}</span> : null}\n    </label>\n  );\n}\nconst Radio = React.forwardRef<unknown, RadioProps>(InternalRadio);\nRadio.displayName = 'Radio';\n\nRadio.defaultProps = {\n  type: 'radio',\n};\n\nexport default Radio;\n```\n* 新建 src/components/Radio/interface.tsx\n```\nexport interface AbstractCheckboxProps<T> {\n  prefixCls?: string;\n  className?: string;\n  defaultChecked?: boolean;\n  checked?: boolean;\n  style?: React.CSSProperties;\n  disabled?: boolean;\n  onChange?: (e: T) => void;\n  onClick?: React.MouseEventHandler<HTMLElement>;\n  onMouseEnter?: React.MouseEventHandler<HTMLElement>;\n  onMouseLeave?: React.MouseEventHandler<HTMLElement>;\n  onKeyPress?: React.KeyboardEventHandler<HTMLElement>;\n  onKeyDown?: React.KeyboardEventHandler<HTMLElement>;\n  value?: any;\n  tabIndex?: number;\n  name?: string;\n  children?: React.ReactNode;\n  id?: string;\n  autoFocus?: boolean;\n  type?: string;\n}\nexport type RadioProps = AbstractCheckboxProps<RadioChangeEvent>;\nexport interface RadioChangeEventTarget extends RadioProps {\n  checked: boolean;\n}\nexport interface RadioChangeEvent {\n  target: RadioChangeEventTarget;\n  stopPropagation: () => void;\n  preventDefault: () => void;\n  nativeEvent: MouseEvent;\n}\n\nexport interface RadioGroupContextProps {\n  onChange: (e: RadioChangeEvent) => void;\n  value: any;\n  disabled?: boolean;\n  name?: string;\n}\n```\n* 新建 src/components/config-provider/context.tsx: 为组件库提供共享状态\n```\nimport * as React from 'react';\nexport interface ConfigConsumerProps {\n  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) => string;\n  direction?: 'ltr' | 'rtl';\n}\nexport const ConfigContext = React.createContext<ConfigConsumerProps>({\n  // We provide a default function for Context without provider\n  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) => {\n    if (customizePrefixCls) return customizePrefixCls;\n\n    return suffixCls ? `echo-${suffixCls}` : 'echo';\n  },\n});\n\nexport const ConfigConsumer = ConfigContext.Consumer;\n```\n\n* 新建 src/components/config-provider/index.tsx: 为组件库提供共享状态\n```\nimport { ConfigContext, ConfigConsumer } from './context';\nexport { ConfigContext, ConfigConsumer};\n```\n* 新建 src/components/config-provider/SizeContext.tsx: 为组件库提供大小共享状态\n```\nimport * as React from 'react';\nexport type SizeType = 'small' | 'middle' | 'large' | undefined;\nconst SizeContext = React.createContext<SizeType>(undefined);\nexport default SizeContext;\n```\n* 新建 src/components/Radio/context.tsx: 为Radio相关组件提供共享状态\n```\nimport * as React from 'react';\nimport { RadioGroupContextProps } from './interface';\nconst RadioGroupContext = React.createContext<RadioGroupContextProps | null>(null);\nexport const RadioGroupContextProvider = RadioGroupContext.Provider;\nexport default RadioGroupContext;\n```\n* 新建 src/components/_util/ref.tsx:组件库通用方法\n```\nimport * as React from 'react';\n\nexport function fillRef<T>(ref: React.Ref<T>, node: T) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else if (typeof ref === 'object' && ref && 'current' in ref) {\n    (ref as any).current = node;\n  }\n}\n\nexport function composeRef<T>(...refs: React.Ref<T>[]): React.Ref<T> {\n  return (node: T) => {\n    refs.forEach(ref => {\n      fillRef(ref, node);\n    });\n  };\n}\n```\n* 新建 src/components/Radio/index.tsx\n\n ```\nimport Radio from \"./radio\";\nexport default Radio;\n```\n* 新建 src/components/Radio/_rtl.scss\n```\n@import \"../../styles/variables/radio\";\n\n\n$radio-prefix-cls: 'echo-radio';\n$radio-group-prefix-cls: '#{$radio-prefix-cls}-group';\n$radio-prefix-cls-button-wrapper: '#{$radio-prefix-cls}-button-wrapper';\n.#{$radio-group-prefix-cls}{\n  &-rtl {\n    direction: rtl;\n  }\n}\n\n// 一般状态\n.#{$radio-prefix-cls}-wrapper {\n  &-rtl {\n    margin-right: 0;\n    margin-left: $radio-wrapper-margin-right;\n    direction: rtl;\n  }\n}\n\n.#{$radio-prefix-cls-button-wrapper} {\n  &-rtl {\n    border-right-width: 0;\n    border-left-width: $border-width-base;\n  }\n\n  &:not(:first-child) {\n    &::before {\n      .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n        right: -1px;\n        left: 0;\n      }\n    }\n  }\n\n  &:first-child {\n    .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n      border-right: $border-width-base $border-style-base $border-color-base;\n      border-radius: 0 $border-radius-base $border-radius-base 0;\n    }\n    .#{$radio-prefix-cls-button-wrapper}-checked:not([class*=\"'#{$radio-prefix-cls}-button-wrapper-disabled'\"]) & {\n      border-right-color:lighten($primary, 10%);\n    }\n  }\n\n  &:last-child {\n    .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n      border-radius: $border-radius-base 0 0 $border-radius-base;\n    }\n  }\n\n  &-disabled {\n    &:first-child {\n      .#{$radio-prefix-cls-button-wrapper}.#{$radio-prefix-cls-button-wrapper}-rtl & {\n        border-right-color: $border-color-base;\n      }\n    }\n  }\n}\n\n\n```\n* 新建 src/components/Icon/_style.scss\n```\n@import \"../../styles/variables/radio\";\n@import \"./rtl\";\n\n$radio-prefix-cls: 'echo-radio';\n$radio-group-prefix-cls: '#{$radio-prefix-cls}-group';\n$radio-inner-prefix-cls: '#{radio-prefix-cls}-inner';\n$radio-duration: 0.3s;\n$radio-focus-shadow: 0 0 0 3px fade($primary, 8%);\n$radio-button-focus-shadow: $radio-focus-shadow;\n\n.#{$radio-group-prefix-cls} {\n  @include reset-component;\n\n  display: inline-block;\n  font-size: 0;\n  line-height: unset;\n\n  .echo-badge-count {\n    z-index: 1;\n  }\n\n  .echo-badge:not(:first-child) .#{$radio-prefix-cls}-button-wrapper {\n    border-left: none;\n  }\n}\n\n// 一般状态\n.#{$radio-prefix-cls}-wrapper {\n  @include reset-component;\n\n  position: relative;\n  display: inline-block;\n  margin-right: $radio-wrapper-margin-right;\n  white-space: nowrap;\n  cursor: pointer;\n}\n\n.#{$radio-prefix-cls} {\n  @include reset-component;\n\n  position: relative;\n  top: -3px;\n  display: inline-block;\n  line-height: 1;\n  white-space: nowrap;\n  vertical-align: sub;\n  outline: none;\n  cursor: pointer;\n\n  .#{$radio-prefix-cls}-wrapper:hover &,\n  &:hover .#{$radio-inner-prefix-cls},\n  &-input:focus + .#{$radio-inner-prefix-cls} {\n    border-color: $radio-dot-color;\n  }\n\n  &-input:focus + .#{$radio-inner-prefix-cls} {\n    box-shadow: $radio-focus-shadow;\n  }\n\n  &-checked::after {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    border: 1px solid $radio-dot-color;\n    border-radius: 50%;\n    visibility: hidden;\n    animation: antRadioEffect 0.36s ease-in-out;\n    animation-fill-mode: both;\n    content: '';\n  }\n\n  &:hover::after,\n  .#{$radio-prefix-cls}-wrapper:hover &::after {\n    visibility: visible;\n  }\n\n  &-inner {\n    &::after {\n      $radio-dot-size: $radio-size - 8px;\n\n      position: absolute;\n      top: ($radio-size - $radio-dot-size) / 2 - 1px;\n      left: ($radio-size - $radio-dot-size) / 2 - 1px;\n      display: table;\n      width: $radio-dot-size;\n      height: $radio-dot-size;\n      background-color: $radio-dot-color;\n      border-top: 0;\n      border-left: 0;\n      border-radius: $radio-dot-size;\n      transform: scale(0);\n      opacity: 0;\n      transition: all $radio-duration $ease-in-out-circ;\n      content: ' ';\n    }\n  }\n}\n\n// 选中状态\n.#{$radio-prefix-cls}-checked {\n  .#{$radio-inner-prefix-cls} {\n    border-color: $radio-dot-color;\n    &::after {\n      transform: scale(1);\n      opacity: 1;\n      transition: all $radio-duration $ease-in-out-circ;\n    }\n  }\n}\n\n.#{$radio-prefix-cls}-disabled {\n  .#{$radio-inner-prefix-cls} {\n    background-color: $disabled-color;\n    border-color: $border-color-base !important;\n    cursor: not-allowed;\n    &::after {\n      background-color: $radio-dot-disabled-color;\n    }\n  }\n\n  .#{$radio-prefix-cls}-input {\n    cursor: not-allowed;\n  }\n\n  & + span {\n    color: $disabled-color;\n    cursor: not-allowed;\n  }\n}\n\nspan.#{$radio-prefix-cls} + * {\n  padding-right: 8px;\n  padding-left: 4px;\n}\n\n.#{$radio-prefix-cls}-button-wrapper {\n  position: relative;\n  display: inline-block;\n  height: $height-base;\n  margin: 0;\n  padding: 0 $padding-md - 1px;\n  color: $radio-button-color;\n  font-size: $font-size-base;\n  line-height: $height-base - 2px;\n  background: $radio-button-bg;\n  border: $border-width-base $border-style-base $border-color-base;\n  // strange align fix for chrome but works\n  // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif\n  border-top-width: $border-width-base + 0.02px;\n  border-left-width: 0;\n  cursor: pointer;\n  transition: color 0.3s, background 0.3s, border-color 0.3s, box-shadow 0.3s;\n\n  a {\n    color: $radio-button-color;\n  }\n\n  > .#{$radio-prefix-cls}-button {\n    display: block;\n    width: 0;\n    height: 0;\n    margin-left: 0;\n  }\n\n  .#{$radio-group-prefix-cls}-large & {\n    height: $height-lg;\n    font-size: $font-size-lg;\n    line-height: $height-lg - 2px;\n  }\n\n  .#{$radio-group-prefix-cls}-small & {\n    height: $height-sm;\n    padding: 0 $control-padding-horizontal-sm - 1px;\n    line-height: $height-sm - 2px;\n  }\n\n  &:not(:first-child) {\n    &::before {\n      position: absolute;\n      top: $border-width-base * -1;\n      left: -1px;\n      display: block;\n      box-sizing: content-box;\n      width: 1px;\n      height: 100%;\n      padding: $border-width-base 0;\n      background-color: $border-color-base;\n      transition: background-color 0.3s;\n      content: '';\n    }\n  }\n\n  &:first-child {\n    border-left: $border-width-base $border-style-base $border-color-base;\n    border-radius: $border-radius-base 0 0 $border-radius-base;\n  }\n\n  &:last-child {\n    border-radius: 0 $border-radius-base $border-radius-base 0;\n  }\n\n  &:first-child:last-child {\n    border-radius: $border-radius-base;\n  }\n\n  &:hover {\n    position: relative;\n    color: $radio-dot-color;\n  }\n\n  &:focus-within {\n    box-shadow: $radio-button-focus-shadow;\n  }\n\n  .#{$radio-prefix-cls}-inner,\n  input[type='checkbox'],\n  input[type='radio'] {\n    width: 0;\n    height: 0;\n    opacity: 0;\n    pointer-events: none;\n  }\n\n  &-checked:not(&-disabled) {\n    z-index: 1;\n    color: $radio-dot-color;\n    background: $radio-button-checked-bg;\n    border-color: $radio-dot-color;\n\n    &::before {\n      background-color: $radio-dot-color;\n    }\n\n    &:first-child {\n      border-color: $radio-dot-color;\n    }\n\n    &:hover {\n      color: $radio-button-hover-color;\n      border-color: $radio-button-hover-color;\n      &::before {\n        background-color: $radio-button-hover-color;\n      }\n    }\n\n    &:active {\n      color: $radio-button-active-color;\n      border-color: $radio-button-active-color;\n      &::before {\n        background-color: $radio-button-active-color;\n      }\n    }\n\n    &:focus-within {\n      box-shadow: $radio-button-focus-shadow;\n    }\n  }\n\n  .#{$radio-group-prefix-cls}-solid &-checked:not(&-disabled) {\n    color: $radio-solid-checked-color;\n    background: $radio-dot-color;\n    border-color: $radio-dot-color;\n    &:hover {\n      color: $radio-solid-checked-color;\n      background: $radio-button-hover-color;\n      border-color: $radio-button-hover-color;\n    }\n    &:active {\n      color: $radio-solid-checked-color;\n      background: $radio-button-active-color;\n      border-color: $radio-button-active-color;\n    }\n    &:focus-within {\n      box-shadow: $radio-button-focus-shadow;\n    }\n  }\n\n  &-disabled {\n    color: $disabled-color;\n    background-color: $disabled-bg;;\n    border-color: $border-color-base;\n    cursor: not-allowed;\n\n    &:first-child,\n    &:hover {\n      color: $disabled-color;\n      background-color: $disabled-bg;;\n      border-color: $border-color-base;\n    }\n    &:first-child {\n      border-left-color: $border-color-base;\n    }\n  }\n\n  &-disabled &-checked {\n    color: $radio-disabled-button-checked-color;\n    background-color: $radio-disabled-button-checked-bg;\n    border-color: $border-color-base;\n    box-shadow: none;\n  }\n}\n\n@keyframes antRadioEffect {\n  0% {\n    transform: scale(1);\n    opacity: 0.5;\n  }\n  100% {\n    transform: scale(1.6);\n    opacity: 0;\n  }\n}\n\n// Firefox hack\n@supports (-moz-appearance: meterbar) and (background-blend-mode: difference, normal) {\n  .#{$radio-prefix-cls} {\n    vertical-align: text-bottom;\n  }\n}\n\n```\n\n* 新建 styles/variables/_radio.scss文件\n```\n@import \"./common\";\n// $font-size-base\n$radio-wrapper-margin-right: 8px;\n```\n* 新建 src/styles/index.scss文件\n```\n// radio样式\n@import \"../components/Radio/style\";\n```\n* 接下来[[Typescript] 为第三方库添加声明文件 .d.ts](https://www.jianshu.com/p/1e262b487f26)\n* 新建src/typings/index.d.ts文件\n```\n/// <reference path=\"custom-typings.d.ts\" />\n```\n* 新建src/typings/custom-typings.d.ts文件\n```\ndeclare module 'rc-checkbox';\n\n```\n* 修改App.tsx文件\n```\n// 增加\nimport Radio from \"./components/Radio/radio\";\n<Radio name=\"111\">Radio</Radio>\n<Radio name=\"111\" disabled={true}>Radio2</Radio>\n```\n* 修改index.tsx文件\n```\nexport { default as Radio } from \"./components/Radio\";\n```\n## 三、 运行项目\n 执行命令\n```\n$ npm start\n```\n访问项目 可以看到Radio组件成功了！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-7fc5a5e3af91ee81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 四、 单元测试\n新建src/Radio/radio.test.tsx文件·\n```\nimport React from 'react';\nimport { mount, render } from 'enzyme';\nimport Radio, { Group, Button } from '..';\nimport focusTest from '../../../tests/shared/focusTest';\nimport mountTest from '../../../tests/shared/mountTest';\nimport rtlTest from '../../../tests/shared/rtlTest';\n\ndescribe('Radio', () => {\n  focusTest(Radio, { refFocus: true });\n  mountTest(Radio);\n  mountTest(Group);\n  mountTest(Button);\n\n  rtlTest(Radio);\n  rtlTest(Group);\n  rtlTest(Button);\n\n  it('should render correctly', () => {\n    const wrapper = render(<Radio className=\"customized\">Test</Radio>);\n    expect(wrapper).toMatchSnapshot();\n  });\n\n  it('responses hover events', () => {\n    const onMouseEnter = jest.fn();\n    const onMouseLeave = jest.fn();\n\n    const wrapper = mount(<Radio onMouseEnter={onMouseEnter} onMouseLeave={onMouseLeave} />);\n\n    wrapper.find('label').simulate('mouseenter');\n    expect(onMouseEnter).toHaveBeenCalled();\n\n    wrapper.find('label').simulate('mouseleave');\n    expect(onMouseLeave).toHaveBeenCalled();\n  });\n});\n\n```\n执行命令\n```\n$ npm test\n```\n可以看到单元测试成功通过！\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-44fe42fa111d9409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 五、编写storybook文档\n* 新建`src/Radio/radio.stories.tsx`文件\n```\nimport React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\n\nimport Radio from './radio'\n\nconst defaultRadio = () => (\n    <div>\n        <Radio onClick={action('default Radio')}>default radio</Radio>\n    </div>\n)\n\nconst radioWithDisabled = () => (\n    <div>\n        <Radio onClick={action('disabled radio')}   disabled={true}>disabled radio</Radio>\n        <Radio onClick={action('unDisabled radio')}  >unDisabled radio</Radio>\n    </div>\n)\n\n\nstoriesOf('Radio 按钮', module)\n    .addParameters({\n        info: {\n            text: `\n        ## 引用方法\n        ~~~js\n        import {Radio} from 'echo-rui\n        ~~~\n        `\n        }\n    })\n    .add('默认 Radio', defaultRadio)\n    .add('禁用的 Radio',radioWithDisabled)\n```\n* 执行命令\n```\n$ npm run storybook\n```\n浏览器打开http://localhost:9009/,可以看到组件库文档生成了。\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-88eb962e94583778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 六、 发布到npm\n ✅ ✅ ✅ ✅ ✅\n\n 大功告成✌️✌️✌️\n\n\n\n","slug":"reactCom2","published":1,"updated":"2020-12-14T10:10:23.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrv002878p39n9k15ey","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>你应该需要：<a href=\"[https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc\">使用react搭建组件库：react+typescript+storybook</a><br>)</p>\n<h2 id=\"一、-安装依赖\"><a href=\"#一、-安装依赖\" class=\"headerlink\" title=\"一、 安装依赖\"></a>一、 安装依赖</h2><p>在组件中使用 <code>rc-checkbox</code>： <a href=\"https://www.npmjs.com/package/rc-checkbox\" target=\"_blank\" rel=\"noopener\">react rc-checkbox component</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install rc-checkbox</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、-编写组件\"><a href=\"#二、-编写组件\" class=\"headerlink\" title=\"二、 编写组件\"></a>二、 编写组件</h2><ul>\n<li><p>新建 <code>src/components/Radio/radio.tsx</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">import RcCheckbox from &apos;rc-checkbox&apos;;</span><br><span class=\"line\">import classNames from &apos;classnames&apos;;</span><br><span class=\"line\">import &#123; RadioProps, RadioChangeEvent &#125; from &apos;./interface&apos;;</span><br><span class=\"line\">import &#123; ConfigContext &#125; from &apos;../config-provider&apos;;</span><br><span class=\"line\">import RadioGroupContext from &apos;./context&apos;;</span><br><span class=\"line\">import &#123; composeRef &#125; from &apos;../_util/ref&apos;;</span><br><span class=\"line\">const InternalRadio: React.ForwardRefRenderFunction&lt;unknown, RadioProps&gt; = (props, ref) =&gt; &#123;</span><br><span class=\"line\">  const context = React.useContext(RadioGroupContext);</span><br><span class=\"line\">  const &#123; getPrefixCls, direction &#125; = React.useContext(ConfigContext);</span><br><span class=\"line\">  const innerRef = React.useRef&lt;HTMLElement&gt;();</span><br><span class=\"line\">  const mergedRef = composeRef(ref, innerRef);</span><br><span class=\"line\">  </span><br><span class=\"line\">  const onChange = (e: RadioChangeEvent) =&gt; &#123;</span><br><span class=\"line\">    if (props.onChange) &#123;</span><br><span class=\"line\">      props.onChange(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (context?.onChange) &#123;</span><br><span class=\"line\">      context.onChange(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  const &#123; prefixCls: customizePrefixCls, className, children, style, ...restProps &#125; = props;</span><br><span class=\"line\">  const prefixCls = getPrefixCls(&apos;radio&apos;, customizePrefixCls);</span><br><span class=\"line\">  console.log(prefixCls, customizePrefixCls)</span><br><span class=\"line\">  const radioProps: RadioProps = &#123; ...restProps &#125;;</span><br><span class=\"line\">  if (context) &#123;</span><br><span class=\"line\">    radioProps.name = context.name;</span><br><span class=\"line\">    radioProps.onChange = onChange;</span><br><span class=\"line\">    radioProps.checked = props.value === context.value;</span><br><span class=\"line\">    radioProps.disabled = props.disabled || context.disabled;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const wrapperClassString = classNames(className, &#123;</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper`]: true,</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper-checked`]: radioProps.checked,</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper-disabled`]: radioProps.disabled,</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper-rtl`]: direction === &apos;rtl&apos;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;label</span><br><span class=\"line\">      className=&#123;wrapperClassString&#125;</span><br><span class=\"line\">      style=&#123;style&#125;</span><br><span class=\"line\">      onMouseEnter=&#123;props.onMouseEnter&#125;</span><br><span class=\"line\">      onMouseLeave=&#123;props.onMouseLeave&#125;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">      &lt;RcCheckbox &#123;...radioProps&#125; prefixCls=&#123;prefixCls as string&#125; ref=&#123;mergedRef as any&#125; /&gt;</span><br><span class=\"line\">      &#123;children !== undefined ? &lt;span&gt;&#123;children&#125;&lt;/span&gt; : null&#125;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const Radio = React.forwardRef&lt;unknown, RadioProps&gt;(InternalRadio);</span><br><span class=\"line\">Radio.displayName = &apos;Radio&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">Radio.defaultProps = &#123;</span><br><span class=\"line\">  type: &apos;radio&apos;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Radio;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/interface.tsx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export interface AbstractCheckboxProps&lt;T&gt; &#123;</span><br><span class=\"line\">  prefixCls?: string;</span><br><span class=\"line\">  className?: string;</span><br><span class=\"line\">  defaultChecked?: boolean;</span><br><span class=\"line\">  checked?: boolean;</span><br><span class=\"line\">  style?: React.CSSProperties;</span><br><span class=\"line\">  disabled?: boolean;</span><br><span class=\"line\">  onChange?: (e: T) =&gt; void;</span><br><span class=\"line\">  onClick?: React.MouseEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onMouseEnter?: React.MouseEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onMouseLeave?: React.MouseEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onKeyPress?: React.KeyboardEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onKeyDown?: React.KeyboardEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  value?: any;</span><br><span class=\"line\">  tabIndex?: number;</span><br><span class=\"line\">  name?: string;</span><br><span class=\"line\">  children?: React.ReactNode;</span><br><span class=\"line\">  id?: string;</span><br><span class=\"line\">  autoFocus?: boolean;</span><br><span class=\"line\">  type?: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export type RadioProps = AbstractCheckboxProps&lt;RadioChangeEvent&gt;;</span><br><span class=\"line\">export interface RadioChangeEventTarget extends RadioProps &#123;</span><br><span class=\"line\">  checked: boolean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export interface RadioChangeEvent &#123;</span><br><span class=\"line\">  target: RadioChangeEventTarget;</span><br><span class=\"line\">  stopPropagation: () =&gt; void;</span><br><span class=\"line\">  preventDefault: () =&gt; void;</span><br><span class=\"line\">  nativeEvent: MouseEvent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export interface RadioGroupContextProps &#123;</span><br><span class=\"line\">  onChange: (e: RadioChangeEvent) =&gt; void;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  disabled?: boolean;</span><br><span class=\"line\">  name?: string;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/config-provider/context.tsx: 为组件库提供共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">export interface ConfigConsumerProps &#123;</span><br><span class=\"line\">  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) =&gt; string;</span><br><span class=\"line\">  direction?: &apos;ltr&apos; | &apos;rtl&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export const ConfigContext = React.createContext&lt;ConfigConsumerProps&gt;(&#123;</span><br><span class=\"line\">  // We provide a default function for Context without provider</span><br><span class=\"line\">  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) =&gt; &#123;</span><br><span class=\"line\">    if (customizePrefixCls) return customizePrefixCls;</span><br><span class=\"line\"></span><br><span class=\"line\">    return suffixCls ? `echo-$&#123;suffixCls&#125;` : &apos;echo&apos;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const ConfigConsumer = ConfigContext.Consumer;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/config-provider/index.tsx: 为组件库提供共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; ConfigContext, ConfigConsumer &#125; from &apos;./context&apos;;</span><br><span class=\"line\">export &#123; ConfigContext, ConfigConsumer&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/config-provider/SizeContext.tsx: 为组件库提供大小共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">export type SizeType = &apos;small&apos; | &apos;middle&apos; | &apos;large&apos; | undefined;</span><br><span class=\"line\">const SizeContext = React.createContext&lt;SizeType&gt;(undefined);</span><br><span class=\"line\">export default SizeContext;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/context.tsx: 为Radio相关组件提供共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; RadioGroupContextProps &#125; from &apos;./interface&apos;;</span><br><span class=\"line\">const RadioGroupContext = React.createContext&lt;RadioGroupContextProps | null&gt;(null);</span><br><span class=\"line\">export const RadioGroupContextProvider = RadioGroupContext.Provider;</span><br><span class=\"line\">export default RadioGroupContext;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/_util/ref.tsx:组件库通用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export function fillRef&lt;T&gt;(ref: React.Ref&lt;T&gt;, node: T) &#123;</span><br><span class=\"line\">  if (typeof ref === &apos;function&apos;) &#123;</span><br><span class=\"line\">    ref(node);</span><br><span class=\"line\">  &#125; else if (typeof ref === &apos;object&apos; &amp;&amp; ref &amp;&amp; &apos;current&apos; in ref) &#123;</span><br><span class=\"line\">    (ref as any).current = node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function composeRef&lt;T&gt;(...refs: React.Ref&lt;T&gt;[]): React.Ref&lt;T&gt; &#123;</span><br><span class=\"line\">  return (node: T) =&gt; &#123;</span><br><span class=\"line\">    refs.forEach(ref =&gt; &#123;</span><br><span class=\"line\">      fillRef(ref, node);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/index.tsx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Radio from &quot;./radio&quot;;</span><br><span class=\"line\">export default Radio;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/_rtl.scss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/radio&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$radio-prefix-cls: &apos;echo-radio&apos;;</span><br><span class=\"line\">$radio-group-prefix-cls: &apos;#&#123;$radio-prefix-cls&#125;-group&apos;;</span><br><span class=\"line\">$radio-prefix-cls-button-wrapper: &apos;#&#123;$radio-prefix-cls&#125;-button-wrapper&apos;;</span><br><span class=\"line\">.#&#123;$radio-group-prefix-cls&#125;&#123;</span><br><span class=\"line\">  &amp;-rtl &#123;</span><br><span class=\"line\">    direction: rtl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般状态</span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-wrapper &#123;</span><br><span class=\"line\">  &amp;-rtl &#123;</span><br><span class=\"line\">    margin-right: 0;</span><br><span class=\"line\">    margin-left: $radio-wrapper-margin-right;</span><br><span class=\"line\">    direction: rtl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls-button-wrapper&#125; &#123;</span><br><span class=\"line\">  &amp;-rtl &#123;</span><br><span class=\"line\">    border-right-width: 0;</span><br><span class=\"line\">    border-left-width: $border-width-base;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:not(:first-child) &#123;</span><br><span class=\"line\">    &amp;::before &#123;</span><br><span class=\"line\">      .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">        right: -1px;</span><br><span class=\"line\">        left: 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:first-child &#123;</span><br><span class=\"line\">    .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">      border-right: $border-width-base $border-style-base $border-color-base;</span><br><span class=\"line\">      border-radius: 0 $border-radius-base $border-radius-base 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .#&#123;$radio-prefix-cls-button-wrapper&#125;-checked:not([class*=&quot;&apos;#&#123;$radio-prefix-cls&#125;-button-wrapper-disabled&apos;&quot;]) &amp; &#123;</span><br><span class=\"line\">      border-right-color:lighten($primary, 10%);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:last-child &#123;</span><br><span class=\"line\">    .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">      border-radius: $border-radius-base 0 0 $border-radius-base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-disabled &#123;</span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">        border-right-color: $border-color-base;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Icon/_style.scss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/radio&quot;;</span><br><span class=\"line\">@import &quot;./rtl&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">$radio-prefix-cls: &apos;echo-radio&apos;;</span><br><span class=\"line\">$radio-group-prefix-cls: &apos;#&#123;$radio-prefix-cls&#125;-group&apos;;</span><br><span class=\"line\">$radio-inner-prefix-cls: &apos;#&#123;radio-prefix-cls&#125;-inner&apos;;</span><br><span class=\"line\">$radio-duration: 0.3s;</span><br><span class=\"line\">$radio-focus-shadow: 0 0 0 3px fade($primary, 8%);</span><br><span class=\"line\">$radio-button-focus-shadow: $radio-focus-shadow;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-group-prefix-cls&#125; &#123;</span><br><span class=\"line\">  @include reset-component;</span><br><span class=\"line\"></span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  font-size: 0;</span><br><span class=\"line\">  line-height: unset;</span><br><span class=\"line\"></span><br><span class=\"line\">  .echo-badge-count &#123;</span><br><span class=\"line\">    z-index: 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .echo-badge:not(:first-child) .#&#123;$radio-prefix-cls&#125;-button-wrapper &#123;</span><br><span class=\"line\">    border-left: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般状态</span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-wrapper &#123;</span><br><span class=\"line\">  @include reset-component;</span><br><span class=\"line\"></span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  margin-right: $radio-wrapper-margin-right;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125; &#123;</span><br><span class=\"line\">  @include reset-component;</span><br><span class=\"line\"></span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  top: -3px;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  line-height: 1;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">  vertical-align: sub;</span><br><span class=\"line\">  outline: none;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-wrapper:hover &amp;,</span><br><span class=\"line\">  &amp;:hover .#&#123;$radio-inner-prefix-cls&#125;,</span><br><span class=\"line\">  &amp;-input:focus + .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-input:focus + .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    box-shadow: $radio-focus-shadow;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-checked::after &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    left: 0;</span><br><span class=\"line\">    width: 100%;</span><br><span class=\"line\">    height: 100%;</span><br><span class=\"line\">    border: 1px solid $radio-dot-color;</span><br><span class=\"line\">    border-radius: 50%;</span><br><span class=\"line\">    visibility: hidden;</span><br><span class=\"line\">    animation: antRadioEffect 0.36s ease-in-out;</span><br><span class=\"line\">    animation-fill-mode: both;</span><br><span class=\"line\">    content: &apos;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:hover::after,</span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-wrapper:hover &amp;::after &#123;</span><br><span class=\"line\">    visibility: visible;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-inner &#123;</span><br><span class=\"line\">    &amp;::after &#123;</span><br><span class=\"line\">      $radio-dot-size: $radio-size - 8px;</span><br><span class=\"line\"></span><br><span class=\"line\">      position: absolute;</span><br><span class=\"line\">      top: ($radio-size - $radio-dot-size) / 2 - 1px;</span><br><span class=\"line\">      left: ($radio-size - $radio-dot-size) / 2 - 1px;</span><br><span class=\"line\">      display: table;</span><br><span class=\"line\">      width: $radio-dot-size;</span><br><span class=\"line\">      height: $radio-dot-size;</span><br><span class=\"line\">      background-color: $radio-dot-color;</span><br><span class=\"line\">      border-top: 0;</span><br><span class=\"line\">      border-left: 0;</span><br><span class=\"line\">      border-radius: $radio-dot-size;</span><br><span class=\"line\">      transform: scale(0);</span><br><span class=\"line\">      opacity: 0;</span><br><span class=\"line\">      transition: all $radio-duration $ease-in-out-circ;</span><br><span class=\"line\">      content: &apos; &apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 选中状态</span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-checked &#123;</span><br><span class=\"line\">  .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\">    &amp;::after &#123;</span><br><span class=\"line\">      transform: scale(1);</span><br><span class=\"line\">      opacity: 1;</span><br><span class=\"line\">      transition: all $radio-duration $ease-in-out-circ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-disabled &#123;</span><br><span class=\"line\">  .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    background-color: $disabled-color;</span><br><span class=\"line\">    border-color: $border-color-base !important;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">    &amp;::after &#123;</span><br><span class=\"line\">      background-color: $radio-dot-disabled-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-input &#123;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp; + span &#123;</span><br><span class=\"line\">    color: $disabled-color;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">span.#&#123;$radio-prefix-cls&#125; + * &#123;</span><br><span class=\"line\">  padding-right: 8px;</span><br><span class=\"line\">  padding-left: 4px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-button-wrapper &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  height: $height-base;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">  padding: 0 $padding-md - 1px;</span><br><span class=\"line\">  color: $radio-button-color;</span><br><span class=\"line\">  font-size: $font-size-base;</span><br><span class=\"line\">  line-height: $height-base - 2px;</span><br><span class=\"line\">  background: $radio-button-bg;</span><br><span class=\"line\">  border: $border-width-base $border-style-base $border-color-base;</span><br><span class=\"line\">  // strange align fix for chrome but works</span><br><span class=\"line\">  // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif</span><br><span class=\"line\">  border-top-width: $border-width-base + 0.02px;</span><br><span class=\"line\">  border-left-width: 0;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">  transition: color 0.3s, background 0.3s, border-color 0.3s, box-shadow 0.3s;</span><br><span class=\"line\"></span><br><span class=\"line\">  a &#123;</span><br><span class=\"line\">    color: $radio-button-color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &gt; .#&#123;$radio-prefix-cls&#125;-button &#123;</span><br><span class=\"line\">    display: block;</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    height: 0;</span><br><span class=\"line\">    margin-left: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-group-prefix-cls&#125;-large &amp; &#123;</span><br><span class=\"line\">    height: $height-lg;</span><br><span class=\"line\">    font-size: $font-size-lg;</span><br><span class=\"line\">    line-height: $height-lg - 2px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-group-prefix-cls&#125;-small &amp; &#123;</span><br><span class=\"line\">    height: $height-sm;</span><br><span class=\"line\">    padding: 0 $control-padding-horizontal-sm - 1px;</span><br><span class=\"line\">    line-height: $height-sm - 2px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:not(:first-child) &#123;</span><br><span class=\"line\">    &amp;::before &#123;</span><br><span class=\"line\">      position: absolute;</span><br><span class=\"line\">      top: $border-width-base * -1;</span><br><span class=\"line\">      left: -1px;</span><br><span class=\"line\">      display: block;</span><br><span class=\"line\">      box-sizing: content-box;</span><br><span class=\"line\">      width: 1px;</span><br><span class=\"line\">      height: 100%;</span><br><span class=\"line\">      padding: $border-width-base 0;</span><br><span class=\"line\">      background-color: $border-color-base;</span><br><span class=\"line\">      transition: background-color 0.3s;</span><br><span class=\"line\">      content: &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:first-child &#123;</span><br><span class=\"line\">    border-left: $border-width-base $border-style-base $border-color-base;</span><br><span class=\"line\">    border-radius: $border-radius-base 0 0 $border-radius-base;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:last-child &#123;</span><br><span class=\"line\">    border-radius: 0 $border-radius-base $border-radius-base 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:first-child:last-child &#123;</span><br><span class=\"line\">    border-radius: $border-radius-base;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:hover &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    color: $radio-dot-color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:focus-within &#123;</span><br><span class=\"line\">    box-shadow: $radio-button-focus-shadow;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-inner,</span><br><span class=\"line\">  input[type=&apos;checkbox&apos;],</span><br><span class=\"line\">  input[type=&apos;radio&apos;] &#123;</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    height: 0;</span><br><span class=\"line\">    opacity: 0;</span><br><span class=\"line\">    pointer-events: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-checked:not(&amp;-disabled) &#123;</span><br><span class=\"line\">    z-index: 1;</span><br><span class=\"line\">    color: $radio-dot-color;</span><br><span class=\"line\">    background: $radio-button-checked-bg;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;::before &#123;</span><br><span class=\"line\">      background-color: $radio-dot-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      border-color: $radio-dot-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:hover &#123;</span><br><span class=\"line\">      color: $radio-button-hover-color;</span><br><span class=\"line\">      border-color: $radio-button-hover-color;</span><br><span class=\"line\">      &amp;::before &#123;</span><br><span class=\"line\">        background-color: $radio-button-hover-color;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:active &#123;</span><br><span class=\"line\">      color: $radio-button-active-color;</span><br><span class=\"line\">      border-color: $radio-button-active-color;</span><br><span class=\"line\">      &amp;::before &#123;</span><br><span class=\"line\">        background-color: $radio-button-active-color;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:focus-within &#123;</span><br><span class=\"line\">      box-shadow: $radio-button-focus-shadow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-group-prefix-cls&#125;-solid &amp;-checked:not(&amp;-disabled) &#123;</span><br><span class=\"line\">    color: $radio-solid-checked-color;</span><br><span class=\"line\">    background: $radio-dot-color;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\">    &amp;:hover &#123;</span><br><span class=\"line\">      color: $radio-solid-checked-color;</span><br><span class=\"line\">      background: $radio-button-hover-color;</span><br><span class=\"line\">      border-color: $radio-button-hover-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:active &#123;</span><br><span class=\"line\">      color: $radio-solid-checked-color;</span><br><span class=\"line\">      background: $radio-button-active-color;</span><br><span class=\"line\">      border-color: $radio-button-active-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:focus-within &#123;</span><br><span class=\"line\">      box-shadow: $radio-button-focus-shadow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-disabled &#123;</span><br><span class=\"line\">    color: $disabled-color;</span><br><span class=\"line\">    background-color: $disabled-bg;;</span><br><span class=\"line\">    border-color: $border-color-base;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:first-child,</span><br><span class=\"line\">    &amp;:hover &#123;</span><br><span class=\"line\">      color: $disabled-color;</span><br><span class=\"line\">      background-color: $disabled-bg;;</span><br><span class=\"line\">      border-color: $border-color-base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      border-left-color: $border-color-base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-disabled &amp;-checked &#123;</span><br><span class=\"line\">    color: $radio-disabled-button-checked-color;</span><br><span class=\"line\">    background-color: $radio-disabled-button-checked-bg;</span><br><span class=\"line\">    border-color: $border-color-base;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes antRadioEffect &#123;</span><br><span class=\"line\">  0% &#123;</span><br><span class=\"line\">    transform: scale(1);</span><br><span class=\"line\">    opacity: 0.5;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    transform: scale(1.6);</span><br><span class=\"line\">    opacity: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Firefox hack</span><br><span class=\"line\">@supports (-moz-appearance: meterbar) and (background-blend-mode: difference, normal) &#123;</span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125; &#123;</span><br><span class=\"line\">    vertical-align: text-bottom;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 styles/variables/_radio.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;./common&quot;;</span><br><span class=\"line\">// $font-size-base</span><br><span class=\"line\">$radio-wrapper-margin-right: 8px;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/styles/index.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// radio样式</span><br><span class=\"line\">@import &quot;../components/Radio/style&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来<a href=\"https://www.jianshu.com/p/1e262b487f26\" target=\"_blank\" rel=\"noopener\">[Typescript] 为第三方库添加声明文件 .d.ts</a></p>\n</li>\n<li><p>新建src/typings/index.d.ts文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;custom-typings.d.ts&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建src/typings/custom-typings.d.ts文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare module &apos;rc-checkbox&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改App.tsx文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 增加</span><br><span class=\"line\">import Radio from &quot;./components/Radio/radio&quot;;</span><br><span class=\"line\">&lt;Radio name=&quot;111&quot;&gt;Radio&lt;/Radio&gt;</span><br><span class=\"line\">&lt;Radio name=&quot;111&quot; disabled=&#123;true&#125;&gt;Radio2&lt;/Radio&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改index.tsx文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as Radio &#125; from &quot;./components/Radio&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"三、-运行项目\"><a href=\"#三、-运行项目\" class=\"headerlink\" title=\"三、 运行项目\"></a>三、 运行项目</h2><p> 执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p>访问项目 可以看到Radio组件成功了！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-7fc5a5e3af91ee81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"四、-单元测试\"><a href=\"#四、-单元测试\" class=\"headerlink\" title=\"四、 单元测试\"></a>四、 单元测试</h2><p>新建src/Radio/radio.test.tsx文件·<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; mount, render &#125; from &apos;enzyme&apos;;</span><br><span class=\"line\">import Radio, &#123; Group, Button &#125; from &apos;..&apos;;</span><br><span class=\"line\">import focusTest from &apos;../../../tests/shared/focusTest&apos;;</span><br><span class=\"line\">import mountTest from &apos;../../../tests/shared/mountTest&apos;;</span><br><span class=\"line\">import rtlTest from &apos;../../../tests/shared/rtlTest&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;Radio&apos;, () =&gt; &#123;</span><br><span class=\"line\">  focusTest(Radio, &#123; refFocus: true &#125;);</span><br><span class=\"line\">  mountTest(Radio);</span><br><span class=\"line\">  mountTest(Group);</span><br><span class=\"line\">  mountTest(Button);</span><br><span class=\"line\"></span><br><span class=\"line\">  rtlTest(Radio);</span><br><span class=\"line\">  rtlTest(Group);</span><br><span class=\"line\">  rtlTest(Button);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;should render correctly&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const wrapper = render(&lt;Radio className=&quot;customized&quot;&gt;Test&lt;/Radio&gt;);</span><br><span class=\"line\">    expect(wrapper).toMatchSnapshot();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;responses hover events&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const onMouseEnter = jest.fn();</span><br><span class=\"line\">    const onMouseLeave = jest.fn();</span><br><span class=\"line\"></span><br><span class=\"line\">    const wrapper = mount(&lt;Radio onMouseEnter=&#123;onMouseEnter&#125; onMouseLeave=&#123;onMouseLeave&#125; /&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\">    wrapper.find(&apos;label&apos;).simulate(&apos;mouseenter&apos;);</span><br><span class=\"line\">    expect(onMouseEnter).toHaveBeenCalled();</span><br><span class=\"line\"></span><br><span class=\"line\">    wrapper.find(&apos;label&apos;).simulate(&apos;mouseleave&apos;);</span><br><span class=\"line\">    expect(onMouseLeave).toHaveBeenCalled();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm test</span><br></pre></td></tr></table></figure></p>\n<p>可以看到单元测试成功通过！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-44fe42fa111d9409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"五、编写storybook文档\"><a href=\"#五、编写storybook文档\" class=\"headerlink\" title=\"五、编写storybook文档\"></a>五、编写storybook文档</h2><ul>\n<li><p>新建<code>src/Radio/radio.stories.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; storiesOf &#125; from &apos;@storybook/react&apos;;</span><br><span class=\"line\">import &#123; action &#125; from &apos;@storybook/addon-actions&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">import Radio from &apos;./radio&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const defaultRadio = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Radio onClick=&#123;action(&apos;default Radio&apos;)&#125;&gt;default radio&lt;/Radio&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const radioWithDisabled = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Radio onClick=&#123;action(&apos;disabled radio&apos;)&#125;   disabled=&#123;true&#125;&gt;disabled radio&lt;/Radio&gt;</span><br><span class=\"line\">        &lt;Radio onClick=&#123;action(&apos;unDisabled radio&apos;)&#125;  &gt;unDisabled radio&lt;/Radio&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">storiesOf(&apos;Radio 按钮&apos;, module)</span><br><span class=\"line\">    .addParameters(&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">        ## 引用方法</span><br><span class=\"line\">        ~~~js</span><br><span class=\"line\">        import &#123;Radio&#125; from &apos;echo-rui</span><br><span class=\"line\">        ~~~</span><br><span class=\"line\">        `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .add(&apos;默认 Radio&apos;, defaultRadio)</span><br><span class=\"line\">    .add(&apos;禁用的 Radio&apos;,radioWithDisabled)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run storybook</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>浏览器打开<a href=\"http://localhost:9009/,可以看到组件库文档生成了。\" target=\"_blank\" rel=\"noopener\">http://localhost:9009/,可以看到组件库文档生成了。</a><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-88eb962e94583778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"六、-发布到npm\"><a href=\"#六、-发布到npm\" class=\"headerlink\" title=\"六、 发布到npm\"></a>六、 发布到npm</h2><p> ✅ ✅ ✅ ✅ ✅</p>\n<p> 大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>你应该需要：<a href=\"[https://www.jianshu.com/p/8ef96e06adcc](https://www.jianshu.com/p/8ef96e06adcc\">使用react搭建组件库：react+typescript+storybook</a><br>)</p>\n<h2 id=\"一、-安装依赖\"><a href=\"#一、-安装依赖\" class=\"headerlink\" title=\"一、 安装依赖\"></a>一、 安装依赖</h2><p>在组件中使用 <code>rc-checkbox</code>： <a href=\"https://www.npmjs.com/package/rc-checkbox\" target=\"_blank\" rel=\"noopener\">react rc-checkbox component</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install rc-checkbox</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、-编写组件\"><a href=\"#二、-编写组件\" class=\"headerlink\" title=\"二、 编写组件\"></a>二、 编写组件</h2><ul>\n<li><p>新建 <code>src/components/Radio/radio.tsx</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">import RcCheckbox from &apos;rc-checkbox&apos;;</span><br><span class=\"line\">import classNames from &apos;classnames&apos;;</span><br><span class=\"line\">import &#123; RadioProps, RadioChangeEvent &#125; from &apos;./interface&apos;;</span><br><span class=\"line\">import &#123; ConfigContext &#125; from &apos;../config-provider&apos;;</span><br><span class=\"line\">import RadioGroupContext from &apos;./context&apos;;</span><br><span class=\"line\">import &#123; composeRef &#125; from &apos;../_util/ref&apos;;</span><br><span class=\"line\">const InternalRadio: React.ForwardRefRenderFunction&lt;unknown, RadioProps&gt; = (props, ref) =&gt; &#123;</span><br><span class=\"line\">  const context = React.useContext(RadioGroupContext);</span><br><span class=\"line\">  const &#123; getPrefixCls, direction &#125; = React.useContext(ConfigContext);</span><br><span class=\"line\">  const innerRef = React.useRef&lt;HTMLElement&gt;();</span><br><span class=\"line\">  const mergedRef = composeRef(ref, innerRef);</span><br><span class=\"line\">  </span><br><span class=\"line\">  const onChange = (e: RadioChangeEvent) =&gt; &#123;</span><br><span class=\"line\">    if (props.onChange) &#123;</span><br><span class=\"line\">      props.onChange(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (context?.onChange) &#123;</span><br><span class=\"line\">      context.onChange(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  const &#123; prefixCls: customizePrefixCls, className, children, style, ...restProps &#125; = props;</span><br><span class=\"line\">  const prefixCls = getPrefixCls(&apos;radio&apos;, customizePrefixCls);</span><br><span class=\"line\">  console.log(prefixCls, customizePrefixCls)</span><br><span class=\"line\">  const radioProps: RadioProps = &#123; ...restProps &#125;;</span><br><span class=\"line\">  if (context) &#123;</span><br><span class=\"line\">    radioProps.name = context.name;</span><br><span class=\"line\">    radioProps.onChange = onChange;</span><br><span class=\"line\">    radioProps.checked = props.value === context.value;</span><br><span class=\"line\">    radioProps.disabled = props.disabled || context.disabled;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const wrapperClassString = classNames(className, &#123;</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper`]: true,</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper-checked`]: radioProps.checked,</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper-disabled`]: radioProps.disabled,</span><br><span class=\"line\">    [`$&#123;prefixCls&#125;-wrapper-rtl`]: direction === &apos;rtl&apos;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &lt;label</span><br><span class=\"line\">      className=&#123;wrapperClassString&#125;</span><br><span class=\"line\">      style=&#123;style&#125;</span><br><span class=\"line\">      onMouseEnter=&#123;props.onMouseEnter&#125;</span><br><span class=\"line\">      onMouseLeave=&#123;props.onMouseLeave&#125;</span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">      &lt;RcCheckbox &#123;...radioProps&#125; prefixCls=&#123;prefixCls as string&#125; ref=&#123;mergedRef as any&#125; /&gt;</span><br><span class=\"line\">      &#123;children !== undefined ? &lt;span&gt;&#123;children&#125;&lt;/span&gt; : null&#125;</span><br><span class=\"line\">    &lt;/label&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const Radio = React.forwardRef&lt;unknown, RadioProps&gt;(InternalRadio);</span><br><span class=\"line\">Radio.displayName = &apos;Radio&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">Radio.defaultProps = &#123;</span><br><span class=\"line\">  type: &apos;radio&apos;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Radio;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/interface.tsx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export interface AbstractCheckboxProps&lt;T&gt; &#123;</span><br><span class=\"line\">  prefixCls?: string;</span><br><span class=\"line\">  className?: string;</span><br><span class=\"line\">  defaultChecked?: boolean;</span><br><span class=\"line\">  checked?: boolean;</span><br><span class=\"line\">  style?: React.CSSProperties;</span><br><span class=\"line\">  disabled?: boolean;</span><br><span class=\"line\">  onChange?: (e: T) =&gt; void;</span><br><span class=\"line\">  onClick?: React.MouseEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onMouseEnter?: React.MouseEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onMouseLeave?: React.MouseEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onKeyPress?: React.KeyboardEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  onKeyDown?: React.KeyboardEventHandler&lt;HTMLElement&gt;;</span><br><span class=\"line\">  value?: any;</span><br><span class=\"line\">  tabIndex?: number;</span><br><span class=\"line\">  name?: string;</span><br><span class=\"line\">  children?: React.ReactNode;</span><br><span class=\"line\">  id?: string;</span><br><span class=\"line\">  autoFocus?: boolean;</span><br><span class=\"line\">  type?: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export type RadioProps = AbstractCheckboxProps&lt;RadioChangeEvent&gt;;</span><br><span class=\"line\">export interface RadioChangeEventTarget extends RadioProps &#123;</span><br><span class=\"line\">  checked: boolean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export interface RadioChangeEvent &#123;</span><br><span class=\"line\">  target: RadioChangeEventTarget;</span><br><span class=\"line\">  stopPropagation: () =&gt; void;</span><br><span class=\"line\">  preventDefault: () =&gt; void;</span><br><span class=\"line\">  nativeEvent: MouseEvent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export interface RadioGroupContextProps &#123;</span><br><span class=\"line\">  onChange: (e: RadioChangeEvent) =&gt; void;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  disabled?: boolean;</span><br><span class=\"line\">  name?: string;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/config-provider/context.tsx: 为组件库提供共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">export interface ConfigConsumerProps &#123;</span><br><span class=\"line\">  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) =&gt; string;</span><br><span class=\"line\">  direction?: &apos;ltr&apos; | &apos;rtl&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export const ConfigContext = React.createContext&lt;ConfigConsumerProps&gt;(&#123;</span><br><span class=\"line\">  // We provide a default function for Context without provider</span><br><span class=\"line\">  getPrefixCls: (suffixCls: string, customizePrefixCls?: string) =&gt; &#123;</span><br><span class=\"line\">    if (customizePrefixCls) return customizePrefixCls;</span><br><span class=\"line\"></span><br><span class=\"line\">    return suffixCls ? `echo-$&#123;suffixCls&#125;` : &apos;echo&apos;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const ConfigConsumer = ConfigContext.Consumer;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/config-provider/index.tsx: 为组件库提供共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; ConfigContext, ConfigConsumer &#125; from &apos;./context&apos;;</span><br><span class=\"line\">export &#123; ConfigContext, ConfigConsumer&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/config-provider/SizeContext.tsx: 为组件库提供大小共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">export type SizeType = &apos;small&apos; | &apos;middle&apos; | &apos;large&apos; | undefined;</span><br><span class=\"line\">const SizeContext = React.createContext&lt;SizeType&gt;(undefined);</span><br><span class=\"line\">export default SizeContext;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/context.tsx: 为Radio相关组件提供共享状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; RadioGroupContextProps &#125; from &apos;./interface&apos;;</span><br><span class=\"line\">const RadioGroupContext = React.createContext&lt;RadioGroupContextProps | null&gt;(null);</span><br><span class=\"line\">export const RadioGroupContextProvider = RadioGroupContext.Provider;</span><br><span class=\"line\">export default RadioGroupContext;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/_util/ref.tsx:组件库通用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as React from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export function fillRef&lt;T&gt;(ref: React.Ref&lt;T&gt;, node: T) &#123;</span><br><span class=\"line\">  if (typeof ref === &apos;function&apos;) &#123;</span><br><span class=\"line\">    ref(node);</span><br><span class=\"line\">  &#125; else if (typeof ref === &apos;object&apos; &amp;&amp; ref &amp;&amp; &apos;current&apos; in ref) &#123;</span><br><span class=\"line\">    (ref as any).current = node;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function composeRef&lt;T&gt;(...refs: React.Ref&lt;T&gt;[]): React.Ref&lt;T&gt; &#123;</span><br><span class=\"line\">  return (node: T) =&gt; &#123;</span><br><span class=\"line\">    refs.forEach(ref =&gt; &#123;</span><br><span class=\"line\">      fillRef(ref, node);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/index.tsx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Radio from &quot;./radio&quot;;</span><br><span class=\"line\">export default Radio;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Radio/_rtl.scss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/radio&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">$radio-prefix-cls: &apos;echo-radio&apos;;</span><br><span class=\"line\">$radio-group-prefix-cls: &apos;#&#123;$radio-prefix-cls&#125;-group&apos;;</span><br><span class=\"line\">$radio-prefix-cls-button-wrapper: &apos;#&#123;$radio-prefix-cls&#125;-button-wrapper&apos;;</span><br><span class=\"line\">.#&#123;$radio-group-prefix-cls&#125;&#123;</span><br><span class=\"line\">  &amp;-rtl &#123;</span><br><span class=\"line\">    direction: rtl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般状态</span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-wrapper &#123;</span><br><span class=\"line\">  &amp;-rtl &#123;</span><br><span class=\"line\">    margin-right: 0;</span><br><span class=\"line\">    margin-left: $radio-wrapper-margin-right;</span><br><span class=\"line\">    direction: rtl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls-button-wrapper&#125; &#123;</span><br><span class=\"line\">  &amp;-rtl &#123;</span><br><span class=\"line\">    border-right-width: 0;</span><br><span class=\"line\">    border-left-width: $border-width-base;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:not(:first-child) &#123;</span><br><span class=\"line\">    &amp;::before &#123;</span><br><span class=\"line\">      .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">        right: -1px;</span><br><span class=\"line\">        left: 0;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:first-child &#123;</span><br><span class=\"line\">    .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">      border-right: $border-width-base $border-style-base $border-color-base;</span><br><span class=\"line\">      border-radius: 0 $border-radius-base $border-radius-base 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .#&#123;$radio-prefix-cls-button-wrapper&#125;-checked:not([class*=&quot;&apos;#&#123;$radio-prefix-cls&#125;-button-wrapper-disabled&apos;&quot;]) &amp; &#123;</span><br><span class=\"line\">      border-right-color:lighten($primary, 10%);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:last-child &#123;</span><br><span class=\"line\">    .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">      border-radius: $border-radius-base 0 0 $border-radius-base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-disabled &#123;</span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      .#&#123;$radio-prefix-cls-button-wrapper&#125;.#&#123;$radio-prefix-cls-button-wrapper&#125;-rtl &amp; &#123;</span><br><span class=\"line\">        border-right-color: $border-color-base;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/components/Icon/_style.scss</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;../../styles/variables/radio&quot;;</span><br><span class=\"line\">@import &quot;./rtl&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">$radio-prefix-cls: &apos;echo-radio&apos;;</span><br><span class=\"line\">$radio-group-prefix-cls: &apos;#&#123;$radio-prefix-cls&#125;-group&apos;;</span><br><span class=\"line\">$radio-inner-prefix-cls: &apos;#&#123;radio-prefix-cls&#125;-inner&apos;;</span><br><span class=\"line\">$radio-duration: 0.3s;</span><br><span class=\"line\">$radio-focus-shadow: 0 0 0 3px fade($primary, 8%);</span><br><span class=\"line\">$radio-button-focus-shadow: $radio-focus-shadow;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-group-prefix-cls&#125; &#123;</span><br><span class=\"line\">  @include reset-component;</span><br><span class=\"line\"></span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  font-size: 0;</span><br><span class=\"line\">  line-height: unset;</span><br><span class=\"line\"></span><br><span class=\"line\">  .echo-badge-count &#123;</span><br><span class=\"line\">    z-index: 1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .echo-badge:not(:first-child) .#&#123;$radio-prefix-cls&#125;-button-wrapper &#123;</span><br><span class=\"line\">    border-left: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 一般状态</span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-wrapper &#123;</span><br><span class=\"line\">  @include reset-component;</span><br><span class=\"line\"></span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  margin-right: $radio-wrapper-margin-right;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125; &#123;</span><br><span class=\"line\">  @include reset-component;</span><br><span class=\"line\"></span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  top: -3px;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  line-height: 1;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">  vertical-align: sub;</span><br><span class=\"line\">  outline: none;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-wrapper:hover &amp;,</span><br><span class=\"line\">  &amp;:hover .#&#123;$radio-inner-prefix-cls&#125;,</span><br><span class=\"line\">  &amp;-input:focus + .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-input:focus + .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    box-shadow: $radio-focus-shadow;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-checked::after &#123;</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 0;</span><br><span class=\"line\">    left: 0;</span><br><span class=\"line\">    width: 100%;</span><br><span class=\"line\">    height: 100%;</span><br><span class=\"line\">    border: 1px solid $radio-dot-color;</span><br><span class=\"line\">    border-radius: 50%;</span><br><span class=\"line\">    visibility: hidden;</span><br><span class=\"line\">    animation: antRadioEffect 0.36s ease-in-out;</span><br><span class=\"line\">    animation-fill-mode: both;</span><br><span class=\"line\">    content: &apos;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:hover::after,</span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-wrapper:hover &amp;::after &#123;</span><br><span class=\"line\">    visibility: visible;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-inner &#123;</span><br><span class=\"line\">    &amp;::after &#123;</span><br><span class=\"line\">      $radio-dot-size: $radio-size - 8px;</span><br><span class=\"line\"></span><br><span class=\"line\">      position: absolute;</span><br><span class=\"line\">      top: ($radio-size - $radio-dot-size) / 2 - 1px;</span><br><span class=\"line\">      left: ($radio-size - $radio-dot-size) / 2 - 1px;</span><br><span class=\"line\">      display: table;</span><br><span class=\"line\">      width: $radio-dot-size;</span><br><span class=\"line\">      height: $radio-dot-size;</span><br><span class=\"line\">      background-color: $radio-dot-color;</span><br><span class=\"line\">      border-top: 0;</span><br><span class=\"line\">      border-left: 0;</span><br><span class=\"line\">      border-radius: $radio-dot-size;</span><br><span class=\"line\">      transform: scale(0);</span><br><span class=\"line\">      opacity: 0;</span><br><span class=\"line\">      transition: all $radio-duration $ease-in-out-circ;</span><br><span class=\"line\">      content: &apos; &apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 选中状态</span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-checked &#123;</span><br><span class=\"line\">  .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\">    &amp;::after &#123;</span><br><span class=\"line\">      transform: scale(1);</span><br><span class=\"line\">      opacity: 1;</span><br><span class=\"line\">      transition: all $radio-duration $ease-in-out-circ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-disabled &#123;</span><br><span class=\"line\">  .#&#123;$radio-inner-prefix-cls&#125; &#123;</span><br><span class=\"line\">    background-color: $disabled-color;</span><br><span class=\"line\">    border-color: $border-color-base !important;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">    &amp;::after &#123;</span><br><span class=\"line\">      background-color: $radio-dot-disabled-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-input &#123;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp; + span &#123;</span><br><span class=\"line\">    color: $disabled-color;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">span.#&#123;$radio-prefix-cls&#125; + * &#123;</span><br><span class=\"line\">  padding-right: 8px;</span><br><span class=\"line\">  padding-left: 4px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.#&#123;$radio-prefix-cls&#125;-button-wrapper &#123;</span><br><span class=\"line\">  position: relative;</span><br><span class=\"line\">  display: inline-block;</span><br><span class=\"line\">  height: $height-base;</span><br><span class=\"line\">  margin: 0;</span><br><span class=\"line\">  padding: 0 $padding-md - 1px;</span><br><span class=\"line\">  color: $radio-button-color;</span><br><span class=\"line\">  font-size: $font-size-base;</span><br><span class=\"line\">  line-height: $height-base - 2px;</span><br><span class=\"line\">  background: $radio-button-bg;</span><br><span class=\"line\">  border: $border-width-base $border-style-base $border-color-base;</span><br><span class=\"line\">  // strange align fix for chrome but works</span><br><span class=\"line\">  // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif</span><br><span class=\"line\">  border-top-width: $border-width-base + 0.02px;</span><br><span class=\"line\">  border-left-width: 0;</span><br><span class=\"line\">  cursor: pointer;</span><br><span class=\"line\">  transition: color 0.3s, background 0.3s, border-color 0.3s, box-shadow 0.3s;</span><br><span class=\"line\"></span><br><span class=\"line\">  a &#123;</span><br><span class=\"line\">    color: $radio-button-color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &gt; .#&#123;$radio-prefix-cls&#125;-button &#123;</span><br><span class=\"line\">    display: block;</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    height: 0;</span><br><span class=\"line\">    margin-left: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-group-prefix-cls&#125;-large &amp; &#123;</span><br><span class=\"line\">    height: $height-lg;</span><br><span class=\"line\">    font-size: $font-size-lg;</span><br><span class=\"line\">    line-height: $height-lg - 2px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-group-prefix-cls&#125;-small &amp; &#123;</span><br><span class=\"line\">    height: $height-sm;</span><br><span class=\"line\">    padding: 0 $control-padding-horizontal-sm - 1px;</span><br><span class=\"line\">    line-height: $height-sm - 2px;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:not(:first-child) &#123;</span><br><span class=\"line\">    &amp;::before &#123;</span><br><span class=\"line\">      position: absolute;</span><br><span class=\"line\">      top: $border-width-base * -1;</span><br><span class=\"line\">      left: -1px;</span><br><span class=\"line\">      display: block;</span><br><span class=\"line\">      box-sizing: content-box;</span><br><span class=\"line\">      width: 1px;</span><br><span class=\"line\">      height: 100%;</span><br><span class=\"line\">      padding: $border-width-base 0;</span><br><span class=\"line\">      background-color: $border-color-base;</span><br><span class=\"line\">      transition: background-color 0.3s;</span><br><span class=\"line\">      content: &apos;&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:first-child &#123;</span><br><span class=\"line\">    border-left: $border-width-base $border-style-base $border-color-base;</span><br><span class=\"line\">    border-radius: $border-radius-base 0 0 $border-radius-base;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:last-child &#123;</span><br><span class=\"line\">    border-radius: 0 $border-radius-base $border-radius-base 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:first-child:last-child &#123;</span><br><span class=\"line\">    border-radius: $border-radius-base;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:hover &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    color: $radio-dot-color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;:focus-within &#123;</span><br><span class=\"line\">    box-shadow: $radio-button-focus-shadow;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125;-inner,</span><br><span class=\"line\">  input[type=&apos;checkbox&apos;],</span><br><span class=\"line\">  input[type=&apos;radio&apos;] &#123;</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    height: 0;</span><br><span class=\"line\">    opacity: 0;</span><br><span class=\"line\">    pointer-events: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-checked:not(&amp;-disabled) &#123;</span><br><span class=\"line\">    z-index: 1;</span><br><span class=\"line\">    color: $radio-dot-color;</span><br><span class=\"line\">    background: $radio-button-checked-bg;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;::before &#123;</span><br><span class=\"line\">      background-color: $radio-dot-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      border-color: $radio-dot-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:hover &#123;</span><br><span class=\"line\">      color: $radio-button-hover-color;</span><br><span class=\"line\">      border-color: $radio-button-hover-color;</span><br><span class=\"line\">      &amp;::before &#123;</span><br><span class=\"line\">        background-color: $radio-button-hover-color;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:active &#123;</span><br><span class=\"line\">      color: $radio-button-active-color;</span><br><span class=\"line\">      border-color: $radio-button-active-color;</span><br><span class=\"line\">      &amp;::before &#123;</span><br><span class=\"line\">        background-color: $radio-button-active-color;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:focus-within &#123;</span><br><span class=\"line\">      box-shadow: $radio-button-focus-shadow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  .#&#123;$radio-group-prefix-cls&#125;-solid &amp;-checked:not(&amp;-disabled) &#123;</span><br><span class=\"line\">    color: $radio-solid-checked-color;</span><br><span class=\"line\">    background: $radio-dot-color;</span><br><span class=\"line\">    border-color: $radio-dot-color;</span><br><span class=\"line\">    &amp;:hover &#123;</span><br><span class=\"line\">      color: $radio-solid-checked-color;</span><br><span class=\"line\">      background: $radio-button-hover-color;</span><br><span class=\"line\">      border-color: $radio-button-hover-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:active &#123;</span><br><span class=\"line\">      color: $radio-solid-checked-color;</span><br><span class=\"line\">      background: $radio-button-active-color;</span><br><span class=\"line\">      border-color: $radio-button-active-color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:focus-within &#123;</span><br><span class=\"line\">      box-shadow: $radio-button-focus-shadow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-disabled &#123;</span><br><span class=\"line\">    color: $disabled-color;</span><br><span class=\"line\">    background-color: $disabled-bg;;</span><br><span class=\"line\">    border-color: $border-color-base;</span><br><span class=\"line\">    cursor: not-allowed;</span><br><span class=\"line\"></span><br><span class=\"line\">    &amp;:first-child,</span><br><span class=\"line\">    &amp;:hover &#123;</span><br><span class=\"line\">      color: $disabled-color;</span><br><span class=\"line\">      background-color: $disabled-bg;;</span><br><span class=\"line\">      border-color: $border-color-base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;:first-child &#123;</span><br><span class=\"line\">      border-left-color: $border-color-base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &amp;-disabled &amp;-checked &#123;</span><br><span class=\"line\">    color: $radio-disabled-button-checked-color;</span><br><span class=\"line\">    background-color: $radio-disabled-button-checked-bg;</span><br><span class=\"line\">    border-color: $border-color-base;</span><br><span class=\"line\">    box-shadow: none;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes antRadioEffect &#123;</span><br><span class=\"line\">  0% &#123;</span><br><span class=\"line\">    transform: scale(1);</span><br><span class=\"line\">    opacity: 0.5;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  100% &#123;</span><br><span class=\"line\">    transform: scale(1.6);</span><br><span class=\"line\">    opacity: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Firefox hack</span><br><span class=\"line\">@supports (-moz-appearance: meterbar) and (background-blend-mode: difference, normal) &#123;</span><br><span class=\"line\">  .#&#123;$radio-prefix-cls&#125; &#123;</span><br><span class=\"line\">    vertical-align: text-bottom;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 styles/variables/_radio.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@import &quot;./common&quot;;</span><br><span class=\"line\">// $font-size-base</span><br><span class=\"line\">$radio-wrapper-margin-right: 8px;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建 src/styles/index.scss文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// radio样式</span><br><span class=\"line\">@import &quot;../components/Radio/style&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来<a href=\"https://www.jianshu.com/p/1e262b487f26\" target=\"_blank\" rel=\"noopener\">[Typescript] 为第三方库添加声明文件 .d.ts</a></p>\n</li>\n<li><p>新建src/typings/index.d.ts文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// &lt;reference path=&quot;custom-typings.d.ts&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建src/typings/custom-typings.d.ts文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare module &apos;rc-checkbox&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改App.tsx文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 增加</span><br><span class=\"line\">import Radio from &quot;./components/Radio/radio&quot;;</span><br><span class=\"line\">&lt;Radio name=&quot;111&quot;&gt;Radio&lt;/Radio&gt;</span><br><span class=\"line\">&lt;Radio name=&quot;111&quot; disabled=&#123;true&#125;&gt;Radio2&lt;/Radio&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改index.tsx文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export &#123; default as Radio &#125; from &quot;./components/Radio&quot;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"三、-运行项目\"><a href=\"#三、-运行项目\" class=\"headerlink\" title=\"三、 运行项目\"></a>三、 运行项目</h2><p> 执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm start</span><br></pre></td></tr></table></figure></p>\n<p>访问项目 可以看到Radio组件成功了！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-7fc5a5e3af91ee81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"四、-单元测试\"><a href=\"#四、-单元测试\" class=\"headerlink\" title=\"四、 单元测试\"></a>四、 单元测试</h2><p>新建src/Radio/radio.test.tsx文件·<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; mount, render &#125; from &apos;enzyme&apos;;</span><br><span class=\"line\">import Radio, &#123; Group, Button &#125; from &apos;..&apos;;</span><br><span class=\"line\">import focusTest from &apos;../../../tests/shared/focusTest&apos;;</span><br><span class=\"line\">import mountTest from &apos;../../../tests/shared/mountTest&apos;;</span><br><span class=\"line\">import rtlTest from &apos;../../../tests/shared/rtlTest&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;Radio&apos;, () =&gt; &#123;</span><br><span class=\"line\">  focusTest(Radio, &#123; refFocus: true &#125;);</span><br><span class=\"line\">  mountTest(Radio);</span><br><span class=\"line\">  mountTest(Group);</span><br><span class=\"line\">  mountTest(Button);</span><br><span class=\"line\"></span><br><span class=\"line\">  rtlTest(Radio);</span><br><span class=\"line\">  rtlTest(Group);</span><br><span class=\"line\">  rtlTest(Button);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;should render correctly&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const wrapper = render(&lt;Radio className=&quot;customized&quot;&gt;Test&lt;/Radio&gt;);</span><br><span class=\"line\">    expect(wrapper).toMatchSnapshot();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&apos;responses hover events&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const onMouseEnter = jest.fn();</span><br><span class=\"line\">    const onMouseLeave = jest.fn();</span><br><span class=\"line\"></span><br><span class=\"line\">    const wrapper = mount(&lt;Radio onMouseEnter=&#123;onMouseEnter&#125; onMouseLeave=&#123;onMouseLeave&#125; /&gt;);</span><br><span class=\"line\"></span><br><span class=\"line\">    wrapper.find(&apos;label&apos;).simulate(&apos;mouseenter&apos;);</span><br><span class=\"line\">    expect(onMouseEnter).toHaveBeenCalled();</span><br><span class=\"line\"></span><br><span class=\"line\">    wrapper.find(&apos;label&apos;).simulate(&apos;mouseleave&apos;);</span><br><span class=\"line\">    expect(onMouseLeave).toHaveBeenCalled();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm test</span><br></pre></td></tr></table></figure></p>\n<p>可以看到单元测试成功通过！<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-44fe42fa111d9409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"五、编写storybook文档\"><a href=\"#五、编写storybook文档\" class=\"headerlink\" title=\"五、编写storybook文档\"></a>五、编写storybook文档</h2><ul>\n<li><p>新建<code>src/Radio/radio.stories.tsx</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import &#123; storiesOf &#125; from &apos;@storybook/react&apos;;</span><br><span class=\"line\">import &#123; action &#125; from &apos;@storybook/addon-actions&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">import Radio from &apos;./radio&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const defaultRadio = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Radio onClick=&#123;action(&apos;default Radio&apos;)&#125;&gt;default radio&lt;/Radio&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">const radioWithDisabled = () =&gt; (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;Radio onClick=&#123;action(&apos;disabled radio&apos;)&#125;   disabled=&#123;true&#125;&gt;disabled radio&lt;/Radio&gt;</span><br><span class=\"line\">        &lt;Radio onClick=&#123;action(&apos;unDisabled radio&apos;)&#125;  &gt;unDisabled radio&lt;/Radio&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">storiesOf(&apos;Radio 按钮&apos;, module)</span><br><span class=\"line\">    .addParameters(&#123;</span><br><span class=\"line\">        info: &#123;</span><br><span class=\"line\">            text: `</span><br><span class=\"line\">        ## 引用方法</span><br><span class=\"line\">        ~~~js</span><br><span class=\"line\">        import &#123;Radio&#125; from &apos;echo-rui</span><br><span class=\"line\">        ~~~</span><br><span class=\"line\">        `</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .add(&apos;默认 Radio&apos;, defaultRadio)</span><br><span class=\"line\">    .add(&apos;禁用的 Radio&apos;,radioWithDisabled)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run storybook</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>浏览器打开<a href=\"http://localhost:9009/,可以看到组件库文档生成了。\" target=\"_blank\" rel=\"noopener\">http://localhost:9009/,可以看到组件库文档生成了。</a><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-88eb962e94583778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"六、-发布到npm\"><a href=\"#六、-发布到npm\" class=\"headerlink\" title=\"六、 发布到npm\"></a>六、 发布到npm</h2><p> ✅ ✅ ✅ ✅ ✅</p>\n<p> 大功告成✌️✌️✌️</p>\n"},{"title":"关于前端请求的那些事","date":"2019-08-19T06:05:42.000Z","_content":"\nAuthor: Echo\nTime: 2019-08-19 14:05:42\n\n## 引言\n\n前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。\n\n## XMLHttpRequest\n\nXMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象\n```\nvar xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象\n```\n由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');  //IE5,6\n    } catch (e) {}\n  }\n}\n```\n使用XMLHttpRequest发起一个get请求\n```\n// get请求\nxhr.open(\"GET\",\"test1.txt\",true);\nxhr.send();\n```\n完整的post请求代码如下：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');\n    } catch (e) {}\n  }\n}\n\nif (xhr) {\n  xhr.onreadystatechange = onReadyStateChange;\n  xhr.open('POST', '/api', true);\n  // 设置 Content-Type 为 application/x-www-form-urlencoded\n  // 以表单的形式传递数据\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('username=admin&password=root');\n}\n\n// onreadystatechange 方法\nfunction onReadyStateChange() {\n  // 该函数会被调用四次\n  if (xhr.readyState === 4 &&xhr.status === 200) {\n    console.log('执行成功');\n  } else {\n    console.log('执行出错');\n  }\n}\n```\n## Jquery Ajax\n说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。\n```\n$.ajax({   //标准写法\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}\n});\n$.get(url,function(){}); //get请求\n$.post(url,body,function(){}); //post请求\n$.getJSON(url,function(){});  //get请求从服务器加载Json编码\n```\n#### 优点：\n* 对原生XHR的封装\n* 针对MVC的编程\n* 完美的兼容性\n* 支持jsonp\n#### 缺点：\n* 不符合MVVM\n* 异步模型不够现代，不支持链式，代码可读性差\n* 整个Jquery太大，引入成本过高\n\n## Fetch\nfetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。\n使用fetch的代码会相比xhr来说更具有条理性。\n\n```\nfetch(url).then(function(response) {\n  return response.json();\n}).then(function(data) {\n  console.log(data);\n}).catch(function(e) {\n  console.log(\"Oops, error\");\n});\n```\n在使用ES6的箭头函数后\n```\nfetch(url).then(response => response.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Oops, error\", e))\n```\n优点：\n\n* 更加底层，提供的API丰富（request, response）\n* 语法简单，脱离了XHR，基于ES新的Promise设计\n\n缺点：\n* 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：`es6-promise`,`babel-polyfill`,`fetch-ie8`等\n* 不支持jsonp，可以引入`fetch-jsonp `\n\n```\n安装 npm install fetch-jsonp --save-dev\n```\n```\n// 使用 \nfetchJsonp(url, {\n timeout: 3000, jsonpCallback: 'callback' \n}).then(function(response) { \n  console.log(response.json()); \n}).catch(function(e) { \n  console.log(e) \n});\n```\n\n- 没有拦截器，需要额外再封装一层或者`fetch-interceptor`\n- 默认不带cookie，需要添加配置\n\n```\nfetch(url,{\n  credentials: 'include'  \n  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域\n});\n```\n* 没有abort，不支持timeout超时处理\n可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。\n* 无法获取progress状态\nFetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.\n## Axios\naxios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。\n* 支持node，创建http请求\n* 支持Promise API\n* 客户端防止CSRF：每个请求带一个cookie拿到的key\n* 拦截请求和响应\n* 可取消请求\n兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。\n#### 安装:\n\n```\n//npm\nnpm install axios\n\n//cdn\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n```\n#### 基本使用如下：\n```\naxios({\n    method: 'GET',\n    url: url,\n})\n.then(res => {console.log(res)})\n.catch(err => {console.log(err)})\n\n// get请求\naxios.get(url)\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// post请求\naxios.post（‘/user’, {\n    name: 'Jerry',\n    lastName: 'Liang'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n## 如何选择（个人理解，仅供参考）[](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-)\n\n1.  首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。\n2.  如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。\n3.  如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。\n\n参考：[https://qianduan.group/posts/5bebe26f9fd64d5a7458a932](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932)\n\n","source":"_posts/request.md","raw":"---\ntitle: 关于前端请求的那些事\ndate: 2019-08-19 14:05:42\ntags: js\n---\n\nAuthor: Echo\nTime: 2019-08-19 14:05:42\n\n## 引言\n\n前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。\n\n## XMLHttpRequest\n\nXMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象\n```\nvar xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象\n```\n由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');  //IE5,6\n    } catch (e) {}\n  }\n}\n```\n使用XMLHttpRequest发起一个get请求\n```\n// get请求\nxhr.open(\"GET\",\"test1.txt\",true);\nxhr.send();\n```\n完整的post请求代码如下：\n```\nvar xhr;\nif (window.XMLHttpRequest) { // Mozilla, Safari...\n  xhr = new XMLHttpRequest();\n} else if (window.ActiveXObject) { // IE\n  try {\n    xhr = new ActiveXObject('Msxml2.XMLHTTP');\n  } catch (e) {\n    try {\n      xhr = new ActiveXObject('Microsoft.XMLHTTP');\n    } catch (e) {}\n  }\n}\n\nif (xhr) {\n  xhr.onreadystatechange = onReadyStateChange;\n  xhr.open('POST', '/api', true);\n  // 设置 Content-Type 为 application/x-www-form-urlencoded\n  // 以表单的形式传递数据\n  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  xhr.send('username=admin&password=root');\n}\n\n// onreadystatechange 方法\nfunction onReadyStateChange() {\n  // 该函数会被调用四次\n  if (xhr.readyState === 4 &&xhr.status === 200) {\n    console.log('执行成功');\n  } else {\n    console.log('执行出错');\n  }\n}\n```\n## Jquery Ajax\n说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。\n```\n$.ajax({   //标准写法\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}\n});\n$.get(url,function(){}); //get请求\n$.post(url,body,function(){}); //post请求\n$.getJSON(url,function(){});  //get请求从服务器加载Json编码\n```\n#### 优点：\n* 对原生XHR的封装\n* 针对MVC的编程\n* 完美的兼容性\n* 支持jsonp\n#### 缺点：\n* 不符合MVVM\n* 异步模型不够现代，不支持链式，代码可读性差\n* 整个Jquery太大，引入成本过高\n\n## Fetch\nfetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。\n使用fetch的代码会相比xhr来说更具有条理性。\n\n```\nfetch(url).then(function(response) {\n  return response.json();\n}).then(function(data) {\n  console.log(data);\n}).catch(function(e) {\n  console.log(\"Oops, error\");\n});\n```\n在使用ES6的箭头函数后\n```\nfetch(url).then(response => response.json())\n  .then(data => console.log(data))\n  .catch(e => console.log(\"Oops, error\", e))\n```\n优点：\n\n* 更加底层，提供的API丰富（request, response）\n* 语法简单，脱离了XHR，基于ES新的Promise设计\n\n缺点：\n* 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：`es6-promise`,`babel-polyfill`,`fetch-ie8`等\n* 不支持jsonp，可以引入`fetch-jsonp `\n\n```\n安装 npm install fetch-jsonp --save-dev\n```\n```\n// 使用 \nfetchJsonp(url, {\n timeout: 3000, jsonpCallback: 'callback' \n}).then(function(response) { \n  console.log(response.json()); \n}).catch(function(e) { \n  console.log(e) \n});\n```\n\n- 没有拦截器，需要额外再封装一层或者`fetch-interceptor`\n- 默认不带cookie，需要添加配置\n\n```\nfetch(url,{\n  credentials: 'include'  \n  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域\n});\n```\n* 没有abort，不支持timeout超时处理\n可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。\n* 无法获取progress状态\nFetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.\n## Axios\naxios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。\n* 支持node，创建http请求\n* 支持Promise API\n* 客户端防止CSRF：每个请求带一个cookie拿到的key\n* 拦截请求和响应\n* 可取消请求\n兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。\n#### 安装:\n\n```\n//npm\nnpm install axios\n\n//cdn\n<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>\n```\n#### 基本使用如下：\n```\naxios({\n    method: 'GET',\n    url: url,\n})\n.then(res => {console.log(res)})\n.catch(err => {console.log(err)})\n\n// get请求\naxios.get(url)\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n\n// post请求\naxios.post（‘/user’, {\n    name: 'Jerry',\n    lastName: 'Liang'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\n```\n## 如何选择（个人理解，仅供参考）[](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-)\n\n1.  首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。\n2.  如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。\n3.  如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。\n\n参考：[https://qianduan.group/posts/5bebe26f9fd64d5a7458a932](https://qianduan.group/posts/5bebe26f9fd64d5a7458a932)\n\n","slug":"request","published":1,"updated":"2019-12-04T12:50:48.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjrw002a78p3r62sou67","content":"<p>Author: Echo<br>Time: 2019-08-19 14:05:42</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。</p>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h2><p>XMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象</span><br></pre></td></tr></table></figure></p>\n<p>由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  //IE5,6</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用XMLHttpRequest发起一个get请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// get请求</span><br><span class=\"line\">xhr.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure></p>\n<p>完整的post请求代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (xhr) &#123;</span><br><span class=\"line\">  xhr.onreadystatechange = onReadyStateChange;</span><br><span class=\"line\">  xhr.open(&apos;POST&apos;, &apos;/api&apos;, true);</span><br><span class=\"line\">  // 设置 Content-Type 为 application/x-www-form-urlencoded</span><br><span class=\"line\">  // 以表单的形式传递数据</span><br><span class=\"line\">  xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class=\"line\">  xhr.send(&apos;username=admin&amp;password=root&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// onreadystatechange 方法</span><br><span class=\"line\">function onReadyStateChange() &#123;</span><br><span class=\"line\">  // 该函数会被调用四次</span><br><span class=\"line\">  if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123;</span><br><span class=\"line\">    console.log(&apos;执行成功&apos;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;执行出错&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Jquery-Ajax\"><a href=\"#Jquery-Ajax\" class=\"headerlink\" title=\"Jquery Ajax\"></a>Jquery Ajax</h2><p>说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;   //标准写法</span><br><span class=\"line\">   type: &apos;POST&apos;,</span><br><span class=\"line\">   url: url,</span><br><span class=\"line\">   data: data,</span><br><span class=\"line\">   dataType: dataType,</span><br><span class=\"line\">   success: function () &#123;&#125;,</span><br><span class=\"line\">   error: function () &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$.get(url,function()&#123;&#125;); //get请求</span><br><span class=\"line\">$.post(url,body,function()&#123;&#125;); //post请求</span><br><span class=\"line\">$.getJSON(url,function()&#123;&#125;);  //get请求从服务器加载Json编码</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>对原生XHR的封装</li>\n<li>针对MVC的编程</li>\n<li>完美的兼容性</li>\n<li>支持jsonp<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4></li>\n<li>不符合MVVM</li>\n<li>异步模型不够现代，不支持链式，代码可读性差</li>\n<li>整个Jquery太大，引入成本过高</li>\n</ul>\n<h2 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h2><p>fetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。<br>使用fetch的代码会相比xhr来说更具有条理性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(function(response) &#123;</span><br><span class=\"line\">  return response.json();</span><br><span class=\"line\">&#125;).then(function(data) &#123;</span><br><span class=\"line\">  console.log(data);</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Oops, error&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在使用ES6的箭头函数后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(response =&gt; response.json())</span><br><span class=\"line\">  .then(data =&gt; console.log(data))</span><br><span class=\"line\">  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>更加底层，提供的API丰富（request, response）</li>\n<li>语法简单，脱离了XHR，基于ES新的Promise设计</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：<code>es6-promise</code>,<code>babel-polyfill</code>,<code>fetch-ie8</code>等</li>\n<li>不支持jsonp，可以引入<code>fetch-jsonp</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装 npm install fetch-jsonp --save-dev</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 </span><br><span class=\"line\">fetchJsonp(url, &#123;</span><br><span class=\"line\"> timeout: 3000, jsonpCallback: &apos;callback&apos; </span><br><span class=\"line\">&#125;).then(function(response) &#123; </span><br><span class=\"line\">  console.log(response.json()); </span><br><span class=\"line\">&#125;).catch(function(e) &#123; </span><br><span class=\"line\">  console.log(e) </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有拦截器，需要额外再封装一层或者<code>fetch-interceptor</code></li>\n<li>默认不带cookie，需要添加配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url,&#123;</span><br><span class=\"line\">  credentials: &apos;include&apos;  </span><br><span class=\"line\">  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有abort，不支持timeout超时处理<br>可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。</li>\n<li>无法获取progress状态<br>Fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.<h2 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h2>axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。</li>\n<li>支持node，创建http请求</li>\n<li>支持Promise API</li>\n<li>客户端防止CSRF：每个请求带一个cookie拿到的key</li>\n<li>拦截请求和响应</li>\n<li>可取消请求<br>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装:\"></a>安装:</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//npm</span><br><span class=\"line\">npm install axios</span><br><span class=\"line\"></span><br><span class=\"line\">//cdn</span><br><span class=\"line\">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本使用如下：\"><a href=\"#基本使用如下：\" class=\"headerlink\" title=\"基本使用如下：\"></a>基本使用如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class=\"line\">.catch(err =&gt; &#123;console.log(err)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// get请求</span><br><span class=\"line\">axios.get(url)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// post请求</span><br><span class=\"line\">axios.post（‘/user’, &#123;</span><br><span class=\"line\">    name: &apos;Jerry&apos;,</span><br><span class=\"line\">    lastName: &apos;Liang&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何选择（个人理解，仅供参考）\"><a href=\"#如何选择（个人理解，仅供参考）\" class=\"headerlink\" title=\"如何选择（个人理解，仅供参考）\"></a>如何选择（个人理解，仅供参考）<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-\" target=\"_blank\" rel=\"noopener\"></a></h2><ol>\n<li>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。</li>\n<li>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。</li>\n<li>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。</li>\n</ol>\n<p>参考：<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932\" target=\"_blank\" rel=\"noopener\">https://qianduan.group/posts/5bebe26f9fd64d5a7458a932</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-08-19 14:05:42</p>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。</p>\n<h2 id=\"XMLHttpRequest\"><a href=\"#XMLHttpRequest\" class=\"headerlink\" title=\"XMLHttpRequest\"></a>XMLHttpRequest</h2><p>XMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象</span><br></pre></td></tr></table></figure></p>\n<p>由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  //IE5,6</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用XMLHttpRequest发起一个get请求<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// get请求</span><br><span class=\"line\">xhr.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure></p>\n<p>完整的post请求代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xhr;</span><br><span class=\"line\">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class=\"line\">  xhr = new XMLHttpRequest();</span><br><span class=\"line\">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class=\"line\">  &#125; catch (e) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class=\"line\">    &#125; catch (e) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (xhr) &#123;</span><br><span class=\"line\">  xhr.onreadystatechange = onReadyStateChange;</span><br><span class=\"line\">  xhr.open(&apos;POST&apos;, &apos;/api&apos;, true);</span><br><span class=\"line\">  // 设置 Content-Type 为 application/x-www-form-urlencoded</span><br><span class=\"line\">  // 以表单的形式传递数据</span><br><span class=\"line\">  xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class=\"line\">  xhr.send(&apos;username=admin&amp;password=root&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// onreadystatechange 方法</span><br><span class=\"line\">function onReadyStateChange() &#123;</span><br><span class=\"line\">  // 该函数会被调用四次</span><br><span class=\"line\">  if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123;</span><br><span class=\"line\">    console.log(&apos;执行成功&apos;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    console.log(&apos;执行出错&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Jquery-Ajax\"><a href=\"#Jquery-Ajax\" class=\"headerlink\" title=\"Jquery Ajax\"></a>Jquery Ajax</h2><p>说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;   //标准写法</span><br><span class=\"line\">   type: &apos;POST&apos;,</span><br><span class=\"line\">   url: url,</span><br><span class=\"line\">   data: data,</span><br><span class=\"line\">   dataType: dataType,</span><br><span class=\"line\">   success: function () &#123;&#125;,</span><br><span class=\"line\">   error: function () &#123;&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">$.get(url,function()&#123;&#125;); //get请求</span><br><span class=\"line\">$.post(url,body,function()&#123;&#125;); //post请求</span><br><span class=\"line\">$.getJSON(url,function()&#123;&#125;);  //get请求从服务器加载Json编码</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>对原生XHR的封装</li>\n<li>针对MVC的编程</li>\n<li>完美的兼容性</li>\n<li>支持jsonp<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4></li>\n<li>不符合MVVM</li>\n<li>异步模型不够现代，不支持链式，代码可读性差</li>\n<li>整个Jquery太大，引入成本过高</li>\n</ul>\n<h2 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h2><p>fetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。<br>使用fetch的代码会相比xhr来说更具有条理性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(function(response) &#123;</span><br><span class=\"line\">  return response.json();</span><br><span class=\"line\">&#125;).then(function(data) &#123;</span><br><span class=\"line\">  console.log(data);</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(&quot;Oops, error&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在使用ES6的箭头函数后<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url).then(response =&gt; response.json())</span><br><span class=\"line\">  .then(data =&gt; console.log(data))</span><br><span class=\"line\">  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ul>\n<li>更加底层，提供的API丰富（request, response）</li>\n<li>语法简单，脱离了XHR，基于ES新的Promise设计</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：<code>es6-promise</code>,<code>babel-polyfill</code>,<code>fetch-ie8</code>等</li>\n<li>不支持jsonp，可以引入<code>fetch-jsonp</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">安装 npm install fetch-jsonp --save-dev</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 使用 </span><br><span class=\"line\">fetchJsonp(url, &#123;</span><br><span class=\"line\"> timeout: 3000, jsonpCallback: &apos;callback&apos; </span><br><span class=\"line\">&#125;).then(function(response) &#123; </span><br><span class=\"line\">  console.log(response.json()); </span><br><span class=\"line\">&#125;).catch(function(e) &#123; </span><br><span class=\"line\">  console.log(e) </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有拦截器，需要额外再封装一层或者<code>fetch-interceptor</code></li>\n<li>默认不带cookie，需要添加配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(url,&#123;</span><br><span class=\"line\">  credentials: &apos;include&apos;  </span><br><span class=\"line\">  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>没有abort，不支持timeout超时处理<br>可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。</li>\n<li>无法获取progress状态<br>Fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.<h2 id=\"Axios\"><a href=\"#Axios\" class=\"headerlink\" title=\"Axios\"></a>Axios</h2>axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。</li>\n<li>支持node，创建http请求</li>\n<li>支持Promise API</li>\n<li>客户端防止CSRF：每个请求带一个cookie拿到的key</li>\n<li>拦截请求和响应</li>\n<li>可取消请求<br>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装:\"></a>安装:</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//npm</span><br><span class=\"line\">npm install axios</span><br><span class=\"line\"></span><br><span class=\"line\">//cdn</span><br><span class=\"line\">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本使用如下：\"><a href=\"#基本使用如下：\" class=\"headerlink\" title=\"基本使用如下：\"></a>基本使用如下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios(&#123;</span><br><span class=\"line\">    method: &apos;GET&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class=\"line\">.catch(err =&gt; &#123;console.log(err)&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// get请求</span><br><span class=\"line\">axios.get(url)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// post请求</span><br><span class=\"line\">axios.post（‘/user’, &#123;</span><br><span class=\"line\">    name: &apos;Jerry&apos;,</span><br><span class=\"line\">    lastName: &apos;Liang&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何选择（个人理解，仅供参考）\"><a href=\"#如何选择（个人理解，仅供参考）\" class=\"headerlink\" title=\"如何选择（个人理解，仅供参考）\"></a>如何选择（个人理解，仅供参考）<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-\" target=\"_blank\" rel=\"noopener\"></a></h2><ol>\n<li>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。</li>\n<li>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。</li>\n<li>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。</li>\n</ol>\n<p>参考：<a href=\"https://qianduan.group/posts/5bebe26f9fd64d5a7458a932\" target=\"_blank\" rel=\"noopener\">https://qianduan.group/posts/5bebe26f9fd64d5a7458a932</a></p>\n"},{"title":"vue项目中引入全局scss变量","date":"2020-11-20T06:34:56.000Z","_content":"vue项目中设置全局引入scss，使每个组件都可以使用变量\n\n在Vue项目中使用scss,如果写了一套完整的有变量的scss文件。那么就需要全局引入，这样在每个组件中使用。\n可以在`main.js`全局引入，下面是使用方法。\n\n1： 安装`node-sass`、`sass-loader`、`style-loader`\n```\nnpm install node-sass --save-dev\nnpm install sass-loader --save-dev\nnpm install style-loader --save-dev \n```\n\n2： 安装`sass-resources-loader` （如果不安装的话变量会报错）\n\n```\nnpm install sass-resources-loader --save-dev\n```\n\n3： 修改build中的`utils.js`\n```\nscss: generateLoaders('sass'),\n\n// 修改成:\n\nscss: generateLoaders('sass').concat(\n  {\n    loader: 'sass-resources-loader',\n    options: {\n      resources: path.resolve(__dirname, '../src/assets/main.scss') //这里写自己的文件路径\n    }\n  }\n)\n```\n在main.js里面引入即可。 或者是不在main.js引入，单独在组件引入也可以。 在组件中的style标签添加`lang=\"scss\"`。\n\n大功告成✌️✌️✌️\n","source":"_posts/scss1.md","raw":"---\ntitle: vue项目中引入全局scss变量\ndate: 2020-11-20 14:34:56\ntags: Vue\n---\nvue项目中设置全局引入scss，使每个组件都可以使用变量\n\n在Vue项目中使用scss,如果写了一套完整的有变量的scss文件。那么就需要全局引入，这样在每个组件中使用。\n可以在`main.js`全局引入，下面是使用方法。\n\n1： 安装`node-sass`、`sass-loader`、`style-loader`\n```\nnpm install node-sass --save-dev\nnpm install sass-loader --save-dev\nnpm install style-loader --save-dev \n```\n\n2： 安装`sass-resources-loader` （如果不安装的话变量会报错）\n\n```\nnpm install sass-resources-loader --save-dev\n```\n\n3： 修改build中的`utils.js`\n```\nscss: generateLoaders('sass'),\n\n// 修改成:\n\nscss: generateLoaders('sass').concat(\n  {\n    loader: 'sass-resources-loader',\n    options: {\n      resources: path.resolve(__dirname, '../src/assets/main.scss') //这里写自己的文件路径\n    }\n  }\n)\n```\n在main.js里面引入即可。 或者是不在main.js引入，单独在组件引入也可以。 在组件中的style标签添加`lang=\"scss\"`。\n\n大功告成✌️✌️✌️\n","slug":"scss1","published":1,"updated":"2020-12-14T08:50:31.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjry002c78p3wkb181dv","content":"<p>vue项目中设置全局引入scss，使每个组件都可以使用变量</p>\n<p>在Vue项目中使用scss,如果写了一套完整的有变量的scss文件。那么就需要全局引入，这样在每个组件中使用。<br>可以在<code>main.js</code>全局引入，下面是使用方法。</p>\n<p>1： 安装<code>node-sass</code>、<code>sass-loader</code>、<code>style-loader</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install node-sass --save-dev</span><br><span class=\"line\">npm install sass-loader --save-dev</span><br><span class=\"line\">npm install style-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>2： 安装<code>sass-resources-loader</code> （如果不安装的话变量会报错）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install sass-resources-loader --save-dev</span><br></pre></td></tr></table></figure>\n<p>3： 修改build中的<code>utils.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scss: generateLoaders(&apos;sass&apos;),</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改成:</span><br><span class=\"line\"></span><br><span class=\"line\">scss: generateLoaders(&apos;sass&apos;).concat(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    loader: &apos;sass-resources-loader&apos;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">      resources: path.resolve(__dirname, &apos;../src/assets/main.scss&apos;) //这里写自己的文件路径</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>在main.js里面引入即可。 或者是不在main.js引入，单独在组件引入也可以。 在组件中的style标签添加<code>lang=&quot;scss&quot;</code>。</p>\n<p>大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<p>vue项目中设置全局引入scss，使每个组件都可以使用变量</p>\n<p>在Vue项目中使用scss,如果写了一套完整的有变量的scss文件。那么就需要全局引入，这样在每个组件中使用。<br>可以在<code>main.js</code>全局引入，下面是使用方法。</p>\n<p>1： 安装<code>node-sass</code>、<code>sass-loader</code>、<code>style-loader</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install node-sass --save-dev</span><br><span class=\"line\">npm install sass-loader --save-dev</span><br><span class=\"line\">npm install style-loader --save-dev</span><br></pre></td></tr></table></figure></p>\n<p>2： 安装<code>sass-resources-loader</code> （如果不安装的话变量会报错）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install sass-resources-loader --save-dev</span><br></pre></td></tr></table></figure>\n<p>3： 修改build中的<code>utils.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scss: generateLoaders(&apos;sass&apos;),</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改成:</span><br><span class=\"line\"></span><br><span class=\"line\">scss: generateLoaders(&apos;sass&apos;).concat(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    loader: &apos;sass-resources-loader&apos;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">      resources: path.resolve(__dirname, &apos;../src/assets/main.scss&apos;) //这里写自己的文件路径</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>在main.js里面引入即可。 或者是不在main.js引入，单独在组件引入也可以。 在组件中的style标签添加<code>lang=&quot;scss&quot;</code>。</p>\n<p>大功告成✌️✌️✌️</p>\n"},{"title":"虚拟dom","date":"2019-09-20T03:05:02.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 11:05:02\n\n##### 什么是虚拟DOM树？（Virtual DOM）\nvirtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。\n虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的\n* 当页面渲染的时候Vue会创建一颗虚拟DOM树\n* 当页面发生改变Vue会再创建一颗新的虚拟DOM树\n* 前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方\n* 将有差异的地方更新到真实的DOM树中\n##### 虚拟DOM树有什么用？　\nvue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 -------虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。\n\n可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。\n##### Vue  v-for 中 :key 到底有什么用？\nvue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。\nkey的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元\n\n参考链接： https://www.cnblogs.com/javascript9527/p/11327924.html\n\n实现一个Virtual DOM算法参考链接： https://www.cnblogs.com/ssw-men/p/10818585.html","source":"_posts/virtualDom.md","raw":"---\ntitle: 虚拟dom\ndate: 2019-09-20 11:05:02\ntags: vue\n---\n\nAuthor: Echo\nTime: 2019-09-20 11:05:02\n\n##### 什么是虚拟DOM树？（Virtual DOM）\nvirtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。\n虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的\n* 当页面渲染的时候Vue会创建一颗虚拟DOM树\n* 当页面发生改变Vue会再创建一颗新的虚拟DOM树\n* 前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方\n* 将有差异的地方更新到真实的DOM树中\n##### 虚拟DOM树有什么用？　\nvue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 -------虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。\n\n可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。\n##### Vue  v-for 中 :key 到底有什么用？\nvue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。\nkey的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元\n\n参考链接： https://www.cnblogs.com/javascript9527/p/11327924.html\n\n实现一个Virtual DOM算法参考链接： https://www.cnblogs.com/ssw-men/p/10818585.html","slug":"virtualDom","published":1,"updated":"2019-12-04T12:50:48.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjs0002f78p3edkaf99u","content":"<p>Author: Echo<br>Time: 2019-09-20 11:05:02</p>\n<h5 id=\"什么是虚拟DOM树？（Virtual-DOM）\"><a href=\"#什么是虚拟DOM树？（Virtual-DOM）\" class=\"headerlink\" title=\"什么是虚拟DOM树？（Virtual DOM）\"></a>什么是虚拟DOM树？（Virtual DOM）</h5><p>virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的</p>\n<ul>\n<li>当页面渲染的时候Vue会创建一颗虚拟DOM树</li>\n<li>当页面发生改变Vue会再创建一颗新的虚拟DOM树</li>\n<li>前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方</li>\n<li>将有差异的地方更新到真实的DOM树中<h5 id=\"虚拟DOM树有什么用？\"><a href=\"#虚拟DOM树有什么用？\" class=\"headerlink\" title=\"虚拟DOM树有什么用？　\"></a>虚拟DOM树有什么用？　</h5>vue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 ——-虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。</li>\n</ul>\n<p>可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。</p>\n<h5 id=\"Vue-v-for-中-key-到底有什么用？\"><a href=\"#Vue-v-for-中-key-到底有什么用？\" class=\"headerlink\" title=\"Vue  v-for 中 :key 到底有什么用？\"></a>Vue  v-for 中 :key 到底有什么用？</h5><p>vue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。<br>key的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元</p>\n<p>参考链接： <a href=\"https://www.cnblogs.com/javascript9527/p/11327924.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/javascript9527/p/11327924.html</a></p>\n<p>实现一个Virtual DOM算法参考链接： <a href=\"https://www.cnblogs.com/ssw-men/p/10818585.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ssw-men/p/10818585.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 11:05:02</p>\n<h5 id=\"什么是虚拟DOM树？（Virtual-DOM）\"><a href=\"#什么是虚拟DOM树？（Virtual-DOM）\" class=\"headerlink\" title=\"什么是虚拟DOM树？（Virtual DOM）\"></a>什么是虚拟DOM树？（Virtual DOM）</h5><p>virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的</p>\n<ul>\n<li>当页面渲染的时候Vue会创建一颗虚拟DOM树</li>\n<li>当页面发生改变Vue会再创建一颗新的虚拟DOM树</li>\n<li>前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方</li>\n<li>将有差异的地方更新到真实的DOM树中<h5 id=\"虚拟DOM树有什么用？\"><a href=\"#虚拟DOM树有什么用？\" class=\"headerlink\" title=\"虚拟DOM树有什么用？　\"></a>虚拟DOM树有什么用？　</h5>vue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 ——-虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。</li>\n</ul>\n<p>可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。</p>\n<h5 id=\"Vue-v-for-中-key-到底有什么用？\"><a href=\"#Vue-v-for-中-key-到底有什么用？\" class=\"headerlink\" title=\"Vue  v-for 中 :key 到底有什么用？\"></a>Vue  v-for 中 :key 到底有什么用？</h5><p>vue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。<br>key的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元</p>\n<p>参考链接： <a href=\"https://www.cnblogs.com/javascript9527/p/11327924.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/javascript9527/p/11327924.html</a></p>\n<p>实现一个Virtual DOM算法参考链接： <a href=\"https://www.cnblogs.com/ssw-men/p/10818585.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ssw-men/p/10818585.html</a></p>\n"},{"title":"搭建Vue的SSR服务端渲染","date":"2020-05-19T03:13:15.000Z","_content":"\nAuthor: Echo\nTime: 2020-05-19 11:13:15\n\n## SSR是什么\n---\n`SSR`：Server Side Rendering\n服务端渲染，由服务器进行渲染并返回给客户端渲染完成的html\n* 优点\n超快的响应速度\n易做SEO\n* 缺点\n增加服务器压力\n* 主流框架\nNext.js —— React的SSR方案\nNuxt.js —— Vue的SSR方案\n### SPA是什么\n---\nSPA：single page application\n按照字面意思就是单页面应用，通俗点就是整个网站由一个html页面构成。\n\n######  传统的vue/react项目纯浏览器渲染步骤\n1. 浏览器输入url  -> 发送请求到服务器\n2. 服务器接收到请求 -> 发送项目的index.html + app.bundle.js文件给浏览器\n3. 浏览器执行js,生成dom，渲染dom,发送请求，接收请求，解析数据，操作数据，重新渲染\n\n* SPA缺点 \n1. 如果没有进行异步请求，首屏加载过慢。（因为要一次性加载多种依赖和包）\n2.缺少SEO， 难以进行搜索引擎优化（对于爬虫来说，它仅仅获取到了2个标签，而没有页面真实呈现内容的信息）\n3. 性能问题\n* SPA优点\n1. 带来接近原生的体验\n2. 前后端分离\n3. 服务器压力小 响应速度快\n\n######  进行ssr的vue/react项目浏览器渲染步骤\n1. 浏览器输入url  -> 发送请求到服务器\n2. 服务器(node服务)接收到请求 -> 解析对应的js文件，生成对应的html->发送给浏览器\n3. 浏览器接收并渲染html\n\n## SSR需要哪些配置\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5d9692de712dd7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 搭建Vue的SSR服务端渲染\n---\n\n在vue项目过中安装vue-server-renderer\n```\n $ npm i vue-server-renderer\n$ npm i server\n```\n在vue项目中创建server.js文件\nserver.js文件的内容为：\n```\n/* server.js */\nconst Vue = require('vue');\nconst server = require('express')();\nconst renderer = require('vue-server-renderer').createRenderer();\nconst fs = require('fs');\n\nfunction createApp(url) {\n  if (url == '/') {\n    url = '/index'\n  }\n  let json = fs.readFileSync(`json${url}.json`,'utf_8');\n  let template = fs.readFileSync(`template${url}.html`,'utf_8');\n  return new Vue({\n    template: template,\n    data: JSON.parse(json).data\n  })\n}\n// 响应路由请求\nserver.get('*', (req, res) => {\n  if (req.url !=='/favicon.ico') {\n    const app = createApp(req.url);\n    renderer.renderToString(app, (err, html) => {\n      if (err) { return res.state(500).end('运行时错误') }\n      res.send(html);\n    });\n  }\n});\n\n// 服务器监听地址\nserver.listen(8080, () => {\n    console.log('服务器已启动！')\n});\n```\n目录结构\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-73a701ecb005919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-7853336351f039c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n/* index.js */\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Index</title>\n</head>\n<body>\n  {{a}}\n</body>\n</html>\n/* index.json */\n{\n  \"data\": {\"a\": 1}\n}\n```\n\n执行命令\n```\n$ node server.js\n```\n打开浏览器，地址栏输入：\n\n```\nlocalhost:8080\n```\n\n我们可以看到，页面加载成功\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-94029c331dae155a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-106520d374bea6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 对原有的Vue项目改造成SSR\n---\n1. 在src文件下新建`server.js` + `client.js`\n2. 在根目录下新建`index.ssr.html`\n\n```\n/* index.ssr.html*/\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n<!-- 注意⚠️！！！⬇️下面注释不能少：如果没有，服务器就不知道将生成好的html代码插在什么位置-->\n  <!--vue-ssr-outlet-->\n  <script type=\"text/javescript\" src=\"<%= htmlWebpackPlugin.options.files.js %>\"></script>\n</body>\n</html>\n```\n3. 对router部分进行改造\n* 将路由改造成方法\n```\n// export default router;\nexport function createRouter(){\n  return new VueRouter({\n    mode: \"history\",\n    base: process.env.BASE_URL,\n    routes\n  });\n};\n```\n4. 对main.js进行改造\n* 引入createRouter\n* 将main.js改造成方法\n```\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// import router from \"./router\";\nimport { createRouter } from \"./router\";\nconst router = createRouter();\n// new Vue({\n//   router,\n//   store,\n//   render: h => h(App)\n// }).$mount(\"#app\");\nexport function createApp(){\n  const app = new Vue({\n    router,\n    store,\n    render: h => h(App)\n  });\n  return {app, router}\n};\n```\n** 为什么将main.js和router改造成方法？ 回答：方便调用！**\n5. server.js\n由于sever.js是在服务端运行，我们将代码形成node格式\n```\nimport { createApp } from \"./main\";\n// context = req (服务端的request)\nexport function context=>{\n  return new Promise((resolve, reject)=> {\n    const {app, router} = createApp();\n    // 将当前的请求路径添加到路由表中，\n    router.push(context.url);\n    router.onReady(() => {\n      const matchCcmponents = router.getMatchedComponents(path);\n      if (!matchCcmponents.length) {\n        return reject({code: 404})\n      }\n      resolve(app)\n    }, reject);\n  })\n};\n```\n\n6. client.js\n```\nimport { createApp } from \"./main\";\nconst {app, router} = createApp();\nrouter.onReady(() => {\n  // 手动挂载;\n  app.$mount('#app');\n});\n```\n7. 在build新建`webpack.buildclinet.js`+`webpack.buildserver.js`\n8. webpack.buildserver.js\n`webpack.buildserver.js`类似于`webpack.prod.conf.js`\n对部分内容进行改造：\n\n```\nvar VueSSRServerPlugin = require('vue-server-renderer/server-plugin')\n\n \n// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry\n  entry: {\n    app: './src/server.js'\n  },\n  // 打包之后的结果是在服务端运行的。\n  target: 'node',\n  output: {\n    // 打包之后的文件的模块化规范，遵循node的模块化规范\n    libraryTarget: \"commonjs2\"\n  },\n   new HtmlWebpackPlugin({\n      filename: 'index.srr.html',\n      template: 'index.srr.html',\n      inject: true,\n      files: {\n        js: 'app.js'\n      },\n     // 注意⚠️！！！删除掉压缩部分配置代码⬇️：为什么不能压缩，看第2步的解释（你能找到解释么？嘿嘿）！\n      // minify: {\n        //removeComments: true,\n         //collapseWhitespace: true,\n        //removeAttributeQuotes: true\n      //},\n      chunksSortMode: 'dependency'\n   }),\n  plugins: [\n    // 插件作用：对服务端代码进行打包\n    new VueSSRServerPlugin(),\n ......\n```\n\n9. webpack.buildclient.js\n`webpack.buildclient.js`类似于`webpack.prod.conf.js`\n对部分内容进行改造：\n```\nvar VueSSRClientPlugin = require('vue-server-renderer/client-plugin')\n\n// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry\n  entry: {\n    app: './src/client.js'\n  },\n// 注意⚠️！！！删掉出口配置output:\n\n  plugins: [\n    // 插件作用：对客户端代码进行打包\n    new VueSSRClientPlugin(),\n ......\n```\n\n10. 增加打包命令\n\n```\n\"build:client\": \"webpack --config build/webpack.buildclient.js\"\n\"build:server\": \"webpack --config build/webpack.buildserver.js\"\n```\n11. 执行打包命令\n\n```\n$ npm run build:server\n$ npm run build:client\n```\n打包之后结果\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c96aecf8bdcde96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2bcceeefe888efaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 12 编写server\n* 在根目录下新建server文件夹 + `server.js`\nserver.js\n```\nconst express = require('express');\nconst server = express();\nconst {createBundleRenderer} = require('vue-server-renderder');\nconst path = require('path');\nconst fs = require('fs');\nconst serverBundle = require(path.resolve(__dirname, '../dist/vue-ssr-server-bundle.json'));\nconst clientManifest = require(path.resolve(__dirname, '../dist/vue-ssr-client-manifest.json'));\nconst template= fs.readFileSync(path.resolve(__dirname, '..dist/index.ssr.html'), 'utf-8');\n// 打包出来的json的作用：通知服务器如何分割js,部分js用于客户端执行，部分js用于服务端运行。\nconst renderer = createBundleRenderer(serverBundle,{\n  runInNewContext: false,\n  template:template,\n  clientManifest:clientManifest\n});\n// 设置静态目录，以dist文件夹为静态目录，dist文件夹在服务开始之后可以访问\nserver.use(express.static(path.resolve(__dirname, '../dist')));\n// 设置路由\nserver.get('*',(req,res)=>{\n  if (req.url !=='/favicon.ico') {\n    const context = {url: req.url};\n    // 在项目中生成的html文件巨大，通过流的方式处理大的文件\n    const ssrstream = renderer.renderToStream(context);\n    let buffers = [];\n    ssrstream.on('error', (err) => {\n      console.log(err);\n    });\n    ssrstream.on('data', (data) => buffers.push(data));\n    ssrstream.on('end', () => {\n      res.end(Buffer.concat(buffers));\n    });\n  }\n});\nserver.listen(2000);\n```\n\n## 13 node 运行server.js\n\n```\n$ node server.js\n```\n项目运行之后，会发现切换页面，都会重新请求页面刷新。\n","source":"_posts/ssr.md","raw":"---\ntitle: 搭建Vue的SSR服务端渲染\ndate: 2020-05-19 11:13:15\ntags:\n---\n\nAuthor: Echo\nTime: 2020-05-19 11:13:15\n\n## SSR是什么\n---\n`SSR`：Server Side Rendering\n服务端渲染，由服务器进行渲染并返回给客户端渲染完成的html\n* 优点\n超快的响应速度\n易做SEO\n* 缺点\n增加服务器压力\n* 主流框架\nNext.js —— React的SSR方案\nNuxt.js —— Vue的SSR方案\n### SPA是什么\n---\nSPA：single page application\n按照字面意思就是单页面应用，通俗点就是整个网站由一个html页面构成。\n\n######  传统的vue/react项目纯浏览器渲染步骤\n1. 浏览器输入url  -> 发送请求到服务器\n2. 服务器接收到请求 -> 发送项目的index.html + app.bundle.js文件给浏览器\n3. 浏览器执行js,生成dom，渲染dom,发送请求，接收请求，解析数据，操作数据，重新渲染\n\n* SPA缺点 \n1. 如果没有进行异步请求，首屏加载过慢。（因为要一次性加载多种依赖和包）\n2.缺少SEO， 难以进行搜索引擎优化（对于爬虫来说，它仅仅获取到了2个标签，而没有页面真实呈现内容的信息）\n3. 性能问题\n* SPA优点\n1. 带来接近原生的体验\n2. 前后端分离\n3. 服务器压力小 响应速度快\n\n######  进行ssr的vue/react项目浏览器渲染步骤\n1. 浏览器输入url  -> 发送请求到服务器\n2. 服务器(node服务)接收到请求 -> 解析对应的js文件，生成对应的html->发送给浏览器\n3. 浏览器接收并渲染html\n\n## SSR需要哪些配置\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-5d9692de712dd7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 搭建Vue的SSR服务端渲染\n---\n\n在vue项目过中安装vue-server-renderer\n```\n $ npm i vue-server-renderer\n$ npm i server\n```\n在vue项目中创建server.js文件\nserver.js文件的内容为：\n```\n/* server.js */\nconst Vue = require('vue');\nconst server = require('express')();\nconst renderer = require('vue-server-renderer').createRenderer();\nconst fs = require('fs');\n\nfunction createApp(url) {\n  if (url == '/') {\n    url = '/index'\n  }\n  let json = fs.readFileSync(`json${url}.json`,'utf_8');\n  let template = fs.readFileSync(`template${url}.html`,'utf_8');\n  return new Vue({\n    template: template,\n    data: JSON.parse(json).data\n  })\n}\n// 响应路由请求\nserver.get('*', (req, res) => {\n  if (req.url !=='/favicon.ico') {\n    const app = createApp(req.url);\n    renderer.renderToString(app, (err, html) => {\n      if (err) { return res.state(500).end('运行时错误') }\n      res.send(html);\n    });\n  }\n});\n\n// 服务器监听地址\nserver.listen(8080, () => {\n    console.log('服务器已启动！')\n});\n```\n目录结构\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-73a701ecb005919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-7853336351f039c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\n/* index.js */\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Index</title>\n</head>\n<body>\n  {{a}}\n</body>\n</html>\n/* index.json */\n{\n  \"data\": {\"a\": 1}\n}\n```\n\n执行命令\n```\n$ node server.js\n```\n打开浏览器，地址栏输入：\n\n```\nlocalhost:8080\n```\n\n我们可以看到，页面加载成功\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-94029c331dae155a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-106520d374bea6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 对原有的Vue项目改造成SSR\n---\n1. 在src文件下新建`server.js` + `client.js`\n2. 在根目录下新建`index.ssr.html`\n\n```\n/* index.ssr.html*/\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n<!-- 注意⚠️！！！⬇️下面注释不能少：如果没有，服务器就不知道将生成好的html代码插在什么位置-->\n  <!--vue-ssr-outlet-->\n  <script type=\"text/javescript\" src=\"<%= htmlWebpackPlugin.options.files.js %>\"></script>\n</body>\n</html>\n```\n3. 对router部分进行改造\n* 将路由改造成方法\n```\n// export default router;\nexport function createRouter(){\n  return new VueRouter({\n    mode: \"history\",\n    base: process.env.BASE_URL,\n    routes\n  });\n};\n```\n4. 对main.js进行改造\n* 引入createRouter\n* 将main.js改造成方法\n```\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// import router from \"./router\";\nimport { createRouter } from \"./router\";\nconst router = createRouter();\n// new Vue({\n//   router,\n//   store,\n//   render: h => h(App)\n// }).$mount(\"#app\");\nexport function createApp(){\n  const app = new Vue({\n    router,\n    store,\n    render: h => h(App)\n  });\n  return {app, router}\n};\n```\n** 为什么将main.js和router改造成方法？ 回答：方便调用！**\n5. server.js\n由于sever.js是在服务端运行，我们将代码形成node格式\n```\nimport { createApp } from \"./main\";\n// context = req (服务端的request)\nexport function context=>{\n  return new Promise((resolve, reject)=> {\n    const {app, router} = createApp();\n    // 将当前的请求路径添加到路由表中，\n    router.push(context.url);\n    router.onReady(() => {\n      const matchCcmponents = router.getMatchedComponents(path);\n      if (!matchCcmponents.length) {\n        return reject({code: 404})\n      }\n      resolve(app)\n    }, reject);\n  })\n};\n```\n\n6. client.js\n```\nimport { createApp } from \"./main\";\nconst {app, router} = createApp();\nrouter.onReady(() => {\n  // 手动挂载;\n  app.$mount('#app');\n});\n```\n7. 在build新建`webpack.buildclinet.js`+`webpack.buildserver.js`\n8. webpack.buildserver.js\n`webpack.buildserver.js`类似于`webpack.prod.conf.js`\n对部分内容进行改造：\n\n```\nvar VueSSRServerPlugin = require('vue-server-renderer/server-plugin')\n\n \n// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry\n  entry: {\n    app: './src/server.js'\n  },\n  // 打包之后的结果是在服务端运行的。\n  target: 'node',\n  output: {\n    // 打包之后的文件的模块化规范，遵循node的模块化规范\n    libraryTarget: \"commonjs2\"\n  },\n   new HtmlWebpackPlugin({\n      filename: 'index.srr.html',\n      template: 'index.srr.html',\n      inject: true,\n      files: {\n        js: 'app.js'\n      },\n     // 注意⚠️！！！删除掉压缩部分配置代码⬇️：为什么不能压缩，看第2步的解释（你能找到解释么？嘿嘿）！\n      // minify: {\n        //removeComments: true,\n         //collapseWhitespace: true,\n        //removeAttributeQuotes: true\n      //},\n      chunksSortMode: 'dependency'\n   }),\n  plugins: [\n    // 插件作用：对服务端代码进行打包\n    new VueSSRServerPlugin(),\n ......\n```\n\n9. webpack.buildclient.js\n`webpack.buildclient.js`类似于`webpack.prod.conf.js`\n对部分内容进行改造：\n```\nvar VueSSRClientPlugin = require('vue-server-renderer/client-plugin')\n\n// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry\n  entry: {\n    app: './src/client.js'\n  },\n// 注意⚠️！！！删掉出口配置output:\n\n  plugins: [\n    // 插件作用：对客户端代码进行打包\n    new VueSSRClientPlugin(),\n ......\n```\n\n10. 增加打包命令\n\n```\n\"build:client\": \"webpack --config build/webpack.buildclient.js\"\n\"build:server\": \"webpack --config build/webpack.buildserver.js\"\n```\n11. 执行打包命令\n\n```\n$ npm run build:server\n$ npm run build:client\n```\n打包之后结果\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-c96aecf8bdcde96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-2bcceeefe888efaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 12 编写server\n* 在根目录下新建server文件夹 + `server.js`\nserver.js\n```\nconst express = require('express');\nconst server = express();\nconst {createBundleRenderer} = require('vue-server-renderder');\nconst path = require('path');\nconst fs = require('fs');\nconst serverBundle = require(path.resolve(__dirname, '../dist/vue-ssr-server-bundle.json'));\nconst clientManifest = require(path.resolve(__dirname, '../dist/vue-ssr-client-manifest.json'));\nconst template= fs.readFileSync(path.resolve(__dirname, '..dist/index.ssr.html'), 'utf-8');\n// 打包出来的json的作用：通知服务器如何分割js,部分js用于客户端执行，部分js用于服务端运行。\nconst renderer = createBundleRenderer(serverBundle,{\n  runInNewContext: false,\n  template:template,\n  clientManifest:clientManifest\n});\n// 设置静态目录，以dist文件夹为静态目录，dist文件夹在服务开始之后可以访问\nserver.use(express.static(path.resolve(__dirname, '../dist')));\n// 设置路由\nserver.get('*',(req,res)=>{\n  if (req.url !=='/favicon.ico') {\n    const context = {url: req.url};\n    // 在项目中生成的html文件巨大，通过流的方式处理大的文件\n    const ssrstream = renderer.renderToStream(context);\n    let buffers = [];\n    ssrstream.on('error', (err) => {\n      console.log(err);\n    });\n    ssrstream.on('data', (data) => buffers.push(data));\n    ssrstream.on('end', () => {\n      res.end(Buffer.concat(buffers));\n    });\n  }\n});\nserver.listen(2000);\n```\n\n## 13 node 运行server.js\n\n```\n$ node server.js\n```\n项目运行之后，会发现切换页面，都会重新请求页面刷新。\n","slug":"ssr","published":1,"updated":"2020-05-19T03:14:03.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjs2002h78p3kcyaegnb","content":"<p>Author: Echo<br>Time: 2020-05-19 11:13:15</p>\n<h2 id=\"SSR是什么\"><a href=\"#SSR是什么\" class=\"headerlink\" title=\"SSR是什么\"></a>SSR是什么</h2><hr>\n<p><code>SSR</code>：Server Side Rendering<br>服务端渲染，由服务器进行渲染并返回给客户端渲染完成的html</p>\n<ul>\n<li>优点<br>超快的响应速度<br>易做SEO</li>\n<li>缺点<br>增加服务器压力</li>\n<li>主流框架<br>Next.js —— React的SSR方案<br>Nuxt.js —— Vue的SSR方案<h3 id=\"SPA是什么\"><a href=\"#SPA是什么\" class=\"headerlink\" title=\"SPA是什么\"></a>SPA是什么</h3></li>\n</ul>\n<hr>\n<p>SPA：single page application<br>按照字面意思就是单页面应用，通俗点就是整个网站由一个html页面构成。</p>\n<h6 id=\"传统的vue-react项目纯浏览器渲染步骤\"><a href=\"#传统的vue-react项目纯浏览器渲染步骤\" class=\"headerlink\" title=\"传统的vue/react项目纯浏览器渲染步骤\"></a>传统的vue/react项目纯浏览器渲染步骤</h6><ol>\n<li>浏览器输入url  -&gt; 发送请求到服务器</li>\n<li>服务器接收到请求 -&gt; 发送项目的index.html + app.bundle.js文件给浏览器</li>\n<li>浏览器执行js,生成dom，渲染dom,发送请求，接收请求，解析数据，操作数据，重新渲染</li>\n</ol>\n<ul>\n<li>SPA缺点 </li>\n</ul>\n<ol>\n<li>如果没有进行异步请求，首屏加载过慢。（因为要一次性加载多种依赖和包）<br>2.缺少SEO， 难以进行搜索引擎优化（对于爬虫来说，它仅仅获取到了2个标签，而没有页面真实呈现内容的信息）</li>\n<li>性能问题</li>\n</ol>\n<ul>\n<li>SPA优点</li>\n</ul>\n<ol>\n<li>带来接近原生的体验</li>\n<li>前后端分离</li>\n<li>服务器压力小 响应速度快</li>\n</ol>\n<h6 id=\"进行ssr的vue-react项目浏览器渲染步骤\"><a href=\"#进行ssr的vue-react项目浏览器渲染步骤\" class=\"headerlink\" title=\"进行ssr的vue/react项目浏览器渲染步骤\"></a>进行ssr的vue/react项目浏览器渲染步骤</h6><ol>\n<li>浏览器输入url  -&gt; 发送请求到服务器</li>\n<li>服务器(node服务)接收到请求 -&gt; 解析对应的js文件，生成对应的html-&gt;发送给浏览器</li>\n<li>浏览器接收并渲染html</li>\n</ol>\n<h2 id=\"SSR需要哪些配置\"><a href=\"#SSR需要哪些配置\" class=\"headerlink\" title=\"SSR需要哪些配置\"></a>SSR需要哪些配置</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5d9692de712dd7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"搭建Vue的SSR服务端渲染\"><a href=\"#搭建Vue的SSR服务端渲染\" class=\"headerlink\" title=\"搭建Vue的SSR服务端渲染\"></a>搭建Vue的SSR服务端渲染</h4><hr>\n<p>在vue项目过中安装vue-server-renderer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $ npm i vue-server-renderer</span><br><span class=\"line\">$ npm i server</span><br></pre></td></tr></table></figure></p>\n<p>在vue项目中创建server.js文件<br>server.js文件的内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* server.js */</span><br><span class=\"line\">const Vue = require(&apos;vue&apos;);</span><br><span class=\"line\">const server = require(&apos;express&apos;)();</span><br><span class=\"line\">const renderer = require(&apos;vue-server-renderer&apos;).createRenderer();</span><br><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function createApp(url) &#123;</span><br><span class=\"line\">  if (url == &apos;/&apos;) &#123;</span><br><span class=\"line\">    url = &apos;/index&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let json = fs.readFileSync(`json$&#123;url&#125;.json`,&apos;utf_8&apos;);</span><br><span class=\"line\">  let template = fs.readFileSync(`template$&#123;url&#125;.html`,&apos;utf_8&apos;);</span><br><span class=\"line\">  return new Vue(&#123;</span><br><span class=\"line\">    template: template,</span><br><span class=\"line\">    data: JSON.parse(json).data</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 响应路由请求</span><br><span class=\"line\">server.get(&apos;*&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  if (req.url !==&apos;/favicon.ico&apos;) &#123;</span><br><span class=\"line\">    const app = createApp(req.url);</span><br><span class=\"line\">    renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class=\"line\">      if (err) &#123; return res.state(500).end(&apos;运行时错误&apos;) &#125;</span><br><span class=\"line\">      res.send(html);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 服务器监听地址</span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;服务器已启动！&apos;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>目录结构<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-73a701ecb005919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-7853336351f039c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* index.js */</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Index&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &#123;&#123;a&#125;&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">/* index.json */</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;data&quot;: &#123;&quot;a&quot;: 1&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node server.js</span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器，地址栏输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:8080</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，页面加载成功<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-94029c331dae155a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-106520d374bea6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"对原有的Vue项目改造成SSR\"><a href=\"#对原有的Vue项目改造成SSR\" class=\"headerlink\" title=\"对原有的Vue项目改造成SSR\"></a>对原有的Vue项目改造成SSR</h4><hr>\n<ol>\n<li>在src文件下新建<code>server.js</code> + <code>client.js</code></li>\n<li>在根目录下新建<code>index.ssr.html</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* index.ssr.html*/</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;!-- 注意⚠️！！！⬇️下面注释不能少：如果没有，服务器就不知道将生成好的html代码插在什么位置--&gt;</span><br><span class=\"line\">  &lt;!--vue-ssr-outlet--&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javescript&quot; src=&quot;&lt;%= htmlWebpackPlugin.options.files.js %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>对router部分进行改造</li>\n</ol>\n<ul>\n<li>将路由改造成方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// export default router;</span><br><span class=\"line\">export function createRouter()&#123;</span><br><span class=\"line\">  return new VueRouter(&#123;</span><br><span class=\"line\">    mode: &quot;history&quot;,</span><br><span class=\"line\">    base: process.env.BASE_URL,</span><br><span class=\"line\">    routes</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>对main.js进行改造</li>\n</ol>\n<ul>\n<li>引入createRouter</li>\n<li>将main.js改造成方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &quot;vue&quot;;</span><br><span class=\"line\">import App from &quot;./App.vue&quot;;</span><br><span class=\"line\">// import router from &quot;./router&quot;;</span><br><span class=\"line\">import &#123; createRouter &#125; from &quot;./router&quot;;</span><br><span class=\"line\">const router = createRouter();</span><br><span class=\"line\">// new Vue(&#123;</span><br><span class=\"line\">//   router,</span><br><span class=\"line\">//   store,</span><br><span class=\"line\">//   render: h =&gt; h(App)</span><br><span class=\"line\">// &#125;).$mount(&quot;#app&quot;);</span><br><span class=\"line\">export function createApp()&#123;</span><br><span class=\"line\">  const app = new Vue(&#123;</span><br><span class=\"line\">    router,</span><br><span class=\"line\">    store,</span><br><span class=\"line\">    render: h =&gt; h(App)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return &#123;app, router&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong> 为什么将main.js和router改造成方法？ 回答：方便调用！</strong></p>\n<ol start=\"5\">\n<li><p>server.js<br>由于sever.js是在服务端运行，我们将代码形成node格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createApp &#125; from &quot;./main&quot;;</span><br><span class=\"line\">// context = req (服务端的request)</span><br><span class=\"line\">export function context=&gt;&#123;</span><br><span class=\"line\">  return new Promise((resolve, reject)=&gt; &#123;</span><br><span class=\"line\">    const &#123;app, router&#125; = createApp();</span><br><span class=\"line\">    // 将当前的请求路径添加到路由表中，</span><br><span class=\"line\">    router.push(context.url);</span><br><span class=\"line\">    router.onReady(() =&gt; &#123;</span><br><span class=\"line\">      const matchCcmponents = router.getMatchedComponents(path);</span><br><span class=\"line\">      if (!matchCcmponents.length) &#123;</span><br><span class=\"line\">        return reject(&#123;code: 404&#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      resolve(app)</span><br><span class=\"line\">    &#125;, reject);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>client.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createApp &#125; from &quot;./main&quot;;</span><br><span class=\"line\">const &#123;app, router&#125; = createApp();</span><br><span class=\"line\">router.onReady(() =&gt; &#123;</span><br><span class=\"line\">  // 手动挂载;</span><br><span class=\"line\">  app.$mount(&apos;#app&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在build新建<code>webpack.buildclinet.js</code>+<code>webpack.buildserver.js</code></p>\n</li>\n<li>webpack.buildserver.js<br><code>webpack.buildserver.js</code>类似于<code>webpack.prod.conf.js</code><br>对部分内容进行改造：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VueSSRServerPlugin = require(&apos;vue-server-renderer/server-plugin&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: &apos;./src/server.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 打包之后的结果是在服务端运行的。</span><br><span class=\"line\">  target: &apos;node&apos;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 打包之后的文件的模块化规范，遵循node的模块化规范</span><br><span class=\"line\">    libraryTarget: &quot;commonjs2&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">   new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: &apos;index.srr.html&apos;,</span><br><span class=\"line\">      template: &apos;index.srr.html&apos;,</span><br><span class=\"line\">      inject: true,</span><br><span class=\"line\">      files: &#123;</span><br><span class=\"line\">        js: &apos;app.js&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">     // 注意⚠️！！！删除掉压缩部分配置代码⬇️：为什么不能压缩，看第2步的解释（你能找到解释么？嘿嘿）！</span><br><span class=\"line\">      // minify: &#123;</span><br><span class=\"line\">        //removeComments: true,</span><br><span class=\"line\">         //collapseWhitespace: true,</span><br><span class=\"line\">        //removeAttributeQuotes: true</span><br><span class=\"line\">      //&#125;,</span><br><span class=\"line\">      chunksSortMode: &apos;dependency&apos;</span><br><span class=\"line\">   &#125;),</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 插件作用：对服务端代码进行打包</span><br><span class=\"line\">    new VueSSRServerPlugin(),</span><br><span class=\"line\"> ......</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li><p>webpack.buildclient.js<br><code>webpack.buildclient.js</code>类似于<code>webpack.prod.conf.js</code><br>对部分内容进行改造：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VueSSRClientPlugin = require(&apos;vue-server-renderer/client-plugin&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: &apos;./src/client.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">// 注意⚠️！！！删掉出口配置output:</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 插件作用：对客户端代码进行打包</span><br><span class=\"line\">    new VueSSRClientPlugin(),</span><br><span class=\"line\"> ......</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>增加打包命令</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;build:client&quot;: &quot;webpack --config build/webpack.buildclient.js&quot;</span><br><span class=\"line\">&quot;build:server&quot;: &quot;webpack --config build/webpack.buildserver.js&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>执行打包命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run build:server</span><br><span class=\"line\">$ npm run build:client</span><br></pre></td></tr></table></figure>\n<p>打包之后结果<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c96aecf8bdcde96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2bcceeefe888efaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"12-编写server\"><a href=\"#12-编写server\" class=\"headerlink\" title=\"12 编写server\"></a>12 编写server</h2><ul>\n<li>在根目录下新建server文件夹 + <code>server.js</code><br>server.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const server = express();</span><br><span class=\"line\">const &#123;createBundleRenderer&#125; = require(&apos;vue-server-renderder&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const serverBundle = require(path.resolve(__dirname, &apos;../dist/vue-ssr-server-bundle.json&apos;));</span><br><span class=\"line\">const clientManifest = require(path.resolve(__dirname, &apos;../dist/vue-ssr-client-manifest.json&apos;));</span><br><span class=\"line\">const template= fs.readFileSync(path.resolve(__dirname, &apos;..dist/index.ssr.html&apos;), &apos;utf-8&apos;);</span><br><span class=\"line\">// 打包出来的json的作用：通知服务器如何分割js,部分js用于客户端执行，部分js用于服务端运行。</span><br><span class=\"line\">const renderer = createBundleRenderer(serverBundle,&#123;</span><br><span class=\"line\">  runInNewContext: false,</span><br><span class=\"line\">  template:template,</span><br><span class=\"line\">  clientManifest:clientManifest</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 设置静态目录，以dist文件夹为静态目录，dist文件夹在服务开始之后可以访问</span><br><span class=\"line\">server.use(express.static(path.resolve(__dirname, &apos;../dist&apos;)));</span><br><span class=\"line\">// 设置路由</span><br><span class=\"line\">server.get(&apos;*&apos;,(req,res)=&gt;&#123;</span><br><span class=\"line\">  if (req.url !==&apos;/favicon.ico&apos;) &#123;</span><br><span class=\"line\">    const context = &#123;url: req.url&#125;;</span><br><span class=\"line\">    // 在项目中生成的html文件巨大，通过流的方式处理大的文件</span><br><span class=\"line\">    const ssrstream = renderer.renderToStream(context);</span><br><span class=\"line\">    let buffers = [];</span><br><span class=\"line\">    ssrstream.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class=\"line\">      console.log(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    ssrstream.on(&apos;data&apos;, (data) =&gt; buffers.push(data));</span><br><span class=\"line\">    ssrstream.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class=\"line\">      res.end(Buffer.concat(buffers));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.listen(2000);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"13-node-运行server-js\"><a href=\"#13-node-运行server-js\" class=\"headerlink\" title=\"13 node 运行server.js\"></a>13 node 运行server.js</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node server.js</span><br></pre></td></tr></table></figure>\n<p>项目运行之后，会发现切换页面，都会重新请求页面刷新。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2020-05-19 11:13:15</p>\n<h2 id=\"SSR是什么\"><a href=\"#SSR是什么\" class=\"headerlink\" title=\"SSR是什么\"></a>SSR是什么</h2><hr>\n<p><code>SSR</code>：Server Side Rendering<br>服务端渲染，由服务器进行渲染并返回给客户端渲染完成的html</p>\n<ul>\n<li>优点<br>超快的响应速度<br>易做SEO</li>\n<li>缺点<br>增加服务器压力</li>\n<li>主流框架<br>Next.js —— React的SSR方案<br>Nuxt.js —— Vue的SSR方案<h3 id=\"SPA是什么\"><a href=\"#SPA是什么\" class=\"headerlink\" title=\"SPA是什么\"></a>SPA是什么</h3></li>\n</ul>\n<hr>\n<p>SPA：single page application<br>按照字面意思就是单页面应用，通俗点就是整个网站由一个html页面构成。</p>\n<h6 id=\"传统的vue-react项目纯浏览器渲染步骤\"><a href=\"#传统的vue-react项目纯浏览器渲染步骤\" class=\"headerlink\" title=\"传统的vue/react项目纯浏览器渲染步骤\"></a>传统的vue/react项目纯浏览器渲染步骤</h6><ol>\n<li>浏览器输入url  -&gt; 发送请求到服务器</li>\n<li>服务器接收到请求 -&gt; 发送项目的index.html + app.bundle.js文件给浏览器</li>\n<li>浏览器执行js,生成dom，渲染dom,发送请求，接收请求，解析数据，操作数据，重新渲染</li>\n</ol>\n<ul>\n<li>SPA缺点 </li>\n</ul>\n<ol>\n<li>如果没有进行异步请求，首屏加载过慢。（因为要一次性加载多种依赖和包）<br>2.缺少SEO， 难以进行搜索引擎优化（对于爬虫来说，它仅仅获取到了2个标签，而没有页面真实呈现内容的信息）</li>\n<li>性能问题</li>\n</ol>\n<ul>\n<li>SPA优点</li>\n</ul>\n<ol>\n<li>带来接近原生的体验</li>\n<li>前后端分离</li>\n<li>服务器压力小 响应速度快</li>\n</ol>\n<h6 id=\"进行ssr的vue-react项目浏览器渲染步骤\"><a href=\"#进行ssr的vue-react项目浏览器渲染步骤\" class=\"headerlink\" title=\"进行ssr的vue/react项目浏览器渲染步骤\"></a>进行ssr的vue/react项目浏览器渲染步骤</h6><ol>\n<li>浏览器输入url  -&gt; 发送请求到服务器</li>\n<li>服务器(node服务)接收到请求 -&gt; 解析对应的js文件，生成对应的html-&gt;发送给浏览器</li>\n<li>浏览器接收并渲染html</li>\n</ol>\n<h2 id=\"SSR需要哪些配置\"><a href=\"#SSR需要哪些配置\" class=\"headerlink\" title=\"SSR需要哪些配置\"></a>SSR需要哪些配置</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-5d9692de712dd7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"搭建Vue的SSR服务端渲染\"><a href=\"#搭建Vue的SSR服务端渲染\" class=\"headerlink\" title=\"搭建Vue的SSR服务端渲染\"></a>搭建Vue的SSR服务端渲染</h4><hr>\n<p>在vue项目过中安装vue-server-renderer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $ npm i vue-server-renderer</span><br><span class=\"line\">$ npm i server</span><br></pre></td></tr></table></figure></p>\n<p>在vue项目中创建server.js文件<br>server.js文件的内容为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* server.js */</span><br><span class=\"line\">const Vue = require(&apos;vue&apos;);</span><br><span class=\"line\">const server = require(&apos;express&apos;)();</span><br><span class=\"line\">const renderer = require(&apos;vue-server-renderer&apos;).createRenderer();</span><br><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function createApp(url) &#123;</span><br><span class=\"line\">  if (url == &apos;/&apos;) &#123;</span><br><span class=\"line\">    url = &apos;/index&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let json = fs.readFileSync(`json$&#123;url&#125;.json`,&apos;utf_8&apos;);</span><br><span class=\"line\">  let template = fs.readFileSync(`template$&#123;url&#125;.html`,&apos;utf_8&apos;);</span><br><span class=\"line\">  return new Vue(&#123;</span><br><span class=\"line\">    template: template,</span><br><span class=\"line\">    data: JSON.parse(json).data</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 响应路由请求</span><br><span class=\"line\">server.get(&apos;*&apos;, (req, res) =&gt; &#123;</span><br><span class=\"line\">  if (req.url !==&apos;/favicon.ico&apos;) &#123;</span><br><span class=\"line\">    const app = createApp(req.url);</span><br><span class=\"line\">    renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class=\"line\">      if (err) &#123; return res.state(500).end(&apos;运行时错误&apos;) &#125;</span><br><span class=\"line\">      res.send(html);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 服务器监听地址</span><br><span class=\"line\">server.listen(8080, () =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;服务器已启动！&apos;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>目录结构<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-73a701ecb005919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-7853336351f039c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* index.js */</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Index&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &#123;&#123;a&#125;&#125;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br><span class=\"line\">/* index.json */</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;data&quot;: &#123;&quot;a&quot;: 1&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node server.js</span><br></pre></td></tr></table></figure></p>\n<p>打开浏览器，地址栏输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localhost:8080</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，页面加载成功<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-94029c331dae155a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-106520d374bea6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"对原有的Vue项目改造成SSR\"><a href=\"#对原有的Vue项目改造成SSR\" class=\"headerlink\" title=\"对原有的Vue项目改造成SSR\"></a>对原有的Vue项目改造成SSR</h4><hr>\n<ol>\n<li>在src文件下新建<code>server.js</code> + <code>client.js</code></li>\n<li>在根目录下新建<code>index.ssr.html</code></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* index.ssr.html*/</span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;!-- 注意⚠️！！！⬇️下面注释不能少：如果没有，服务器就不知道将生成好的html代码插在什么位置--&gt;</span><br><span class=\"line\">  &lt;!--vue-ssr-outlet--&gt;</span><br><span class=\"line\">  &lt;script type=&quot;text/javescript&quot; src=&quot;&lt;%= htmlWebpackPlugin.options.files.js %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>对router部分进行改造</li>\n</ol>\n<ul>\n<li>将路由改造成方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// export default router;</span><br><span class=\"line\">export function createRouter()&#123;</span><br><span class=\"line\">  return new VueRouter(&#123;</span><br><span class=\"line\">    mode: &quot;history&quot;,</span><br><span class=\"line\">    base: process.env.BASE_URL,</span><br><span class=\"line\">    routes</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>对main.js进行改造</li>\n</ol>\n<ul>\n<li>引入createRouter</li>\n<li>将main.js改造成方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &quot;vue&quot;;</span><br><span class=\"line\">import App from &quot;./App.vue&quot;;</span><br><span class=\"line\">// import router from &quot;./router&quot;;</span><br><span class=\"line\">import &#123; createRouter &#125; from &quot;./router&quot;;</span><br><span class=\"line\">const router = createRouter();</span><br><span class=\"line\">// new Vue(&#123;</span><br><span class=\"line\">//   router,</span><br><span class=\"line\">//   store,</span><br><span class=\"line\">//   render: h =&gt; h(App)</span><br><span class=\"line\">// &#125;).$mount(&quot;#app&quot;);</span><br><span class=\"line\">export function createApp()&#123;</span><br><span class=\"line\">  const app = new Vue(&#123;</span><br><span class=\"line\">    router,</span><br><span class=\"line\">    store,</span><br><span class=\"line\">    render: h =&gt; h(App)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return &#123;app, router&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong> 为什么将main.js和router改造成方法？ 回答：方便调用！</strong></p>\n<ol start=\"5\">\n<li><p>server.js<br>由于sever.js是在服务端运行，我们将代码形成node格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createApp &#125; from &quot;./main&quot;;</span><br><span class=\"line\">// context = req (服务端的request)</span><br><span class=\"line\">export function context=&gt;&#123;</span><br><span class=\"line\">  return new Promise((resolve, reject)=&gt; &#123;</span><br><span class=\"line\">    const &#123;app, router&#125; = createApp();</span><br><span class=\"line\">    // 将当前的请求路径添加到路由表中，</span><br><span class=\"line\">    router.push(context.url);</span><br><span class=\"line\">    router.onReady(() =&gt; &#123;</span><br><span class=\"line\">      const matchCcmponents = router.getMatchedComponents(path);</span><br><span class=\"line\">      if (!matchCcmponents.length) &#123;</span><br><span class=\"line\">        return reject(&#123;code: 404&#125;)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      resolve(app)</span><br><span class=\"line\">    &#125;, reject);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>client.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; createApp &#125; from &quot;./main&quot;;</span><br><span class=\"line\">const &#123;app, router&#125; = createApp();</span><br><span class=\"line\">router.onReady(() =&gt; &#123;</span><br><span class=\"line\">  // 手动挂载;</span><br><span class=\"line\">  app.$mount(&apos;#app&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在build新建<code>webpack.buildclinet.js</code>+<code>webpack.buildserver.js</code></p>\n</li>\n<li>webpack.buildserver.js<br><code>webpack.buildserver.js</code>类似于<code>webpack.prod.conf.js</code><br>对部分内容进行改造：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VueSSRServerPlugin = require(&apos;vue-server-renderer/server-plugin&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br><span class=\"line\">// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: &apos;./src/server.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 打包之后的结果是在服务端运行的。</span><br><span class=\"line\">  target: &apos;node&apos;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    // 打包之后的文件的模块化规范，遵循node的模块化规范</span><br><span class=\"line\">    libraryTarget: &quot;commonjs2&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">   new HtmlWebpackPlugin(&#123;</span><br><span class=\"line\">      filename: &apos;index.srr.html&apos;,</span><br><span class=\"line\">      template: &apos;index.srr.html&apos;,</span><br><span class=\"line\">      inject: true,</span><br><span class=\"line\">      files: &#123;</span><br><span class=\"line\">        js: &apos;app.js&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">     // 注意⚠️！！！删除掉压缩部分配置代码⬇️：为什么不能压缩，看第2步的解释（你能找到解释么？嘿嘿）！</span><br><span class=\"line\">      // minify: &#123;</span><br><span class=\"line\">        //removeComments: true,</span><br><span class=\"line\">         //collapseWhitespace: true,</span><br><span class=\"line\">        //removeAttributeQuotes: true</span><br><span class=\"line\">      //&#125;,</span><br><span class=\"line\">      chunksSortMode: &apos;dependency&apos;</span><br><span class=\"line\">   &#125;),</span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 插件作用：对服务端代码进行打包</span><br><span class=\"line\">    new VueSSRServerPlugin(),</span><br><span class=\"line\"> ......</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li><p>webpack.buildclient.js<br><code>webpack.buildclient.js</code>类似于<code>webpack.prod.conf.js</code><br>对部分内容进行改造：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var VueSSRClientPlugin = require(&apos;vue-server-renderer/client-plugin&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry</span><br><span class=\"line\">  entry: &#123;</span><br><span class=\"line\">    app: &apos;./src/client.js&apos;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">// 注意⚠️！！！删掉出口配置output:</span><br><span class=\"line\"></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    // 插件作用：对客户端代码进行打包</span><br><span class=\"line\">    new VueSSRClientPlugin(),</span><br><span class=\"line\"> ......</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>增加打包命令</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;build:client&quot;: &quot;webpack --config build/webpack.buildclient.js&quot;</span><br><span class=\"line\">&quot;build:server&quot;: &quot;webpack --config build/webpack.buildserver.js&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"11\">\n<li>执行打包命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm run build:server</span><br><span class=\"line\">$ npm run build:client</span><br></pre></td></tr></table></figure>\n<p>打包之后结果<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-c96aecf8bdcde96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2bcceeefe888efaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h2 id=\"12-编写server\"><a href=\"#12-编写server\" class=\"headerlink\" title=\"12 编写server\"></a>12 编写server</h2><ul>\n<li>在根目录下新建server文件夹 + <code>server.js</code><br>server.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const server = express();</span><br><span class=\"line\">const &#123;createBundleRenderer&#125; = require(&apos;vue-server-renderder&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const serverBundle = require(path.resolve(__dirname, &apos;../dist/vue-ssr-server-bundle.json&apos;));</span><br><span class=\"line\">const clientManifest = require(path.resolve(__dirname, &apos;../dist/vue-ssr-client-manifest.json&apos;));</span><br><span class=\"line\">const template= fs.readFileSync(path.resolve(__dirname, &apos;..dist/index.ssr.html&apos;), &apos;utf-8&apos;);</span><br><span class=\"line\">// 打包出来的json的作用：通知服务器如何分割js,部分js用于客户端执行，部分js用于服务端运行。</span><br><span class=\"line\">const renderer = createBundleRenderer(serverBundle,&#123;</span><br><span class=\"line\">  runInNewContext: false,</span><br><span class=\"line\">  template:template,</span><br><span class=\"line\">  clientManifest:clientManifest</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 设置静态目录，以dist文件夹为静态目录，dist文件夹在服务开始之后可以访问</span><br><span class=\"line\">server.use(express.static(path.resolve(__dirname, &apos;../dist&apos;)));</span><br><span class=\"line\">// 设置路由</span><br><span class=\"line\">server.get(&apos;*&apos;,(req,res)=&gt;&#123;</span><br><span class=\"line\">  if (req.url !==&apos;/favicon.ico&apos;) &#123;</span><br><span class=\"line\">    const context = &#123;url: req.url&#125;;</span><br><span class=\"line\">    // 在项目中生成的html文件巨大，通过流的方式处理大的文件</span><br><span class=\"line\">    const ssrstream = renderer.renderToStream(context);</span><br><span class=\"line\">    let buffers = [];</span><br><span class=\"line\">    ssrstream.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class=\"line\">      console.log(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    ssrstream.on(&apos;data&apos;, (data) =&gt; buffers.push(data));</span><br><span class=\"line\">    ssrstream.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class=\"line\">      res.end(Buffer.concat(buffers));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.listen(2000);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"13-node-运行server-js\"><a href=\"#13-node-运行server-js\" class=\"headerlink\" title=\"13 node 运行server.js\"></a>13 node 运行server.js</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ node server.js</span><br></pre></td></tr></table></figure>\n<p>项目运行之后，会发现切换页面，都会重新请求页面刷新。</p>\n"},{"title":"vue相关面试题汇总","date":"2019-09-19T12:50:06.000Z","_content":"\n##### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n##### 子组件访问父组件数据（除了props） \n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueTitle/\n\n##### new Vue()做了什么？\n##### 什么阶段才能访问DOM？\n##### 谈谈你对Vue的生命周期的理解？\n##### 生命周期钩子的合并策略\n##### 新生命周期钩子：serverPrefetch是什么？\n##### Vue-router 路由模式有几种？\n##### 谈谈你对keep-alive的了解\n##### vue源码中内置的组件？\n##### 了解Vue2.6+新全局API：Vue.observable()吗？\n##### 了解Vue数据绑定原理？\n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueSourceCoding/","source":"_posts/vue.md","raw":"---\ntitle: vue相关面试题汇总\ndate: 2019-09-19 20:50:06\ntags: 前端面试题\n---\n\n##### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n##### 子组件访问父组件数据（除了props） \n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueTitle/\n\n##### new Vue()做了什么？\n##### 什么阶段才能访问DOM？\n##### 谈谈你对Vue的生命周期的理解？\n##### 生命周期钩子的合并策略\n##### 新生命周期钩子：serverPrefetch是什么？\n##### Vue-router 路由模式有几种？\n##### 谈谈你对keep-alive的了解\n##### vue源码中内置的组件？\n##### 了解Vue2.6+新全局API：Vue.observable()吗？\n##### 了解Vue数据绑定原理？\n答案参考链接：https://lujinggirl.github.io/2019/09/03/vueSourceCoding/","slug":"vue","published":1,"updated":"2019-12-04T12:50:48.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjs4002k78p37fb5uo3i","content":"<h5 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h5><h5 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueTitle/</a></p>\n<h5 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h5><h5 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h5><h5 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h5><h5 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h5><h5 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h5><h5 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h5><h5 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h5><h5 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h5><h5 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h5><h5 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueSourceCoding/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueSourceCoding/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h5><h5 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueTitle/</a></p>\n<h5 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h5><h5 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h5><h5 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h5><h5 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h5><h5 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h5><h5 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h5><h5 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h5><h5 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h5><h5 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h5><h5 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/03/vueSourceCoding/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/03/vueSourceCoding/</a></p>\n"},{"title":"vue-cli3项目展示本地Markdown文件的方法","date":"2020-01-15T07:05:46.000Z","_content":"\n【版本】\n```\nvue-cli3\nwebpack@4.33.0\n```\n【步骤】\n\n1. 安装插件\n```\n$ npm install markdown-it --save\n```\n2. 新建markdownLoader.js文件(自定义loader)\n```\nconst markdown = require('markdown-it');\n\nfunction markLoader(src) {\n  const md = markdown({\n    html: true,\n    typographer: true,\n  });\n  const html = md.render(src);\n\n  return (\n    '<template>\\n'\n    + `<div class=\"markdown\">${html}</div>\\n`\n    + '</template>\\n'\n  );\n}\nmodule.exports = markLoader;\n```\n3. 在vue.config.js(如果没有,在根目录下自行创建)文件中配置\n```\nmodule.exports = {\n  configureWebpack: config => {\n    config.module.rules.push({\n      // 处理markdown文件\n      test: /\\.md$/,\n      use: [\n        {\n          loader: \"vue-loader\"\n        },\n        {\n          loader: require.resolve(\"./src/common/markdownLoader\")\n        }\n      ],\n    },\n    );\n  }\n};\n```\n\n4.保存后重新启动项目(尤其是修改自定义lodaer和vue.config.js配置文件,必须重新启动项目生效)","source":"_posts/vueCliMd.md","raw":"---\ntitle: vue-cli3项目展示本地Markdown文件的方法\ndate: 2020-01-15 15:05:46\ntags:\n---\n\n【版本】\n```\nvue-cli3\nwebpack@4.33.0\n```\n【步骤】\n\n1. 安装插件\n```\n$ npm install markdown-it --save\n```\n2. 新建markdownLoader.js文件(自定义loader)\n```\nconst markdown = require('markdown-it');\n\nfunction markLoader(src) {\n  const md = markdown({\n    html: true,\n    typographer: true,\n  });\n  const html = md.render(src);\n\n  return (\n    '<template>\\n'\n    + `<div class=\"markdown\">${html}</div>\\n`\n    + '</template>\\n'\n  );\n}\nmodule.exports = markLoader;\n```\n3. 在vue.config.js(如果没有,在根目录下自行创建)文件中配置\n```\nmodule.exports = {\n  configureWebpack: config => {\n    config.module.rules.push({\n      // 处理markdown文件\n      test: /\\.md$/,\n      use: [\n        {\n          loader: \"vue-loader\"\n        },\n        {\n          loader: require.resolve(\"./src/common/markdownLoader\")\n        }\n      ],\n    },\n    );\n  }\n};\n```\n\n4.保存后重新启动项目(尤其是修改自定义lodaer和vue.config.js配置文件,必须重新启动项目生效)","slug":"vueCliMd","published":1,"updated":"2020-01-15T07:11:30.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjs5002m78p3jqjwe0wi","content":"<p>【版本】<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-cli3</span><br><span class=\"line\">webpack@4.33.0</span><br></pre></td></tr></table></figure></p>\n<p>【步骤】</p>\n<ol>\n<li><p>安装插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install markdown-it --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建markdownLoader.js文件(自定义loader)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const markdown = require(&apos;markdown-it&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function markLoader(src) &#123;</span><br><span class=\"line\">  const md = markdown(&#123;</span><br><span class=\"line\">    html: true,</span><br><span class=\"line\">    typographer: true,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  const html = md.render(src);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &apos;&lt;template&gt;\\n&apos;</span><br><span class=\"line\">    + `&lt;div class=&quot;markdown&quot;&gt;$&#123;html&#125;&lt;/div&gt;\\n`</span><br><span class=\"line\">    + &apos;&lt;/template&gt;\\n&apos;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = markLoader;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在vue.config.js(如果没有,在根目录下自行创建)文件中配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  configureWebpack: config =&gt; &#123;</span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      // 处理markdown文件</span><br><span class=\"line\">      test: /\\.md$/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          loader: &quot;vue-loader&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          loader: require.resolve(&quot;./src/common/markdownLoader&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.保存后重新启动项目(尤其是修改自定义lodaer和vue.config.js配置文件,必须重新启动项目生效)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>【版本】<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vue-cli3</span><br><span class=\"line\">webpack@4.33.0</span><br></pre></td></tr></table></figure></p>\n<p>【步骤】</p>\n<ol>\n<li><p>安装插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install markdown-it --save</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>新建markdownLoader.js文件(自定义loader)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const markdown = require(&apos;markdown-it&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function markLoader(src) &#123;</span><br><span class=\"line\">  const md = markdown(&#123;</span><br><span class=\"line\">    html: true,</span><br><span class=\"line\">    typographer: true,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  const html = md.render(src);</span><br><span class=\"line\"></span><br><span class=\"line\">  return (</span><br><span class=\"line\">    &apos;&lt;template&gt;\\n&apos;</span><br><span class=\"line\">    + `&lt;div class=&quot;markdown&quot;&gt;$&#123;html&#125;&lt;/div&gt;\\n`</span><br><span class=\"line\">    + &apos;&lt;/template&gt;\\n&apos;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = markLoader;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在vue.config.js(如果没有,在根目录下自行创建)文件中配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  configureWebpack: config =&gt; &#123;</span><br><span class=\"line\">    config.module.rules.push(&#123;</span><br><span class=\"line\">      // 处理markdown文件</span><br><span class=\"line\">      test: /\\.md$/,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          loader: &quot;vue-loader&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          loader: require.resolve(&quot;./src/common/markdownLoader&quot;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.保存后重新启动项目(尤其是修改自定义lodaer和vue.config.js配置文件,必须重新启动项目生效)</p>\n"},{"title":"v8","date":"2020-03-30T08:45:02.000Z","_content":"\n# v8引擎如何回收内存\n","source":"_posts/v8.md","raw":"---\ntitle: v8\ndate: 2020-03-30 16:45:02\ntags:\n---\n\n# v8引擎如何回收内存\n","slug":"v8","published":1,"updated":"2020-03-30T08:45:36.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjs7002p78p3akt3g4vq","content":"<h1 id=\"v8引擎如何回收内存\"><a href=\"#v8引擎如何回收内存\" class=\"headerlink\" title=\"v8引擎如何回收内存\"></a>v8引擎如何回收内存</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"v8引擎如何回收内存\"><a href=\"#v8引擎如何回收内存\" class=\"headerlink\" title=\"v8引擎如何回收内存\"></a>v8引擎如何回收内存</h1>"},{"title":"解读element-ui-----this.$message()","date":"2020-07-27T09:15:39.000Z","_content":"\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 一个 message.js 文件\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后运行代码。\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## 配置duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n\n 大功告成✌️✌️✌️\n\n参考链接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n\n","source":"_posts/vueMessage.md","raw":"---\ntitle: 解读element-ui-----this.$message()\ndate: 2020-07-27 17:15:39\ntags: Vue\n---\n\n\n## 前言\n\n在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 `import` 引入即可，但如果是下面这种类型的组件呢👇\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n\n上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：\n\n```\nthis.$message({\n    duration: 3000,\n    content: '这是一条消息提示'\n});\n```\n\n没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！\n\n## 前置知识\n\n不知道小伙伴们有没有用过 `Vue.extend()` 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 `Vue.extend()` 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n \n没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：\n\n```\n// 导入以往的普通组件\nimport Main from './main.vue';\n// 用 Vue.extend 创建组件的模板（构造函数）\nlet mainConstructor = Vue.extend(Main);\n// 实例化组件\nlet instance = new mainConstructor();\n// 挂载到相应的元素上\ninstance.$mount('#app');\n\n\n```\n\n不知道你看懂没有，上面的 `Vue.extend(Main)` 就是一个基于 main.vue 的组件模板（构造函数），`instance` 是实例化的组件，`$mount()` 是手动挂载的意思。其中 `Vue.extend()` 和 `$mount()` 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 `createElement` 和 `appendChild`，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。\n补充一下🤐：`$mount()` 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。\n\n## 一个 message 组件\n\njs 调用归调用，最原始的组件还是要有的，只是我们不通过 `import` 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：\n\n```\n<!-- message.vue -->\n<template>\n  <div class=\"echojoy-message\" >\n    <p>服务器错误，请稍后重试</p>\n  </div>\n</template>\n<script>\nexport default {\n  name: \"EchojoyMessage\",\n  \n  mounted() {\n    setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, 3000);\n    \n  },\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  color: #fff;\n  z-index: 9999;\n  background: transparent;\n  > p {\n    padding: 12px 22px;\n    font-size: 18px;\n    border-radius: 4px;\n    background: rgba(17, 17, 17, 0.7);\n   }\n}\n</style>\n```\n\n上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。\n\n## 一个 message.js 文件\n\n我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\n\nconst Toast = function() {\n  instance = new ToastConstructor().$mount(); // 渲染组件\n  \n};\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n    instance = new messageConstructor().$mount(); // 渲染组件\n    document.body.appendChild(instance.$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 `this.$Message ()` 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 `this.$Message ()` 就是执行了上面代码中导出的 `export default Message`，也就是执行了 Message 函数（`const Message = function() {}`），所以当我们调用 `this.$Message()` 的时候其实就是执行了 `Message()` 函数。而 `Message()` 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。\n补充一下🤐：一般来说我们常见的是 `$mount(\"#app\")`，也就是把组件挂载到 `#app` 下面，`<router-view />` 也包含在 `#app` 中，但是我们这种 Message提示是放在 `body` 下面的，也就是说它不受 `#app` 和 `<router-view />` 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。\n这里顺便给个组件的目录结构，如下图所示：\n![message.png](https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 开始调用\n\n调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，\n\n```\nimport EchojoyMessage from './../packages/message/src/message.js'\nVue.prototype.$message = EchojoyMessage;\n```\n\n然后在页面中测试一下，就像下面这样子：\n![ALAERT.png](https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后运行代码。\n\n<figcaption></figcaption>\n\n嗯，挺好，小有成就的 feel 👏👏👏。\n\n## 支持可传参数\n\n别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 `this.$message()` 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 `duration` 和 `content` 举个栗子🌰。\n首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：\n\n```\n<!-- message.vue 可配置版 -->\n<template>\n   <div class=\"echojoy-message\" >\n    <p >\n      {{content}} \n    </p>\n  </div>\n</template>\n\n<script>\n// 主要就改了 data\nexport default {\n  name: \"EchojoyMessage\",\n  data() {\n    return {\n      content: \"\",\n      duration: 3000\n    };\n  },\n  mounted() {\n    setTimeout(() => {\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }, this.duration);\n  }\n};\n</script>\n```\n\n上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：\n\n```\n// message.js\nimport Vue from \"vue\"; // 引入 Vue 是因为要用到 Vue.extend() 这个方法\nimport message from \"./message.vue\"; // 引入刚才的 toast 组件\n\nlet messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到\nlet instance;\n\nconst Message = function (options = {}) {\n  instance = new messageConstructor({\n    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里\n  }); // 渲染组件\n  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下\n};\nexport default Message;\n```\n\n其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 `new messageConstructor({ data: options })` 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 `options` 会和组件中的 data 合并（Vue 的功劳）。\nem。。。是的，就这么简单，现在让我们继续来调用一下它：\n\n```\n<script>\nexport default {\n  methods: {\n    show(){\n      this.$message.success({\n        content: \"哈哈哈哈，消失的贼快\",\n        duration: 0\n      })\n    }\n  }\n};\n</script>\n```\n\n运行一下就可以看到：\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip)\n\n<figcaption></figcaption>\n\n当然，这还没完，我们继续添加个小功能点🙄。。。\n\n## 支持 this.$message.error()\n\n这里我们打算支持 `this.$message.error()` 和 `this.$message.success()` 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 `type` 值来修改组件的样式），就像下面这样：\n\n```\n<!--main.vue-->\n<div class=\"echojoy-message\" :class=\"type ? `echojoy-message--${type}` : ''\">\n    <p class=\"echojoy-message-content\">\n      {{content}} \n    </p>\n  </div>\n<script>\nexport default {\n  ...\n  data() {\n    return {\n      type: \"\",\n      content: \"\",\n      duration: 3000\n    };\n  },\n  ...\n};\n</script>\n<style lang=\"scss\" scoped>\n.echojoy-message{\n  ...\n  &--error p { background: rgba(255, 0, 0, 0.5); }\n  &--success p { background: rgba(0, 255, 0, 0.5); }\n}\n</style>\n```\n\n其次，`this.$message.error()` 其实就等价于 `Message.error()`，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：\n\n```\n// message.js\nconst Message= function(options = {}) {\n ...\n};\n// 以下就是在 Message函数中拓展 [\"success\", \"error\"] 这两个方法\n\n[\"success\", \"error\"].forEach(type => {\n  Message[type] = options => {\n    options.type = type;\n    return Message(options);\n  };\n});\n\nexport default Message;\n\n```\n\n我们可以看到 `Message.error()` 和 `Message.success()` 最终还是调用 `Message(options)` 这个函数，只不过在调用之前需要多做一步处理，就是将 `[\"success\", \"error\"]` 作为一个 `type` 参数给合并进 `options` 里面再传递，仅此而已😬。\n那就试试效果吧：\n\n```\n<script>\nexport default {\n  methods: {\n    show() {\n      this.$message({ content: \"这是正常的\" });\n    },\n    showError() {\n      this.$message.error({ content: \"竟然失败了\" });\n    },\n    showSuccess() {\n      this.$message.success({ content: \"居然成功了\" });\n    }\n  }\n};\n</script>\n```\n\n![image](https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip)\n\n\n\n## 配置duration <= 0,message一直存在\n* 传入参数非number类型\n首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）\n* 传入参数为number类型移除该组件实例和 DOM 节点\n`>0`\n在duration的时间范围内，移除该组件实例和 DOM 节点\n`<=0`\n不做任何处理\n ```\nmounted() {\n    if (typeof this.duration !== 'number' ) {\n      console.error('the duration must be a number!')\n      this.duration = 1000\n    }\n    if (this.duration > 0) {\n      setTimeout(() => {\n        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点\n        this.$destroy(true);\n        this.$el.parentNode.removeChild(this.$el);\n      }, this.duration);\n    }\n  },\n```\n## 手动关闭message\n在dom结构上设置可以执行关闭的icon图标,添加事件\n```\n<i class=\"echojoy-icon-close echojoy-message-close\" @click=\"close\"></i>\n```\n在scripts中增加函数\n```\nmethods:{\n    close(){\n      this.$destroy(true);\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n```\n#### 结束语\n\n 大功告成✌️✌️✌️\n\n参考链接：https://juejin.im/post/5ca20e426fb9a05e42555d1d\n\n\n","slug":"vueMessage","published":1,"updated":"2020-12-14T10:19:55.826Z","_id":"ckioehjs8002r78p3jtyur3np","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"一个-message-组件\"><a href=\"#一个-message-组件\" class=\"headerlink\" title=\"一个 message 组件\"></a>一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"一个-message-js-文件\"><a href=\"#一个-message-js-文件\" class=\"headerlink\" title=\"一个 message.js 文件\"></a>一个 message.js 文件</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>然后运行代码。</p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"配置duration-lt-0-message一直存在\"><a href=\"#配置duration-lt-0-message一直存在\" class=\"headerlink\" title=\"配置duration &lt;= 0,message一直存在\"></a>配置duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p> 大功告成✌️✌️✌️</p>\n<p>参考链接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.$message(&#123;</span><br><span class=\"line\">    duration: 3000,</span><br><span class=\"line\">    content: &apos;这是一条消息提示&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>\n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导入以往的普通组件</span><br><span class=\"line\">import Main from &apos;./main.vue&apos;;</span><br><span class=\"line\">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class=\"line\">let mainConstructor = Vue.extend(Main);</span><br><span class=\"line\">// 实例化组件</span><br><span class=\"line\">let instance = new mainConstructor();</span><br><span class=\"line\">// 挂载到相应的元素上</span><br><span class=\"line\">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>\n<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>\n<h2 id=\"一个-message-组件\"><a href=\"#一个-message-组件\" class=\"headerlink\" title=\"一个 message 组件\"></a>一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, 3000);</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  right: 0;</span><br><span class=\"line\">  color: #fff;</span><br><span class=\"line\">  z-index: 9999;</span><br><span class=\"line\">  background: transparent;</span><br><span class=\"line\">  &gt; p &#123;</span><br><span class=\"line\">    padding: 12px 22px;</span><br><span class=\"line\">    font-size: 18px;</span><br><span class=\"line\">    border-radius: 4px;</span><br><span class=\"line\">    background: rgba(17, 17, 17, 0.7);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>\n<h2 id=\"一个-message-js-文件\"><a href=\"#一个-message-js-文件\" class=\"headerlink\" title=\"一个 message.js 文件\"></a>一个 message.js 文件</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const Toast = function() &#123;</span><br><span class=\"line\">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class=\"line\">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"message.png\"></p>\n<h2 id=\"开始调用\"><a href=\"#开始调用\" class=\"headerlink\" title=\"开始调用\"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class=\"line\">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>\n<p>然后在页面中测试一下，就像下面这样子：<br><img src=\"https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ALAERT.png\"></p>\n<p>然后运行代码。</p>\n<figcaption></figcaption>\n\n<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>\n<h2 id=\"支持可传参数\"><a href=\"#支持可传参数\" class=\"headerlink\" title=\"支持可传参数\"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class=\"line\">    &lt;p &gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">// 主要就改了 data</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;EchojoyMessage&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;, this.duration);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class=\"line\">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class=\"line\"></span><br><span class=\"line\">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class=\"line\">let instance;</span><br><span class=\"line\"></span><br><span class=\"line\">const Message = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">  instance = new messageConstructor(&#123;</span><br><span class=\"line\">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class=\"line\">  &#125;); // 渲染组件</span><br><span class=\"line\">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show()&#123;</span><br><span class=\"line\">      this.$message.success(&#123;</span><br><span class=\"line\">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class=\"line\">        duration: 0</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>运行一下就可以看到：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<figcaption></figcaption>\n\n<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>\n<h2 id=\"支持-this-message-error\"><a href=\"#支持-this-message-error\" class=\"headerlink\" title=\"支持 this.$message.error()\"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--main.vue--&gt;</span><br><span class=\"line\">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class=\"line\">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class=\"line\">      &#123;&#123;content&#125;&#125; </span><br><span class=\"line\">    &lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      type: &quot;&quot;,</span><br><span class=\"line\">      content: &quot;&quot;,</span><br><span class=\"line\">      duration: 3000</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class=\"line\">.echojoy-message&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class=\"line\">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br></pre></td></tr></table></figure>\n<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// message.js</span><br><span class=\"line\">const Message= function(options = &#123;&#125;) &#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class=\"line\"></span><br><span class=\"line\">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class=\"line\">  Message[type] = options =&gt; &#123;</span><br><span class=\"line\">    options.type = type;</span><br><span class=\"line\">    return Message(options);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default Message;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    show() &#123;</span><br><span class=\"line\">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showError() &#123;</span><br><span class=\"line\">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    showSuccess() &#123;</span><br><span class=\"line\">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip\" alt=\"image\"></p>\n<h2 id=\"配置duration-lt-0-message一直存在\"><a href=\"#配置duration-lt-0-message一直存在\" class=\"headerlink\" title=\"配置duration &lt;= 0,message一直存在\"></a>配置duration &lt;= 0,message一直存在</h2><ul>\n<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>\n<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class=\"line\">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class=\"line\">      this.duration = 1000</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (this.duration &gt; 0) &#123;</span><br><span class=\"line\">      setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class=\"line\">        this.$destroy(true);</span><br><span class=\"line\">        this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">      &#125;, this.duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"手动关闭message\"><a href=\"#手动关闭message\" class=\"headerlink\" title=\"手动关闭message\"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在scripts中增加函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods:&#123;</span><br><span class=\"line\">    close()&#123;</span><br><span class=\"line\">      this.$destroy(true);</span><br><span class=\"line\">      this.$el.parentNode.removeChild(this.$el);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p> 大功告成✌️✌️✌️</p>\n<p>参考链接：<a href=\"https://juejin.im/post/5ca20e426fb9a05e42555d1d\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>\n"},{"title":"探究vue-router的源码","date":"2020-05-13T08:30:54.000Z","_content":"Author: Echo\nTime: 2020-05-13 16:30:54\n\n## 一个vue路由的工作流程\n\n---\n#### 前端路由和后端路由的区别\n* 后端路由\n输入url  -->  请求发送到服务器 --> 服务器解析请求的路径 --> 浏览器拿取对应页面 --> 页面渲染\n* 前端路由\n输入url  -->  js解析地址 --> 找到对应地址的页面 --> 执行页面生成的js --> 页面渲染\n\n#### vue-router的工作流程\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-ae149ebe3bad8a05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### Hash与History\n###### hash和history的使用\n`hash: `\n*  `#`号后面的就是hash的内容\n*  通过location.hash来获取\n* 通过onhashchange监听hash的改变\n\n`history: `\n*  history即正常的路径\n*  通过location.pathname来获取\n* 通过onpopstate监听history的改变\n\n##实现vue-router源码实例\n---\n```\nclass HistoryRoute {\n  constructor(){\n    this.current = null;\n  }\n};\n/**\n * options: newRouter时传入的参数；\n*/\nclass VueRouter{\n  constructor(options){\n    this.mode = options.mode || 'hash';\n    this.routes= options.routes || [];\n    // 此处可以直接令this.history.current = null；但是为了记录前后路由跳转历史，生成HistoryRoute类\n    this.history = new HistoryRoute;\n    this.routesMap =  this.creatMap(this.routes);\n    this.init(); //初始化路由\n  },\n  init () {\n    // 触发监听事件\n    // 改变vue-router中的current变量\n    if (this.mode == 'hash') {\n      // 根据hash的值自动在url上增加hash\n      location.hash ? '': location.hash = '/';\n      window.addEventListener('load',() => {\n        this.history.current = location.hash.slice(1);\n      })\n      window.addEventListener('hashchange',() => {\n        this.history.current = location.hash.slice(1);\n      })\n    } else {\n      // 根据hash的值自动在url上增加hash\n      location.pathname ? '': location.pathname = '/';\n      window.addEventListener('load',() => {\n        this.history.current = location.pathname;\n      })\n      window.addEventListener('hashchange',() => {\n        this.history.current = location.pathname;\n      })\n    }\n  }\n  creatMap(routes){\n    // 将routes转化成键值对形式 ‘/’: Hello\n    // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n    // 参数一：初始值, 或者计算结束后的返回值。\n    // 参数二：当前元素\n    return routes.reduce((memo, current)=> {\n      memo[current.path] = current.component;\n      return memo\n    })\n  }\n}\nVueRouter.install = function (Vue) {\n  // 监视current变量的监视者\n  Vue.mixin({ //mixin会注入到每个组件\n    // 查找到在根实例上放入的VueRouter对象，然后注入到每个组件。\n    beforeCreate() {\n      // this.$option && this.$options.router:当前这个组件的配置&& 当前组件上已经加载过route路由对象\n      if (this.$options && this.$options.router) {\n        // 将当前的实例，挂在到当前实例的_root变量上。\n        this._root = this;\n        // 将当前router 注入到当前实例（组件）的_router上。\n        this._router = this.$options.router;\n        // 在当前组件this下面中的this._router.history变量上对current进行监听\n        Vue.util.defineReactive(this,'current', this._router.history);\n      } else {\n        // 逐级向上查找是否挂载\n        this._root = this.$parent._root;\n      }\n\n      // 扩展知识 组件使用this.$router和this.$route\n      // 在this上注册$router属性，并且不能更改。\n      Object.defineProperty(this, '$router', {\n        get () {\n          return this._root._router;\n        },\n      })\n      Object.defineProperty(this, '$route', {\n        get () {\n          return this._root._router.history.current;\n        },\n      })\n    }\n  });\n  Vue.component('route-view', {\n    render(h){\n      // 根据当前current获取到对应的路径;\n      // _self是vue自带的，_self指向实例自身；\n      let current = this._self._root._router.history.current;\n      let routeMap = this._self._root._router.routesMap;\n      return h(routeMap[current]) //h：渲染作用\n    }\n  })\n}\n// 暴露vue类\nexport default VueRouter;\n```\n\n直接在项目中引入就可以啦！！\n","source":"_posts/vueRouter.md","raw":"---\ntitle: 探究vue-router的源码\ndate: 2020-05-13 16:30:54\ntags: vue, vueRouter\n---\nAuthor: Echo\nTime: 2020-05-13 16:30:54\n\n## 一个vue路由的工作流程\n\n---\n#### 前端路由和后端路由的区别\n* 后端路由\n输入url  -->  请求发送到服务器 --> 服务器解析请求的路径 --> 浏览器拿取对应页面 --> 页面渲染\n* 前端路由\n输入url  -->  js解析地址 --> 找到对应地址的页面 --> 执行页面生成的js --> 页面渲染\n\n#### vue-router的工作流程\n![image.png](https://upload-images.jianshu.io/upload_images/11846892-ae149ebe3bad8a05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### Hash与History\n###### hash和history的使用\n`hash: `\n*  `#`号后面的就是hash的内容\n*  通过location.hash来获取\n* 通过onhashchange监听hash的改变\n\n`history: `\n*  history即正常的路径\n*  通过location.pathname来获取\n* 通过onpopstate监听history的改变\n\n##实现vue-router源码实例\n---\n```\nclass HistoryRoute {\n  constructor(){\n    this.current = null;\n  }\n};\n/**\n * options: newRouter时传入的参数；\n*/\nclass VueRouter{\n  constructor(options){\n    this.mode = options.mode || 'hash';\n    this.routes= options.routes || [];\n    // 此处可以直接令this.history.current = null；但是为了记录前后路由跳转历史，生成HistoryRoute类\n    this.history = new HistoryRoute;\n    this.routesMap =  this.creatMap(this.routes);\n    this.init(); //初始化路由\n  },\n  init () {\n    // 触发监听事件\n    // 改变vue-router中的current变量\n    if (this.mode == 'hash') {\n      // 根据hash的值自动在url上增加hash\n      location.hash ? '': location.hash = '/';\n      window.addEventListener('load',() => {\n        this.history.current = location.hash.slice(1);\n      })\n      window.addEventListener('hashchange',() => {\n        this.history.current = location.hash.slice(1);\n      })\n    } else {\n      // 根据hash的值自动在url上增加hash\n      location.pathname ? '': location.pathname = '/';\n      window.addEventListener('load',() => {\n        this.history.current = location.pathname;\n      })\n      window.addEventListener('hashchange',() => {\n        this.history.current = location.pathname;\n      })\n    }\n  }\n  creatMap(routes){\n    // 将routes转化成键值对形式 ‘/’: Hello\n    // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n    // 参数一：初始值, 或者计算结束后的返回值。\n    // 参数二：当前元素\n    return routes.reduce((memo, current)=> {\n      memo[current.path] = current.component;\n      return memo\n    })\n  }\n}\nVueRouter.install = function (Vue) {\n  // 监视current变量的监视者\n  Vue.mixin({ //mixin会注入到每个组件\n    // 查找到在根实例上放入的VueRouter对象，然后注入到每个组件。\n    beforeCreate() {\n      // this.$option && this.$options.router:当前这个组件的配置&& 当前组件上已经加载过route路由对象\n      if (this.$options && this.$options.router) {\n        // 将当前的实例，挂在到当前实例的_root变量上。\n        this._root = this;\n        // 将当前router 注入到当前实例（组件）的_router上。\n        this._router = this.$options.router;\n        // 在当前组件this下面中的this._router.history变量上对current进行监听\n        Vue.util.defineReactive(this,'current', this._router.history);\n      } else {\n        // 逐级向上查找是否挂载\n        this._root = this.$parent._root;\n      }\n\n      // 扩展知识 组件使用this.$router和this.$route\n      // 在this上注册$router属性，并且不能更改。\n      Object.defineProperty(this, '$router', {\n        get () {\n          return this._root._router;\n        },\n      })\n      Object.defineProperty(this, '$route', {\n        get () {\n          return this._root._router.history.current;\n        },\n      })\n    }\n  });\n  Vue.component('route-view', {\n    render(h){\n      // 根据当前current获取到对应的路径;\n      // _self是vue自带的，_self指向实例自身；\n      let current = this._self._root._router.history.current;\n      let routeMap = this._self._root._router.routesMap;\n      return h(routeMap[current]) //h：渲染作用\n    }\n  })\n}\n// 暴露vue类\nexport default VueRouter;\n```\n\n直接在项目中引入就可以啦！！\n","slug":"vueRouter","published":1,"updated":"2020-05-13T08:32:44.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjs9002t78p3qv79xebr","content":"<p>Author: Echo<br>Time: 2020-05-13 16:30:54</p>\n<h2 id=\"一个vue路由的工作流程\"><a href=\"#一个vue路由的工作流程\" class=\"headerlink\" title=\"一个vue路由的工作流程\"></a>一个vue路由的工作流程</h2><hr>\n<h4 id=\"前端路由和后端路由的区别\"><a href=\"#前端路由和后端路由的区别\" class=\"headerlink\" title=\"前端路由和后端路由的区别\"></a>前端路由和后端路由的区别</h4><ul>\n<li>后端路由<br>输入url  –&gt;  请求发送到服务器 –&gt; 服务器解析请求的路径 –&gt; 浏览器拿取对应页面 –&gt; 页面渲染</li>\n<li>前端路由<br>输入url  –&gt;  js解析地址 –&gt; 找到对应地址的页面 –&gt; 执行页面生成的js –&gt; 页面渲染</li>\n</ul>\n<h4 id=\"vue-router的工作流程\"><a href=\"#vue-router的工作流程\" class=\"headerlink\" title=\"vue-router的工作流程\"></a>vue-router的工作流程</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-ae149ebe3bad8a05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"Hash与History\"><a href=\"#Hash与History\" class=\"headerlink\" title=\"Hash与History\"></a>Hash与History</h4><h6 id=\"hash和history的使用\"><a href=\"#hash和history的使用\" class=\"headerlink\" title=\"hash和history的使用\"></a>hash和history的使用</h6><p><code>hash:</code></p>\n<ul>\n<li><code>#</code>号后面的就是hash的内容</li>\n<li>通过location.hash来获取</li>\n<li>通过onhashchange监听hash的改变</li>\n</ul>\n<p><code>history:</code></p>\n<ul>\n<li>history即正常的路径</li>\n<li>通过location.pathname来获取</li>\n<li>通过onpopstate监听history的改变</li>\n</ul>\n<h2 id=\"实现vue-router源码实例\"><a href=\"#实现vue-router源码实例\" class=\"headerlink\" title=\"##实现vue-router源码实例\"></a>##实现vue-router源码实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HistoryRoute &#123;</span><br><span class=\"line\">  constructor()&#123;</span><br><span class=\"line\">    this.current = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * options: newRouter时传入的参数；</span><br><span class=\"line\">*/</span><br><span class=\"line\">class VueRouter&#123;</span><br><span class=\"line\">  constructor(options)&#123;</span><br><span class=\"line\">    this.mode = options.mode || &apos;hash&apos;;</span><br><span class=\"line\">    this.routes= options.routes || [];</span><br><span class=\"line\">    // 此处可以直接令this.history.current = null；但是为了记录前后路由跳转历史，生成HistoryRoute类</span><br><span class=\"line\">    this.history = new HistoryRoute;</span><br><span class=\"line\">    this.routesMap =  this.creatMap(this.routes);</span><br><span class=\"line\">    this.init(); //初始化路由</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  init () &#123;</span><br><span class=\"line\">    // 触发监听事件</span><br><span class=\"line\">    // 改变vue-router中的current变量</span><br><span class=\"line\">    if (this.mode == &apos;hash&apos;) &#123;</span><br><span class=\"line\">      // 根据hash的值自动在url上增加hash</span><br><span class=\"line\">      location.hash ? &apos;&apos;: location.hash = &apos;/&apos;;</span><br><span class=\"line\">      window.addEventListener(&apos;load&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.hash.slice(1);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      window.addEventListener(&apos;hashchange&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.hash.slice(1);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 根据hash的值自动在url上增加hash</span><br><span class=\"line\">      location.pathname ? &apos;&apos;: location.pathname = &apos;/&apos;;</span><br><span class=\"line\">      window.addEventListener(&apos;load&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.pathname;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      window.addEventListener(&apos;hashchange&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.pathname;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  creatMap(routes)&#123;</span><br><span class=\"line\">    // 将routes转化成键值对形式 ‘/’: Hello</span><br><span class=\"line\">    // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class=\"line\">    // 参数一：初始值, 或者计算结束后的返回值。</span><br><span class=\"line\">    // 参数二：当前元素</span><br><span class=\"line\">    return routes.reduce((memo, current)=&gt; &#123;</span><br><span class=\"line\">      memo[current.path] = current.component;</span><br><span class=\"line\">      return memo</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VueRouter.install = function (Vue) &#123;</span><br><span class=\"line\">  // 监视current变量的监视者</span><br><span class=\"line\">  Vue.mixin(&#123; //mixin会注入到每个组件</span><br><span class=\"line\">    // 查找到在根实例上放入的VueRouter对象，然后注入到每个组件。</span><br><span class=\"line\">    beforeCreate() &#123;</span><br><span class=\"line\">      // this.$option &amp;&amp; this.$options.router:当前这个组件的配置&amp;&amp; 当前组件上已经加载过route路由对象</span><br><span class=\"line\">      if (this.$options &amp;&amp; this.$options.router) &#123;</span><br><span class=\"line\">        // 将当前的实例，挂在到当前实例的_root变量上。</span><br><span class=\"line\">        this._root = this;</span><br><span class=\"line\">        // 将当前router 注入到当前实例（组件）的_router上。</span><br><span class=\"line\">        this._router = this.$options.router;</span><br><span class=\"line\">        // 在当前组件this下面中的this._router.history变量上对current进行监听</span><br><span class=\"line\">        Vue.util.defineReactive(this,&apos;current&apos;, this._router.history);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        // 逐级向上查找是否挂载</span><br><span class=\"line\">        this._root = this.$parent._root;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 扩展知识 组件使用this.$router和this.$route</span><br><span class=\"line\">      // 在this上注册$router属性，并且不能更改。</span><br><span class=\"line\">      Object.defineProperty(this, &apos;$router&apos;, &#123;</span><br><span class=\"line\">        get () &#123;</span><br><span class=\"line\">          return this._root._router;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      Object.defineProperty(this, &apos;$route&apos;, &#123;</span><br><span class=\"line\">        get () &#123;</span><br><span class=\"line\">          return this._root._router.history.current;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  Vue.component(&apos;route-view&apos;, &#123;</span><br><span class=\"line\">    render(h)&#123;</span><br><span class=\"line\">      // 根据当前current获取到对应的路径;</span><br><span class=\"line\">      // _self是vue自带的，_self指向实例自身；</span><br><span class=\"line\">      let current = this._self._root._router.history.current;</span><br><span class=\"line\">      let routeMap = this._self._root._router.routesMap;</span><br><span class=\"line\">      return h(routeMap[current]) //h：渲染作用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 暴露vue类</span><br><span class=\"line\">export default VueRouter;</span><br></pre></td></tr></table></figure>\n<p>直接在项目中引入就可以啦！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2020-05-13 16:30:54</p>\n<h2 id=\"一个vue路由的工作流程\"><a href=\"#一个vue路由的工作流程\" class=\"headerlink\" title=\"一个vue路由的工作流程\"></a>一个vue路由的工作流程</h2><hr>\n<h4 id=\"前端路由和后端路由的区别\"><a href=\"#前端路由和后端路由的区别\" class=\"headerlink\" title=\"前端路由和后端路由的区别\"></a>前端路由和后端路由的区别</h4><ul>\n<li>后端路由<br>输入url  –&gt;  请求发送到服务器 –&gt; 服务器解析请求的路径 –&gt; 浏览器拿取对应页面 –&gt; 页面渲染</li>\n<li>前端路由<br>输入url  –&gt;  js解析地址 –&gt; 找到对应地址的页面 –&gt; 执行页面生成的js –&gt; 页面渲染</li>\n</ul>\n<h4 id=\"vue-router的工作流程\"><a href=\"#vue-router的工作流程\" class=\"headerlink\" title=\"vue-router的工作流程\"></a>vue-router的工作流程</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-ae149ebe3bad8a05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h4 id=\"Hash与History\"><a href=\"#Hash与History\" class=\"headerlink\" title=\"Hash与History\"></a>Hash与History</h4><h6 id=\"hash和history的使用\"><a href=\"#hash和history的使用\" class=\"headerlink\" title=\"hash和history的使用\"></a>hash和history的使用</h6><p><code>hash:</code></p>\n<ul>\n<li><code>#</code>号后面的就是hash的内容</li>\n<li>通过location.hash来获取</li>\n<li>通过onhashchange监听hash的改变</li>\n</ul>\n<p><code>history:</code></p>\n<ul>\n<li>history即正常的路径</li>\n<li>通过location.pathname来获取</li>\n<li>通过onpopstate监听history的改变</li>\n</ul>\n<h2 id=\"实现vue-router源码实例\"><a href=\"#实现vue-router源码实例\" class=\"headerlink\" title=\"##实现vue-router源码实例\"></a>##实现vue-router源码实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class HistoryRoute &#123;</span><br><span class=\"line\">  constructor()&#123;</span><br><span class=\"line\">    this.current = null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * options: newRouter时传入的参数；</span><br><span class=\"line\">*/</span><br><span class=\"line\">class VueRouter&#123;</span><br><span class=\"line\">  constructor(options)&#123;</span><br><span class=\"line\">    this.mode = options.mode || &apos;hash&apos;;</span><br><span class=\"line\">    this.routes= options.routes || [];</span><br><span class=\"line\">    // 此处可以直接令this.history.current = null；但是为了记录前后路由跳转历史，生成HistoryRoute类</span><br><span class=\"line\">    this.history = new HistoryRoute;</span><br><span class=\"line\">    this.routesMap =  this.creatMap(this.routes);</span><br><span class=\"line\">    this.init(); //初始化路由</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  init () &#123;</span><br><span class=\"line\">    // 触发监听事件</span><br><span class=\"line\">    // 改变vue-router中的current变量</span><br><span class=\"line\">    if (this.mode == &apos;hash&apos;) &#123;</span><br><span class=\"line\">      // 根据hash的值自动在url上增加hash</span><br><span class=\"line\">      location.hash ? &apos;&apos;: location.hash = &apos;/&apos;;</span><br><span class=\"line\">      window.addEventListener(&apos;load&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.hash.slice(1);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      window.addEventListener(&apos;hashchange&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.hash.slice(1);</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      // 根据hash的值自动在url上增加hash</span><br><span class=\"line\">      location.pathname ? &apos;&apos;: location.pathname = &apos;/&apos;;</span><br><span class=\"line\">      window.addEventListener(&apos;load&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.pathname;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      window.addEventListener(&apos;hashchange&apos;,() =&gt; &#123;</span><br><span class=\"line\">        this.history.current = location.pathname;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  creatMap(routes)&#123;</span><br><span class=\"line\">    // 将routes转化成键值对形式 ‘/’: Hello</span><br><span class=\"line\">    // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class=\"line\">    // 参数一：初始值, 或者计算结束后的返回值。</span><br><span class=\"line\">    // 参数二：当前元素</span><br><span class=\"line\">    return routes.reduce((memo, current)=&gt; &#123;</span><br><span class=\"line\">      memo[current.path] = current.component;</span><br><span class=\"line\">      return memo</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">VueRouter.install = function (Vue) &#123;</span><br><span class=\"line\">  // 监视current变量的监视者</span><br><span class=\"line\">  Vue.mixin(&#123; //mixin会注入到每个组件</span><br><span class=\"line\">    // 查找到在根实例上放入的VueRouter对象，然后注入到每个组件。</span><br><span class=\"line\">    beforeCreate() &#123;</span><br><span class=\"line\">      // this.$option &amp;&amp; this.$options.router:当前这个组件的配置&amp;&amp; 当前组件上已经加载过route路由对象</span><br><span class=\"line\">      if (this.$options &amp;&amp; this.$options.router) &#123;</span><br><span class=\"line\">        // 将当前的实例，挂在到当前实例的_root变量上。</span><br><span class=\"line\">        this._root = this;</span><br><span class=\"line\">        // 将当前router 注入到当前实例（组件）的_router上。</span><br><span class=\"line\">        this._router = this.$options.router;</span><br><span class=\"line\">        // 在当前组件this下面中的this._router.history变量上对current进行监听</span><br><span class=\"line\">        Vue.util.defineReactive(this,&apos;current&apos;, this._router.history);</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        // 逐级向上查找是否挂载</span><br><span class=\"line\">        this._root = this.$parent._root;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      // 扩展知识 组件使用this.$router和this.$route</span><br><span class=\"line\">      // 在this上注册$router属性，并且不能更改。</span><br><span class=\"line\">      Object.defineProperty(this, &apos;$router&apos;, &#123;</span><br><span class=\"line\">        get () &#123;</span><br><span class=\"line\">          return this._root._router;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      Object.defineProperty(this, &apos;$route&apos;, &#123;</span><br><span class=\"line\">        get () &#123;</span><br><span class=\"line\">          return this._root._router.history.current;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  Vue.component(&apos;route-view&apos;, &#123;</span><br><span class=\"line\">    render(h)&#123;</span><br><span class=\"line\">      // 根据当前current获取到对应的路径;</span><br><span class=\"line\">      // _self是vue自带的，_self指向实例自身；</span><br><span class=\"line\">      let current = this._self._root._router.history.current;</span><br><span class=\"line\">      let routeMap = this._self._root._router.routesMap;</span><br><span class=\"line\">      return h(routeMap[current]) //h：渲染作用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 暴露vue类</span><br><span class=\"line\">export default VueRouter;</span><br></pre></td></tr></table></figure>\n<p>直接在项目中引入就可以啦！！</p>\n"},{"title":"vue项目中引入&使用国际化","date":"2020-07-27T09:24:07.000Z","_content":"\n* 国际化思路：将当前语言代码-国家地区对照表（zh-CN）放到cookie中和vuex中,每次通过读取cookie&vuex中的语言代码，来展示对应的语言包，在切换语言的时候将语言代码存入到cookie&vuex中（保证刷新页面后能记住用户选择的语言）。\n## 一、安装vue-i18n&vuex&js-cookie\n`vue-i18n`是vue国际化依赖包,vuex是状态管理。\n```\nnpm install --save vue-i18n vuex js-cookie\n```\n## 二、引入vue-i18n&vuex&js-cookie\n在main.js中注册引入即可。\n```\nimport VueI18n from 'vue-i18n'\nimport Cookies from 'js-cookie'\nVue.use(VueI18n)\nimport store from 'vuex'\nnew Vue({\n  el: '#app',\n  i18n,\n  store,\n  components: { App },\n  template: '<App/>'\n}\n```\n小编是将其放在store&lang之中,在main.js中引入两个文件\n```\nimport store from './store'\nimport i18n from './lang'\n// 由于这里用到了element组件库，这里需要的同学自行安装element-ui\n// npm install element-ui\n//  Vue.use(Element, {\n//  i18n: (key, value) => i18n.t(key, value)\n// })\nnew Vue({\n  el: '#app',\n  router,\n  i18n,\n  store,\n  components: { App },\n  template: '<App/>'\n})\n```\nlang文件夹：当前以中英文为例，需要支持多个语言则可添加同级语言包。\n```\nlang\n  |--index.js   //主文件\n  |\n  |-- zh.js      //中文语言包\n  |\n  |-- zh.js      //英文语言包\n\n```\n```\n`index.js`\nimport Vue from 'vue'\nimport VueI18n from 'vue-i18n'\nimport Cookies from 'js-cookie'\nimport elementEnLocale from 'element-ui/lib/locale/lang/en' // element-ui lang\nimport elementZhLocale from 'element-ui/lib/locale/lang/zh-CN'// element-ui lang\nimport enLocale from './en'\nimport zhLocale from './zh'\n\nVue.use(VueI18n)\n\nconst messages = {\n  en-US: {\n    ...enLocale,\n    ...elementEnLocale\n  },\n  zh-CN: {\n    ...zhLocale,\n    ...elementZhLocale\n  }\n}\n\nconst i18n = new VueI18n({\n  locale: Cookies.get('language') || 'en-US',\n  messages\n})\n\nexport default i18n\n\n```\n```\n`zh.js`\n  export default {\n  login: {\n    title: '欢迎'\n    logIn: '登录'\n }\n`en.js`\nexport default {\n  login: {\n    title: 'Welcome',\n    logIn: 'Log in'\n }\n```\n## 三、使用实例：\n```\n<span>{{$t('login.title')}}</span>\n// 在语言代码为中文（zh-CN）时,则展示为：欢迎\n// 在语言代码为英文（en-US）时,则展示为：Welcome'\n```\nstore文件夹：vue&cookie中存入语言代码。\n```\nstore\n  |--index.js   //主文件\n  |\n  |-- modules      //vuex子模块文件\n          |\n          |-- language.js      //语言\n```\n```\n`index.js`\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport language from './modules/language'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n  modules: {\n    language\n  }\n})\n\nexport default store\n```\n```\n`language.js  `\nimport Cookies from 'js-cookie'\nimport Cookies from 'js-cookie'\n\nconst app = {\n  state: {\n    language: Cookies.get('language') || 'en-US' // 项目初始化时，默认为英文\n  },\n  mutations: {\n    SET_LANGUAGE: (state, language) => {\n      state.language = language\n      Cookies.set('language', language)\n    },\n  },\n  getters: {\n    language: state => state.language\n  },\n  actions: {\n    setLanguage({ commit }, language) {\n      commit('SET_LANGUAGE', language)\n    },\n  }\n}\n\nexport default app\n```\n在项目需要切换语言的位置，添加如下事件即可，（事件：将语言代码存入到vuex中，vuex中调用setcookie即可存入到cookie中,并改变i18n中的local即可切换语言。）\n```\nhandleSetLanguage(lang) {\n  this.$i18n.locale = lang\n  this.$store.dispatch('setLanguage', lang)\n}\n```\n大功告成✌️✌️✌️\n\n\n\n\n","source":"_posts/vueI18.md","raw":"---\ntitle: vue项目中引入&使用国际化\ndate: 2020-07-27 17:24:07\ntags: Vue\n---\n\n* 国际化思路：将当前语言代码-国家地区对照表（zh-CN）放到cookie中和vuex中,每次通过读取cookie&vuex中的语言代码，来展示对应的语言包，在切换语言的时候将语言代码存入到cookie&vuex中（保证刷新页面后能记住用户选择的语言）。\n## 一、安装vue-i18n&vuex&js-cookie\n`vue-i18n`是vue国际化依赖包,vuex是状态管理。\n```\nnpm install --save vue-i18n vuex js-cookie\n```\n## 二、引入vue-i18n&vuex&js-cookie\n在main.js中注册引入即可。\n```\nimport VueI18n from 'vue-i18n'\nimport Cookies from 'js-cookie'\nVue.use(VueI18n)\nimport store from 'vuex'\nnew Vue({\n  el: '#app',\n  i18n,\n  store,\n  components: { App },\n  template: '<App/>'\n}\n```\n小编是将其放在store&lang之中,在main.js中引入两个文件\n```\nimport store from './store'\nimport i18n from './lang'\n// 由于这里用到了element组件库，这里需要的同学自行安装element-ui\n// npm install element-ui\n//  Vue.use(Element, {\n//  i18n: (key, value) => i18n.t(key, value)\n// })\nnew Vue({\n  el: '#app',\n  router,\n  i18n,\n  store,\n  components: { App },\n  template: '<App/>'\n})\n```\nlang文件夹：当前以中英文为例，需要支持多个语言则可添加同级语言包。\n```\nlang\n  |--index.js   //主文件\n  |\n  |-- zh.js      //中文语言包\n  |\n  |-- zh.js      //英文语言包\n\n```\n```\n`index.js`\nimport Vue from 'vue'\nimport VueI18n from 'vue-i18n'\nimport Cookies from 'js-cookie'\nimport elementEnLocale from 'element-ui/lib/locale/lang/en' // element-ui lang\nimport elementZhLocale from 'element-ui/lib/locale/lang/zh-CN'// element-ui lang\nimport enLocale from './en'\nimport zhLocale from './zh'\n\nVue.use(VueI18n)\n\nconst messages = {\n  en-US: {\n    ...enLocale,\n    ...elementEnLocale\n  },\n  zh-CN: {\n    ...zhLocale,\n    ...elementZhLocale\n  }\n}\n\nconst i18n = new VueI18n({\n  locale: Cookies.get('language') || 'en-US',\n  messages\n})\n\nexport default i18n\n\n```\n```\n`zh.js`\n  export default {\n  login: {\n    title: '欢迎'\n    logIn: '登录'\n }\n`en.js`\nexport default {\n  login: {\n    title: 'Welcome',\n    logIn: 'Log in'\n }\n```\n## 三、使用实例：\n```\n<span>{{$t('login.title')}}</span>\n// 在语言代码为中文（zh-CN）时,则展示为：欢迎\n// 在语言代码为英文（en-US）时,则展示为：Welcome'\n```\nstore文件夹：vue&cookie中存入语言代码。\n```\nstore\n  |--index.js   //主文件\n  |\n  |-- modules      //vuex子模块文件\n          |\n          |-- language.js      //语言\n```\n```\n`index.js`\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport language from './modules/language'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n  modules: {\n    language\n  }\n})\n\nexport default store\n```\n```\n`language.js  `\nimport Cookies from 'js-cookie'\nimport Cookies from 'js-cookie'\n\nconst app = {\n  state: {\n    language: Cookies.get('language') || 'en-US' // 项目初始化时，默认为英文\n  },\n  mutations: {\n    SET_LANGUAGE: (state, language) => {\n      state.language = language\n      Cookies.set('language', language)\n    },\n  },\n  getters: {\n    language: state => state.language\n  },\n  actions: {\n    setLanguage({ commit }, language) {\n      commit('SET_LANGUAGE', language)\n    },\n  }\n}\n\nexport default app\n```\n在项目需要切换语言的位置，添加如下事件即可，（事件：将语言代码存入到vuex中，vuex中调用setcookie即可存入到cookie中,并改变i18n中的local即可切换语言。）\n```\nhandleSetLanguage(lang) {\n  this.$i18n.locale = lang\n  this.$store.dispatch('setLanguage', lang)\n}\n```\n大功告成✌️✌️✌️\n\n\n\n\n","slug":"vueI18","published":1,"updated":"2020-12-14T09:06:34.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjsa002v78p3fw7qkhau","content":"<ul>\n<li>国际化思路：将当前语言代码-国家地区对照表（zh-CN）放到cookie中和vuex中,每次通过读取cookie&amp;vuex中的语言代码，来展示对应的语言包，在切换语言的时候将语言代码存入到cookie&amp;vuex中（保证刷新页面后能记住用户选择的语言）。<h2 id=\"一、安装vue-i18n-amp-vuex-amp-js-cookie\"><a href=\"#一、安装vue-i18n-amp-vuex-amp-js-cookie\" class=\"headerlink\" title=\"一、安装vue-i18n&amp;vuex&amp;js-cookie\"></a>一、安装vue-i18n&amp;vuex&amp;js-cookie</h2><code>vue-i18n</code>是vue国际化依赖包,vuex是状态管理。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save vue-i18n vuex js-cookie</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二、引入vue-i18n-amp-vuex-amp-js-cookie\"><a href=\"#二、引入vue-i18n-amp-vuex-amp-js-cookie\" class=\"headerlink\" title=\"二、引入vue-i18n&amp;vuex&amp;js-cookie\"></a>二、引入vue-i18n&amp;vuex&amp;js-cookie</h2><p>在main.js中注册引入即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import VueI18n from &apos;vue-i18n&apos;</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\">Vue.use(VueI18n)</span><br><span class=\"line\">import store from &apos;vuex&apos;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  i18n,</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>小编是将其放在store&amp;lang之中,在main.js中引入两个文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import store from &apos;./store&apos;</span><br><span class=\"line\">import i18n from &apos;./lang&apos;</span><br><span class=\"line\">// 由于这里用到了element组件库，这里需要的同学自行安装element-ui</span><br><span class=\"line\">// npm install element-ui</span><br><span class=\"line\">//  Vue.use(Element, &#123;</span><br><span class=\"line\">//  i18n: (key, value) =&gt; i18n.t(key, value)</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  i18n,</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>lang文件夹：当前以中英文为例，需要支持多个语言则可添加同级语言包。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lang</span><br><span class=\"line\">  |--index.js   //主文件</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- zh.js      //中文语言包</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- zh.js      //英文语言包</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`index.js`</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import VueI18n from &apos;vue-i18n&apos;</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\">import elementEnLocale from &apos;element-ui/lib/locale/lang/en&apos; // element-ui lang</span><br><span class=\"line\">import elementZhLocale from &apos;element-ui/lib/locale/lang/zh-CN&apos;// element-ui lang</span><br><span class=\"line\">import enLocale from &apos;./en&apos;</span><br><span class=\"line\">import zhLocale from &apos;./zh&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueI18n)</span><br><span class=\"line\"></span><br><span class=\"line\">const messages = &#123;</span><br><span class=\"line\">  en-US: &#123;</span><br><span class=\"line\">    ...enLocale,</span><br><span class=\"line\">    ...elementEnLocale</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  zh-CN: &#123;</span><br><span class=\"line\">    ...zhLocale,</span><br><span class=\"line\">    ...elementZhLocale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const i18n = new VueI18n(&#123;</span><br><span class=\"line\">  locale: Cookies.get(&apos;language&apos;) || &apos;en-US&apos;,</span><br><span class=\"line\">  messages</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default i18n</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`zh.js`</span><br><span class=\"line\">  export default &#123;</span><br><span class=\"line\">  login: &#123;</span><br><span class=\"line\">    title: &apos;欢迎&apos;</span><br><span class=\"line\">    logIn: &apos;登录&apos;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">`en.js`</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  login: &#123;</span><br><span class=\"line\">    title: &apos;Welcome&apos;,</span><br><span class=\"line\">    logIn: &apos;Log in&apos;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、使用实例：\"><a href=\"#三、使用实例：\" class=\"headerlink\" title=\"三、使用实例：\"></a>三、使用实例：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;&#123;&#123;$t(&apos;login.title&apos;)&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">// 在语言代码为中文（zh-CN）时,则展示为：欢迎</span><br><span class=\"line\">// 在语言代码为英文（en-US）时,则展示为：Welcome&apos;</span><br></pre></td></tr></table></figure>\n<p>store文件夹：vue&amp;cookie中存入语言代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store</span><br><span class=\"line\">  |--index.js   //主文件</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- modules      //vuex子模块文件</span><br><span class=\"line\">          |</span><br><span class=\"line\">          |-- language.js      //语言</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`index.js`</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\">import language from &apos;./modules/language&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    language</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default store</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`language.js  `</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const app = &#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    language: Cookies.get(&apos;language&apos;) || &apos;en-US&apos; // 项目初始化时，默认为英文</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    SET_LANGUAGE: (state, language) =&gt; &#123;</span><br><span class=\"line\">      state.language = language</span><br><span class=\"line\">      Cookies.set(&apos;language&apos;, language)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    language: state =&gt; state.language</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    setLanguage(&#123; commit &#125;, language) &#123;</span><br><span class=\"line\">      commit(&apos;SET_LANGUAGE&apos;, language)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default app</span><br></pre></td></tr></table></figure>\n<p>在项目需要切换语言的位置，添加如下事件即可，（事件：将语言代码存入到vuex中，vuex中调用setcookie即可存入到cookie中,并改变i18n中的local即可切换语言。）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleSetLanguage(lang) &#123;</span><br><span class=\"line\">  this.$i18n.locale = lang</span><br><span class=\"line\">  this.$store.dispatch(&apos;setLanguage&apos;, lang)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大功告成✌️✌️✌️</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>国际化思路：将当前语言代码-国家地区对照表（zh-CN）放到cookie中和vuex中,每次通过读取cookie&amp;vuex中的语言代码，来展示对应的语言包，在切换语言的时候将语言代码存入到cookie&amp;vuex中（保证刷新页面后能记住用户选择的语言）。<h2 id=\"一、安装vue-i18n-amp-vuex-amp-js-cookie\"><a href=\"#一、安装vue-i18n-amp-vuex-amp-js-cookie\" class=\"headerlink\" title=\"一、安装vue-i18n&amp;vuex&amp;js-cookie\"></a>一、安装vue-i18n&amp;vuex&amp;js-cookie</h2><code>vue-i18n</code>是vue国际化依赖包,vuex是状态管理。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save vue-i18n vuex js-cookie</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"二、引入vue-i18n-amp-vuex-amp-js-cookie\"><a href=\"#二、引入vue-i18n-amp-vuex-amp-js-cookie\" class=\"headerlink\" title=\"二、引入vue-i18n&amp;vuex&amp;js-cookie\"></a>二、引入vue-i18n&amp;vuex&amp;js-cookie</h2><p>在main.js中注册引入即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import VueI18n from &apos;vue-i18n&apos;</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\">Vue.use(VueI18n)</span><br><span class=\"line\">import store from &apos;vuex&apos;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  i18n,</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>小编是将其放在store&amp;lang之中,在main.js中引入两个文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import store from &apos;./store&apos;</span><br><span class=\"line\">import i18n from &apos;./lang&apos;</span><br><span class=\"line\">// 由于这里用到了element组件库，这里需要的同学自行安装element-ui</span><br><span class=\"line\">// npm install element-ui</span><br><span class=\"line\">//  Vue.use(Element, &#123;</span><br><span class=\"line\">//  i18n: (key, value) =&gt; i18n.t(key, value)</span><br><span class=\"line\">// &#125;)</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#app&apos;,</span><br><span class=\"line\">  router,</span><br><span class=\"line\">  i18n,</span><br><span class=\"line\">  store,</span><br><span class=\"line\">  components: &#123; App &#125;,</span><br><span class=\"line\">  template: &apos;&lt;App/&gt;&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>lang文件夹：当前以中英文为例，需要支持多个语言则可添加同级语言包。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lang</span><br><span class=\"line\">  |--index.js   //主文件</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- zh.js      //中文语言包</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- zh.js      //英文语言包</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`index.js`</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import VueI18n from &apos;vue-i18n&apos;</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\">import elementEnLocale from &apos;element-ui/lib/locale/lang/en&apos; // element-ui lang</span><br><span class=\"line\">import elementZhLocale from &apos;element-ui/lib/locale/lang/zh-CN&apos;// element-ui lang</span><br><span class=\"line\">import enLocale from &apos;./en&apos;</span><br><span class=\"line\">import zhLocale from &apos;./zh&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(VueI18n)</span><br><span class=\"line\"></span><br><span class=\"line\">const messages = &#123;</span><br><span class=\"line\">  en-US: &#123;</span><br><span class=\"line\">    ...enLocale,</span><br><span class=\"line\">    ...elementEnLocale</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  zh-CN: &#123;</span><br><span class=\"line\">    ...zhLocale,</span><br><span class=\"line\">    ...elementZhLocale</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const i18n = new VueI18n(&#123;</span><br><span class=\"line\">  locale: Cookies.get(&apos;language&apos;) || &apos;en-US&apos;,</span><br><span class=\"line\">  messages</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default i18n</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`zh.js`</span><br><span class=\"line\">  export default &#123;</span><br><span class=\"line\">  login: &#123;</span><br><span class=\"line\">    title: &apos;欢迎&apos;</span><br><span class=\"line\">    logIn: &apos;登录&apos;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">`en.js`</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  login: &#123;</span><br><span class=\"line\">    title: &apos;Welcome&apos;,</span><br><span class=\"line\">    logIn: &apos;Log in&apos;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、使用实例：\"><a href=\"#三、使用实例：\" class=\"headerlink\" title=\"三、使用实例：\"></a>三、使用实例：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;&#123;&#123;$t(&apos;login.title&apos;)&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">// 在语言代码为中文（zh-CN）时,则展示为：欢迎</span><br><span class=\"line\">// 在语言代码为英文（en-US）时,则展示为：Welcome&apos;</span><br></pre></td></tr></table></figure>\n<p>store文件夹：vue&amp;cookie中存入语言代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store</span><br><span class=\"line\">  |--index.js   //主文件</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- modules      //vuex子模块文件</span><br><span class=\"line\">          |</span><br><span class=\"line\">          |-- language.js      //语言</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`index.js`</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\">import language from &apos;./modules/language&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br><span class=\"line\"></span><br><span class=\"line\">const store = new Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    language</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">export default store</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`language.js  `</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\">import Cookies from &apos;js-cookie&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const app = &#123;</span><br><span class=\"line\">  state: &#123;</span><br><span class=\"line\">    language: Cookies.get(&apos;language&apos;) || &apos;en-US&apos; // 项目初始化时，默认为英文</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mutations: &#123;</span><br><span class=\"line\">    SET_LANGUAGE: (state, language) =&gt; &#123;</span><br><span class=\"line\">      state.language = language</span><br><span class=\"line\">      Cookies.set(&apos;language&apos;, language)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  getters: &#123;</span><br><span class=\"line\">    language: state =&gt; state.language</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  actions: &#123;</span><br><span class=\"line\">    setLanguage(&#123; commit &#125;, language) &#123;</span><br><span class=\"line\">      commit(&apos;SET_LANGUAGE&apos;, language)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default app</span><br></pre></td></tr></table></figure>\n<p>在项目需要切换语言的位置，添加如下事件即可，（事件：将语言代码存入到vuex中，vuex中调用setcookie即可存入到cookie中,并改变i18n中的local即可切换语言。）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleSetLanguage(lang) &#123;</span><br><span class=\"line\">  this.$i18n.locale = lang</span><br><span class=\"line\">  this.$store.dispatch(&apos;setLanguage&apos;, lang)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大功告成✌️✌️✌️</p>\n"},{"title":"vueTest","date":"2020-05-06T07:15:23.000Z","_content":"\nAuthor: Echo\nTime: 2020-05-06 15:15:23\n\n## 组件单元测试的好处\n\n* 提供描述组件行为的文档\n* 节省手动测试的时间\n* 减少研发新特性时产生的bug\n* 改进设计\n* 促进重构\n\n自动化测试使得大团队中的开发者可以维护复杂的基础代码。\n\n##  I. 单元测试简介\n\n---\n\n> 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。\n\n简单来说，`单元`就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。\n\n对于开发活动中的各种测试，最常见的划分方法：从下至上依次为 **单元测试->集成测试->端到端测试** ，随着其集成度的递增，对应的自动化程度递减。\n\n端到端（在浏览器等真实场景中走通功能而把程序当成黑盒子的测试）与集成测试（集合多个测试过的单元一起测试）的反馈与修复的周期比较长、运行速度慢，测试运行不稳定，由于很多时候还要靠人工手动进行，维护成本也很高。而单元测试只针对具体一个方法或API，定位准确，采用 mock 机制，运行速度非常快（毫秒级），又是开发人员在本地执行，反馈修复及时，成本较低。\n\n我们把绝大部分能在单元测试里覆盖的用例都放在单元测试覆盖，只有单元测试测不了的，才会通过端到端与集成测试来覆盖。\n\n**讲解单元测试的具体概念之前，先 咀个栗子 直观了解下：**\n\n比如我们有这样一个模块，暴露两个方法用以对菜单路径进行一些处理：\n\n```\n// src/menuChecker.js\n\nexport function getRoutePath(str) {\n  let to = \"\"\n  //...\n  return to;\n}\n\nexport function getHighlight(str) {\n  let hl = \"\";\n  //...\n  return hl;\n}\n```\n编写对应的测试文件：\n\n```\nimport {\n  getRoutePath,\n  getHighlight\n} from \"@/menuChecker\";\n\ndescribe(\"检查菜单路径相关函数\", ()=>{\n\n  it(\"应该获得正确高亮值\", ()=>{\n    expect( getHighlight(\"/myworksheet/(.*)\") ).toBe(\"myTickets\");\n  });\n\n  it(\"应该为未知路径取得默认的高亮值\", ()=>{\n    expect( getHighlight(\"/myworksheet/ccc/aaa\") ).toBe(\"mydefaulthl111\");\n  });\n\n  it(\"应该补齐开头的斜杠\", ()=>{\n    expect( getRoutePath(\"/worksheet/list\") ).toBe('/worksheet/list');\n  });\n\n  it(\"应该能修正非法的路径\", ()=>{\n    expect( getRoutePath(\"/myworksheet/(.*)\") ).toBe(\"/myworksheet/list\");\n  });\n});\n```\n运行该测试文件，得到如下输出：\n\n![![20200506151145.png](https://upload-images.jianshu.io/upload_images/11846892-1dec9c605aeb4dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n](https://upload-images.jianshu.io/upload_images/11846892-e6bc2edad5dc4097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由此，我们对一次单元测试的过程有了基本的了解。\n\n## 断言(assertions)\n\n断言是单元测试框架中核心的部分，断言失败会导致测试不通过，或报告错误信息。\n\n对于常见的断言，举一些例子如下：\n\n- 同等性断言 Equality Asserts\n\n      1. expect(sth).toEqual(value)\n      2. expect(sth).not.toEqual(value)\n- 比较性断言 Comparison Asserts\n\n      1. expect(sth).toBeGreaterThan(number)\n      2. expect(sth).toBeLessThanOrEqual(number)\n- 类型性断言 Type Asserts\n\n      1. expect(sth).toBeInstanceOf(Class)\n- 条件性测试 Condition Test\n\n      1. expect(sth).toBeTruthy()\n      2. expect(sth).toBeFalsy()\n      3. expect(sth).toBeDefined()\n\n## 断言库\n\n断言库主要提供上述断言的语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 Should.js, Chai.js 等。\n\n## 测试用例 test case\n\n为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。\n\n一般的形式为：\n\n```\nit('should ...', function() {\n    ...\n        \n    expect(sth).toEqual(sth);\n});\n\n```\n\n##  测试套件 test suite\n\n通常把一组相关的测试称为一个测试套件\n\n一般的形式为：\n```\ndescribe('test ...', function() {\n    \n    it('should ...', function() { ... });\n    \n    it('should ...', function() { ... });\n    \n    ...\n    \n});\n```\n\n## spy\n\n> 正如 spy 字面的意思一样，我们用这种“间谍”来“监视”函数的调用情况\n\n通过对监视的函数进行包装，可以通过它清楚的知道该函数被调用过几次、传入什么参数、返回什么结果，甚至是抛出的异常情况。\n\n```\nvar spy = sinon.spy(MyComp.prototype, 'someMethod');\n\n...\n\nexpect(spy.callCount).toEqual(1);\n```\n\n## stub\n> 有时候会使用stub来嵌入或者直接替换掉一些代码，来达到隔离的目的\n\n一个stub可以使用最少的依赖方法来模拟该单元测试。比如一个方法可能依赖另一个方法的执行，而后者对我们来说是透明的。好的做法是使用stub 对它进行隔离替换。这样就实现了更准确的单元测试。\n\n```\nvar myObj = {\n    prop: function() {\n        return 'foo';\n    }\n};\n\nsinon.stub(myObj, 'prop').callsFake(function() {\n    return 'bar';\n});\n\nmyObj.prop(); // 'bar'\n```\n\n## mock\n\n`mock`一般指在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法\n\n广义的讲，以上的 spy 和 stub 等，以及一些对模块的模拟，对 ajax 返回值的模拟、对 timer 的模拟，都叫做 mock 。\n\n## 测试覆盖率(code coverage)\n\n用于统计测试用例对代码的测试情况，生成相应的报表，比如 `istanbul` 是常见的测试覆盖率统计工具。\n\n`istanbul` 也就是土耳其首都 “伊斯坦布尔”，这样命名是因为土耳其地毯世界闻名，而地毯是用来\"覆盖\"的😷。\n\n回顾一下上面的图：\n\n\n![20200506151145.png](https://upload-images.jianshu.io/upload_images/11846892-8cc2514fc4359845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n表格中的第2列至第5列，分别对应了四个衡量维度：\n\n* 语句覆盖率（statement coverage）：是否每个语句都执行了\n* 分支覆盖率（branch coverage）：是否每个`if`代码块都执行了\n* 函数覆盖率（function coverage）：是否每个函数都调用了\n* 行覆盖率（line coverage）：是否每一行都执行了\n\n测试结果根据覆盖率被分为“绿色、黄色、红色”三种，应该关注这些指标，测试越全面，就能提供更高的保证。\n\n同时也没有必要一味追求行覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。\n\n\n## II. Vue.js 中的单元测试工具\n\n---\n\n## Jest\n\n不同于\"传统的\"(其实也没出现几年)的 jasmine / Mocha / Chai 等前端测试框架；Jest的使用更简单（也许就是这个单词的本意“俏皮话、玩笑话”的意思），并且提供了更高的集成度、更丰富的功能。\n\nJest 是一个由 Facebook 开发的测试运行器，相对其他测试框架，其特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。\n\n#### 配置\n\nJest 号称自己是一个 “Zero configuration testing platform”，只需在 npm scripts里面配置了test: jest，即可运行npm test，自动识别并测试符合其规则的（ Vue.js 项目中一般是 __tests__ 目录下的）用例文件。\n\n实际使用中，适当的在 package.json 的 jest 字段或独立的 jest.config.js 里自定义配置一下，会得到更适合我们的测试场景。\n\n参考文档 https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html ，可以很快在 Vue.js 项目中配置好 Jest 测试环境\n\n\n#### 四个基础单词\n\n编写单元测试的语法通常非常简单；对于jest来说，由于其内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。\n\n实际上，只要先记这住四个单词，就足以应付大多数测试情况了：\n\n* describe： 定义一个测试套件\n* it：定义一个测试用例\n* expect：断言的判断条件\n* toEqual：断言的比较结果\n\n```\ndescribe('test ...', function() {\n    it('should ...', function() {\n        expect(sth).toEqual(sth);\n        expect(sth.length).toEqual(1);\n        expect(sth > oth).toEqual(true);\n    });\n});\n```\n\n##  Vue Test Utils\n\n> Vue Test Utils 是 Vue.js 官方的单元测试实用工具库\n\n它模拟了一部分类似 jQuery 的 API，非常直观并且易于使用和学习，提供了一些接口和几个方法来减少测试的样板代码，方便判断、操纵和遍历 Vue Component 的输出，并且减少了测试代码和实现代码之间的耦合。\n\n一般使用其 mount() 或 shallowMount() 方法，将目标组件转化为一个 Wrapper 对象，并在测试中调用其各种方法，例如：\n```\nimport { mount } from '@vue/test-utils'\nimport Foo from './Foo.vue'\n\ndescribe('Foo', () => {\n  it('renders a div', () => {\n    const wrapper = mount(Foo)\n    expect(wrapper.contains('div')).toBe(true)\n  })\n})\n```\n\n## V. 将单元测试整合到工作流中\n\n---\n\n写好的单元测试，如果仅仅要靠每次 npm test 手动执行，必然会有日久忘记、逐渐过时，最后甚至无法执行的情况。\n\n有多个时间点可以作为选择，插入自动执行单元测试 -- 例如每次保存文件、每次执行 build 等；此处我们选择了一种很简单的配置办法：\n\n首先在项目中安装 pre-commit 依赖包；然后在 package.json 中配置 npm scripts ：\n\n```\n\"scripts\": {\n  ...\n  \"test\": \"jest\"\n},\n\"pre-commit\": [\n  \"test\"\n],\n```\n这样在每次 git commit 之前，项目中存在的单元测试就会自动执行一次，往往就避免了 “改一个 bug，送十个新 bug” 的窘况。\n\n## VI. 总结\n\n---\n单元测试作为一种经典的开发和重构手段，在软件开发领域被广泛认可和采用；前端领域也逐渐积累起了丰富的测试框架和方法。\n\n单元测试可以为我们的开发和维护提供基础保障，使我们在思路清晰、心中有底的情况下完成对代码的搭建和重构。\n\n封装好则测试易，反之不恰当的封装让测试变得困难。\n\n可测试性是一个检验组件结构良好程度的实践标准。\n\n参考资料：\n  wx公众号：云前端\n  文章: 实例入门 Vue.js 单元测试\n","source":"_posts/vueTest.md","raw":"---\ntitle: vueTest\ndate: 2020-05-06 15:15:23\ntags: vue test\n---\n\nAuthor: Echo\nTime: 2020-05-06 15:15:23\n\n## 组件单元测试的好处\n\n* 提供描述组件行为的文档\n* 节省手动测试的时间\n* 减少研发新特性时产生的bug\n* 改进设计\n* 促进重构\n\n自动化测试使得大团队中的开发者可以维护复杂的基础代码。\n\n##  I. 单元测试简介\n\n---\n\n> 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。\n\n简单来说，`单元`就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。\n\n对于开发活动中的各种测试，最常见的划分方法：从下至上依次为 **单元测试->集成测试->端到端测试** ，随着其集成度的递增，对应的自动化程度递减。\n\n端到端（在浏览器等真实场景中走通功能而把程序当成黑盒子的测试）与集成测试（集合多个测试过的单元一起测试）的反馈与修复的周期比较长、运行速度慢，测试运行不稳定，由于很多时候还要靠人工手动进行，维护成本也很高。而单元测试只针对具体一个方法或API，定位准确，采用 mock 机制，运行速度非常快（毫秒级），又是开发人员在本地执行，反馈修复及时，成本较低。\n\n我们把绝大部分能在单元测试里覆盖的用例都放在单元测试覆盖，只有单元测试测不了的，才会通过端到端与集成测试来覆盖。\n\n**讲解单元测试的具体概念之前，先 咀个栗子 直观了解下：**\n\n比如我们有这样一个模块，暴露两个方法用以对菜单路径进行一些处理：\n\n```\n// src/menuChecker.js\n\nexport function getRoutePath(str) {\n  let to = \"\"\n  //...\n  return to;\n}\n\nexport function getHighlight(str) {\n  let hl = \"\";\n  //...\n  return hl;\n}\n```\n编写对应的测试文件：\n\n```\nimport {\n  getRoutePath,\n  getHighlight\n} from \"@/menuChecker\";\n\ndescribe(\"检查菜单路径相关函数\", ()=>{\n\n  it(\"应该获得正确高亮值\", ()=>{\n    expect( getHighlight(\"/myworksheet/(.*)\") ).toBe(\"myTickets\");\n  });\n\n  it(\"应该为未知路径取得默认的高亮值\", ()=>{\n    expect( getHighlight(\"/myworksheet/ccc/aaa\") ).toBe(\"mydefaulthl111\");\n  });\n\n  it(\"应该补齐开头的斜杠\", ()=>{\n    expect( getRoutePath(\"/worksheet/list\") ).toBe('/worksheet/list');\n  });\n\n  it(\"应该能修正非法的路径\", ()=>{\n    expect( getRoutePath(\"/myworksheet/(.*)\") ).toBe(\"/myworksheet/list\");\n  });\n});\n```\n运行该测试文件，得到如下输出：\n\n![![20200506151145.png](https://upload-images.jianshu.io/upload_images/11846892-1dec9c605aeb4dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n](https://upload-images.jianshu.io/upload_images/11846892-e6bc2edad5dc4097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由此，我们对一次单元测试的过程有了基本的了解。\n\n## 断言(assertions)\n\n断言是单元测试框架中核心的部分，断言失败会导致测试不通过，或报告错误信息。\n\n对于常见的断言，举一些例子如下：\n\n- 同等性断言 Equality Asserts\n\n      1. expect(sth).toEqual(value)\n      2. expect(sth).not.toEqual(value)\n- 比较性断言 Comparison Asserts\n\n      1. expect(sth).toBeGreaterThan(number)\n      2. expect(sth).toBeLessThanOrEqual(number)\n- 类型性断言 Type Asserts\n\n      1. expect(sth).toBeInstanceOf(Class)\n- 条件性测试 Condition Test\n\n      1. expect(sth).toBeTruthy()\n      2. expect(sth).toBeFalsy()\n      3. expect(sth).toBeDefined()\n\n## 断言库\n\n断言库主要提供上述断言的语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 Should.js, Chai.js 等。\n\n## 测试用例 test case\n\n为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。\n\n一般的形式为：\n\n```\nit('should ...', function() {\n    ...\n        \n    expect(sth).toEqual(sth);\n});\n\n```\n\n##  测试套件 test suite\n\n通常把一组相关的测试称为一个测试套件\n\n一般的形式为：\n```\ndescribe('test ...', function() {\n    \n    it('should ...', function() { ... });\n    \n    it('should ...', function() { ... });\n    \n    ...\n    \n});\n```\n\n## spy\n\n> 正如 spy 字面的意思一样，我们用这种“间谍”来“监视”函数的调用情况\n\n通过对监视的函数进行包装，可以通过它清楚的知道该函数被调用过几次、传入什么参数、返回什么结果，甚至是抛出的异常情况。\n\n```\nvar spy = sinon.spy(MyComp.prototype, 'someMethod');\n\n...\n\nexpect(spy.callCount).toEqual(1);\n```\n\n## stub\n> 有时候会使用stub来嵌入或者直接替换掉一些代码，来达到隔离的目的\n\n一个stub可以使用最少的依赖方法来模拟该单元测试。比如一个方法可能依赖另一个方法的执行，而后者对我们来说是透明的。好的做法是使用stub 对它进行隔离替换。这样就实现了更准确的单元测试。\n\n```\nvar myObj = {\n    prop: function() {\n        return 'foo';\n    }\n};\n\nsinon.stub(myObj, 'prop').callsFake(function() {\n    return 'bar';\n});\n\nmyObj.prop(); // 'bar'\n```\n\n## mock\n\n`mock`一般指在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法\n\n广义的讲，以上的 spy 和 stub 等，以及一些对模块的模拟，对 ajax 返回值的模拟、对 timer 的模拟，都叫做 mock 。\n\n## 测试覆盖率(code coverage)\n\n用于统计测试用例对代码的测试情况，生成相应的报表，比如 `istanbul` 是常见的测试覆盖率统计工具。\n\n`istanbul` 也就是土耳其首都 “伊斯坦布尔”，这样命名是因为土耳其地毯世界闻名，而地毯是用来\"覆盖\"的😷。\n\n回顾一下上面的图：\n\n\n![20200506151145.png](https://upload-images.jianshu.io/upload_images/11846892-8cc2514fc4359845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n表格中的第2列至第5列，分别对应了四个衡量维度：\n\n* 语句覆盖率（statement coverage）：是否每个语句都执行了\n* 分支覆盖率（branch coverage）：是否每个`if`代码块都执行了\n* 函数覆盖率（function coverage）：是否每个函数都调用了\n* 行覆盖率（line coverage）：是否每一行都执行了\n\n测试结果根据覆盖率被分为“绿色、黄色、红色”三种，应该关注这些指标，测试越全面，就能提供更高的保证。\n\n同时也没有必要一味追求行覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。\n\n\n## II. Vue.js 中的单元测试工具\n\n---\n\n## Jest\n\n不同于\"传统的\"(其实也没出现几年)的 jasmine / Mocha / Chai 等前端测试框架；Jest的使用更简单（也许就是这个单词的本意“俏皮话、玩笑话”的意思），并且提供了更高的集成度、更丰富的功能。\n\nJest 是一个由 Facebook 开发的测试运行器，相对其他测试框架，其特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。\n\n此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。\n\n#### 配置\n\nJest 号称自己是一个 “Zero configuration testing platform”，只需在 npm scripts里面配置了test: jest，即可运行npm test，自动识别并测试符合其规则的（ Vue.js 项目中一般是 __tests__ 目录下的）用例文件。\n\n实际使用中，适当的在 package.json 的 jest 字段或独立的 jest.config.js 里自定义配置一下，会得到更适合我们的测试场景。\n\n参考文档 https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html ，可以很快在 Vue.js 项目中配置好 Jest 测试环境\n\n\n#### 四个基础单词\n\n编写单元测试的语法通常非常简单；对于jest来说，由于其内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。\n\n实际上，只要先记这住四个单词，就足以应付大多数测试情况了：\n\n* describe： 定义一个测试套件\n* it：定义一个测试用例\n* expect：断言的判断条件\n* toEqual：断言的比较结果\n\n```\ndescribe('test ...', function() {\n    it('should ...', function() {\n        expect(sth).toEqual(sth);\n        expect(sth.length).toEqual(1);\n        expect(sth > oth).toEqual(true);\n    });\n});\n```\n\n##  Vue Test Utils\n\n> Vue Test Utils 是 Vue.js 官方的单元测试实用工具库\n\n它模拟了一部分类似 jQuery 的 API，非常直观并且易于使用和学习，提供了一些接口和几个方法来减少测试的样板代码，方便判断、操纵和遍历 Vue Component 的输出，并且减少了测试代码和实现代码之间的耦合。\n\n一般使用其 mount() 或 shallowMount() 方法，将目标组件转化为一个 Wrapper 对象，并在测试中调用其各种方法，例如：\n```\nimport { mount } from '@vue/test-utils'\nimport Foo from './Foo.vue'\n\ndescribe('Foo', () => {\n  it('renders a div', () => {\n    const wrapper = mount(Foo)\n    expect(wrapper.contains('div')).toBe(true)\n  })\n})\n```\n\n## V. 将单元测试整合到工作流中\n\n---\n\n写好的单元测试，如果仅仅要靠每次 npm test 手动执行，必然会有日久忘记、逐渐过时，最后甚至无法执行的情况。\n\n有多个时间点可以作为选择，插入自动执行单元测试 -- 例如每次保存文件、每次执行 build 等；此处我们选择了一种很简单的配置办法：\n\n首先在项目中安装 pre-commit 依赖包；然后在 package.json 中配置 npm scripts ：\n\n```\n\"scripts\": {\n  ...\n  \"test\": \"jest\"\n},\n\"pre-commit\": [\n  \"test\"\n],\n```\n这样在每次 git commit 之前，项目中存在的单元测试就会自动执行一次，往往就避免了 “改一个 bug，送十个新 bug” 的窘况。\n\n## VI. 总结\n\n---\n单元测试作为一种经典的开发和重构手段，在软件开发领域被广泛认可和采用；前端领域也逐渐积累起了丰富的测试框架和方法。\n\n单元测试可以为我们的开发和维护提供基础保障，使我们在思路清晰、心中有底的情况下完成对代码的搭建和重构。\n\n封装好则测试易，反之不恰当的封装让测试变得困难。\n\n可测试性是一个检验组件结构良好程度的实践标准。\n\n参考资料：\n  wx公众号：云前端\n  文章: 实例入门 Vue.js 单元测试\n","slug":"vueTest","published":1,"updated":"2020-05-07T06:08:49.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjsb002x78p361donsw7","content":"<p>Author: Echo<br>Time: 2020-05-06 15:15:23</p>\n<h2 id=\"组件单元测试的好处\"><a href=\"#组件单元测试的好处\" class=\"headerlink\" title=\"组件单元测试的好处\"></a>组件单元测试的好处</h2><ul>\n<li>提供描述组件行为的文档</li>\n<li>节省手动测试的时间</li>\n<li>减少研发新特性时产生的bug</li>\n<li>改进设计</li>\n<li>促进重构</li>\n</ul>\n<p>自动化测试使得大团队中的开发者可以维护复杂的基础代码。</p>\n<h2 id=\"I-单元测试简介\"><a href=\"#I-单元测试简介\" class=\"headerlink\" title=\"I. 单元测试简介\"></a>I. 单元测试简介</h2><hr>\n<blockquote>\n<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。</p>\n</blockquote>\n<p>简单来说，<code>单元</code>就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>\n<p>对于开发活动中的各种测试，最常见的划分方法：从下至上依次为 <strong>单元测试-&gt;集成测试-&gt;端到端测试</strong> ，随着其集成度的递增，对应的自动化程度递减。</p>\n<p>端到端（在浏览器等真实场景中走通功能而把程序当成黑盒子的测试）与集成测试（集合多个测试过的单元一起测试）的反馈与修复的周期比较长、运行速度慢，测试运行不稳定，由于很多时候还要靠人工手动进行，维护成本也很高。而单元测试只针对具体一个方法或API，定位准确，采用 mock 机制，运行速度非常快（毫秒级），又是开发人员在本地执行，反馈修复及时，成本较低。</p>\n<p>我们把绝大部分能在单元测试里覆盖的用例都放在单元测试覆盖，只有单元测试测不了的，才会通过端到端与集成测试来覆盖。</p>\n<p><strong>讲解单元测试的具体概念之前，先 咀个栗子 直观了解下：</strong></p>\n<p>比如我们有这样一个模块，暴露两个方法用以对菜单路径进行一些处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/menuChecker.js</span><br><span class=\"line\"></span><br><span class=\"line\">export function getRoutePath(str) &#123;</span><br><span class=\"line\">  let to = &quot;&quot;</span><br><span class=\"line\">  //...</span><br><span class=\"line\">  return to;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function getHighlight(str) &#123;</span><br><span class=\"line\">  let hl = &quot;&quot;;</span><br><span class=\"line\">  //...</span><br><span class=\"line\">  return hl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写对应的测试文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">  getRoutePath,</span><br><span class=\"line\">  getHighlight</span><br><span class=\"line\">&#125; from &quot;@/menuChecker&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&quot;检查菜单路径相关函数&quot;, ()=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该获得正确高亮值&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getHighlight(&quot;/myworksheet/(.*)&quot;) ).toBe(&quot;myTickets&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该为未知路径取得默认的高亮值&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getHighlight(&quot;/myworksheet/ccc/aaa&quot;) ).toBe(&quot;mydefaulthl111&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该补齐开头的斜杠&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getRoutePath(&quot;/worksheet/list&quot;) ).toBe(&apos;/worksheet/list&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该能修正非法的路径&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getRoutePath(&quot;/myworksheet/(.*)&quot;) ).toBe(&quot;/myworksheet/list&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行该测试文件，得到如下输出：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-e6bc2edad5dc4097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"![20200506151145.png](https://upload-images.jianshu.io/upload_images/11846892-1dec9c605aeb4dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\"></p>\n<p>由此，我们对一次单元测试的过程有了基本的了解。</p>\n<h2 id=\"断言-assertions\"><a href=\"#断言-assertions\" class=\"headerlink\" title=\"断言(assertions)\"></a>断言(assertions)</h2><p>断言是单元测试框架中核心的部分，断言失败会导致测试不通过，或报告错误信息。</p>\n<p>对于常见的断言，举一些例子如下：</p>\n<ul>\n<li><p>同等性断言 Equality Asserts</p>\n<pre><code>1. expect(sth).toEqual(value)\n2. expect(sth).not.toEqual(value)\n</code></pre></li>\n<li><p>比较性断言 Comparison Asserts</p>\n<pre><code>1. expect(sth).toBeGreaterThan(number)\n2. expect(sth).toBeLessThanOrEqual(number)\n</code></pre></li>\n<li><p>类型性断言 Type Asserts</p>\n<pre><code>1. expect(sth).toBeInstanceOf(Class)\n</code></pre></li>\n<li><p>条件性测试 Condition Test</p>\n<pre><code>1. expect(sth).toBeTruthy()\n2. expect(sth).toBeFalsy()\n3. expect(sth).toBeDefined()\n</code></pre></li>\n</ul>\n<h2 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h2><p>断言库主要提供上述断言的语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 Should.js, Chai.js 等。</p>\n<h2 id=\"测试用例-test-case\"><a href=\"#测试用例-test-case\" class=\"headerlink\" title=\"测试用例 test case\"></a>测试用例 test case</h2><p>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。</p>\n<p>一般的形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&apos;should ...&apos;, function() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    expect(sth).toEqual(sth);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试套件-test-suite\"><a href=\"#测试套件-test-suite\" class=\"headerlink\" title=\"测试套件 test suite\"></a>测试套件 test suite</h2><p>通常把一组相关的测试称为一个测试套件</p>\n<p>一般的形式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&apos;test ...&apos;, function() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    it(&apos;should ...&apos;, function() &#123; ... &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    it(&apos;should ...&apos;, function() &#123; ... &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"spy\"><a href=\"#spy\" class=\"headerlink\" title=\"spy\"></a>spy</h2><blockquote>\n<p>正如 spy 字面的意思一样，我们用这种“间谍”来“监视”函数的调用情况</p>\n</blockquote>\n<p>通过对监视的函数进行包装，可以通过它清楚的知道该函数被调用过几次、传入什么参数、返回什么结果，甚至是抛出的异常情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var spy = sinon.spy(MyComp.prototype, &apos;someMethod&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">expect(spy.callCount).toEqual(1);</span><br></pre></td></tr></table></figure>\n<h2 id=\"stub\"><a href=\"#stub\" class=\"headerlink\" title=\"stub\"></a>stub</h2><blockquote>\n<p>有时候会使用stub来嵌入或者直接替换掉一些代码，来达到隔离的目的</p>\n</blockquote>\n<p>一个stub可以使用最少的依赖方法来模拟该单元测试。比如一个方法可能依赖另一个方法的执行，而后者对我们来说是透明的。好的做法是使用stub 对它进行隔离替换。这样就实现了更准确的单元测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObj = &#123;</span><br><span class=\"line\">    prop: function() &#123;</span><br><span class=\"line\">        return &apos;foo&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">sinon.stub(myObj, &apos;prop&apos;).callsFake(function() &#123;</span><br><span class=\"line\">    return &apos;bar&apos;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.prop(); // &apos;bar&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mock\"><a href=\"#mock\" class=\"headerlink\" title=\"mock\"></a>mock</h2><p><code>mock</code>一般指在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法</p>\n<p>广义的讲，以上的 spy 和 stub 等，以及一些对模块的模拟，对 ajax 返回值的模拟、对 timer 的模拟，都叫做 mock 。</p>\n<h2 id=\"测试覆盖率-code-coverage\"><a href=\"#测试覆盖率-code-coverage\" class=\"headerlink\" title=\"测试覆盖率(code coverage)\"></a>测试覆盖率(code coverage)</h2><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <code>istanbul</code> 是常见的测试覆盖率统计工具。</p>\n<p><code>istanbul</code> 也就是土耳其首都 “伊斯坦布尔”，这样命名是因为土耳其地毯世界闻名，而地毯是用来”覆盖”的😷。</p>\n<p>回顾一下上面的图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8cc2514fc4359845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"20200506151145.png\"></p>\n<p>表格中的第2列至第5列，分别对应了四个衡量维度：</p>\n<ul>\n<li>语句覆盖率（statement coverage）：是否每个语句都执行了</li>\n<li>分支覆盖率（branch coverage）：是否每个<code>if</code>代码块都执行了</li>\n<li>函数覆盖率（function coverage）：是否每个函数都调用了</li>\n<li>行覆盖率（line coverage）：是否每一行都执行了</li>\n</ul>\n<p>测试结果根据覆盖率被分为“绿色、黄色、红色”三种，应该关注这些指标，测试越全面，就能提供更高的保证。</p>\n<p>同时也没有必要一味追求行覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。</p>\n<h2 id=\"II-Vue-js-中的单元测试工具\"><a href=\"#II-Vue-js-中的单元测试工具\" class=\"headerlink\" title=\"II. Vue.js 中的单元测试工具\"></a>II. Vue.js 中的单元测试工具</h2><hr>\n<h2 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h2><p>不同于”传统的”(其实也没出现几年)的 jasmine / Mocha / Chai 等前端测试框架；Jest的使用更简单（也许就是这个单词的本意“俏皮话、玩笑话”的意思），并且提供了更高的集成度、更丰富的功能。</p>\n<p>Jest 是一个由 Facebook 开发的测试运行器，相对其他测试框架，其特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</p>\n<p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>Jest 号称自己是一个 “Zero configuration testing platform”，只需在 npm scripts里面配置了test: jest，即可运行npm test，自动识别并测试符合其规则的（ Vue.js 项目中一般是 <strong>tests</strong> 目录下的）用例文件。</p>\n<p>实际使用中，适当的在 package.json 的 jest 字段或独立的 jest.config.js 里自定义配置一下，会得到更适合我们的测试场景。</p>\n<p>参考文档 <a href=\"https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html\" target=\"_blank\" rel=\"noopener\">https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html</a> ，可以很快在 Vue.js 项目中配置好 Jest 测试环境</p>\n<h4 id=\"四个基础单词\"><a href=\"#四个基础单词\" class=\"headerlink\" title=\"四个基础单词\"></a>四个基础单词</h4><p>编写单元测试的语法通常非常简单；对于jest来说，由于其内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。</p>\n<p>实际上，只要先记这住四个单词，就足以应付大多数测试情况了：</p>\n<ul>\n<li>describe： 定义一个测试套件</li>\n<li>it：定义一个测试用例</li>\n<li>expect：断言的判断条件</li>\n<li>toEqual：断言的比较结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&apos;test ...&apos;, function() &#123;</span><br><span class=\"line\">    it(&apos;should ...&apos;, function() &#123;</span><br><span class=\"line\">        expect(sth).toEqual(sth);</span><br><span class=\"line\">        expect(sth.length).toEqual(1);</span><br><span class=\"line\">        expect(sth &gt; oth).toEqual(true);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Vue-Test-Utils\"><a href=\"#Vue-Test-Utils\" class=\"headerlink\" title=\"Vue Test Utils\"></a>Vue Test Utils</h2><blockquote>\n<p>Vue Test Utils 是 Vue.js 官方的单元测试实用工具库</p>\n</blockquote>\n<p>它模拟了一部分类似 jQuery 的 API，非常直观并且易于使用和学习，提供了一些接口和几个方法来减少测试的样板代码，方便判断、操纵和遍历 Vue Component 的输出，并且减少了测试代码和实现代码之间的耦合。</p>\n<p>一般使用其 mount() 或 shallowMount() 方法，将目标组件转化为一个 Wrapper 对象，并在测试中调用其各种方法，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mount &#125; from &apos;@vue/test-utils&apos;</span><br><span class=\"line\">import Foo from &apos;./Foo.vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;Foo&apos;, () =&gt; &#123;</span><br><span class=\"line\">  it(&apos;renders a div&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const wrapper = mount(Foo)</span><br><span class=\"line\">    expect(wrapper.contains(&apos;div&apos;)).toBe(true)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"V-将单元测试整合到工作流中\"><a href=\"#V-将单元测试整合到工作流中\" class=\"headerlink\" title=\"V. 将单元测试整合到工作流中\"></a>V. 将单元测试整合到工作流中</h2><hr>\n<p>写好的单元测试，如果仅仅要靠每次 npm test 手动执行，必然会有日久忘记、逐渐过时，最后甚至无法执行的情况。</p>\n<p>有多个时间点可以作为选择，插入自动执行单元测试 – 例如每次保存文件、每次执行 build 等；此处我们选择了一种很简单的配置办法：</p>\n<p>首先在项目中安装 pre-commit 依赖包；然后在 package.json 中配置 npm scripts ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;test&quot;: &quot;jest&quot;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;pre-commit&quot;: [</span><br><span class=\"line\">  &quot;test&quot;</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<p>这样在每次 git commit 之前，项目中存在的单元测试就会自动执行一次，往往就避免了 “改一个 bug，送十个新 bug” 的窘况。</p>\n<h2 id=\"VI-总结\"><a href=\"#VI-总结\" class=\"headerlink\" title=\"VI. 总结\"></a>VI. 总结</h2><hr>\n<p>单元测试作为一种经典的开发和重构手段，在软件开发领域被广泛认可和采用；前端领域也逐渐积累起了丰富的测试框架和方法。</p>\n<p>单元测试可以为我们的开发和维护提供基础保障，使我们在思路清晰、心中有底的情况下完成对代码的搭建和重构。</p>\n<p>封装好则测试易，反之不恰当的封装让测试变得困难。</p>\n<p>可测试性是一个检验组件结构良好程度的实践标准。</p>\n<p>参考资料：<br>  wx公众号：云前端<br>  文章: 实例入门 Vue.js 单元测试</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2020-05-06 15:15:23</p>\n<h2 id=\"组件单元测试的好处\"><a href=\"#组件单元测试的好处\" class=\"headerlink\" title=\"组件单元测试的好处\"></a>组件单元测试的好处</h2><ul>\n<li>提供描述组件行为的文档</li>\n<li>节省手动测试的时间</li>\n<li>减少研发新特性时产生的bug</li>\n<li>改进设计</li>\n<li>促进重构</li>\n</ul>\n<p>自动化测试使得大团队中的开发者可以维护复杂的基础代码。</p>\n<h2 id=\"I-单元测试简介\"><a href=\"#I-单元测试简介\" class=\"headerlink\" title=\"I. 单元测试简介\"></a>I. 单元测试简介</h2><hr>\n<blockquote>\n<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。</p>\n</blockquote>\n<p>简单来说，<code>单元</code>就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>\n<p>对于开发活动中的各种测试，最常见的划分方法：从下至上依次为 <strong>单元测试-&gt;集成测试-&gt;端到端测试</strong> ，随着其集成度的递增，对应的自动化程度递减。</p>\n<p>端到端（在浏览器等真实场景中走通功能而把程序当成黑盒子的测试）与集成测试（集合多个测试过的单元一起测试）的反馈与修复的周期比较长、运行速度慢，测试运行不稳定，由于很多时候还要靠人工手动进行，维护成本也很高。而单元测试只针对具体一个方法或API，定位准确，采用 mock 机制，运行速度非常快（毫秒级），又是开发人员在本地执行，反馈修复及时，成本较低。</p>\n<p>我们把绝大部分能在单元测试里覆盖的用例都放在单元测试覆盖，只有单元测试测不了的，才会通过端到端与集成测试来覆盖。</p>\n<p><strong>讲解单元测试的具体概念之前，先 咀个栗子 直观了解下：</strong></p>\n<p>比如我们有这样一个模块，暴露两个方法用以对菜单路径进行一些处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// src/menuChecker.js</span><br><span class=\"line\"></span><br><span class=\"line\">export function getRoutePath(str) &#123;</span><br><span class=\"line\">  let to = &quot;&quot;</span><br><span class=\"line\">  //...</span><br><span class=\"line\">  return to;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function getHighlight(str) &#123;</span><br><span class=\"line\">  let hl = &quot;&quot;;</span><br><span class=\"line\">  //...</span><br><span class=\"line\">  return hl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编写对应的测试文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">  getRoutePath,</span><br><span class=\"line\">  getHighlight</span><br><span class=\"line\">&#125; from &quot;@/menuChecker&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&quot;检查菜单路径相关函数&quot;, ()=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该获得正确高亮值&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getHighlight(&quot;/myworksheet/(.*)&quot;) ).toBe(&quot;myTickets&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该为未知路径取得默认的高亮值&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getHighlight(&quot;/myworksheet/ccc/aaa&quot;) ).toBe(&quot;mydefaulthl111&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该补齐开头的斜杠&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getRoutePath(&quot;/worksheet/list&quot;) ).toBe(&apos;/worksheet/list&apos;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(&quot;应该能修正非法的路径&quot;, ()=&gt;&#123;</span><br><span class=\"line\">    expect( getRoutePath(&quot;/myworksheet/(.*)&quot;) ).toBe(&quot;/myworksheet/list&quot;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行该测试文件，得到如下输出：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-e6bc2edad5dc4097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"![20200506151145.png](https://upload-images.jianshu.io/upload_images/11846892-1dec9c605aeb4dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\"></p>\n<p>由此，我们对一次单元测试的过程有了基本的了解。</p>\n<h2 id=\"断言-assertions\"><a href=\"#断言-assertions\" class=\"headerlink\" title=\"断言(assertions)\"></a>断言(assertions)</h2><p>断言是单元测试框架中核心的部分，断言失败会导致测试不通过，或报告错误信息。</p>\n<p>对于常见的断言，举一些例子如下：</p>\n<ul>\n<li><p>同等性断言 Equality Asserts</p>\n<pre><code>1. expect(sth).toEqual(value)\n2. expect(sth).not.toEqual(value)\n</code></pre></li>\n<li><p>比较性断言 Comparison Asserts</p>\n<pre><code>1. expect(sth).toBeGreaterThan(number)\n2. expect(sth).toBeLessThanOrEqual(number)\n</code></pre></li>\n<li><p>类型性断言 Type Asserts</p>\n<pre><code>1. expect(sth).toBeInstanceOf(Class)\n</code></pre></li>\n<li><p>条件性测试 Condition Test</p>\n<pre><code>1. expect(sth).toBeTruthy()\n2. expect(sth).toBeFalsy()\n3. expect(sth).toBeDefined()\n</code></pre></li>\n</ul>\n<h2 id=\"断言库\"><a href=\"#断言库\" class=\"headerlink\" title=\"断言库\"></a>断言库</h2><p>断言库主要提供上述断言的语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 Should.js, Chai.js 等。</p>\n<h2 id=\"测试用例-test-case\"><a href=\"#测试用例-test-case\" class=\"headerlink\" title=\"测试用例 test case\"></a>测试用例 test case</h2><p>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。</p>\n<p>一般的形式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(&apos;should ...&apos;, function() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    expect(sth).toEqual(sth);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试套件-test-suite\"><a href=\"#测试套件-test-suite\" class=\"headerlink\" title=\"测试套件 test suite\"></a>测试套件 test suite</h2><p>通常把一组相关的测试称为一个测试套件</p>\n<p>一般的形式为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&apos;test ...&apos;, function() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    it(&apos;should ...&apos;, function() &#123; ... &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    it(&apos;should ...&apos;, function() &#123; ... &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"spy\"><a href=\"#spy\" class=\"headerlink\" title=\"spy\"></a>spy</h2><blockquote>\n<p>正如 spy 字面的意思一样，我们用这种“间谍”来“监视”函数的调用情况</p>\n</blockquote>\n<p>通过对监视的函数进行包装，可以通过它清楚的知道该函数被调用过几次、传入什么参数、返回什么结果，甚至是抛出的异常情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var spy = sinon.spy(MyComp.prototype, &apos;someMethod&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">expect(spy.callCount).toEqual(1);</span><br></pre></td></tr></table></figure>\n<h2 id=\"stub\"><a href=\"#stub\" class=\"headerlink\" title=\"stub\"></a>stub</h2><blockquote>\n<p>有时候会使用stub来嵌入或者直接替换掉一些代码，来达到隔离的目的</p>\n</blockquote>\n<p>一个stub可以使用最少的依赖方法来模拟该单元测试。比如一个方法可能依赖另一个方法的执行，而后者对我们来说是透明的。好的做法是使用stub 对它进行隔离替换。这样就实现了更准确的单元测试。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myObj = &#123;</span><br><span class=\"line\">    prop: function() &#123;</span><br><span class=\"line\">        return &apos;foo&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">sinon.stub(myObj, &apos;prop&apos;).callsFake(function() &#123;</span><br><span class=\"line\">    return &apos;bar&apos;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.prop(); // &apos;bar&apos;</span><br></pre></td></tr></table></figure>\n<h2 id=\"mock\"><a href=\"#mock\" class=\"headerlink\" title=\"mock\"></a>mock</h2><p><code>mock</code>一般指在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法</p>\n<p>广义的讲，以上的 spy 和 stub 等，以及一些对模块的模拟，对 ajax 返回值的模拟、对 timer 的模拟，都叫做 mock 。</p>\n<h2 id=\"测试覆盖率-code-coverage\"><a href=\"#测试覆盖率-code-coverage\" class=\"headerlink\" title=\"测试覆盖率(code coverage)\"></a>测试覆盖率(code coverage)</h2><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <code>istanbul</code> 是常见的测试覆盖率统计工具。</p>\n<p><code>istanbul</code> 也就是土耳其首都 “伊斯坦布尔”，这样命名是因为土耳其地毯世界闻名，而地毯是用来”覆盖”的😷。</p>\n<p>回顾一下上面的图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/11846892-8cc2514fc4359845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"20200506151145.png\"></p>\n<p>表格中的第2列至第5列，分别对应了四个衡量维度：</p>\n<ul>\n<li>语句覆盖率（statement coverage）：是否每个语句都执行了</li>\n<li>分支覆盖率（branch coverage）：是否每个<code>if</code>代码块都执行了</li>\n<li>函数覆盖率（function coverage）：是否每个函数都调用了</li>\n<li>行覆盖率（line coverage）：是否每一行都执行了</li>\n</ul>\n<p>测试结果根据覆盖率被分为“绿色、黄色、红色”三种，应该关注这些指标，测试越全面，就能提供更高的保证。</p>\n<p>同时也没有必要一味追求行覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。</p>\n<h2 id=\"II-Vue-js-中的单元测试工具\"><a href=\"#II-Vue-js-中的单元测试工具\" class=\"headerlink\" title=\"II. Vue.js 中的单元测试工具\"></a>II. Vue.js 中的单元测试工具</h2><hr>\n<h2 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h2><p>不同于”传统的”(其实也没出现几年)的 jasmine / Mocha / Chai 等前端测试框架；Jest的使用更简单（也许就是这个单词的本意“俏皮话、玩笑话”的意思），并且提供了更高的集成度、更丰富的功能。</p>\n<p>Jest 是一个由 Facebook 开发的测试运行器，相对其他测试框架，其特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</p>\n<p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>Jest 号称自己是一个 “Zero configuration testing platform”，只需在 npm scripts里面配置了test: jest，即可运行npm test，自动识别并测试符合其规则的（ Vue.js 项目中一般是 <strong>tests</strong> 目录下的）用例文件。</p>\n<p>实际使用中，适当的在 package.json 的 jest 字段或独立的 jest.config.js 里自定义配置一下，会得到更适合我们的测试场景。</p>\n<p>参考文档 <a href=\"https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html\" target=\"_blank\" rel=\"noopener\">https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html</a> ，可以很快在 Vue.js 项目中配置好 Jest 测试环境</p>\n<h4 id=\"四个基础单词\"><a href=\"#四个基础单词\" class=\"headerlink\" title=\"四个基础单词\"></a>四个基础单词</h4><p>编写单元测试的语法通常非常简单；对于jest来说，由于其内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。</p>\n<p>实际上，只要先记这住四个单词，就足以应付大多数测试情况了：</p>\n<ul>\n<li>describe： 定义一个测试套件</li>\n<li>it：定义一个测试用例</li>\n<li>expect：断言的判断条件</li>\n<li>toEqual：断言的比较结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(&apos;test ...&apos;, function() &#123;</span><br><span class=\"line\">    it(&apos;should ...&apos;, function() &#123;</span><br><span class=\"line\">        expect(sth).toEqual(sth);</span><br><span class=\"line\">        expect(sth.length).toEqual(1);</span><br><span class=\"line\">        expect(sth &gt; oth).toEqual(true);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Vue-Test-Utils\"><a href=\"#Vue-Test-Utils\" class=\"headerlink\" title=\"Vue Test Utils\"></a>Vue Test Utils</h2><blockquote>\n<p>Vue Test Utils 是 Vue.js 官方的单元测试实用工具库</p>\n</blockquote>\n<p>它模拟了一部分类似 jQuery 的 API，非常直观并且易于使用和学习，提供了一些接口和几个方法来减少测试的样板代码，方便判断、操纵和遍历 Vue Component 的输出，并且减少了测试代码和实现代码之间的耦合。</p>\n<p>一般使用其 mount() 或 shallowMount() 方法，将目标组件转化为一个 Wrapper 对象，并在测试中调用其各种方法，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mount &#125; from &apos;@vue/test-utils&apos;</span><br><span class=\"line\">import Foo from &apos;./Foo.vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">describe(&apos;Foo&apos;, () =&gt; &#123;</span><br><span class=\"line\">  it(&apos;renders a div&apos;, () =&gt; &#123;</span><br><span class=\"line\">    const wrapper = mount(Foo)</span><br><span class=\"line\">    expect(wrapper.contains(&apos;div&apos;)).toBe(true)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"V-将单元测试整合到工作流中\"><a href=\"#V-将单元测试整合到工作流中\" class=\"headerlink\" title=\"V. 将单元测试整合到工作流中\"></a>V. 将单元测试整合到工作流中</h2><hr>\n<p>写好的单元测试，如果仅仅要靠每次 npm test 手动执行，必然会有日久忘记、逐渐过时，最后甚至无法执行的情况。</p>\n<p>有多个时间点可以作为选择，插入自动执行单元测试 – 例如每次保存文件、每次执行 build 等；此处我们选择了一种很简单的配置办法：</p>\n<p>首先在项目中安装 pre-commit 依赖包；然后在 package.json 中配置 npm scripts ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  &quot;test&quot;: &quot;jest&quot;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;pre-commit&quot;: [</span><br><span class=\"line\">  &quot;test&quot;</span><br><span class=\"line\">],</span><br></pre></td></tr></table></figure>\n<p>这样在每次 git commit 之前，项目中存在的单元测试就会自动执行一次，往往就避免了 “改一个 bug，送十个新 bug” 的窘况。</p>\n<h2 id=\"VI-总结\"><a href=\"#VI-总结\" class=\"headerlink\" title=\"VI. 总结\"></a>VI. 总结</h2><hr>\n<p>单元测试作为一种经典的开发和重构手段，在软件开发领域被广泛认可和采用；前端领域也逐渐积累起了丰富的测试框架和方法。</p>\n<p>单元测试可以为我们的开发和维护提供基础保障，使我们在思路清晰、心中有底的情况下完成对代码的搭建和重构。</p>\n<p>封装好则测试易，反之不恰当的封装让测试变得困难。</p>\n<p>可测试性是一个检验组件结构良好程度的实践标准。</p>\n<p>参考资料：<br>  wx公众号：云前端<br>  文章: 实例入门 Vue.js 单元测试</p>\n"},{"title":"了解vue源码","date":"2019-09-03T01:47:57.000Z","_content":"\nAuthor: EchodefineProperty\nTime: 2019-09-03 09:47:57\n\n## new Vue()做了什么？\nnew关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是\n`/src/core/instance/index.js`\n```\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n接着我们跳转追踪至`this._init()`，即`Vue.prototype._init`,位于`src\\core\\instance\\init.js`.\n在`_init()`方法的内部有一系列 `init*` 的方法\n```\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // ...忽略，从第45行看起\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n    // ...忽略\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n统一概述一遍new Vue()时做了什么处理:\n\n* `initProxy`，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)\n* `initLifecycle`（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。\n* `initEvents`，用来存放除@hook:生命周期钩子名称=\"绑定的函数\"事件的对象。如:$on、$emit等。\n* `initRender`，用于初始化$slots、$attrs、$listeners\n* `initInjections`，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。\n* `initState`，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。\n* `initProvide`，初始化provide。\n* `vm.$mount`，挂载实例。\n\n## 什么阶段才能访问DOM？\n这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:\n```\ncallHook(vm, 'beforeCreate')\n// 初始化 inject\n// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)\n// 初始化 provide\ncallHook(vm, 'created')\n// 挂载实例 vm.$mount(vm.$options.el)\n// vue实例的数据对象data有了\n```\n所以当面试官问你:\n\n* beforeCreate以及 created 调用时，哪些数据能用与否？\n* 什么阶段才能访问DOM？\n* 为什么created之后才挂载实例？\n\n## 谈谈你对Vue的生命周期的理解？\n生命周期函数解释说明（图片）：https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\n##### 理解:\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会\n##### 生命周期的几个阶段:\n1. created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=>挂载=>更新=>销毁\n* beforeCreate & created 看上一题\n* beforeMount & mounted\n```\ncallHook(vm, 'beforeMount')\n// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，\ncallHook(vm, 'mounted')\n// vue实例挂载完成，data.message成功渲染\n```\n* beforeUpdate & updated\n```\ndata变化会触发beforeUpdate和updated方法\n```\n* beforeDestroy & destroyed\n```\ncallHook(vm, 'destroyed')\n// data的改变不会再触发周期函数\n// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。\n```\n\n深入理解源码:\n\n2. Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。\n```\n// v2.6.10 最新版\nvar LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    // v2.6+ \n    'serverPrefetch' //看下一题\n];\n```\n于是，你可以答多`activated & deactivated`（keep-alive 组件激活/停用）、`errorCaptured`（v2.5 以上版本有的一个钩子，用于处理错误）这三个。\n\n-----\n\n## 生命周期钩子的合并策略\nhttps://www.cnblogs.com/xweizi/p/10572281.html\n\n----- \n单独抽出一天来处理\n\n## 新生命周期钩子：serverPrefetch是什么？\n```\n// v2.6.10的变化\n```\n可以看到，`serverPrefetch`前身是`ssrPrefetch`。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。\n![image](https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n这里我们贴出一段官方例子：\n```\n<!-- Item.vue -->\n<template>\n  <div v-if=\"item\">{{ item.title }}</div>\n  <div v-else>...</div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    item () {\n      return this.$store.state.items[this.$route.params.id]\n    }\n  },\n  serverPrefetch () {\n    return this.fetchItem()\n  },\n  mounted () {\n    if (!this.item) {\n      this.fetchItem()\n    }\n  },\n  methods: {\n    fetchItem () {\n      // return the Promise from the action\n      return this.$store.dispatch('fetchItem', this.$route.params.id)\n    }\n  }\n}\n</script>\n```\n## Vue-router 路由模式有几种？\n三种 \"hash\" | \"history\" | \"abstract\"，一般人只知道两种\"hash\" | \"history\"\n```\n// 源码：\n\nswitch (mode) {\n  case 'history':\n    this.history = new HTML5History(this, options.base)\n    break\n  case 'hash':\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case 'abstract':\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== 'production') {\n      assert(false, `invalid mode: ${mode}`)\n    }\n}\n```\n##### mode\n* 类型: string\n* 默认值: \"hash\" (浏览器环境) | \"abstract\" (Node.js 环境)\n* 可选值: \"hash\" | \"history\" | \"abstract\"\n\n配置路由模式:\n\n* hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。\n* history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。\n* abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.\n\n###### 路由模式解析\n对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.\n\n前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求\n`\n浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。\n`\n\n.\n\n* vue-router: hash\n\nhash模式中url带有#号，修改成history模式，url中的#自动就去除了。\n\nhash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：\n```\nwindow.onhashchange = function(event){\n    console.log(event.oldURL, event.newURL);\n    let hash = location.hash.slice(1)\n}\n```\n\nhash模式下，仅hash符号之前的内容会被包含在请求中,如 http://www.abc.com, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.\n\n* vue-router: history\n随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。\n　history api可以分为两大部分：切换和修改\n1. 切换历史状态\n\n包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：\n```\nhistory.go(-2);//后退两次\nhistory.go(2);//前进两次\nhistory.back(); //后退\nhsitory.forward(); //前进\n```\n`\n坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页\n`\n\n2. 修改历史状态\n包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url\n```\nhistory.pushState(stateObj，title，url)\nwindow.onpopstate = function(event){\n    console.log(event.state)\n    if(event.state && event.state.color === 'red'){\n        document.body.style.color = 'red';\n    }\n}\n\n```\n`\n坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。\n`\n3. popstate实现history路由拦截，监听页面返回事件\n当活动历史记录条目更改时，将触发popstate事件\n\n*  如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。\n\n* 需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；\n\n  　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）\n* vue-router: abstract\nabstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。\n\n根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式\n\n## 谈谈你对keep-alive的了解\n先贴一个常规回答：\n`\nkeep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。\n在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。\n<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n`\n\n`然后你可以开始骚了：`\n\n1. `<keep-alive>`是 Vue 源码中实现的一个全局抽象组件，通过自定义 `render` 函数并且利用了`插槽`来实现数据缓存和更新。它的定义在`src/core/components/keep-alive.js` 中：\n```\nexport default {\n  name: 'keep-alive',\n  abstract: true,\n  ...\n}\n```\n2. 所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：\n```\nif (parent && !options.abstract) {\n  // abstract 即 `ptions.abstract`\n  // while 循环查找第一个非抽象的父组件\n  while (parent.$options.abstract && parent.$parent) {\n    parent = parent.$parent\n  }\n  parent.$children.push(vm)\n}\n```\n\n3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。\n\n## vue源码中内置的组件？\n* component\n* transition\n* transition-group\n* keep-alive\n* slot\n## 了解Vue2.6+新全局API：Vue.observable()吗？\nVue2.6+新的全局API是Vue.observable(),它的使用方式：\n```\n// 准备个文件store.js - /store/store.js\nimport Vue from 'vue'\n\nexport const store = Vue.observable({ count: 0 })  //定义一个变量\nexport const mutations = {  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值\n  setCount (count) {\n    store.count = count\n  }\n}\n```\n返回的对象可以直接用于`渲染函数`和`计算属性`内，并且会在发生改变时触发相应的更新。\n```\n<template>\n    <div>\n        <p>你点+-，看我能不能根据状态去动态改变</p>\n        <label for=\"bookNum\">数量</label>\n        <button @click=\"setCount(count+1)\">+</button>\n        <span>{{count}}</span>\n        <button @click=\"setCount(count-1)\">-</button>\n    </div>\n</template>\n\n<script>\nimport { store, mutations } from '../store/store' // Vue2.6新增API Observable\n\nexport default {\n  name: 'Add',\n  computed: {\n    count () {\n      return store.count //用于去渲染之前Observable中定义的变量count\n    }\n  },\n  methods: {\n    setCount: mutations.setCount\n  }\n}\n</script>\n```\n## 了解Vue数据绑定原理？\n参考Vue.js官网介绍响应式原理图，我们进行分析：\n\n这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。\nVue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。\n\nVue在初始化组件数据时，在生命周期的`beforeCreate`与`created`钩子函数之间实现了对`data、props、computed、methods、events`以及`watch`的处理.\n\n* initData\n参考源码instance下的state.js文件\n\ninitData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。\n\n\n```\nfunction initData (vm: Component) {  \n  /*得到data数据*/\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} \n  /*判断是否是对象*/\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' +'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm)\n  }  \n  // proxy data on instance\n  /*遍历data对象*/\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  //遍历data中的数据\n  while (i--) {\n    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(`The data property \"${keys[i]}\" is already declared as a prop. ` +`Use prop default value instead.`,vm)\n    } else if (!isReserved(keys[i])) {\n      /*判断是否是保留字段*/\n      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/\n      proxy(vm, `_data`, keys[i])\n    }\n  }\n  // observe data\n  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  \n  observe(data, true /* asRootData */)\n  }\n```\n其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。\n\n* proxy\n接下来看一下proxy代理。\n\n```\n/*添加代理*/\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。\n\n* observe\n参考源码文件在core文件下oberver的index.js文件中\n\n\n```\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n /*\n 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  /*判断是否是一个对象*/\n  if (!isObject(value)) {\n    return\n  }\n  let ob: Observer | void\n\n  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n\n    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n\n    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/\n    ob.vmCount++\n  }\n  return ob\n}\n\n```\nVue的响应式数据都会有一个__ob__的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。\n* Observer\nObserver的作用就是遍历对象的所有属性将其进行双向绑定。\n\n```\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nexport class  {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n\n    /*\n    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16\n    */\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n\n      /*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      */\n      const augment = hasProto\n        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/\n        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/\n      augment(value, arrayMethods, arrayKeys)\n\n      /*如果是数组则需要遍历数组的每一个成员进行observe*/\n      this.observeArray(value)\n    } else {\n\n      /*如果是对象则直接walk进行绑定*/\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n\n    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n\n    /*数组需要便利每一个成员进行observe*/\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n```\nObserver为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。\n如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。\n但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？\n\nVue.js提供的方法是重写 `push、pop、shift、unshift、splice、sort、reverse`这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。\n```\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nimport { def } from '../util/index'\n\n/*取得原生数组的原型*/\nconst arrayProto = Array.prototype\n/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/\nexport const arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  /*将数组的原生方法缓存起来，后面要调用*/\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    let i = arguments.length\n    const args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    /*调用原生的数组方法*/\n    const result = original.apply(this, args)\n\n    /*数组新插入的元素需要重新进行observe才能响应式*/\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n      \n    // notify change\n    /*dep通知所有注册的观察者进行响应式处理*/\n    ob.dep.notify()\n    return result\n  })\n})\n```\n从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持__proto__这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。\n\n如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。\n\n在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。\n\n但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。\n\n* Watcher\n\nWatcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。\n\n\n```\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    this.vm = vm\n    /*_watchers存放订阅者实例*/\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.lazy // for lazy watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    /*把表达式expOrFn解析成getter*/\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n   /*获得getter的值并且重新进行依赖收集*/\n  get () {\n    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/\n    pushTarget(this)\n    let value\n    const vm = this.vm\n\n    /*\n      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。\n      在将Dep.target设置为自生观察者实例以后，执行getter操作。\n      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，\n      那么在执行getter的时候就会触发a跟c两个数据的getter函数，\n      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，\n      将该观察者对象放入闭包中的Dep的subs中去。\n    */\n    if (this.user) {\n      try {\n        value = this.getter.call(vm, vm)\n      } catch (e) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      }\n    } else {\n      value = this.getter.call(vm, vm)\n    }\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/\n    if (this.deep) {\n      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/\n      traverse(value)\n    }\n\n    /*将观察者实例从target栈中取出并设置给Dep.target*/\n    popTarget()\n    this.cleanupDeps()\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n   /*添加一个依赖关系到Deps集合中*/\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n   /*清理依赖收集*/\n  cleanupDeps () {\n    /*移除所有观察者对象*/\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n   /*\n      调度者接口，当依赖发生改变的时候进行回调。\n   */\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      /*同步则执行run直接渲染视图*/\n      this.run()\n    } else {\n      /*异步推送到观察者队列中，由调度者调用。*/\n      queueWatcher(this)\n    }\n  }\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n   /*\n      调度者工作接口，将被调度者回调。\n    */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        /*\n            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。\n        */\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        /*设置新的值*/\n        this.value = value\n\n        /*触发回调渲染视图*/\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n   /*获取观察者的值*/\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n   /*收集该watcher的所有deps依赖*/\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n   /*将自身从所有依赖收集订阅列表删除*/\n  teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n}\n```\n* Dep\n\n来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。\n\n```\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  /*添加一个观察者对象*/\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  /*移除一个观察者对象*/\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  /*依赖收集，当存在Dep.target的时候添加观察者对象*/\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  /*通知所有订阅者*/\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/\n```\n\n* defineReactive\n\n接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。\n触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。\n\n```\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  /*在闭包中定义一个dep对象*/\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n\n  /*对象的子对象递归进行observe并返回子节点的Observer对象*/\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n\n      /*如果原本对象拥有getter方法则执行*/\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n\n        /*进行依赖收集*/\n        dep.depend()\n        if (childOb) {\n\n          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/\n          childOb.dep.depend()\n        }\n        if (Array.isArray(value)) {\n\n          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/\n          dependArray(value)\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n\n      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (setter) {\n\n        /*如果原本对象拥有setter方法则执行setter*/\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n\n      /*新的值需要重新进行observe，保证数据响应式*/\n      childOb = observe(newVal)\n\n      /*dep对象通知所有的观察者*/\n      dep.notify()\n    }\n  })\n}\n```\n----\n整篇文章主要参考链接：https://juejin.im/post/5c959f74f265da610c068fa8\n源码解析参考链接：https://github.com/answershuto/learnVue\n\n\n\n","source":"_posts/vueSourceCoding.md","raw":"---\ntitle: 了解vue源码\ndate: 2019-09-03 09:47:57\ntags: vue\n---\n\nAuthor: EchodefineProperty\nTime: 2019-09-03 09:47:57\n\n## new Vue()做了什么？\nnew关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是\n`/src/core/instance/index.js`\n```\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n接着我们跳转追踪至`this._init()`，即`Vue.prototype._init`,位于`src\\core\\instance\\init.js`.\n在`_init()`方法的内部有一系列 `init*` 的方法\n```\nVue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // ...忽略，从第45行看起\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n    // ...忽略\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n```\n统一概述一遍new Vue()时做了什么处理:\n\n* `initProxy`，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)\n* `initLifecycle`（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。\n* `initEvents`，用来存放除@hook:生命周期钩子名称=\"绑定的函数\"事件的对象。如:$on、$emit等。\n* `initRender`，用于初始化$slots、$attrs、$listeners\n* `initInjections`，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。\n* `initState`，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。\n* `initProvide`，初始化provide。\n* `vm.$mount`，挂载实例。\n\n## 什么阶段才能访问DOM？\n这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:\n```\ncallHook(vm, 'beforeCreate')\n// 初始化 inject\n// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)\n// 初始化 provide\ncallHook(vm, 'created')\n// 挂载实例 vm.$mount(vm.$options.el)\n// vue实例的数据对象data有了\n```\n所以当面试官问你:\n\n* beforeCreate以及 created 调用时，哪些数据能用与否？\n* 什么阶段才能访问DOM？\n* 为什么created之后才挂载实例？\n\n## 谈谈你对Vue的生命周期的理解？\n生命周期函数解释说明（图片）：https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\n##### 理解:\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会\n##### 生命周期的几个阶段:\n1. created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=>挂载=>更新=>销毁\n* beforeCreate & created 看上一题\n* beforeMount & mounted\n```\ncallHook(vm, 'beforeMount')\n// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，\ncallHook(vm, 'mounted')\n// vue实例挂载完成，data.message成功渲染\n```\n* beforeUpdate & updated\n```\ndata变化会触发beforeUpdate和updated方法\n```\n* beforeDestroy & destroyed\n```\ncallHook(vm, 'destroyed')\n// data的改变不会再触发周期函数\n// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。\n```\n\n深入理解源码:\n\n2. Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。\n```\n// v2.6.10 最新版\nvar LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    // v2.6+ \n    'serverPrefetch' //看下一题\n];\n```\n于是，你可以答多`activated & deactivated`（keep-alive 组件激活/停用）、`errorCaptured`（v2.5 以上版本有的一个钩子，用于处理错误）这三个。\n\n-----\n\n## 生命周期钩子的合并策略\nhttps://www.cnblogs.com/xweizi/p/10572281.html\n\n----- \n单独抽出一天来处理\n\n## 新生命周期钩子：serverPrefetch是什么？\n```\n// v2.6.10的变化\n```\n可以看到，`serverPrefetch`前身是`ssrPrefetch`。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。\n![image](https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n这里我们贴出一段官方例子：\n```\n<!-- Item.vue -->\n<template>\n  <div v-if=\"item\">{{ item.title }}</div>\n  <div v-else>...</div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    item () {\n      return this.$store.state.items[this.$route.params.id]\n    }\n  },\n  serverPrefetch () {\n    return this.fetchItem()\n  },\n  mounted () {\n    if (!this.item) {\n      this.fetchItem()\n    }\n  },\n  methods: {\n    fetchItem () {\n      // return the Promise from the action\n      return this.$store.dispatch('fetchItem', this.$route.params.id)\n    }\n  }\n}\n</script>\n```\n## Vue-router 路由模式有几种？\n三种 \"hash\" | \"history\" | \"abstract\"，一般人只知道两种\"hash\" | \"history\"\n```\n// 源码：\n\nswitch (mode) {\n  case 'history':\n    this.history = new HTML5History(this, options.base)\n    break\n  case 'hash':\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case 'abstract':\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== 'production') {\n      assert(false, `invalid mode: ${mode}`)\n    }\n}\n```\n##### mode\n* 类型: string\n* 默认值: \"hash\" (浏览器环境) | \"abstract\" (Node.js 环境)\n* 可选值: \"hash\" | \"history\" | \"abstract\"\n\n配置路由模式:\n\n* hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。\n* history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。\n* abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.\n\n###### 路由模式解析\n对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.\n\n前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求\n`\n浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。\n`\n\n.\n\n* vue-router: hash\n\nhash模式中url带有#号，修改成history模式，url中的#自动就去除了。\n\nhash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：\n```\nwindow.onhashchange = function(event){\n    console.log(event.oldURL, event.newURL);\n    let hash = location.hash.slice(1)\n}\n```\n\nhash模式下，仅hash符号之前的内容会被包含在请求中,如 http://www.abc.com, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.\n\n* vue-router: history\n随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。\n　history api可以分为两大部分：切换和修改\n1. 切换历史状态\n\n包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：\n```\nhistory.go(-2);//后退两次\nhistory.go(2);//前进两次\nhistory.back(); //后退\nhsitory.forward(); //前进\n```\n`\n坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页\n`\n\n2. 修改历史状态\n包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url\n```\nhistory.pushState(stateObj，title，url)\nwindow.onpopstate = function(event){\n    console.log(event.state)\n    if(event.state && event.state.color === 'red'){\n        document.body.style.color = 'red';\n    }\n}\n\n```\n`\n坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。\n`\n3. popstate实现history路由拦截，监听页面返回事件\n当活动历史记录条目更改时，将触发popstate事件\n\n*  如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。\n\n* 需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；\n\n  　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）\n* vue-router: abstract\nabstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。\n\n根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式\n\n## 谈谈你对keep-alive的了解\n先贴一个常规回答：\n`\nkeep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。\n在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。\n<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n`\n\n`然后你可以开始骚了：`\n\n1. `<keep-alive>`是 Vue 源码中实现的一个全局抽象组件，通过自定义 `render` 函数并且利用了`插槽`来实现数据缓存和更新。它的定义在`src/core/components/keep-alive.js` 中：\n```\nexport default {\n  name: 'keep-alive',\n  abstract: true,\n  ...\n}\n```\n2. 所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：\n```\nif (parent && !options.abstract) {\n  // abstract 即 `ptions.abstract`\n  // while 循环查找第一个非抽象的父组件\n  while (parent.$options.abstract && parent.$parent) {\n    parent = parent.$parent\n  }\n  parent.$children.push(vm)\n}\n```\n\n3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。\n\n## vue源码中内置的组件？\n* component\n* transition\n* transition-group\n* keep-alive\n* slot\n## 了解Vue2.6+新全局API：Vue.observable()吗？\nVue2.6+新的全局API是Vue.observable(),它的使用方式：\n```\n// 准备个文件store.js - /store/store.js\nimport Vue from 'vue'\n\nexport const store = Vue.observable({ count: 0 })  //定义一个变量\nexport const mutations = {  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值\n  setCount (count) {\n    store.count = count\n  }\n}\n```\n返回的对象可以直接用于`渲染函数`和`计算属性`内，并且会在发生改变时触发相应的更新。\n```\n<template>\n    <div>\n        <p>你点+-，看我能不能根据状态去动态改变</p>\n        <label for=\"bookNum\">数量</label>\n        <button @click=\"setCount(count+1)\">+</button>\n        <span>{{count}}</span>\n        <button @click=\"setCount(count-1)\">-</button>\n    </div>\n</template>\n\n<script>\nimport { store, mutations } from '../store/store' // Vue2.6新增API Observable\n\nexport default {\n  name: 'Add',\n  computed: {\n    count () {\n      return store.count //用于去渲染之前Observable中定义的变量count\n    }\n  },\n  methods: {\n    setCount: mutations.setCount\n  }\n}\n</script>\n```\n## 了解Vue数据绑定原理？\n参考Vue.js官网介绍响应式原理图，我们进行分析：\n\n这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。\nVue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。\n\nVue在初始化组件数据时，在生命周期的`beforeCreate`与`created`钩子函数之间实现了对`data、props、computed、methods、events`以及`watch`的处理.\n\n* initData\n参考源码instance下的state.js文件\n\ninitData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。\n\n\n```\nfunction initData (vm: Component) {  \n  /*得到data数据*/\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {} \n  /*判断是否是对象*/\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' +'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm)\n  }  \n  // proxy data on instance\n  /*遍历data对象*/\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  //遍历data中的数据\n  while (i--) {\n    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(`The data property \"${keys[i]}\" is already declared as a prop. ` +`Use prop default value instead.`,vm)\n    } else if (!isReserved(keys[i])) {\n      /*判断是否是保留字段*/\n      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/\n      proxy(vm, `_data`, keys[i])\n    }\n  }\n  // observe data\n  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  \n  observe(data, true /* asRootData */)\n  }\n```\n其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。\n\n* proxy\n接下来看一下proxy代理。\n\n```\n/*添加代理*/\nexport function proxy (target: Object, sourceKey: string, key: string) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  }\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n```\n\n通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。\n\n* observe\n参考源码文件在core文件下oberver的index.js文件中\n\n\n```\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\n /*\n 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。\n */\nexport function observe (value: any, asRootData: ?boolean): Observer | void {\n  /*判断是否是一个对象*/\n  if (!isObject(value)) {\n    return\n  }\n  let ob: Observer | void\n\n  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n\n    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n\n    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/\n    ob.vmCount++\n  }\n  return ob\n}\n\n```\nVue的响应式数据都会有一个__ob__的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。\n* Observer\nObserver的作用就是遍历对象的所有属性将其进行双向绑定。\n\n```\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nexport class  {\n  value: any;\n  dep: Dep;\n  vmCount: number; // number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0\n\n    /*\n    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16\n    */\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n\n      /*\n          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。\n          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。\n      */\n      const augment = hasProto\n        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/\n        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/\n      augment(value, arrayMethods, arrayKeys)\n\n      /*如果是数组则需要遍历数组的每一个成员进行observe*/\n      this.observeArray(value)\n    } else {\n\n      /*如果是对象则直接walk进行绑定*/\n      this.walk(value)\n    }\n  }\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n\n    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  /**\n   * Observe a list of Array items.\n   */\n  observeArray (items: Array<any>) {\n\n    /*数组需要便利每一个成员进行observe*/\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n```\nObserver为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。\n如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。\n但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？\n\nVue.js提供的方法是重写 `push、pop、shift、unshift、splice、sort、reverse`这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。\n```\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nimport { def } from '../util/index'\n\n/*取得原生数组的原型*/\nconst arrayProto = Array.prototype\n/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/\nexport const arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  /*将数组的原生方法缓存起来，后面要调用*/\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    let i = arguments.length\n    const args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    /*调用原生的数组方法*/\n    const result = original.apply(this, args)\n\n    /*数组新插入的元素需要重新进行observe才能响应式*/\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n      \n    // notify change\n    /*dep通知所有注册的观察者进行响应式处理*/\n    ob.dep.notify()\n    return result\n  })\n})\n```\n从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持__proto__这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。\n\n如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。\n\n在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。\n\n但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。\n\n* Watcher\n\nWatcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。\n\n\n```\nexport default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: Array<Dep>;\n  newDeps: Array<Dep>;\n  depIds: ISet;\n  newDepIds: ISet;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    this.vm = vm\n    /*_watchers存放订阅者实例*/\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.lazy // for lazy watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    /*把表达式expOrFn解析成getter*/\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n   /*获得getter的值并且重新进行依赖收集*/\n  get () {\n    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/\n    pushTarget(this)\n    let value\n    const vm = this.vm\n\n    /*\n      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。\n      在将Dep.target设置为自生观察者实例以后，执行getter操作。\n      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，\n      那么在执行getter的时候就会触发a跟c两个数据的getter函数，\n      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，\n      将该观察者对象放入闭包中的Dep的subs中去。\n    */\n    if (this.user) {\n      try {\n        value = this.getter.call(vm, vm)\n      } catch (e) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      }\n    } else {\n      value = this.getter.call(vm, vm)\n    }\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/\n    if (this.deep) {\n      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/\n      traverse(value)\n    }\n\n    /*将观察者实例从target栈中取出并设置给Dep.target*/\n    popTarget()\n    this.cleanupDeps()\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n   /*添加一个依赖关系到Deps集合中*/\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n   /*清理依赖收集*/\n  cleanupDeps () {\n    /*移除所有观察者对象*/\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n   /*\n      调度者接口，当依赖发生改变的时候进行回调。\n   */\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      /*同步则执行run直接渲染视图*/\n      this.run()\n    } else {\n      /*异步推送到观察者队列中，由调度者调用。*/\n      queueWatcher(this)\n    }\n  }\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n   /*\n      调度者工作接口，将被调度者回调。\n    */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        /*\n            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。\n        */\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        /*设置新的值*/\n        this.value = value\n\n        /*触发回调渲染视图*/\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher \"${this.expression}\"`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n   /*获取观察者的值*/\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n   /*收集该watcher的所有deps依赖*/\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n   /*将自身从所有依赖收集订阅列表删除*/\n  teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n}\n```\n* Dep\n\n来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。\n\n```\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array<Watcher>;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  /*添加一个观察者对象*/\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  /*移除一个观察者对象*/\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  /*依赖收集，当存在Dep.target的时候添加观察者对象*/\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  /*通知所有订阅者*/\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null\n/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/\n```\n\n* defineReactive\n\n接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。\n触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。\n\n```\n/**\n * Define a reactive property on an Object.\n */\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  /*在闭包中定义一个dep对象*/\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n\n  /*对象的子对象递归进行observe并返回子节点的Observer对象*/\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n\n      /*如果原本对象拥有getter方法则执行*/\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n\n        /*进行依赖收集*/\n        dep.depend()\n        if (childOb) {\n\n          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/\n          childOb.dep.depend()\n        }\n        if (Array.isArray(value)) {\n\n          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/\n          dependArray(value)\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n\n      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      if (setter) {\n\n        /*如果原本对象拥有setter方法则执行setter*/\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n\n      /*新的值需要重新进行observe，保证数据响应式*/\n      childOb = observe(newVal)\n\n      /*dep对象通知所有的观察者*/\n      dep.notify()\n    }\n  })\n}\n```\n----\n整篇文章主要参考链接：https://juejin.im/post/5c959f74f265da610c068fa8\n源码解析参考链接：https://github.com/answershuto/learnVue\n\n\n\n","slug":"vueSourceCoding","published":1,"updated":"2020-07-22T08:13:14.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjsc002z78p3befiyz2q","content":"<p>Author: EchodefineProperty<br>Time: 2019-09-03 09:47:57</p>\n<h2 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h2><p>new关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是<br><code>/src/core/instance/index.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们跳转追踪至<code>this._init()</code>，即<code>Vue.prototype._init</code>,位于<code>src\\core\\instance\\init.js</code>.<br>在<code>_init()</code>方法的内部有一系列 <code>init*</code> 的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // ...忽略，从第45行看起</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">    // ...忽略</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>统一概述一遍new Vue()时做了什么处理:</p>\n<ul>\n<li><code>initProxy</code>，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)</li>\n<li><code>initLifecycle</code>（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。</li>\n<li><code>initEvents</code>，用来存放除@hook:生命周期钩子名称=”绑定的函数”事件的对象。如:$on、$emit等。</li>\n<li><code>initRender</code>，用于初始化$slots、$attrs、$listeners</li>\n<li><code>initInjections</code>，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。</li>\n<li><code>initState</code>，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。</li>\n<li><code>initProvide</code>，初始化provide。</li>\n<li><code>vm.$mount</code>，挂载实例。</li>\n</ul>\n<h2 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h2><p>这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">// 初始化 inject</span><br><span class=\"line\">// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)</span><br><span class=\"line\">// 初始化 provide</span><br><span class=\"line\">callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">// 挂载实例 vm.$mount(vm.$options.el)</span><br><span class=\"line\">// vue实例的数据对象data有了</span><br></pre></td></tr></table></figure></p>\n<p>所以当面试官问你:</p>\n<ul>\n<li>beforeCreate以及 created 调用时，哪些数据能用与否？</li>\n<li>什么阶段才能访问DOM？</li>\n<li>为什么created之后才挂载实例？</li>\n</ul>\n<h2 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h2><p>生命周期函数解释说明（图片）：<a href=\"https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\" target=\"_blank\" rel=\"noopener\">https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png</a></p>\n<h5 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解:\"></a>理解:</h5><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会</p>\n<h5 id=\"生命周期的几个阶段\"><a href=\"#生命周期的几个阶段\" class=\"headerlink\" title=\"生命周期的几个阶段:\"></a>生命周期的几个阶段:</h5><ol>\n<li>created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁</li>\n</ol>\n<ul>\n<li>beforeCreate &amp; created 看上一题</li>\n<li><p>beforeMount &amp; mounted</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeMount&apos;)</span><br><span class=\"line\">// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，</span><br><span class=\"line\">callHook(vm, &apos;mounted&apos;)</span><br><span class=\"line\">// vue实例挂载完成，data.message成功渲染</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeUpdate &amp; updated</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data变化会触发beforeUpdate和updated方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeDestroy &amp; destroyed</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;destroyed&apos;)</span><br><span class=\"line\">// data的改变不会再触发周期函数</span><br><span class=\"line\">// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>深入理解源码:</p>\n<ol start=\"2\">\n<li>Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10 最新版</span><br><span class=\"line\">var LIFECYCLE_HOOKS = [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;,</span><br><span class=\"line\">    &apos;errorCaptured&apos;,</span><br><span class=\"line\">    // v2.6+ </span><br><span class=\"line\">    &apos;serverPrefetch&apos; //看下一题</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>于是，你可以答多<code>activated &amp; deactivated</code>（keep-alive 组件激活/停用）、<code>errorCaptured</code>（v2.5 以上版本有的一个钩子，用于处理错误）这三个。</p>\n<hr>\n<h2 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h2><p><a href=\"https://www.cnblogs.com/xweizi/p/10572281.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xweizi/p/10572281.html</a></p>\n<hr>\n<p>单独抽出一天来处理</p>\n<h2 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10的变化</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>serverPrefetch</code>前身是<code>ssrPrefetch</code>。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。<br><img src=\"https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>这里我们贴出一段官方例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Item.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;item&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    item () &#123;</span><br><span class=\"line\">      return this.$store.state.items[this.$route.params.id]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  serverPrefetch () &#123;</span><br><span class=\"line\">    return this.fetchItem()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    if (!this.item) &#123;</span><br><span class=\"line\">      this.fetchItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    fetchItem () &#123;</span><br><span class=\"line\">      // return the Promise from the action</span><br><span class=\"line\">      return this.$store.dispatch(&apos;fetchItem&apos;, this.$route.params.id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h2><p>三种 “hash” | “history” | “abstract”，一般人只知道两种”hash” | “history”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码：</span><br><span class=\"line\"></span><br><span class=\"line\">switch (mode) &#123;</span><br><span class=\"line\">  case &apos;history&apos;:</span><br><span class=\"line\">    this.history = new HTML5History(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;hash&apos;:</span><br><span class=\"line\">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;abstract&apos;:</span><br><span class=\"line\">    this.history = new AbstractHistory(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h5><ul>\n<li>类型: string</li>\n<li>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</li>\n<li>可选值: “hash” | “history” | “abstract”</li>\n</ul>\n<p>配置路由模式:</p>\n<ul>\n<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</li>\n<li>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</li>\n<li>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>\n</ul>\n<h6 id=\"路由模式解析\"><a href=\"#路由模式解析\" class=\"headerlink\" title=\"路由模式解析\"></a>路由模式解析</h6><p>对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.</p>\n<p>前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求<br><code>浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。</code></p>\n<p>.</p>\n<ul>\n<li>vue-router: hash</li>\n</ul>\n<p>hash模式中url带有#号，修改成history模式，url中的#自动就去除了。</p>\n<p>hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onhashchange = function(event)&#123;</span><br><span class=\"line\">    console.log(event.oldURL, event.newURL);</span><br><span class=\"line\">    let hash = location.hash.slice(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hash模式下，仅hash符号之前的内容会被包含在请求中,如 <a href=\"http://www.abc.com\" target=\"_blank\" rel=\"noopener\">http://www.abc.com</a>, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.</p>\n<ul>\n<li>vue-router: history<br>随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。<br>　history api可以分为两大部分：切换和修改</li>\n</ul>\n<ol>\n<li>切换历史状态</li>\n</ol>\n<p>包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-2);//后退两次</span><br><span class=\"line\">history.go(2);//前进两次</span><br><span class=\"line\">history.back(); //后退</span><br><span class=\"line\">hsitory.forward(); //前进</span><br></pre></td></tr></table></figure></p>\n<p><code>坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页</code></p>\n<ol start=\"2\">\n<li>修改历史状态<br>包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.pushState(stateObj，title，url)</span><br><span class=\"line\">window.onpopstate = function(event)&#123;</span><br><span class=\"line\">    console.log(event.state)</span><br><span class=\"line\">    if(event.state &amp;&amp; event.state.color === &apos;red&apos;)&#123;</span><br><span class=\"line\">        document.body.style.color = &apos;red&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</code></p>\n<ol start=\"3\">\n<li>popstate实现history路由拦截，监听页面返回事件<br>当活动历史记录条目更改时，将触发popstate事件</li>\n</ol>\n<ul>\n<li><p>如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。</p>\n</li>\n<li><p>需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；</p>\n<p>　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）</p>\n</li>\n<li>vue-router: abstract<br>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</li>\n</ul>\n<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式</p>\n<h2 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h2><p>先贴一个常规回答：<br>`<br>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>\n<p><keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br>`</keep-alive></p>\n<p><code>然后你可以开始骚了：</code></p>\n<ol>\n<li><p><code>&lt;keep-alive&gt;</code>是 Vue 源码中实现的一个全局抽象组件，通过自定义 <code>render</code> 函数并且利用了<code>插槽</code>来实现数据缓存和更新。它的定义在<code>src/core/components/keep-alive.js</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;keep-alive&apos;,</span><br><span class=\"line\">  abstract: true,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">  // abstract 即 `ptions.abstract`</span><br><span class=\"line\">  // while 循环查找第一个非抽象的父组件</span><br><span class=\"line\">  while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">    parent = parent.$parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  parent.$children.push(vm)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。</keep-alive></p>\n<h2 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h2><ul>\n<li>component</li>\n<li>transition</li>\n<li>transition-group</li>\n<li>keep-alive</li>\n<li>slot<h2 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h2>Vue2.6+新的全局API是Vue.observable(),它的使用方式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 准备个文件store.js - /store/store.js</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export const store = Vue.observable(&#123; count: 0 &#125;)  //定义一个变量</span><br><span class=\"line\">export const mutations = &#123;  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值</span><br><span class=\"line\">  setCount (count) &#123;</span><br><span class=\"line\">    store.count = count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>返回的对象可以直接用于<code>渲染函数</code>和<code>计算属性</code>内，并且会在发生改变时触发相应的更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;你点+-，看我能不能根据状态去动态改变&lt;/p&gt;</span><br><span class=\"line\">        &lt;label for=&quot;bookNum&quot;&gt;数量&lt;/label&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count+1)&quot;&gt;+&lt;/button&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count-1)&quot;&gt;-&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; store, mutations &#125; from &apos;../store/store&apos; // Vue2.6新增API Observable</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;Add&apos;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return store.count //用于去渲染之前Observable中定义的变量count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    setCount: mutations.setCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h2><p>参考Vue.js官网介绍响应式原理图，我们进行分析：</p>\n<p>这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。<br>Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。</p>\n<p>Vue在初始化组件数据时，在生命周期的<code>beforeCreate</code>与<code>created</code>钩子函数之间实现了对<code>data、props、computed、methods、events</code>以及<code>watch</code>的处理.</p>\n<ul>\n<li>initData<br>参考源码instance下的state.js文件</li>\n</ul>\n<p>initData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initData (vm: Component) &#123;  </span><br><span class=\"line\">  /*得到data数据*/</span><br><span class=\"line\">  let data = vm.$options.data</span><br><span class=\"line\">  data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; </span><br><span class=\"line\">  /*判断是否是对象*/</span><br><span class=\"line\">  if (!isPlainObject(data)) &#123;</span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(&apos;data functions should return an object:\\n&apos; +&apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm)</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  // proxy data on instance</span><br><span class=\"line\">  /*遍历data对象*/</span><br><span class=\"line\">  const keys = Object.keys(data)</span><br><span class=\"line\">  const props = vm.$options.props</span><br><span class=\"line\">  let i = keys.length</span><br><span class=\"line\">  //遍历data中的数据</span><br><span class=\"line\">  while (i--) &#123;</span><br><span class=\"line\">    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class=\"line\">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(`The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +`Use prop default value instead.`,vm)</span><br><span class=\"line\">    &#125; else if (!isReserved(keys[i])) &#123;</span><br><span class=\"line\">      /*判断是否是保留字段*/</span><br><span class=\"line\">      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/</span><br><span class=\"line\">      proxy(vm, `_data`, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // observe data</span><br><span class=\"line\">  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  </span><br><span class=\"line\">  observe(data, true /* asRootData */)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。</p>\n<ul>\n<li>proxy<br>接下来看一下proxy代理。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*添加代理*/</span><br><span class=\"line\">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class=\"line\">  sharedPropertyDefinition.get = function proxyGetter () &#123;</span><br><span class=\"line\">    return this[sourceKey][key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sharedPropertyDefinition.set = function proxySetter (val) &#123;</span><br><span class=\"line\">    this[sourceKey][key] = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。</p>\n<ul>\n<li>observe<br>参考源码文件在core文件下oberver的index.js文件中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Attempt to create an observer instance for a value,</span><br><span class=\"line\"> * returns the new observer if successfully observed,</span><br><span class=\"line\"> * or the existing observer if the value already has one.</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*</span><br><span class=\"line\"> 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class=\"line\">  /*判断是否是一个对象*/</span><br><span class=\"line\">  if (!isObject(value)) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let ob: Observer | void</span><br><span class=\"line\"></span><br><span class=\"line\">  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/</span><br><span class=\"line\">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; else if (</span><br><span class=\"line\"></span><br><span class=\"line\">    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/</span><br><span class=\"line\">    observerState.shouldConvert &amp;&amp;</span><br><span class=\"line\">    !isServerRendering() &amp;&amp;</span><br><span class=\"line\">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class=\"line\">    Object.isExtensible(value) &amp;&amp;</span><br><span class=\"line\">    !value._isVue</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = new Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/</span><br><span class=\"line\">    ob.vmCount++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vue的响应式数据都会有一个<strong>ob</strong>的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。</p>\n<ul>\n<li>Observer<br>Observer的作用就是遍历对象的所有属性将其进行双向绑定。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Observer class that are attached to each observed</span><br><span class=\"line\"> * object. Once attached, the observer converts target</span><br><span class=\"line\"> * object&apos;s property keys into getter/setters that</span><br><span class=\"line\"> * collect dependencies and dispatches updates.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export class  &#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\">  vmCount: number; // number of vms that has this object as root $data</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (value: any) &#123;</span><br><span class=\"line\">    this.value = value</span><br><span class=\"line\">    this.dep = new Dep()</span><br><span class=\"line\">    this.vmCount = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16</span><br><span class=\"line\">    */</span><br><span class=\"line\">    def(value, &apos;__ob__&apos;, this)</span><br><span class=\"line\">    if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*</span><br><span class=\"line\">          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。</span><br><span class=\"line\">          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。</span><br><span class=\"line\">      */</span><br><span class=\"line\">      const augment = hasProto</span><br><span class=\"line\">        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/</span><br><span class=\"line\">        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是数组则需要遍历数组的每一个成员进行observe*/</span><br><span class=\"line\">      this.observeArray(value)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是对象则直接walk进行绑定*/</span><br><span class=\"line\">      this.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Walk through each property and convert them into</span><br><span class=\"line\">   * getter/setters. This method should only be called when</span><br><span class=\"line\">   * value type is Object.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  walk (obj: Object) &#123;</span><br><span class=\"line\">    const keys = Object.keys(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/</span><br><span class=\"line\">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Observe a list of Array items.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组需要便利每一个成员进行observe*/</span><br><span class=\"line\">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。<br>如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。<br>但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？</p>\n<p>Vue.js提供的方法是重写 <code>push、pop、shift、unshift、splice、sort、reverse</code>这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * not type checking this file because flow doesn&apos;t play well with</span><br><span class=\"line\"> * dynamically accessing methods on Array prototype</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; def &#125; from &apos;../util/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">/*取得原生数组的原型*/</span><br><span class=\"line\">const arrayProto = Array.prototype</span><br><span class=\"line\">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span><br><span class=\"line\">export const arrayMethods = Object.create(arrayProto)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Intercept mutating methods and emit events</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/</span><br><span class=\"line\">;[</span><br><span class=\"line\">  &apos;push&apos;,</span><br><span class=\"line\">  &apos;pop&apos;,</span><br><span class=\"line\">  &apos;shift&apos;,</span><br><span class=\"line\">  &apos;unshift&apos;,</span><br><span class=\"line\">  &apos;splice&apos;,</span><br><span class=\"line\">  &apos;sort&apos;,</span><br><span class=\"line\">  &apos;reverse&apos;</span><br><span class=\"line\">]</span><br><span class=\"line\">.forEach(function (method) &#123;</span><br><span class=\"line\">  // cache original method</span><br><span class=\"line\">  /*将数组的原生方法缓存起来，后面要调用*/</span><br><span class=\"line\">  const original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, function mutator () &#123;</span><br><span class=\"line\">    // avoid leaking arguments:</span><br><span class=\"line\">    // http://jsperf.com/closure-with-arguments</span><br><span class=\"line\">    let i = arguments.length</span><br><span class=\"line\">    const args = new Array(i)</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      args[i] = arguments[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /*调用原生的数组方法*/</span><br><span class=\"line\">    const result = original.apply(this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组新插入的元素需要重新进行observe才能响应式*/</span><br><span class=\"line\">    const ob = this.__ob__</span><br><span class=\"line\">    let inserted</span><br><span class=\"line\">    switch (method) &#123;</span><br><span class=\"line\">      case &apos;push&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;unshift&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;splice&apos;:</span><br><span class=\"line\">        inserted = args.slice(2)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (inserted) ob.observeArray(inserted)</span><br><span class=\"line\">      </span><br><span class=\"line\">    // notify change</span><br><span class=\"line\">    /*dep通知所有注册的观察者进行响应式处理*/</span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    return result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持<strong>proto</strong>这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。</p>\n<p>如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。</p>\n<p>在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。</p>\n<p>但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。</p>\n<ul>\n<li>Watcher</li>\n</ul>\n<p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default class Watcher &#123;</span><br><span class=\"line\">  vm: Component;</span><br><span class=\"line\">  expression: string;</span><br><span class=\"line\">  cb: Function;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  deep: boolean;</span><br><span class=\"line\">  user: boolean;</span><br><span class=\"line\">  lazy: boolean;</span><br><span class=\"line\">  sync: boolean;</span><br><span class=\"line\">  dirty: boolean;</span><br><span class=\"line\">  active: boolean;</span><br><span class=\"line\">  deps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  newDeps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  depIds: ISet;</span><br><span class=\"line\">  newDepIds: ISet;</span><br><span class=\"line\">  getter: Function;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (</span><br><span class=\"line\">    vm: Component,</span><br><span class=\"line\">    expOrFn: string | Function,</span><br><span class=\"line\">    cb: Function,</span><br><span class=\"line\">    options?: Object</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    this.vm = vm</span><br><span class=\"line\">    /*_watchers存放订阅者实例*/</span><br><span class=\"line\">    vm._watchers.push(this)</span><br><span class=\"line\">    // options</span><br><span class=\"line\">    if (options) &#123;</span><br><span class=\"line\">      this.deep = !!options.deep</span><br><span class=\"line\">      this.user = !!options.user</span><br><span class=\"line\">      this.lazy = !!options.lazy</span><br><span class=\"line\">      this.sync = !!options.sync</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.cb = cb</span><br><span class=\"line\">    this.id = ++uid // uid for batching</span><br><span class=\"line\">    this.active = true</span><br><span class=\"line\">    this.dirty = this.lazy // for lazy watchers</span><br><span class=\"line\">    this.deps = []</span><br><span class=\"line\">    this.newDeps = []</span><br><span class=\"line\">    this.depIds = new Set()</span><br><span class=\"line\">    this.newDepIds = new Set()</span><br><span class=\"line\">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class=\"line\">      ? expOrFn.toString()</span><br><span class=\"line\">      : &apos;&apos;</span><br><span class=\"line\">    // parse expression for getter</span><br><span class=\"line\">    /*把表达式expOrFn解析成getter*/</span><br><span class=\"line\">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class=\"line\">      this.getter = expOrFn</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.getter = parsePath(expOrFn)</span><br><span class=\"line\">      if (!this.getter) &#123;</span><br><span class=\"line\">        this.getter = function () &#123;&#125;</span><br><span class=\"line\">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class=\"line\">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class=\"line\">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class=\"line\">          &apos;For full control, use a function instead.&apos;,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.value = this.lazy</span><br><span class=\"line\">      ? undefined</span><br><span class=\"line\">      : this.get()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the getter, and re-collect dependencies.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获得getter的值并且重新进行依赖收集*/</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span><br><span class=\"line\">    pushTarget(this)</span><br><span class=\"line\">    let value</span><br><span class=\"line\">    const vm = this.vm</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。</span><br><span class=\"line\">      在将Dep.target设置为自生观察者实例以后，执行getter操作。</span><br><span class=\"line\">      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，</span><br><span class=\"line\">      那么在执行getter的时候就会触发a跟c两个数据的getter函数，</span><br><span class=\"line\">      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，</span><br><span class=\"line\">      将该观察者对象放入闭包中的Dep的subs中去。</span><br><span class=\"line\">    */</span><br><span class=\"line\">    if (this.user) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        value = this.getter.call(vm, vm)</span><br><span class=\"line\">      &#125; catch (e) &#123;</span><br><span class=\"line\">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      value = this.getter.call(vm, vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // &quot;touch&quot; every property so they are all tracked as</span><br><span class=\"line\">    // dependencies for deep watching</span><br><span class=\"line\">    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span><br><span class=\"line\">    if (this.deep) &#123;</span><br><span class=\"line\">      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span><br><span class=\"line\">      traverse(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*将观察者实例从target栈中取出并设置给Dep.target*/</span><br><span class=\"line\">    popTarget()</span><br><span class=\"line\">    this.cleanupDeps()</span><br><span class=\"line\">    return value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Add a dependency to this directive.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*添加一个依赖关系到Deps集合中*/</span><br><span class=\"line\">  addDep (dep: Dep) &#123;</span><br><span class=\"line\">    const id = dep.id</span><br><span class=\"line\">    if (!this.newDepIds.has(id)) &#123;</span><br><span class=\"line\">      this.newDepIds.add(id)</span><br><span class=\"line\">      this.newDeps.push(dep)</span><br><span class=\"line\">      if (!this.depIds.has(id)) &#123;</span><br><span class=\"line\">        dep.addSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Clean up for dependency collection.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*清理依赖收集*/</span><br><span class=\"line\">  cleanupDeps () &#123;</span><br><span class=\"line\">    /*移除所有观察者对象*/</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      const dep = this.deps[i]</span><br><span class=\"line\">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class=\"line\">        dep.removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let tmp = this.depIds</span><br><span class=\"line\">    this.depIds = this.newDepIds</span><br><span class=\"line\">    this.newDepIds = tmp</span><br><span class=\"line\">    this.newDepIds.clear()</span><br><span class=\"line\">    tmp = this.deps</span><br><span class=\"line\">    this.deps = this.newDeps</span><br><span class=\"line\">    this.newDeps = tmp</span><br><span class=\"line\">    this.newDeps.length = 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Subscriber interface.</span><br><span class=\"line\">   * Will be called when a dependency changes.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class=\"line\">   */</span><br><span class=\"line\">  update () &#123;</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (this.lazy) &#123;</span><br><span class=\"line\">      this.dirty = true</span><br><span class=\"line\">    &#125; else if (this.sync) &#123;</span><br><span class=\"line\">      /*同步则执行run直接渲染视图*/</span><br><span class=\"line\">      this.run()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class=\"line\">      queueWatcher(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Scheduler job interface.</span><br><span class=\"line\">   * Will be called by the scheduler.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者工作接口，将被调度者回调。</span><br><span class=\"line\">    */</span><br><span class=\"line\">  run () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      const value = this.get()</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        value !== this.value ||</span><br><span class=\"line\">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class=\"line\">        // when the value is the same, because the value may</span><br><span class=\"line\">        // have mutated.</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。</span><br><span class=\"line\">        */</span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        this.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // set new value</span><br><span class=\"line\">        const oldValue = this.value</span><br><span class=\"line\">        /*设置新的值*/</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        /*触发回调渲染视图*/</span><br><span class=\"line\">        if (this.user) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the value of the watcher.</span><br><span class=\"line\">   * This only gets called for lazy watchers.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获取观察者的值*/</span><br><span class=\"line\">  evaluate () &#123;</span><br><span class=\"line\">    this.value = this.get()</span><br><span class=\"line\">    this.dirty = false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Depend on all deps collected by this watcher.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*收集该watcher的所有deps依赖*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      this.deps[i].depend()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*将自身从所有依赖收集订阅列表删除*/</span><br><span class=\"line\">  teardown () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      // remove self from vm&apos;s watcher list</span><br><span class=\"line\">      // this is a somewhat expensive operation so we skip it</span><br><span class=\"line\">      // if the vm is being destroyed.</span><br><span class=\"line\">      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/</span><br><span class=\"line\">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class=\"line\">        remove(this.vm._watchers, this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      let i = this.deps.length</span><br><span class=\"line\">      while (i--) &#123;</span><br><span class=\"line\">        this.deps[i].removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.active = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Dep</li>\n</ul>\n<p>来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * A dep is an observable that can have multiple</span><br><span class=\"line\"> * directives subscribing to it.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export default class Dep &#123;</span><br><span class=\"line\">  static target: ?Watcher;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  subs: Array&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.id = uid++</span><br><span class=\"line\">    this.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*添加一个观察者对象*/</span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    this.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*移除一个观察者对象*/</span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(this.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*依赖收集，当存在Dep.target的时候添加观察者对象*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    if (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*通知所有订阅者*/</span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    // stabilize the subscriber list first</span><br><span class=\"line\">    const subs = this.subs.slice()</span><br><span class=\"line\">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// the current target watcher being evaluated.</span><br><span class=\"line\">// this is globally unique because there could be only one</span><br><span class=\"line\">// watcher being evaluated at any time.</span><br><span class=\"line\">Dep.target = null</span><br><span class=\"line\">/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defineReactive</li>\n</ul>\n<p>接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。<br>触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Define a reactive property on an Object.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function defineReactive (</span><br><span class=\"line\">  obj: Object,</span><br><span class=\"line\">  key: string,</span><br><span class=\"line\">  val: any,</span><br><span class=\"line\">  customSetter?: Function</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  /*在闭包中定义一个dep对象*/</span><br><span class=\"line\">  const dep = new Dep()</span><br><span class=\"line\"></span><br><span class=\"line\">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/</span><br><span class=\"line\">  // cater for pre-defined getter/setters</span><br><span class=\"line\">  const getter = property &amp;&amp; property.get</span><br><span class=\"line\">  const setter = property &amp;&amp; property.set</span><br><span class=\"line\"></span><br><span class=\"line\">  /*对象的子对象递归进行observe并返回子节点的Observer对象*/</span><br><span class=\"line\">  let childOb = observe(val)</span><br><span class=\"line\">  Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果原本对象拥有getter方法则执行*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      if (Dep.target) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*进行依赖收集*/</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        if (childOb) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span><br><span class=\"line\">          dependArray(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      /* eslint-disable no-self-compare */</span><br><span class=\"line\">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      /* eslint-enable no-self-compare */</span><br><span class=\"line\">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (setter) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*如果原本对象拥有setter方法则执行setter*/</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*新的值需要重新进行observe，保证数据响应式*/</span><br><span class=\"line\">      childOb = observe(newVal)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*dep对象通知所有的观察者*/</span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>整篇文章主要参考链接：<a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a><br>源码解析参考链接：<a href=\"https://github.com/answershuto/learnVue\" target=\"_blank\" rel=\"noopener\">https://github.com/answershuto/learnVue</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: EchodefineProperty<br>Time: 2019-09-03 09:47:57</p>\n<h2 id=\"new-Vue-做了什么？\"><a href=\"#new-Vue-做了什么？\" class=\"headerlink\" title=\"new Vue()做了什么？\"></a>new Vue()做了什么？</h2><p>new关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是<br><code>/src/core/instance/index.js</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Vue (options) &#123;</span><br><span class=\"line\">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class=\"line\">    !(this instanceof Vue)</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this._init(options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着我们跳转追踪至<code>this._init()</code>，即<code>Vue.prototype._init</code>,位于<code>src\\core\\instance\\init.js</code>.<br>在<code>_init()</code>方法的内部有一系列 <code>init*</code> 的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class=\"line\">    const vm: Component = this</span><br><span class=\"line\">    // ...忽略，从第45行看起</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      initProxy(vm)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      vm._renderProxy = vm</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // expose real self</span><br><span class=\"line\">    vm._self = vm</span><br><span class=\"line\">    initLifecycle(vm)</span><br><span class=\"line\">    initEvents(vm)</span><br><span class=\"line\">    initRender(vm)</span><br><span class=\"line\">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">    initInjections(vm) // resolve injections before data/props</span><br><span class=\"line\">    initState(vm)</span><br><span class=\"line\">    initProvide(vm) // resolve provide after data/props</span><br><span class=\"line\">    callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">    // ...忽略</span><br><span class=\"line\">    if (vm.$options.el) &#123;</span><br><span class=\"line\">      vm.$mount(vm.$options.el)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>统一概述一遍new Vue()时做了什么处理:</p>\n<ul>\n<li><code>initProxy</code>，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)</li>\n<li><code>initLifecycle</code>（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。</li>\n<li><code>initEvents</code>，用来存放除@hook:生命周期钩子名称=”绑定的函数”事件的对象。如:$on、$emit等。</li>\n<li><code>initRender</code>，用于初始化$slots、$attrs、$listeners</li>\n<li><code>initInjections</code>，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。</li>\n<li><code>initState</code>，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。</li>\n<li><code>initProvide</code>，初始化provide。</li>\n<li><code>vm.$mount</code>，挂载实例。</li>\n</ul>\n<h2 id=\"什么阶段才能访问DOM？\"><a href=\"#什么阶段才能访问DOM？\" class=\"headerlink\" title=\"什么阶段才能访问DOM？\"></a>什么阶段才能访问DOM？</h2><p>这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeCreate&apos;)</span><br><span class=\"line\">// 初始化 inject</span><br><span class=\"line\">// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)</span><br><span class=\"line\">// 初始化 provide</span><br><span class=\"line\">callHook(vm, &apos;created&apos;)</span><br><span class=\"line\">// 挂载实例 vm.$mount(vm.$options.el)</span><br><span class=\"line\">// vue实例的数据对象data有了</span><br></pre></td></tr></table></figure></p>\n<p>所以当面试官问你:</p>\n<ul>\n<li>beforeCreate以及 created 调用时，哪些数据能用与否？</li>\n<li>什么阶段才能访问DOM？</li>\n<li>为什么created之后才挂载实例？</li>\n</ul>\n<h2 id=\"谈谈你对Vue的生命周期的理解？\"><a href=\"#谈谈你对Vue的生命周期的理解？\" class=\"headerlink\" title=\"谈谈你对Vue的生命周期的理解？\"></a>谈谈你对Vue的生命周期的理解？</h2><p>生命周期函数解释说明（图片）：<a href=\"https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png\" target=\"_blank\" rel=\"noopener\">https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png</a></p>\n<h5 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解:\"></a>理解:</h5><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会</p>\n<h5 id=\"生命周期的几个阶段\"><a href=\"#生命周期的几个阶段\" class=\"headerlink\" title=\"生命周期的几个阶段:\"></a>生命周期的几个阶段:</h5><ol>\n<li>created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁</li>\n</ol>\n<ul>\n<li>beforeCreate &amp; created 看上一题</li>\n<li><p>beforeMount &amp; mounted</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;beforeMount&apos;)</span><br><span class=\"line\">// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，</span><br><span class=\"line\">callHook(vm, &apos;mounted&apos;)</span><br><span class=\"line\">// vue实例挂载完成，data.message成功渲染</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeUpdate &amp; updated</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data变化会触发beforeUpdate和updated方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>beforeDestroy &amp; destroyed</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callHook(vm, &apos;destroyed&apos;)</span><br><span class=\"line\">// data的改变不会再触发周期函数</span><br><span class=\"line\">// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>深入理解源码:</p>\n<ol start=\"2\">\n<li>Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10 最新版</span><br><span class=\"line\">var LIFECYCLE_HOOKS = [</span><br><span class=\"line\">    &apos;beforeCreate&apos;,</span><br><span class=\"line\">    &apos;created&apos;,</span><br><span class=\"line\">    &apos;beforeMount&apos;,</span><br><span class=\"line\">    &apos;mounted&apos;,</span><br><span class=\"line\">    &apos;beforeUpdate&apos;,</span><br><span class=\"line\">    &apos;updated&apos;,</span><br><span class=\"line\">    &apos;beforeDestroy&apos;,</span><br><span class=\"line\">    &apos;destroyed&apos;,</span><br><span class=\"line\">    &apos;activated&apos;,</span><br><span class=\"line\">    &apos;deactivated&apos;,</span><br><span class=\"line\">    &apos;errorCaptured&apos;,</span><br><span class=\"line\">    // v2.6+ </span><br><span class=\"line\">    &apos;serverPrefetch&apos; //看下一题</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>于是，你可以答多<code>activated &amp; deactivated</code>（keep-alive 组件激活/停用）、<code>errorCaptured</code>（v2.5 以上版本有的一个钩子，用于处理错误）这三个。</p>\n<hr>\n<h2 id=\"生命周期钩子的合并策略\"><a href=\"#生命周期钩子的合并策略\" class=\"headerlink\" title=\"生命周期钩子的合并策略\"></a>生命周期钩子的合并策略</h2><p><a href=\"https://www.cnblogs.com/xweizi/p/10572281.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xweizi/p/10572281.html</a></p>\n<hr>\n<p>单独抽出一天来处理</p>\n<h2 id=\"新生命周期钩子：serverPrefetch是什么？\"><a href=\"#新生命周期钩子：serverPrefetch是什么？\" class=\"headerlink\" title=\"新生命周期钩子：serverPrefetch是什么？\"></a>新生命周期钩子：serverPrefetch是什么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// v2.6.10的变化</span><br></pre></td></tr></table></figure>\n<p>可以看到，<code>serverPrefetch</code>前身是<code>ssrPrefetch</code>。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。<br><img src=\"https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"image\"><br>这里我们贴出一段官方例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Item.vue --&gt;</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;item&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    item () &#123;</span><br><span class=\"line\">      return this.$store.state.items[this.$route.params.id]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  serverPrefetch () &#123;</span><br><span class=\"line\">    return this.fetchItem()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted () &#123;</span><br><span class=\"line\">    if (!this.item) &#123;</span><br><span class=\"line\">      this.fetchItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    fetchItem () &#123;</span><br><span class=\"line\">      // return the Promise from the action</span><br><span class=\"line\">      return this.$store.dispatch(&apos;fetchItem&apos;, this.$route.params.id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Vue-router-路由模式有几种？\"><a href=\"#Vue-router-路由模式有几种？\" class=\"headerlink\" title=\"Vue-router 路由模式有几种？\"></a>Vue-router 路由模式有几种？</h2><p>三种 “hash” | “history” | “abstract”，一般人只知道两种”hash” | “history”<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 源码：</span><br><span class=\"line\"></span><br><span class=\"line\">switch (mode) &#123;</span><br><span class=\"line\">  case &apos;history&apos;:</span><br><span class=\"line\">    this.history = new HTML5History(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;hash&apos;:</span><br><span class=\"line\">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  case &apos;abstract&apos;:</span><br><span class=\"line\">    this.history = new AbstractHistory(this, options.base)</span><br><span class=\"line\">    break</span><br><span class=\"line\">  default:</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"mode\"><a href=\"#mode\" class=\"headerlink\" title=\"mode\"></a>mode</h5><ul>\n<li>类型: string</li>\n<li>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</li>\n<li>可选值: “hash” | “history” | “abstract”</li>\n</ul>\n<p>配置路由模式:</p>\n<ul>\n<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</li>\n<li>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</li>\n<li>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>\n</ul>\n<h6 id=\"路由模式解析\"><a href=\"#路由模式解析\" class=\"headerlink\" title=\"路由模式解析\"></a>路由模式解析</h6><p>对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.</p>\n<p>前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求<br><code>浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。\n实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。\n其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。</code></p>\n<p>.</p>\n<ul>\n<li>vue-router: hash</li>\n</ul>\n<p>hash模式中url带有#号，修改成history模式，url中的#自动就去除了。</p>\n<p>hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onhashchange = function(event)&#123;</span><br><span class=\"line\">    console.log(event.oldURL, event.newURL);</span><br><span class=\"line\">    let hash = location.hash.slice(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>hash模式下，仅hash符号之前的内容会被包含在请求中,如 <a href=\"http://www.abc.com\" target=\"_blank\" rel=\"noopener\">http://www.abc.com</a>, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.</p>\n<ul>\n<li>vue-router: history<br>随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。<br>　history api可以分为两大部分：切换和修改</li>\n</ul>\n<ol>\n<li>切换历史状态</li>\n</ol>\n<p>包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.go(-2);//后退两次</span><br><span class=\"line\">history.go(2);//前进两次</span><br><span class=\"line\">history.back(); //后退</span><br><span class=\"line\">hsitory.forward(); //前进</span><br></pre></td></tr></table></figure></p>\n<p><code>坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，\n有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页</code></p>\n<ol start=\"2\">\n<li>修改历史状态<br>包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.pushState(stateObj，title，url)</span><br><span class=\"line\">window.onpopstate = function(event)&#123;</span><br><span class=\"line\">    console.log(event.state)</span><br><span class=\"line\">    if(event.state &amp;&amp; event.state.color === &apos;red&apos;)&#123;</span><br><span class=\"line\">        document.body.style.color = &apos;red&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</code></p>\n<ol start=\"3\">\n<li>popstate实现history路由拦截，监听页面返回事件<br>当活动历史记录条目更改时，将触发popstate事件</li>\n</ol>\n<ul>\n<li><p>如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。</p>\n</li>\n<li><p>需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；</p>\n<p>　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）</p>\n</li>\n<li>vue-router: abstract<br>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</li>\n</ul>\n<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式</p>\n<h2 id=\"谈谈你对keep-alive的了解\"><a href=\"#谈谈你对keep-alive的了解\" class=\"headerlink\" title=\"谈谈你对keep-alive的了解\"></a>谈谈你对keep-alive的了解</h2><p>先贴一个常规回答：<br>`<br>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>\n<p><keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br>`</keep-alive></p>\n<p><code>然后你可以开始骚了：</code></p>\n<ol>\n<li><p><code>&lt;keep-alive&gt;</code>是 Vue 源码中实现的一个全局抽象组件，通过自定义 <code>render</code> 函数并且利用了<code>插槽</code>来实现数据缓存和更新。它的定义在<code>src/core/components/keep-alive.js</code> 中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;keep-alive&apos;,</span><br><span class=\"line\">  abstract: true,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (parent &amp;&amp; !options.abstract) &#123;</span><br><span class=\"line\">  // abstract 即 `ptions.abstract`</span><br><span class=\"line\">  // while 循环查找第一个非抽象的父组件</span><br><span class=\"line\">  while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class=\"line\">    parent = parent.$parent</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  parent.$children.push(vm)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。</keep-alive></p>\n<h2 id=\"vue源码中内置的组件？\"><a href=\"#vue源码中内置的组件？\" class=\"headerlink\" title=\"vue源码中内置的组件？\"></a>vue源码中内置的组件？</h2><ul>\n<li>component</li>\n<li>transition</li>\n<li>transition-group</li>\n<li>keep-alive</li>\n<li>slot<h2 id=\"了解Vue2-6-新全局API：Vue-observable-吗？\"><a href=\"#了解Vue2-6-新全局API：Vue-observable-吗？\" class=\"headerlink\" title=\"了解Vue2.6+新全局API：Vue.observable()吗？\"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h2>Vue2.6+新的全局API是Vue.observable(),它的使用方式：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 准备个文件store.js - /store/store.js</span><br><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export const store = Vue.observable(&#123; count: 0 &#125;)  //定义一个变量</span><br><span class=\"line\">export const mutations = &#123;  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值</span><br><span class=\"line\">  setCount (count) &#123;</span><br><span class=\"line\">    store.count = count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>返回的对象可以直接用于<code>渲染函数</code>和<code>计算属性</code>内，并且会在发生改变时触发相应的更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;你点+-，看我能不能根据状态去动态改变&lt;/p&gt;</span><br><span class=\"line\">        &lt;label for=&quot;bookNum&quot;&gt;数量&lt;/label&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count+1)&quot;&gt;+&lt;/button&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;button @click=&quot;setCount(count-1)&quot;&gt;-&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">import &#123; store, mutations &#125; from &apos;../store/store&apos; // Vue2.6新增API Observable</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &apos;Add&apos;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return store.count //用于去渲染之前Observable中定义的变量count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    setCount: mutations.setCount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"了解Vue数据绑定原理？\"><a href=\"#了解Vue数据绑定原理？\" class=\"headerlink\" title=\"了解Vue数据绑定原理？\"></a>了解Vue数据绑定原理？</h2><p>参考Vue.js官网介绍响应式原理图，我们进行分析：</p>\n<p>这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。<br>Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。</p>\n<p>Vue在初始化组件数据时，在生命周期的<code>beforeCreate</code>与<code>created</code>钩子函数之间实现了对<code>data、props、computed、methods、events</code>以及<code>watch</code>的处理.</p>\n<ul>\n<li>initData<br>参考源码instance下的state.js文件</li>\n</ul>\n<p>initData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initData (vm: Component) &#123;  </span><br><span class=\"line\">  /*得到data数据*/</span><br><span class=\"line\">  let data = vm.$options.data</span><br><span class=\"line\">  data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; </span><br><span class=\"line\">  /*判断是否是对象*/</span><br><span class=\"line\">  if (!isPlainObject(data)) &#123;</span><br><span class=\"line\">    data = &#123;&#125;</span><br><span class=\"line\">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(&apos;data functions should return an object:\\n&apos; +&apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm)</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  // proxy data on instance</span><br><span class=\"line\">  /*遍历data对象*/</span><br><span class=\"line\">  const keys = Object.keys(data)</span><br><span class=\"line\">  const props = vm.$options.props</span><br><span class=\"line\">  let i = keys.length</span><br><span class=\"line\">  //遍历data中的数据</span><br><span class=\"line\">  while (i--) &#123;</span><br><span class=\"line\">    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class=\"line\">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(`The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +`Use prop default value instead.`,vm)</span><br><span class=\"line\">    &#125; else if (!isReserved(keys[i])) &#123;</span><br><span class=\"line\">      /*判断是否是保留字段*/</span><br><span class=\"line\">      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/</span><br><span class=\"line\">      proxy(vm, `_data`, keys[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // observe data</span><br><span class=\"line\">  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  </span><br><span class=\"line\">  observe(data, true /* asRootData */)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。</p>\n<ul>\n<li>proxy<br>接下来看一下proxy代理。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*添加代理*/</span><br><span class=\"line\">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class=\"line\">  sharedPropertyDefinition.get = function proxyGetter () &#123;</span><br><span class=\"line\">    return this[sourceKey][key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sharedPropertyDefinition.set = function proxySetter (val) &#123;</span><br><span class=\"line\">    this[sourceKey][key] = val</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。</p>\n<ul>\n<li>observe<br>参考源码文件在core文件下oberver的index.js文件中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Attempt to create an observer instance for a value,</span><br><span class=\"line\"> * returns the new observer if successfully observed,</span><br><span class=\"line\"> * or the existing observer if the value already has one.</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*</span><br><span class=\"line\"> 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class=\"line\">  /*判断是否是一个对象*/</span><br><span class=\"line\">  if (!isObject(value)) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let ob: Observer | void</span><br><span class=\"line\"></span><br><span class=\"line\">  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/</span><br><span class=\"line\">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class=\"line\">    ob = value.__ob__</span><br><span class=\"line\">  &#125; else if (</span><br><span class=\"line\"></span><br><span class=\"line\">    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/</span><br><span class=\"line\">    observerState.shouldConvert &amp;&amp;</span><br><span class=\"line\">    !isServerRendering() &amp;&amp;</span><br><span class=\"line\">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class=\"line\">    Object.isExtensible(value) &amp;&amp;</span><br><span class=\"line\">    !value._isVue</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    ob = new Observer(value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/</span><br><span class=\"line\">    ob.vmCount++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return ob</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vue的响应式数据都会有一个<strong>ob</strong>的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。</p>\n<ul>\n<li>Observer<br>Observer的作用就是遍历对象的所有属性将其进行双向绑定。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Observer class that are attached to each observed</span><br><span class=\"line\"> * object. Once attached, the observer converts target</span><br><span class=\"line\"> * object&apos;s property keys into getter/setters that</span><br><span class=\"line\"> * collect dependencies and dispatches updates.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export class  &#123;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\">  dep: Dep;</span><br><span class=\"line\">  vmCount: number; // number of vms that has this object as root $data</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (value: any) &#123;</span><br><span class=\"line\">    this.value = value</span><br><span class=\"line\">    this.dep = new Dep()</span><br><span class=\"line\">    this.vmCount = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16</span><br><span class=\"line\">    */</span><br><span class=\"line\">    def(value, &apos;__ob__&apos;, this)</span><br><span class=\"line\">    if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*</span><br><span class=\"line\">          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。</span><br><span class=\"line\">          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。</span><br><span class=\"line\">      */</span><br><span class=\"line\">      const augment = hasProto</span><br><span class=\"line\">        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/</span><br><span class=\"line\">        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/</span><br><span class=\"line\">      augment(value, arrayMethods, arrayKeys)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是数组则需要遍历数组的每一个成员进行observe*/</span><br><span class=\"line\">      this.observeArray(value)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果是对象则直接walk进行绑定*/</span><br><span class=\"line\">      this.walk(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Walk through each property and convert them into</span><br><span class=\"line\">   * getter/setters. This method should only be called when</span><br><span class=\"line\">   * value type is Object.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  walk (obj: Object) &#123;</span><br><span class=\"line\">    const keys = Object.keys(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/</span><br><span class=\"line\">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Observe a list of Array items.</span><br><span class=\"line\">   */</span><br><span class=\"line\">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组需要便利每一个成员进行observe*/</span><br><span class=\"line\">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      observe(items[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。<br>如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。<br>但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？</p>\n<p>Vue.js提供的方法是重写 <code>push、pop、shift、unshift、splice、sort、reverse</code>这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * not type checking this file because flow doesn&apos;t play well with</span><br><span class=\"line\"> * dynamically accessing methods on Array prototype</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; def &#125; from &apos;../util/index&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">/*取得原生数组的原型*/</span><br><span class=\"line\">const arrayProto = Array.prototype</span><br><span class=\"line\">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span><br><span class=\"line\">export const arrayMethods = Object.create(arrayProto)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * Intercept mutating methods and emit events</span><br><span class=\"line\"> */</span><br><span class=\"line\"> /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/</span><br><span class=\"line\">;[</span><br><span class=\"line\">  &apos;push&apos;,</span><br><span class=\"line\">  &apos;pop&apos;,</span><br><span class=\"line\">  &apos;shift&apos;,</span><br><span class=\"line\">  &apos;unshift&apos;,</span><br><span class=\"line\">  &apos;splice&apos;,</span><br><span class=\"line\">  &apos;sort&apos;,</span><br><span class=\"line\">  &apos;reverse&apos;</span><br><span class=\"line\">]</span><br><span class=\"line\">.forEach(function (method) &#123;</span><br><span class=\"line\">  // cache original method</span><br><span class=\"line\">  /*将数组的原生方法缓存起来，后面要调用*/</span><br><span class=\"line\">  const original = arrayProto[method]</span><br><span class=\"line\">  def(arrayMethods, method, function mutator () &#123;</span><br><span class=\"line\">    // avoid leaking arguments:</span><br><span class=\"line\">    // http://jsperf.com/closure-with-arguments</span><br><span class=\"line\">    let i = arguments.length</span><br><span class=\"line\">    const args = new Array(i)</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      args[i] = arguments[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    /*调用原生的数组方法*/</span><br><span class=\"line\">    const result = original.apply(this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">    /*数组新插入的元素需要重新进行observe才能响应式*/</span><br><span class=\"line\">    const ob = this.__ob__</span><br><span class=\"line\">    let inserted</span><br><span class=\"line\">    switch (method) &#123;</span><br><span class=\"line\">      case &apos;push&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;unshift&apos;:</span><br><span class=\"line\">        inserted = args</span><br><span class=\"line\">        break</span><br><span class=\"line\">      case &apos;splice&apos;:</span><br><span class=\"line\">        inserted = args.slice(2)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (inserted) ob.observeArray(inserted)</span><br><span class=\"line\">      </span><br><span class=\"line\">    // notify change</span><br><span class=\"line\">    /*dep通知所有注册的观察者进行响应式处理*/</span><br><span class=\"line\">    ob.dep.notify()</span><br><span class=\"line\">    return result</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持<strong>proto</strong>这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。</p>\n<p>如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。</p>\n<p>在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。</p>\n<p>但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。</p>\n<ul>\n<li>Watcher</li>\n</ul>\n<p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default class Watcher &#123;</span><br><span class=\"line\">  vm: Component;</span><br><span class=\"line\">  expression: string;</span><br><span class=\"line\">  cb: Function;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  deep: boolean;</span><br><span class=\"line\">  user: boolean;</span><br><span class=\"line\">  lazy: boolean;</span><br><span class=\"line\">  sync: boolean;</span><br><span class=\"line\">  dirty: boolean;</span><br><span class=\"line\">  active: boolean;</span><br><span class=\"line\">  deps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  newDeps: Array&lt;Dep&gt;;</span><br><span class=\"line\">  depIds: ISet;</span><br><span class=\"line\">  newDepIds: ISet;</span><br><span class=\"line\">  getter: Function;</span><br><span class=\"line\">  value: any;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor (</span><br><span class=\"line\">    vm: Component,</span><br><span class=\"line\">    expOrFn: string | Function,</span><br><span class=\"line\">    cb: Function,</span><br><span class=\"line\">    options?: Object</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    this.vm = vm</span><br><span class=\"line\">    /*_watchers存放订阅者实例*/</span><br><span class=\"line\">    vm._watchers.push(this)</span><br><span class=\"line\">    // options</span><br><span class=\"line\">    if (options) &#123;</span><br><span class=\"line\">      this.deep = !!options.deep</span><br><span class=\"line\">      this.user = !!options.user</span><br><span class=\"line\">      this.lazy = !!options.lazy</span><br><span class=\"line\">      this.sync = !!options.sync</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.cb = cb</span><br><span class=\"line\">    this.id = ++uid // uid for batching</span><br><span class=\"line\">    this.active = true</span><br><span class=\"line\">    this.dirty = this.lazy // for lazy watchers</span><br><span class=\"line\">    this.deps = []</span><br><span class=\"line\">    this.newDeps = []</span><br><span class=\"line\">    this.depIds = new Set()</span><br><span class=\"line\">    this.newDepIds = new Set()</span><br><span class=\"line\">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class=\"line\">      ? expOrFn.toString()</span><br><span class=\"line\">      : &apos;&apos;</span><br><span class=\"line\">    // parse expression for getter</span><br><span class=\"line\">    /*把表达式expOrFn解析成getter*/</span><br><span class=\"line\">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class=\"line\">      this.getter = expOrFn</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      this.getter = parsePath(expOrFn)</span><br><span class=\"line\">      if (!this.getter) &#123;</span><br><span class=\"line\">        this.getter = function () &#123;&#125;</span><br><span class=\"line\">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class=\"line\">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class=\"line\">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class=\"line\">          &apos;For full control, use a function instead.&apos;,</span><br><span class=\"line\">          vm</span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.value = this.lazy</span><br><span class=\"line\">      ? undefined</span><br><span class=\"line\">      : this.get()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the getter, and re-collect dependencies.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获得getter的值并且重新进行依赖收集*/</span><br><span class=\"line\">  get () &#123;</span><br><span class=\"line\">    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span><br><span class=\"line\">    pushTarget(this)</span><br><span class=\"line\">    let value</span><br><span class=\"line\">    const vm = this.vm</span><br><span class=\"line\"></span><br><span class=\"line\">    /*</span><br><span class=\"line\">      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。</span><br><span class=\"line\">      在将Dep.target设置为自生观察者实例以后，执行getter操作。</span><br><span class=\"line\">      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，</span><br><span class=\"line\">      那么在执行getter的时候就会触发a跟c两个数据的getter函数，</span><br><span class=\"line\">      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，</span><br><span class=\"line\">      将该观察者对象放入闭包中的Dep的subs中去。</span><br><span class=\"line\">    */</span><br><span class=\"line\">    if (this.user) &#123;</span><br><span class=\"line\">      try &#123;</span><br><span class=\"line\">        value = this.getter.call(vm, vm)</span><br><span class=\"line\">      &#125; catch (e) &#123;</span><br><span class=\"line\">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      value = this.getter.call(vm, vm)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // &quot;touch&quot; every property so they are all tracked as</span><br><span class=\"line\">    // dependencies for deep watching</span><br><span class=\"line\">    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span><br><span class=\"line\">    if (this.deep) &#123;</span><br><span class=\"line\">      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span><br><span class=\"line\">      traverse(value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /*将观察者实例从target栈中取出并设置给Dep.target*/</span><br><span class=\"line\">    popTarget()</span><br><span class=\"line\">    this.cleanupDeps()</span><br><span class=\"line\">    return value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Add a dependency to this directive.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*添加一个依赖关系到Deps集合中*/</span><br><span class=\"line\">  addDep (dep: Dep) &#123;</span><br><span class=\"line\">    const id = dep.id</span><br><span class=\"line\">    if (!this.newDepIds.has(id)) &#123;</span><br><span class=\"line\">      this.newDepIds.add(id)</span><br><span class=\"line\">      this.newDeps.push(dep)</span><br><span class=\"line\">      if (!this.depIds.has(id)) &#123;</span><br><span class=\"line\">        dep.addSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Clean up for dependency collection.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*清理依赖收集*/</span><br><span class=\"line\">  cleanupDeps () &#123;</span><br><span class=\"line\">    /*移除所有观察者对象*/</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      const dep = this.deps[i]</span><br><span class=\"line\">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class=\"line\">        dep.removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    let tmp = this.depIds</span><br><span class=\"line\">    this.depIds = this.newDepIds</span><br><span class=\"line\">    this.newDepIds = tmp</span><br><span class=\"line\">    this.newDepIds.clear()</span><br><span class=\"line\">    tmp = this.deps</span><br><span class=\"line\">    this.deps = this.newDeps</span><br><span class=\"line\">    this.newDeps = tmp</span><br><span class=\"line\">    this.newDeps.length = 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Subscriber interface.</span><br><span class=\"line\">   * Will be called when a dependency changes.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class=\"line\">   */</span><br><span class=\"line\">  update () &#123;</span><br><span class=\"line\">    /* istanbul ignore else */</span><br><span class=\"line\">    if (this.lazy) &#123;</span><br><span class=\"line\">      this.dirty = true</span><br><span class=\"line\">    &#125; else if (this.sync) &#123;</span><br><span class=\"line\">      /*同步则执行run直接渲染视图*/</span><br><span class=\"line\">      this.run()</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class=\"line\">      queueWatcher(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Scheduler job interface.</span><br><span class=\"line\">   * Will be called by the scheduler.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*</span><br><span class=\"line\">      调度者工作接口，将被调度者回调。</span><br><span class=\"line\">    */</span><br><span class=\"line\">  run () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      const value = this.get()</span><br><span class=\"line\">      if (</span><br><span class=\"line\">        value !== this.value ||</span><br><span class=\"line\">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class=\"line\">        // when the value is the same, because the value may</span><br><span class=\"line\">        // have mutated.</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。</span><br><span class=\"line\">        */</span><br><span class=\"line\">        isObject(value) ||</span><br><span class=\"line\">        this.deep</span><br><span class=\"line\">      ) &#123;</span><br><span class=\"line\">        // set new value</span><br><span class=\"line\">        const oldValue = this.value</span><br><span class=\"line\">        /*设置新的值*/</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        /*触发回调渲染视图*/</span><br><span class=\"line\">        if (this.user) &#123;</span><br><span class=\"line\">          try &#123;</span><br><span class=\"line\">            this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">          &#125; catch (e) &#123;</span><br><span class=\"line\">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          this.cb.call(this.vm, value, oldValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Evaluate the value of the watcher.</span><br><span class=\"line\">   * This only gets called for lazy watchers.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*获取观察者的值*/</span><br><span class=\"line\">  evaluate () &#123;</span><br><span class=\"line\">    this.value = this.get()</span><br><span class=\"line\">    this.dirty = false</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Depend on all deps collected by this watcher.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*收集该watcher的所有deps依赖*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    let i = this.deps.length</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">      this.deps[i].depend()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class=\"line\">   */</span><br><span class=\"line\">   /*将自身从所有依赖收集订阅列表删除*/</span><br><span class=\"line\">  teardown () &#123;</span><br><span class=\"line\">    if (this.active) &#123;</span><br><span class=\"line\">      // remove self from vm&apos;s watcher list</span><br><span class=\"line\">      // this is a somewhat expensive operation so we skip it</span><br><span class=\"line\">      // if the vm is being destroyed.</span><br><span class=\"line\">      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/</span><br><span class=\"line\">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class=\"line\">        remove(this.vm._watchers, this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      let i = this.deps.length</span><br><span class=\"line\">      while (i--) &#123;</span><br><span class=\"line\">        this.deps[i].removeSub(this)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      this.active = false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Dep</li>\n</ul>\n<p>来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * A dep is an observable that can have multiple</span><br><span class=\"line\"> * directives subscribing to it.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export default class Dep &#123;</span><br><span class=\"line\">  static target: ?Watcher;</span><br><span class=\"line\">  id: number;</span><br><span class=\"line\">  subs: Array&lt;Watcher&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.id = uid++</span><br><span class=\"line\">    this.subs = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*添加一个观察者对象*/</span><br><span class=\"line\">  addSub (sub: Watcher) &#123;</span><br><span class=\"line\">    this.subs.push(sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*移除一个观察者对象*/</span><br><span class=\"line\">  removeSub (sub: Watcher) &#123;</span><br><span class=\"line\">    remove(this.subs, sub)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*依赖收集，当存在Dep.target的时候添加观察者对象*/</span><br><span class=\"line\">  depend () &#123;</span><br><span class=\"line\">    if (Dep.target) &#123;</span><br><span class=\"line\">      Dep.target.addDep(this)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*通知所有订阅者*/</span><br><span class=\"line\">  notify () &#123;</span><br><span class=\"line\">    // stabilize the subscriber list first</span><br><span class=\"line\">    const subs = this.subs.slice()</span><br><span class=\"line\">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">      subs[i].update()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// the current target watcher being evaluated.</span><br><span class=\"line\">// this is globally unique because there could be only one</span><br><span class=\"line\">// watcher being evaluated at any time.</span><br><span class=\"line\">Dep.target = null</span><br><span class=\"line\">/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/</span><br></pre></td></tr></table></figure>\n<ul>\n<li>defineReactive</li>\n</ul>\n<p>接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。<br>触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Define a reactive property on an Object.</span><br><span class=\"line\"> */</span><br><span class=\"line\">export function defineReactive (</span><br><span class=\"line\">  obj: Object,</span><br><span class=\"line\">  key: string,</span><br><span class=\"line\">  val: any,</span><br><span class=\"line\">  customSetter?: Function</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">  /*在闭包中定义一个dep对象*/</span><br><span class=\"line\">  const dep = new Dep()</span><br><span class=\"line\"></span><br><span class=\"line\">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class=\"line\">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/</span><br><span class=\"line\">  // cater for pre-defined getter/setters</span><br><span class=\"line\">  const getter = property &amp;&amp; property.get</span><br><span class=\"line\">  const setter = property &amp;&amp; property.set</span><br><span class=\"line\"></span><br><span class=\"line\">  /*对象的子对象递归进行observe并返回子节点的Observer对象*/</span><br><span class=\"line\">  let childOb = observe(val)</span><br><span class=\"line\">  Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    enumerable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    get: function reactiveGetter () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*如果原本对象拥有getter方法则执行*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      if (Dep.target) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*进行依赖收集*/</span><br><span class=\"line\">        dep.depend()</span><br><span class=\"line\">        if (childOb) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span><br><span class=\"line\">          childOb.dep.depend()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (Array.isArray(value)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span><br><span class=\"line\">          dependArray(value)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: function reactiveSetter (newVal) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span><br><span class=\"line\">      const value = getter ? getter.call(obj) : val</span><br><span class=\"line\">      /* eslint-disable no-self-compare */</span><br><span class=\"line\">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class=\"line\">        return</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      /* eslint-enable no-self-compare */</span><br><span class=\"line\">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class=\"line\">        customSetter()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      if (setter) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        /*如果原本对象拥有setter方法则执行setter*/</span><br><span class=\"line\">        setter.call(obj, newVal)</span><br><span class=\"line\">      &#125; else &#123;</span><br><span class=\"line\">        val = newVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      /*新的值需要重新进行observe，保证数据响应式*/</span><br><span class=\"line\">      childOb = observe(newVal)</span><br><span class=\"line\"></span><br><span class=\"line\">      /*dep对象通知所有的观察者*/</span><br><span class=\"line\">      dep.notify()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>整篇文章主要参考链接：<a href=\"https://juejin.im/post/5c959f74f265da610c068fa8\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c959f74f265da610c068fa8</a><br>源码解析参考链接：<a href=\"https://github.com/answershuto/learnVue\" target=\"_blank\" rel=\"noopener\">https://github.com/answershuto/learnVue</a></p>\n"},{"title":"前端面试题汇总","date":"2019-09-19T12:53:29.000Z","_content":"\n##### 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n##### 浏览器工作原理\n##### 浏览器内核\n##### 常见的浏览器内核有哪些？\n##### cookies，sessionStorage 和 localStorage 的区别？\n##### 页面访问cookie的限制条件\n##### 实现浏览器内多个标签页之间的通信\n##### 页面可见性（Page Visibility API） 可以有哪些用途\n##### 网页验证码是做什么的，是为了解决什么安全问题\n##### 为什么利用多个域名来存储网站资源\n##### 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n##### 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n##### 前端性能优化\n##### webSocket如何兼容低浏览器\n##### web开发中会话跟踪的方法\n##### HTTP method\n##### HTTP状态码及其含义\n##### 什么是同源：协议相同 域名相同 端口相同\n##### 爬虫和反爬虫的理解\n\n答案参考链接：https://lujinggirl.github.io/2019/09/02/webTitle/","source":"_posts/web.md","raw":"---\ntitle: 前端面试题汇总\ndate: 2019-09-19 20:53:29\ntags: 前端面试题\n---\n\n##### 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n##### 浏览器工作原理\n##### 浏览器内核\n##### 常见的浏览器内核有哪些？\n##### cookies，sessionStorage 和 localStorage 的区别？\n##### 页面访问cookie的限制条件\n##### 实现浏览器内多个标签页之间的通信\n##### 页面可见性（Page Visibility API） 可以有哪些用途\n##### 网页验证码是做什么的，是为了解决什么安全问题\n##### 为什么利用多个域名来存储网站资源\n##### 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n##### 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n##### 前端性能优化\n##### webSocket如何兼容低浏览器\n##### web开发中会话跟踪的方法\n##### HTTP method\n##### HTTP状态码及其含义\n##### 什么是同源：协议相同 域名相同 端口相同\n##### 爬虫和反爬虫的理解\n\n答案参考链接：https://lujinggirl.github.io/2019/09/02/webTitle/","slug":"web","published":1,"updated":"2019-12-14T10:29:55.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjsd003078p3smjec5v9","content":"<h5 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h5><h5 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h5><h5 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h5><h5 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h5><h5 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h5><h5 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h5><h5 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h5><h5 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h5><h5 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h5><h5 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h5><h5 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h5><h5 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h5><h5 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h5><h5 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h5><h5 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h5><h5 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h5><h5 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h5><h5 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h5><h5 id=\"爬虫和反爬虫的理解\"><a href=\"#爬虫和反爬虫的理解\" class=\"headerlink\" title=\"爬虫和反爬虫的理解\"></a>爬虫和反爬虫的理解</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/02/webTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/02/webTitle/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h5><h5 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h5><h5 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h5><h5 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h5><h5 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h5><h5 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h5><h5 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h5><h5 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h5><h5 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h5><h5 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h5><h5 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h5><h5 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h5><h5 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h5><h5 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h5><h5 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h5><h5 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h5><h5 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h5><h5 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h5><h5 id=\"爬虫和反爬虫的理解\"><a href=\"#爬虫和反爬虫的理解\" class=\"headerlink\" title=\"爬虫和反爬虫的理解\"></a>爬虫和反爬虫的理解</h5><p>答案参考链接：<a href=\"https://lujinggirl.github.io/2019/09/02/webTitle/\" target=\"_blank\" rel=\"noopener\">https://lujinggirl.github.io/2019/09/02/webTitle/</a></p>\n"},{"title":"vue相关面试题","date":"2019-09-03T02:10:37.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-03 10:10:37\n\n### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n* Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递\n###### 缺点:\n使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护\n#####1.  父组件使用provide，子组件使用inject\n* 通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等\n```\n1.provide就相当于加强版父组件prop\n2.inject就相当于加强版子组件的props \n```\n// 示例代码\n```\n// 父组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'father',\n  // 传入对象写法\n  provide: {\n    name: 'bar'\n  }\n  // 函数写法\n\tprovide () {\n    return {\n      name: 'foo'\n    }\n  }\n}\n</script>\n\n// 孙子组件或者深层次组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'Grandson',\n\tinject: [name]\n}\n</script>\n```\n\n###### 缺点\n在任意层级都能访问，导致数据变化追踪比较困难。\n\n##### 2.通过$attrs传递属性\nvue api解释说明：\n```\nvm.$attrs和inheritAttrs\n2.4.0 新增\n类型：{ [key: string]: string }\n只读\n详细：\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\n```\n细节使用示例参考链接：https://www.jianshu.com/p/ce8ca875c337\n\n##### 3.通过$listeners传递事件\n```\nvm.$listeners\n2.4.0 新增\n类型：{ [key: string]: Function | Array<Function> }\n只读\n详细：\n包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。\n```\n##### 4.Vue2.6+新全局API：Vue.observable()\n\n### 子组件访问父组件数据（除了props）\n* 使用$parent属性\n* 通过$attrs传递属性\n* Vue2.6+新全局API：Vue.observable()\n","source":"_posts/vueTitle.md","raw":"---\ntitle: vue相关面试题\ndate: 2019-09-03 10:10:37\ntags: vue\n---\n\nAuthor: Echo\nTime: 2019-09-03 10:10:37\n\n### 孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\n* Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递\n###### 缺点:\n使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护\n#####1.  父组件使用provide，子组件使用inject\n* 通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等\n```\n1.provide就相当于加强版父组件prop\n2.inject就相当于加强版子组件的props \n```\n// 示例代码\n```\n// 父组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'father',\n  // 传入对象写法\n  provide: {\n    name: 'bar'\n  }\n  // 函数写法\n\tprovide () {\n    return {\n      name: 'foo'\n    }\n  }\n}\n</script>\n\n// 孙子组件或者深层次组件\n<template>\n\t<div>\n\t\t{{name}}\n\t</div>\n</template>\n \n<script>\nexport default {\n\tname: 'Grandson',\n\tinject: [name]\n}\n</script>\n```\n\n###### 缺点\n在任意层级都能访问，导致数据变化追踪比较困难。\n\n##### 2.通过$attrs传递属性\nvue api解释说明：\n```\nvm.$attrs和inheritAttrs\n2.4.0 新增\n类型：{ [key: string]: string }\n只读\n详细：\n包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"$attrs\" 传入内部组件——在创建高级别的组件时非常有用。\n```\n细节使用示例参考链接：https://www.jianshu.com/p/ce8ca875c337\n\n##### 3.通过$listeners传递事件\n```\nvm.$listeners\n2.4.0 新增\n类型：{ [key: string]: Function | Array<Function> }\n只读\n详细：\n包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件——在创建更高层次的组件时非常有用。\n```\n##### 4.Vue2.6+新全局API：Vue.observable()\n\n### 子组件访问父组件数据（除了props）\n* 使用$parent属性\n* 通过$attrs传递属性\n* Vue2.6+新全局API：Vue.observable()\n","slug":"vueTitle","published":1,"updated":"2019-12-04T12:50:48.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjsf003378p3b2q2wjgb","content":"<p>Author: Echo<br>Time: 2019-09-03 10:10:37</p>\n<h3 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h3><ul>\n<li>Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h6>使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护<br>#####1.  父组件使用provide，子组件使用inject</li>\n<li>通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.provide就相当于加强版父组件prop</span><br><span class=\"line\">2.inject就相当于加强版子组件的props</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>// 示例代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;father&apos;,</span><br><span class=\"line\">  // 传入对象写法</span><br><span class=\"line\">  provide: &#123;</span><br><span class=\"line\">    name: &apos;bar&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 函数写法</span><br><span class=\"line\">\tprovide () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name: &apos;foo&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 孙子组件或者深层次组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;Grandson&apos;,</span><br><span class=\"line\">\tinject: [name]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>在任意层级都能访问，导致数据变化追踪比较困难。</p>\n<h5 id=\"2-通过-attrs传递属性\"><a href=\"#2-通过-attrs传递属性\" class=\"headerlink\" title=\"2.通过$attrs传递属性\"></a>2.通过$attrs传递属性</h5><p>vue api解释说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$attrs和inheritAttrs</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: string &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</span><br></pre></td></tr></table></figure></p>\n<p>细节使用示例参考链接：<a href=\"https://www.jianshu.com/p/ce8ca875c337\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ce8ca875c337</a></p>\n<h5 id=\"3-通过-listeners传递事件\"><a href=\"#3-通过-listeners传递事件\" class=\"headerlink\" title=\"3.通过$listeners传递事件\"></a>3.通过$listeners传递事件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$listeners</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: Function | Array&lt;Function&gt; &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-Vue2-6-新全局API：Vue-observable\"><a href=\"#4-Vue2-6-新全局API：Vue-observable\" class=\"headerlink\" title=\"4.Vue2.6+新全局API：Vue.observable()\"></a>4.Vue2.6+新全局API：Vue.observable()</h5><h3 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h3><ul>\n<li>使用$parent属性</li>\n<li>通过$attrs传递属性</li>\n<li>Vue2.6+新全局API：Vue.observable()</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-03 10:10:37</p>\n<h3 id=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"><a href=\"#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\" class=\"headerlink\" title=\"孙子组件或更深层次的组件通信（除了props和vuex的其他用法）\"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h3><ul>\n<li>Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递<h6 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h6>使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护<br>#####1.  父组件使用provide，子组件使用inject</li>\n<li>通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.provide就相当于加强版父组件prop</span><br><span class=\"line\">2.inject就相当于加强版子组件的props</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>// 示例代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;father&apos;,</span><br><span class=\"line\">  // 传入对象写法</span><br><span class=\"line\">  provide: &#123;</span><br><span class=\"line\">    name: &apos;bar&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 函数写法</span><br><span class=\"line\">\tprovide () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      name: &apos;foo&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 孙子组件或者深层次组件</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;div&gt;</span><br><span class=\"line\">\t\t&#123;&#123;name&#125;&#125;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">\tname: &apos;Grandson&apos;,</span><br><span class=\"line\">\tinject: [name]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<h6 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h6><p>在任意层级都能访问，导致数据变化追踪比较困难。</p>\n<h5 id=\"2-通过-attrs传递属性\"><a href=\"#2-通过-attrs传递属性\" class=\"headerlink\" title=\"2.通过$attrs传递属性\"></a>2.通过$attrs传递属性</h5><p>vue api解释说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$attrs和inheritAttrs</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: string &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</span><br></pre></td></tr></table></figure></p>\n<p>细节使用示例参考链接：<a href=\"https://www.jianshu.com/p/ce8ca875c337\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/ce8ca875c337</a></p>\n<h5 id=\"3-通过-listeners传递事件\"><a href=\"#3-通过-listeners传递事件\" class=\"headerlink\" title=\"3.通过$listeners传递事件\"></a>3.通过$listeners传递事件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.$listeners</span><br><span class=\"line\">2.4.0 新增</span><br><span class=\"line\">类型：&#123; [key: string]: Function | Array&lt;Function&gt; &#125;</span><br><span class=\"line\">只读</span><br><span class=\"line\">详细：</span><br><span class=\"line\">包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-Vue2-6-新全局API：Vue-observable\"><a href=\"#4-Vue2-6-新全局API：Vue-observable\" class=\"headerlink\" title=\"4.Vue2.6+新全局API：Vue.observable()\"></a>4.Vue2.6+新全局API：Vue.observable()</h5><h3 id=\"子组件访问父组件数据（除了props）\"><a href=\"#子组件访问父组件数据（除了props）\" class=\"headerlink\" title=\"子组件访问父组件数据（除了props）\"></a>子组件访问父组件数据（除了props）</h3><ul>\n<li>使用$parent属性</li>\n<li>通过$attrs传递属性</li>\n<li>Vue2.6+新全局API：Vue.observable()</li>\n</ul>\n"},{"title":"前端面试题整理","date":"2019-09-02T02:42:59.000Z","_content":" \nAuthor: Echo\nTime: 2019-09-02 10:42:59\n\n## 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n\n1.输入域名地址\n2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；\n3.与WEB服务器建立TCP连接；\n4.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）\n5.浏览器跟踪重定向地址\n6.服务器处理请求\n7.服务器返回一个HTTP响应\n8.浏览器显示 HTML\n9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）\n10.浏览器发送异步请求\n\n```\nDNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。\nTCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。\n```\n\n## 浏览器工作原理\n\n1. `用户界面` － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。\n\n2. `浏览器引擎` － 用来查询及操作渲染引擎的接口。\n\n3. `渲染引擎` － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。\n\n4. `网络` － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。\n\n5. `UI后端` － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。\n\n6. `JS解释器` － 用来解释执行JS代码。\n\n7. `数据存储` － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术\n![image](https://pic.xiaohuochai.site/blog/browserRender1.png)\n\n\n参考链接:https://www.cnblogs.com/xiaohuochai/p/9174471.html\n\n## 浏览器内核\n\n主要分成两部分:`渲染引擎`(layout engineer或Rendering Engine)和`JS引擎`。\n\n`渲染引擎`:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\n`JS引擎`:解析和执行javascript来实现网页的动态效果。\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n\n## 常见的浏览器内核有哪些？\n\nTrident内核:IE，360.... (微软开发的一种排版引擎)\nGecko内核:Firefox\nPresto内核:Opera(已经废弃了)\nBlink内核:Opera；\nWebkit内核:Safari，Chrome。\n##  cookies，sessionStorage 和 localStorage 的区别？\n`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。\n`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。\n\n##### 存储大小:\n* cookie数据大小不能超过4k。\n* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。\n##### 存储时间:\n* localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;\n* sessionStorage 数据在当前浏览器窗口关闭后自动删除.\n* cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n```\n// 存储内容类型: \nsessionStorage和localStorage只能存储字符串类型\n// 获取方式:\nlocalStorage:window.localStorage;；sessionStorage:window.sessionStorage;\n// WebStorage提供了一些方法，数据操作比cookie方便；\nsetItem (key, value) ——  保存数据，以键值对的方式储存信息。\ngetItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。\nremoveItem (key) ——  删除单个数据，根据键值移除对应的信息。\nclear () ——  删除所有的数据\nkey (index) —— 获取某个索引的key\n// cookie需要自己封装接口setCookie. getCookit\n```\n\n## 页面访问cookie的限制条件\n跨域问题，设置了HttpOnly\n\n参考链接:https://www.cnblogs.com/hujunzheng/p/5744755.html\n\n## 实现浏览器内多个标签页之间的通信\n\n* localstorge\nlocalstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。\n```\n// a:click\n$(\"#btn\").click(function(){  \n  var name=$(\"#name\").val();  \n  localStorage.setItem(\"name\", name); \n}); \n\n// b:watch\nwindow.addEventListener(\"storage\", function(event){   console.log(event.key + \"=\" + event.newValue);  \n}); \n```\n* cookie+setInterval\n将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息\n\n* websocket协议\n1.首先我们得了解websocket是什么？\n它是一种网络通信协议\n2.为什么会用到websocket?\n因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。\n但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。\n轮询:每隔一段时间，就发出一个询问.\n因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.\n* html5浏览器的新特性SharedWorker\n\n参考链接:https://segmentfault.com/a/1190000018354650\n\n## 页面可见性（Page Visibility API） 可以有哪些用途\n通过 visibilityState 的值检测页面\n* 当前是否可见\n* 打开网页的时间\n* 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等\n##  网页验证码是做什么的，是为了解决什么安全问题\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n##  为什么利用多个域名来存储网站资源\n1、CDN缓存更方便\n\n2、突破浏览器并发限制\n\n3、节约cookie带宽\n\n4、节约主域名的连接数，优化页面响应速度\n\n5、防止不必要的安全问题\n\n```\nCDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源\n// 突破浏览器并发限制\n同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。\n\n```\n\n## 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n\n* 图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n* 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n* 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n* 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n## 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n\n* 语义化html标签\n\n* 合理的title，description,keywords\n\n* 主要html代码放在前面\n\n* 少用iframe，搜索引擎不会抓取iframe中的内容\n\n* 图片加上Alt\n\n参考链接(了解seo): https://blog.csdn.net/jnshu_it/article/details/80029988\n\n## 前端性能优化\n\n###### 一、减少请求资源大小或者次数　\n1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）\n　　原因:主要是为了减少http请求次数以及减少请求资源的大小\n　　打包工具:\n　　webpack\n　　gulp\n　　grunt\n.　　....\n2、尽量所使用的字体图标或者SVG图标来代替传统png图\n　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快\n\n3、采用图片的懒加载（延迟加载）\n　　目的为了，减少页面第一次加载过程中http的请求次数\n　　具体步骤:\n　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图\n　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息\n\n4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。\n　　避免引入第三方大量的库。而自己却只是用里面的一个小功能\n\n5、使用雪碧图或者是说图片精灵\n　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用\n　　图片定位来讲小图展现在页面中（background-position:百分比，数值）\n\n6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie\n\n7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势\n　　目的:是数据处理方便，资源偏小\n\n8、前端与后端协商，合理使用keep-alive\n\n9、前端与服务器协商，使用响应资源的压缩\n\n10、避免使用iframe\n　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源\n\n11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个\n缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据\n时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）\n\n二、代码优化相关\n1、在js中尽量减少闭包的使用\n　　原因:使用闭包后，闭包所在的上下文不会被释放\n\n2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）\n　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）\n\n3、在js中避免嵌套循环和\"死循环\"(一旦遇到死循环，浏览器就会直接卡掉)\n\n4、把css放在body上，把js放在body下面\n　　让其先加载css（注意:这里关于优化没有多大关系）\n\n5、减少css表达式的使用\n\n6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象\n\n7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。\n\n9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上\n\n10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作\n\n11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画\n　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout\n　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间\n　　缩短\n\n12、尽量减少使用递归，避免死递归。\n　　解决:建议使用尾递归\n\n13、基于script标签下载js文件时，可以使用defer或者async来异步加载\n\n14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。\n\n15、减少Flash的使用\n\n三、存储\n\n1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs\n\n2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，\n　　避免向后台请求数据或者说在离线状态下做一些数据展示。\n\n四、其他优化\n\n\n1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢\n　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的\n　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示\n　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数\n\n3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）\n　　解决方法:只需要将音视频的`preload=none`即可。\n　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源\n\n## webSocket如何兼容低浏览器\n\n* 基于长轮询的 XHR\n* Adobe Flash Socket\n* ActiveX HTMLFile (IE)\n* 基于 multipart 编码发送 XHR\n参考链接:https://www.cnblogs.com/pengc/p/8718380.html\n\n## web开发中会话跟踪的方法\n1. 隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。\n2. URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。\n3. Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。\n4. Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话\n5. IP地址\n\n## HTTP method\n一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。\n* GET是最常用的方法，通常用于请求服务器发送某个资源。\n* HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。\n* PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。\n* POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。\n* TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。\n* OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。\n* DELETE 请求服务器删除请求 URL 指定的资源\n\n## HTTP状态码及其含义\n\n| 状态码        | 类别    |  原因短语  |\n| --------   | -----:  | :----: |\n| 1XX        | Information（信息性状态码）      |   接收的请求正在处理    |\n| 2XX        | Success（成功状态码）      |   请求正常处理完毕    |\n| 3XX        | Redirection（重定向状态码）      |   需要进行附加的操作以完成请求    |\n| 4XX        | Client Error（客户端错误状态码）      |   服务器无法处理请求    |\n| 5XX        | Server Error（服务端错误状态码）      |   服务器处理请求出错    |\n\n* 204\t 服务器成功处理，但未返回内容。\n* 304\tNot Modified 未修改。\t所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n* 400\tBad Request\t客户端请求的语法错误，服务器无法理解\n* 403\tForbidden\t服务器理解请求客户端的请求，但是拒绝执行此请求\n* 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n## 什么是同源：协议相同 域名相同 端口相同\n\n同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。\n\n如果非同源，共有三种行为受到限制\n1.Cookie、LocalStorage 和 IndexDB 无法读取。\n2.DOM 无法获得。\n3.AJAX 请求不能发送。\n\n## 爬虫和反爬虫的理解\n\n参考链接： https://www.cnblogs.com/tulintao/p/11614577.html\n\n* `爬虫`：为了获得任何信息而采用任何手段对某一网站进行`攻击`行为，之所以成为攻击行为，因为对网站的爬虫过程会对网站造成不同程度的影响。\n  爬虫与手动点击访问网站数据的主要区别在于这个是批量操作。\n* `反爬虫`： 网站为了维护自己的核心安全而采取的抑制爬虫的手段。\n\n常见的反爬虫机制：\n1. 基于User-Agent反爬\n* 思想： 服务器后台访问的User-Agent进行同籍，单位时间内同一个User-Agent访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。\n* 解决： \n 方案一：\n   将常见的User-Agent封装到一个文件中，别人总结好的常用的User-Agent链接：https://www.cnblogs.com/zrmw/p/9332801.html\n   在爬取的过程中首先导入这个文件，然后随机选择这里面的某一个User-Agent\n 方案二：\n   在python中使用第三方类库：fake_useragent ，生成随机的User-Agent\n2. 基于IP反爬 \n* 思想：后端服务器对访问进行统计，单位时间内同一个IP访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。\n* 解决\n  使用不同的IP进行访问，设置一定的访问停滞，random.sleep(3)\n3. 动态页面抓包 \n\n\n----\n// 下面的还没有看\n关于建站安全防护\n\n要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。\n\nXSS概念:\n\n译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。\nXSS预防:\n\n关键cookie字段设置httpOnly\n输入检查,特殊字符 < > / &等,对其进行转义后存储\nCSRF概念：\n\n本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。\nCSRF 预防：\n\n使用验证码，更高级用图灵测试\nSQL概念：\n\n通常没有任何过滤，直接把参数存放到了SQL语句当中\nSQL预防：\n\n根本上防止SQL注入的方法，就是参数化查询或者做词法分析。\nDDOS概念：\n\n利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。\nDDOS预防：用软硬件结合的方式来防御是最有效的\n25.对前端工程化的理解\n\n1.开发规范\n2.模块化开发\n3.组件化开发\n4.组件仓库\n5.性能优化\n6.项目部署\n7.开发流程\n8.开发工具\n26.AMD和CMD是什么？它们的区别有哪些？\n\nAMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。\n\n27.MVC BFC\n\nmvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。\n\nBFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。\n\n28.你如何对网站的文件和资源进行优化？\n\n期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。\n29.如果网页内容需要支持多语言，你会怎么做？\n\n1.应用字符集的选择，选择UTF-8编码\n2.语言书写习惯&导航结构\n3.数据库驱动型网站\n30.如果设计中使用了非标准的字体，你该如何去实现？\n\n所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。\n方法：\n用图片代替\nweb fonts在线字库，如Google Webfonts，Typekit等等;http://www.chinaz.com/free/20…；\n@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)\n31.如何自学一门新编程语言\n\n(1)了解背景知识：历史、现状、特点、应用领域、发展趋势\n(2)搭建开发环境，编写HelloWorld\n(3)声明变量和常量\n(4)数据类型\n(5)运算符\n(6)逻辑结构\n(7)通用小程序\n(8)函数和对象\n(9)第三方库、组件、框架\n(10)实用项目\n32.什么是哈希表？\n\n散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n\n33.静态网页和动态网页区别：\n\n静态: 网页内容任何人在任何时间访问都是不变的\n\n动态: 网页内容不同人在不同时间访问可能是不同的\n\n34.SQL语句的分类\n\nDDL:数据定义语句 CREATE/DROP/ALTER…\nDCL:数据控制语句 GRANT…\nDML:操作操作语句 INSERT/UPDATE/DELETE\nDQL:查询语句 SELECT\n35.什么是弹性布局？\n\n解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。\n\n设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!\n\ndisplay:flex; 属性align-self 定义子元素的位置。\n\n36.编写响应式？\n\n1.声明viewport元标签\n2.使用流式布局\n3.所有容器使用相对尺寸，不用绝对尺寸\n4.（最重要原则）使用CSS3 Media Query技术\n37.常见的浏览器兼容问题？\n\n1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}\n2.图片默认有间距使用float属性为img布局\n3.居中问题（而FF默认为左对齐）margin: 0 auto;\n4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、\n5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀\n38.H5新特性：\n\n(1)Canvas绘图\n(2)SVG绘图\n(3)地理定位\n(4)Web Worker\nweb worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。\n(5)Web Storage\n1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）\n2.（兼容性差,数据8MB,操作简单）sessionStorage\n3.localStorage\n(6)Web Socket\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n39.C3新特性：\n\n1.复杂的选择器\n2.弹性布局\n3.动画\n40.什么是typescript\n\n1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。\n41.三大框架的区别：\n\nAngular带有比较强的排它性的\nReact主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。\nVue 渐进式的\n42.spa应用\n\n优点：用户体验好 、良好的前后端分离。\n\n缺点：\n1.不利于SEO。\n2.初次加载耗时相对增多。\n3.导航不可用，如果一定要导航需要自行实现前进、后退。\n43.什么是模块化编程？\n\n每个模块内部，module变量代表当前模块。\n\n这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。\n\n44.性能优化？\n\n1.使用 CDN\n2.图片懒加载\n3.使用外部 JavaScript 和 CSS\n4.压缩 JavaScript 、 CSS 、字体、图片等\n5.优化 CSS Sprite\n6.减少 HTTP 请求数\n7.减少 DNS 查询\n8.减少 DOM 元素数量\n9.减少 DOM 操作\n10.把脚本放在页面底部\n可以看看这篇文章 关于前端优化的一些方案\n45.什么是HTTP协议：\n\nHTTP是一个客户端和服务器端请求和应答的标准（TCP）。\nHTTP1.1 和 2.0协议的区别：\nHTTP1.1不支持 header 数据的压缩，而2.0支持","source":"_posts/webTitle.md","raw":"---\ntitle: 前端面试题整理\ndate: 2019-09-02 10:42:59\ntags: web\n---\n \nAuthor: Echo\nTime: 2019-09-02 10:42:59\n\n## 页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\n\n1.输入域名地址\n2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；\n3.与WEB服务器建立TCP连接；\n4.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）\n5.浏览器跟踪重定向地址\n6.服务器处理请求\n7.服务器返回一个HTTP响应\n8.浏览器显示 HTML\n9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）\n10.浏览器发送异步请求\n\n```\nDNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。\nTCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。\n```\n\n## 浏览器工作原理\n\n1. `用户界面` － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。\n\n2. `浏览器引擎` － 用来查询及操作渲染引擎的接口。\n\n3. `渲染引擎` － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。\n\n4. `网络` － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。\n\n5. `UI后端` － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。\n\n6. `JS解释器` － 用来解释执行JS代码。\n\n7. `数据存储` － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术\n![image](https://pic.xiaohuochai.site/blog/browserRender1.png)\n\n\n参考链接:https://www.cnblogs.com/xiaohuochai/p/9174471.html\n\n## 浏览器内核\n\n主要分成两部分:`渲染引擎`(layout engineer或Rendering Engine)和`JS引擎`。\n\n`渲染引擎`:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\n`JS引擎`:解析和执行javascript来实现网页的动态效果。\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n\n## 常见的浏览器内核有哪些？\n\nTrident内核:IE，360.... (微软开发的一种排版引擎)\nGecko内核:Firefox\nPresto内核:Opera(已经废弃了)\nBlink内核:Opera；\nWebkit内核:Safari，Chrome。\n##  cookies，sessionStorage 和 localStorage 的区别？\n`cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。\n`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。\n\n##### 存储大小:\n* cookie数据大小不能超过4k。\n* sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。\n##### 存储时间:\n* localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;\n* sessionStorage 数据在当前浏览器窗口关闭后自动删除.\n* cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n```\n// 存储内容类型: \nsessionStorage和localStorage只能存储字符串类型\n// 获取方式:\nlocalStorage:window.localStorage;；sessionStorage:window.sessionStorage;\n// WebStorage提供了一些方法，数据操作比cookie方便；\nsetItem (key, value) ——  保存数据，以键值对的方式储存信息。\ngetItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。\nremoveItem (key) ——  删除单个数据，根据键值移除对应的信息。\nclear () ——  删除所有的数据\nkey (index) —— 获取某个索引的key\n// cookie需要自己封装接口setCookie. getCookit\n```\n\n## 页面访问cookie的限制条件\n跨域问题，设置了HttpOnly\n\n参考链接:https://www.cnblogs.com/hujunzheng/p/5744755.html\n\n## 实现浏览器内多个标签页之间的通信\n\n* localstorge\nlocalstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。\n```\n// a:click\n$(\"#btn\").click(function(){  \n  var name=$(\"#name\").val();  \n  localStorage.setItem(\"name\", name); \n}); \n\n// b:watch\nwindow.addEventListener(\"storage\", function(event){   console.log(event.key + \"=\" + event.newValue);  \n}); \n```\n* cookie+setInterval\n将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息\n\n* websocket协议\n1.首先我们得了解websocket是什么？\n它是一种网络通信协议\n2.为什么会用到websocket?\n因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。\n但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。\n轮询:每隔一段时间，就发出一个询问.\n因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.\n* html5浏览器的新特性SharedWorker\n\n参考链接:https://segmentfault.com/a/1190000018354650\n\n## 页面可见性（Page Visibility API） 可以有哪些用途\n通过 visibilityState 的值检测页面\n* 当前是否可见\n* 打开网页的时间\n* 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等\n##  网页验证码是做什么的，是为了解决什么安全问题\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；\n有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n##  为什么利用多个域名来存储网站资源\n1、CDN缓存更方便\n\n2、突破浏览器并发限制\n\n3、节约cookie带宽\n\n4、节约主域名的连接数，优化页面响应速度\n\n5、防止不必要的安全问题\n\n```\nCDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源\n// 突破浏览器并发限制\n同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。\n\n```\n\n## 一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\n\n* 图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n* 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n* 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n* 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n## 以前端角度出发做好SEO（搜索引擎）需要考虑什么？\n\n* 语义化html标签\n\n* 合理的title，description,keywords\n\n* 主要html代码放在前面\n\n* 少用iframe，搜索引擎不会抓取iframe中的内容\n\n* 图片加上Alt\n\n参考链接(了解seo): https://blog.csdn.net/jnshu_it/article/details/80029988\n\n## 前端性能优化\n\n###### 一、减少请求资源大小或者次数　\n1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）\n　　原因:主要是为了减少http请求次数以及减少请求资源的大小\n　　打包工具:\n　　webpack\n　　gulp\n　　grunt\n.　　....\n2、尽量所使用的字体图标或者SVG图标来代替传统png图\n　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快\n\n3、采用图片的懒加载（延迟加载）\n　　目的为了，减少页面第一次加载过程中http的请求次数\n　　具体步骤:\n　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图\n　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息\n\n4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。\n　　避免引入第三方大量的库。而自己却只是用里面的一个小功能\n\n5、使用雪碧图或者是说图片精灵\n　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用\n　　图片定位来讲小图展现在页面中（background-position:百分比，数值）\n\n6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie\n\n7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势\n　　目的:是数据处理方便，资源偏小\n\n8、前端与后端协商，合理使用keep-alive\n\n9、前端与服务器协商，使用响应资源的压缩\n\n10、避免使用iframe\n　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源\n\n11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个\n缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据\n时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）\n\n二、代码优化相关\n1、在js中尽量减少闭包的使用\n　　原因:使用闭包后，闭包所在的上下文不会被释放\n\n2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）\n　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）\n\n3、在js中避免嵌套循环和\"死循环\"(一旦遇到死循环，浏览器就会直接卡掉)\n\n4、把css放在body上，把js放在body下面\n　　让其先加载css（注意:这里关于优化没有多大关系）\n\n5、减少css表达式的使用\n\n6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象\n\n7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。\n\n9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上\n\n10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作\n\n11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画\n　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout\n　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间\n　　缩短\n\n12、尽量减少使用递归，避免死递归。\n　　解决:建议使用尾递归\n\n13、基于script标签下载js文件时，可以使用defer或者async来异步加载\n\n14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。\n\n15、减少Flash的使用\n\n三、存储\n\n1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs\n\n2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，\n　　避免向后台请求数据或者说在离线状态下做一些数据展示。\n\n四、其他优化\n\n\n1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）\n　　注意:图层不要过多设置，否则不但效果没有达到反而更差了\n\n2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢\n　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的\n　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示\n　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数\n\n3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）\n　　解决方法:只需要将音视频的`preload=none`即可。\n　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源\n\n## webSocket如何兼容低浏览器\n\n* 基于长轮询的 XHR\n* Adobe Flash Socket\n* ActiveX HTMLFile (IE)\n* 基于 multipart 编码发送 XHR\n参考链接:https://www.cnblogs.com/pengc/p/8718380.html\n\n## web开发中会话跟踪的方法\n1. 隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。\n2. URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。\n3. Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。\n4. Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话\n5. IP地址\n\n## HTTP method\n一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。\n* GET是最常用的方法，通常用于请求服务器发送某个资源。\n* HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。\n* PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。\n* POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。\n* TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。\n* OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。\n* DELETE 请求服务器删除请求 URL 指定的资源\n\n## HTTP状态码及其含义\n\n| 状态码        | 类别    |  原因短语  |\n| --------   | -----:  | :----: |\n| 1XX        | Information（信息性状态码）      |   接收的请求正在处理    |\n| 2XX        | Success（成功状态码）      |   请求正常处理完毕    |\n| 3XX        | Redirection（重定向状态码）      |   需要进行附加的操作以完成请求    |\n| 4XX        | Client Error（客户端错误状态码）      |   服务器无法处理请求    |\n| 5XX        | Server Error（服务端错误状态码）      |   服务器处理请求出错    |\n\n* 204\t 服务器成功处理，但未返回内容。\n* 304\tNot Modified 未修改。\t所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源\n* 400\tBad Request\t客户端请求的语法错误，服务器无法理解\n* 403\tForbidden\t服务器理解请求客户端的请求，但是拒绝执行此请求\n* 404\tNot Found\t服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面\n## 什么是同源：协议相同 域名相同 端口相同\n\n同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。\n\n如果非同源，共有三种行为受到限制\n1.Cookie、LocalStorage 和 IndexDB 无法读取。\n2.DOM 无法获得。\n3.AJAX 请求不能发送。\n\n## 爬虫和反爬虫的理解\n\n参考链接： https://www.cnblogs.com/tulintao/p/11614577.html\n\n* `爬虫`：为了获得任何信息而采用任何手段对某一网站进行`攻击`行为，之所以成为攻击行为，因为对网站的爬虫过程会对网站造成不同程度的影响。\n  爬虫与手动点击访问网站数据的主要区别在于这个是批量操作。\n* `反爬虫`： 网站为了维护自己的核心安全而采取的抑制爬虫的手段。\n\n常见的反爬虫机制：\n1. 基于User-Agent反爬\n* 思想： 服务器后台访问的User-Agent进行同籍，单位时间内同一个User-Agent访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。\n* 解决： \n 方案一：\n   将常见的User-Agent封装到一个文件中，别人总结好的常用的User-Agent链接：https://www.cnblogs.com/zrmw/p/9332801.html\n   在爬取的过程中首先导入这个文件，然后随机选择这里面的某一个User-Agent\n 方案二：\n   在python中使用第三方类库：fake_useragent ，生成随机的User-Agent\n2. 基于IP反爬 \n* 思想：后端服务器对访问进行统计，单位时间内同一个IP访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。\n* 解决\n  使用不同的IP进行访问，设置一定的访问停滞，random.sleep(3)\n3. 动态页面抓包 \n\n\n----\n// 下面的还没有看\n关于建站安全防护\n\n要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。\n\nXSS概念:\n\n译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。\nXSS预防:\n\n关键cookie字段设置httpOnly\n输入检查,特殊字符 < > / &等,对其进行转义后存储\nCSRF概念：\n\n本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。\nCSRF 预防：\n\n使用验证码，更高级用图灵测试\nSQL概念：\n\n通常没有任何过滤，直接把参数存放到了SQL语句当中\nSQL预防：\n\n根本上防止SQL注入的方法，就是参数化查询或者做词法分析。\nDDOS概念：\n\n利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。\nDDOS预防：用软硬件结合的方式来防御是最有效的\n25.对前端工程化的理解\n\n1.开发规范\n2.模块化开发\n3.组件化开发\n4.组件仓库\n5.性能优化\n6.项目部署\n7.开发流程\n8.开发工具\n26.AMD和CMD是什么？它们的区别有哪些？\n\nAMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。\n\n27.MVC BFC\n\nmvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。\n\nBFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。\n\n28.你如何对网站的文件和资源进行优化？\n\n期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。\n29.如果网页内容需要支持多语言，你会怎么做？\n\n1.应用字符集的选择，选择UTF-8编码\n2.语言书写习惯&导航结构\n3.数据库驱动型网站\n30.如果设计中使用了非标准的字体，你该如何去实现？\n\n所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。\n方法：\n用图片代替\nweb fonts在线字库，如Google Webfonts，Typekit等等;http://www.chinaz.com/free/20…；\n@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)\n31.如何自学一门新编程语言\n\n(1)了解背景知识：历史、现状、特点、应用领域、发展趋势\n(2)搭建开发环境，编写HelloWorld\n(3)声明变量和常量\n(4)数据类型\n(5)运算符\n(6)逻辑结构\n(7)通用小程序\n(8)函数和对象\n(9)第三方库、组件、框架\n(10)实用项目\n32.什么是哈希表？\n\n散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n\n33.静态网页和动态网页区别：\n\n静态: 网页内容任何人在任何时间访问都是不变的\n\n动态: 网页内容不同人在不同时间访问可能是不同的\n\n34.SQL语句的分类\n\nDDL:数据定义语句 CREATE/DROP/ALTER…\nDCL:数据控制语句 GRANT…\nDML:操作操作语句 INSERT/UPDATE/DELETE\nDQL:查询语句 SELECT\n35.什么是弹性布局？\n\n解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。\n\n设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!\n\ndisplay:flex; 属性align-self 定义子元素的位置。\n\n36.编写响应式？\n\n1.声明viewport元标签\n2.使用流式布局\n3.所有容器使用相对尺寸，不用绝对尺寸\n4.（最重要原则）使用CSS3 Media Query技术\n37.常见的浏览器兼容问题？\n\n1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}\n2.图片默认有间距使用float属性为img布局\n3.居中问题（而FF默认为左对齐）margin: 0 auto;\n4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、\n5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀\n38.H5新特性：\n\n(1)Canvas绘图\n(2)SVG绘图\n(3)地理定位\n(4)Web Worker\nweb worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。\n(5)Web Storage\n1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）\n2.（兼容性差,数据8MB,操作简单）sessionStorage\n3.localStorage\n(6)Web Socket\nWebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。\n39.C3新特性：\n\n1.复杂的选择器\n2.弹性布局\n3.动画\n40.什么是typescript\n\n1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。\n41.三大框架的区别：\n\nAngular带有比较强的排它性的\nReact主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。\nVue 渐进式的\n42.spa应用\n\n优点：用户体验好 、良好的前后端分离。\n\n缺点：\n1.不利于SEO。\n2.初次加载耗时相对增多。\n3.导航不可用，如果一定要导航需要自行实现前进、后退。\n43.什么是模块化编程？\n\n每个模块内部，module变量代表当前模块。\n\n这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。\n\n44.性能优化？\n\n1.使用 CDN\n2.图片懒加载\n3.使用外部 JavaScript 和 CSS\n4.压缩 JavaScript 、 CSS 、字体、图片等\n5.优化 CSS Sprite\n6.减少 HTTP 请求数\n7.减少 DNS 查询\n8.减少 DOM 元素数量\n9.减少 DOM 操作\n10.把脚本放在页面底部\n可以看看这篇文章 关于前端优化的一些方案\n45.什么是HTTP协议：\n\nHTTP是一个客户端和服务器端请求和应答的标准（TCP）。\nHTTP1.1 和 2.0协议的区别：\nHTTP1.1不支持 header 数据的压缩，而2.0支持","slug":"webTitle","published":1,"updated":"2019-12-14T10:29:55.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckioehjsg003578p3ni5dvjds","content":"<p>Author: Echo<br>Time: 2019-09-02 10:42:59</p>\n<h2 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h2><p>1.输入域名地址<br>2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；<br>3.与WEB服务器建立TCP连接；<br>4.服务器的永久重定向响应（从 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 到 <a href=\"http://www.example.com）\" target=\"_blank\" rel=\"noopener\">http://www.example.com）</a><br>5.浏览器跟踪重定向地址<br>6.服务器处理请求<br>7.服务器返回一个HTTP响应<br>8.浏览器显示 HTML<br>9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）<br>10.浏览器发送异步请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。</span><br><span class=\"line\">TCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h2><ol>\n<li><p><code>用户界面</code> － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。</p>\n</li>\n<li><p><code>浏览器引擎</code> － 用来查询及操作渲染引擎的接口。</p>\n</li>\n<li><p><code>渲染引擎</code> － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。</p>\n</li>\n<li><p><code>网络</code> － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。</p>\n</li>\n<li><p><code>UI后端</code> － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p>\n</li>\n<li><p><code>JS解释器</code> － 用来解释执行JS代码。</p>\n</li>\n<li><p><code>数据存储</code> － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术<br><img src=\"https://pic.xiaohuochai.site/blog/browserRender1.png\" alt=\"image\"></p>\n</li>\n</ol>\n<p>参考链接:<a href=\"https://www.cnblogs.com/xiaohuochai/p/9174471.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaohuochai/p/9174471.html</a></p>\n<h2 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h2><p>主要分成两部分:<code>渲染引擎</code>(layout engineer或Rendering Engine)和<code>JS引擎</code>。</p>\n<p><code>渲染引擎</code>:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p><code>JS引擎</code>:解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><p>Trident内核:IE，360…. (微软开发的一种排版引擎)<br>Gecko内核:Firefox<br>Presto内核:Opera(已经废弃了)<br>Blink内核:Opera；<br>Webkit内核:Safari，Chrome。</p>\n<h2 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>\n<h5 id=\"存储大小\"><a href=\"#存储大小\" class=\"headerlink\" title=\"存储大小:\"></a>存储大小:</h5><ul>\n<li>cookie数据大小不能超过4k。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。<h5 id=\"存储时间\"><a href=\"#存储时间\" class=\"headerlink\" title=\"存储时间:\"></a>存储时间:</h5></li>\n<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;</li>\n<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除.</li>\n<li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 存储内容类型: </span><br><span class=\"line\">sessionStorage和localStorage只能存储字符串类型</span><br><span class=\"line\">// 获取方式:</span><br><span class=\"line\">localStorage:window.localStorage;；sessionStorage:window.sessionStorage;</span><br><span class=\"line\">// WebStorage提供了一些方法，数据操作比cookie方便；</span><br><span class=\"line\">setItem (key, value) ——  保存数据，以键值对的方式储存信息。</span><br><span class=\"line\">getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</span><br><span class=\"line\">removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</span><br><span class=\"line\">clear () ——  删除所有的数据</span><br><span class=\"line\">key (index) —— 获取某个索引的key</span><br><span class=\"line\">// cookie需要自己封装接口setCookie. getCookit</span><br></pre></td></tr></table></figure>\n<h2 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h2><p>跨域问题，设置了HttpOnly</p>\n<p>参考链接:<a href=\"https://www.cnblogs.com/hujunzheng/p/5744755.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hujunzheng/p/5744755.html</a></p>\n<h2 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h2><ul>\n<li><p>localstorge<br>localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a:click</span><br><span class=\"line\">$(&quot;#btn&quot;).click(function()&#123;  </span><br><span class=\"line\">  var name=$(&quot;#name&quot;).val();  </span><br><span class=\"line\">  localStorage.setItem(&quot;name&quot;, name); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">// b:watch</span><br><span class=\"line\">window.addEventListener(&quot;storage&quot;, function(event)&#123;   console.log(event.key + &quot;=&quot; + event.newValue);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cookie+setInterval<br>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息</p>\n</li>\n<li><p>websocket协议<br>1.首先我们得了解websocket是什么？<br>它是一种网络通信协议<br>2.为什么会用到websocket?<br>因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。<br>但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。<br>轮询:每隔一段时间，就发出一个询问.<br>因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.</p>\n</li>\n<li>html5浏览器的新特性SharedWorker</li>\n</ul>\n<p>参考链接:<a href=\"https://segmentfault.com/a/1190000018354650\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000018354650</a></p>\n<h2 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h2><p>通过 visibilityState 的值检测页面</p>\n<ul>\n<li>当前是否可见</li>\n<li>打开网页的时间</li>\n<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等<h2 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h2>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试<h2 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h2>1、CDN缓存更方便</li>\n</ul>\n<p>2、突破浏览器并发限制</p>\n<p>3、节约cookie带宽</p>\n<p>4、节约主域名的连接数，优化页面响应速度</p>\n<p>5、防止不必要的安全问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源</span><br><span class=\"line\">// 突破浏览器并发限制</span><br><span class=\"line\">同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h2><ul>\n<li>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>\n<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>\n<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>\n<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>\n</ul>\n<h2 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h2><ul>\n<li><p>语义化html标签</p>\n</li>\n<li><p>合理的title，description,keywords</p>\n</li>\n<li><p>主要html代码放在前面</p>\n</li>\n<li><p>少用iframe，搜索引擎不会抓取iframe中的内容</p>\n</li>\n<li><p>图片加上Alt</p>\n</li>\n</ul>\n<p>参考链接(了解seo): <a href=\"https://blog.csdn.net/jnshu_it/article/details/80029988\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jnshu_it/article/details/80029988</a></p>\n<h2 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h2><h6 id=\"一、减少请求资源大小或者次数\"><a href=\"#一、减少请求资源大小或者次数\" class=\"headerlink\" title=\"一、减少请求资源大小或者次数　\"></a>一、减少请求资源大小或者次数　</h6><p>1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）<br>　　原因:主要是为了减少http请求次数以及减少请求资源的大小<br>　　打包工具:<br>　　webpack<br>　　gulp<br>　　grunt<br>.　　….<br>2、尽量所使用的字体图标或者SVG图标来代替传统png图<br>　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快</p>\n<p>3、采用图片的懒加载（延迟加载）<br>　　目的为了，减少页面第一次加载过程中http的请求次数<br>　　具体步骤:<br>　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图<br>　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息</p>\n<p>4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。<br>　　避免引入第三方大量的库。而自己却只是用里面的一个小功能</p>\n<p>5、使用雪碧图或者是说图片精灵<br>　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用<br>　　图片定位来讲小图展现在页面中（background-position:百分比，数值）</p>\n<p>6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie</p>\n<p>7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势<br>　　目的:是数据处理方便，资源偏小</p>\n<p>8、前端与后端协商，合理使用keep-alive</p>\n<p>9、前端与服务器协商，使用响应资源的压缩</p>\n<p>10、避免使用iframe<br>　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源</p>\n<p>11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个<br>缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据<br>时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）</p>\n<p>二、代码优化相关<br>1、在js中尽量减少闭包的使用<br>　　原因:使用闭包后，闭包所在的上下文不会被释放</p>\n<p>2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）<br>　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）</p>\n<p>3、在js中避免嵌套循环和”死循环”(一旦遇到死循环，浏览器就会直接卡掉)</p>\n<p>4、把css放在body上，把js放在body下面<br>　　让其先加载css（注意:这里关于优化没有多大关系）</p>\n<p>5、减少css表达式的使用</p>\n<p>6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象</p>\n<p>7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。</p>\n<p>9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上</p>\n<p>10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作</p>\n<p>11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画<br>　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout<br>　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间<br>　　缩短</p>\n<p>12、尽量减少使用递归，避免死递归。<br>　　解决:建议使用尾递归</p>\n<p>13、基于script标签下载js文件时，可以使用defer或者async来异步加载</p>\n<p>14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。</p>\n<p>15、减少Flash的使用</p>\n<p>三、存储</p>\n<p>1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs</p>\n<p>2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，<br>　　避免向后台请求数据或者说在离线状态下做一些数据展示。</p>\n<p>四、其他优化</p>\n<p>1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢<br>　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的<br>　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示<br>　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数</p>\n<p>3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）<br>　　解决方法:只需要将音视频的<code>preload=none</code>即可。<br>　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源</p>\n<h2 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h2><ul>\n<li>基于长轮询的 XHR</li>\n<li>Adobe Flash Socket</li>\n<li>ActiveX HTMLFile (IE)</li>\n<li>基于 multipart 编码发送 XHR<br>参考链接:<a href=\"https://www.cnblogs.com/pengc/p/8718380.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/pengc/p/8718380.html</a></li>\n</ul>\n<h2 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h2><ol>\n<li>隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。</li>\n<li>URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。</li>\n<li>Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。</li>\n<li>Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</li>\n<li>IP地址</li>\n</ol>\n<h2 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。</p>\n<ul>\n<li>GET是最常用的方法，通常用于请求服务器发送某个资源。</li>\n<li>HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。</li>\n<li>PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。</li>\n<li>POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li>\n<li>TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li>\n<li>OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>\n<li>DELETE 请求服务器删除请求 URL 指定的资源</li>\n</ul>\n<h2 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h2><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th style=\"text-align:right\">类别</th>\n<th style=\"text-align:center\">原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td style=\"text-align:right\">Information（信息性状态码）</td>\n<td style=\"text-align:center\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td style=\"text-align:right\">Success（成功状态码）</td>\n<td style=\"text-align:center\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td style=\"text-align:right\">Redirection（重定向状态码）</td>\n<td style=\"text-align:center\">需要进行附加的操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td style=\"text-align:right\">Client Error（客户端错误状态码）</td>\n<td style=\"text-align:center\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td style=\"text-align:right\">Server Error（服务端错误状态码）</td>\n<td style=\"text-align:center\">服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>204     服务器成功处理，但未返回内容。</li>\n<li>304    Not Modified 未修改。    所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>\n<li>400    Bad Request    客户端请求的语法错误，服务器无法理解</li>\n<li>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面<h2 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h2></li>\n</ul>\n<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<p>如果非同源，共有三种行为受到限制<br>1.Cookie、LocalStorage 和 IndexDB 无法读取。<br>2.DOM 无法获得。<br>3.AJAX 请求不能发送。</p>\n<h2 id=\"爬虫和反爬虫的理解\"><a href=\"#爬虫和反爬虫的理解\" class=\"headerlink\" title=\"爬虫和反爬虫的理解\"></a>爬虫和反爬虫的理解</h2><p>参考链接： <a href=\"https://www.cnblogs.com/tulintao/p/11614577.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/tulintao/p/11614577.html</a></p>\n<ul>\n<li><code>爬虫</code>：为了获得任何信息而采用任何手段对某一网站进行<code>攻击</code>行为，之所以成为攻击行为，因为对网站的爬虫过程会对网站造成不同程度的影响。<br>爬虫与手动点击访问网站数据的主要区别在于这个是批量操作。</li>\n<li><code>反爬虫</code>： 网站为了维护自己的核心安全而采取的抑制爬虫的手段。</li>\n</ul>\n<p>常见的反爬虫机制：</p>\n<ol>\n<li>基于User-Agent反爬</li>\n</ol>\n<ul>\n<li>思想： 服务器后台访问的User-Agent进行同籍，单位时间内同一个User-Agent访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。</li>\n<li>解决：<br>方案一：<br> 将常见的User-Agent封装到一个文件中，别人总结好的常用的User-Agent链接：<a href=\"https://www.cnblogs.com/zrmw/p/9332801.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zrmw/p/9332801.html</a><br> 在爬取的过程中首先导入这个文件，然后随机选择这里面的某一个User-Agent<br>方案二：<br> 在python中使用第三方类库：fake_useragent ，生成随机的User-Agent</li>\n</ul>\n<ol start=\"2\">\n<li>基于IP反爬 </li>\n</ol>\n<ul>\n<li>思想：后端服务器对访问进行统计，单位时间内同一个IP访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。</li>\n<li>解决<br>使用不同的IP进行访问，设置一定的访问停滞，random.sleep(3)</li>\n</ul>\n<ol start=\"3\">\n<li>动态页面抓包 </li>\n</ol>\n<hr>\n<p>// 下面的还没有看<br>关于建站安全防护</p>\n<p>要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。</p>\n<p>XSS概念:</p>\n<p>译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。<br>XSS预防:</p>\n<p>关键cookie字段设置httpOnly<br>输入检查,特殊字符 &lt; &gt; / &amp;等,对其进行转义后存储<br>CSRF概念：</p>\n<p>本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。<br>CSRF 预防：</p>\n<p>使用验证码，更高级用图灵测试<br>SQL概念：</p>\n<p>通常没有任何过滤，直接把参数存放到了SQL语句当中<br>SQL预防：</p>\n<p>根本上防止SQL注入的方法，就是参数化查询或者做词法分析。<br>DDOS概念：</p>\n<p>利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。<br>DDOS预防：用软硬件结合的方式来防御是最有效的<br>25.对前端工程化的理解</p>\n<p>1.开发规范<br>2.模块化开发<br>3.组件化开发<br>4.组件仓库<br>5.性能优化<br>6.项目部署<br>7.开发流程<br>8.开发工具<br>26.AMD和CMD是什么？它们的区别有哪些？</p>\n<p>AMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。</p>\n<p>27.MVC BFC</p>\n<p>mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。</p>\n<p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。</p>\n<p>28.你如何对网站的文件和资源进行优化？</p>\n<p>期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。<br>29.如果网页内容需要支持多语言，你会怎么做？</p>\n<p>1.应用字符集的选择，选择UTF-8编码<br>2.语言书写习惯&amp;导航结构<br>3.数据库驱动型网站<br>30.如果设计中使用了非标准的字体，你该如何去实现？</p>\n<p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：<br>用图片代替<br>web fonts在线字库，如Google Webfonts，Typekit等等;<a href=\"http://www.chinaz.com/free/20…；\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/free/20…；</a><br>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)<br>31.如何自学一门新编程语言</p>\n<p>(1)了解背景知识：历史、现状、特点、应用领域、发展趋势<br>(2)搭建开发环境，编写HelloWorld<br>(3)声明变量和常量<br>(4)数据类型<br>(5)运算符<br>(6)逻辑结构<br>(7)通用小程序<br>(8)函数和对象<br>(9)第三方库、组件、框架<br>(10)实用项目<br>32.什么是哈希表？</p>\n<p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>\n<p>33.静态网页和动态网页区别：</p>\n<p>静态: 网页内容任何人在任何时间访问都是不变的</p>\n<p>动态: 网页内容不同人在不同时间访问可能是不同的</p>\n<p>34.SQL语句的分类</p>\n<p>DDL:数据定义语句 CREATE/DROP/ALTER…<br>DCL:数据控制语句 GRANT…<br>DML:操作操作语句 INSERT/UPDATE/DELETE<br>DQL:查询语句 SELECT<br>35.什么是弹性布局？</p>\n<p>解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。</p>\n<p>设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!</p>\n<p>display:flex; 属性align-self 定义子元素的位置。</p>\n<p>36.编写响应式？</p>\n<p>1.声明viewport元标签<br>2.使用流式布局<br>3.所有容器使用相对尺寸，不用绝对尺寸<br>4.（最重要原则）使用CSS3 Media Query技术<br>37.常见的浏览器兼容问题？</p>\n<p>1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}<br>2.图片默认有间距使用float属性为img布局<br>3.居中问题（而FF默认为左对齐）margin: 0 auto;<br>4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、<br>5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀<br>38.H5新特性：</p>\n<p>(1)Canvas绘图<br>(2)SVG绘图<br>(3)地理定位<br>(4)Web Worker<br>web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。<br>(5)Web Storage<br>1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）<br>2.（兼容性差,数据8MB,操作简单）sessionStorage<br>3.localStorage<br>(6)Web Socket<br>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。<br>39.C3新特性：</p>\n<p>1.复杂的选择器<br>2.弹性布局<br>3.动画<br>40.什么是typescript</p>\n<p>1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。<br>41.三大框架的区别：</p>\n<p>Angular带有比较强的排它性的<br>React主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。<br>Vue 渐进式的<br>42.spa应用</p>\n<p>优点：用户体验好 、良好的前后端分离。</p>\n<p>缺点：<br>1.不利于SEO。<br>2.初次加载耗时相对增多。<br>3.导航不可用，如果一定要导航需要自行实现前进、后退。<br>43.什么是模块化编程？</p>\n<p>每个模块内部，module变量代表当前模块。</p>\n<p>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>\n<p>44.性能优化？</p>\n<p>1.使用 CDN<br>2.图片懒加载<br>3.使用外部 JavaScript 和 CSS<br>4.压缩 JavaScript 、 CSS 、字体、图片等<br>5.优化 CSS Sprite<br>6.减少 HTTP 请求数<br>7.减少 DNS 查询<br>8.减少 DOM 元素数量<br>9.减少 DOM 操作<br>10.把脚本放在页面底部<br>可以看看这篇文章 关于前端优化的一些方案<br>45.什么是HTTP协议：</p>\n<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。<br>HTTP1.1 和 2.0协议的区别：<br>HTTP1.1不支持 header 数据的压缩，而2.0支持</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-02 10:42:59</p>\n<h2 id=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"><a href=\"#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\" class=\"headerlink\" title=\"页面从输入URL到页面加载显示完成，这个过程中都发生了什么？\"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h2><p>1.输入域名地址<br>2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；<br>3.与WEB服务器建立TCP连接；<br>4.服务器的永久重定向响应（从 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 到 <a href=\"http://www.example.com）\" target=\"_blank\" rel=\"noopener\">http://www.example.com）</a><br>5.浏览器跟踪重定向地址<br>6.服务器处理请求<br>7.服务器返回一个HTTP响应<br>8.浏览器显示 HTML<br>9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）<br>10.浏览器发送异步请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。</span><br><span class=\"line\">TCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器工作原理\"><a href=\"#浏览器工作原理\" class=\"headerlink\" title=\"浏览器工作原理\"></a>浏览器工作原理</h2><ol>\n<li><p><code>用户界面</code> － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。</p>\n</li>\n<li><p><code>浏览器引擎</code> － 用来查询及操作渲染引擎的接口。</p>\n</li>\n<li><p><code>渲染引擎</code> － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。</p>\n</li>\n<li><p><code>网络</code> － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。</p>\n</li>\n<li><p><code>UI后端</code> － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p>\n</li>\n<li><p><code>JS解释器</code> － 用来解释执行JS代码。</p>\n</li>\n<li><p><code>数据存储</code> － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术<br><img src=\"https://pic.xiaohuochai.site/blog/browserRender1.png\" alt=\"image\"></p>\n</li>\n</ol>\n<p>参考链接:<a href=\"https://www.cnblogs.com/xiaohuochai/p/9174471.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/xiaohuochai/p/9174471.html</a></p>\n<h2 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h2><p>主要分成两部分:<code>渲染引擎</code>(layout engineer或Rendering Engine)和<code>JS引擎</code>。</p>\n<p><code>渲染引擎</code>:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p><code>JS引擎</code>:解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n<h2 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h2><p>Trident内核:IE，360…. (微软开发的一种排版引擎)<br>Gecko内核:Firefox<br>Presto内核:Opera(已经废弃了)<br>Blink内核:Opera；<br>Webkit内核:Safari，Chrome。</p>\n<h2 id=\"cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"cookies，sessionStorage 和 localStorage 的区别？\"></a>cookies，sessionStorage 和 localStorage 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>\n<h5 id=\"存储大小\"><a href=\"#存储大小\" class=\"headerlink\" title=\"存储大小:\"></a>存储大小:</h5><ul>\n<li>cookie数据大小不能超过4k。</li>\n<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。<h5 id=\"存储时间\"><a href=\"#存储时间\" class=\"headerlink\" title=\"存储时间:\"></a>存储时间:</h5></li>\n<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;</li>\n<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除.</li>\n<li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 存储内容类型: </span><br><span class=\"line\">sessionStorage和localStorage只能存储字符串类型</span><br><span class=\"line\">// 获取方式:</span><br><span class=\"line\">localStorage:window.localStorage;；sessionStorage:window.sessionStorage;</span><br><span class=\"line\">// WebStorage提供了一些方法，数据操作比cookie方便；</span><br><span class=\"line\">setItem (key, value) ——  保存数据，以键值对的方式储存信息。</span><br><span class=\"line\">getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</span><br><span class=\"line\">removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</span><br><span class=\"line\">clear () ——  删除所有的数据</span><br><span class=\"line\">key (index) —— 获取某个索引的key</span><br><span class=\"line\">// cookie需要自己封装接口setCookie. getCookit</span><br></pre></td></tr></table></figure>\n<h2 id=\"页面访问cookie的限制条件\"><a href=\"#页面访问cookie的限制条件\" class=\"headerlink\" title=\"页面访问cookie的限制条件\"></a>页面访问cookie的限制条件</h2><p>跨域问题，设置了HttpOnly</p>\n<p>参考链接:<a href=\"https://www.cnblogs.com/hujunzheng/p/5744755.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/hujunzheng/p/5744755.html</a></p>\n<h2 id=\"实现浏览器内多个标签页之间的通信\"><a href=\"#实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"实现浏览器内多个标签页之间的通信\"></a>实现浏览器内多个标签页之间的通信</h2><ul>\n<li><p>localstorge<br>localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// a:click</span><br><span class=\"line\">$(&quot;#btn&quot;).click(function()&#123;  </span><br><span class=\"line\">  var name=$(&quot;#name&quot;).val();  </span><br><span class=\"line\">  localStorage.setItem(&quot;name&quot;, name); </span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"></span><br><span class=\"line\">// b:watch</span><br><span class=\"line\">window.addEventListener(&quot;storage&quot;, function(event)&#123;   console.log(event.key + &quot;=&quot; + event.newValue);  </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cookie+setInterval<br>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息</p>\n</li>\n<li><p>websocket协议<br>1.首先我们得了解websocket是什么？<br>它是一种网络通信协议<br>2.为什么会用到websocket?<br>因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。<br>但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。<br>轮询:每隔一段时间，就发出一个询问.<br>因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.</p>\n</li>\n<li>html5浏览器的新特性SharedWorker</li>\n</ul>\n<p>参考链接:<a href=\"https://segmentfault.com/a/1190000018354650\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000018354650</a></p>\n<h2 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途\"></a>页面可见性（Page Visibility API） 可以有哪些用途</h2><p>通过 visibilityState 的值检测页面</p>\n<ul>\n<li>当前是否可见</li>\n<li>打开网页的时间</li>\n<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等<h2 id=\"网页验证码是做什么的，是为了解决什么安全问题\"><a href=\"#网页验证码是做什么的，是为了解决什么安全问题\" class=\"headerlink\" title=\"网页验证码是做什么的，是为了解决什么安全问题\"></a>网页验证码是做什么的，是为了解决什么安全问题</h2>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试<h2 id=\"为什么利用多个域名来存储网站资源\"><a href=\"#为什么利用多个域名来存储网站资源\" class=\"headerlink\" title=\"为什么利用多个域名来存储网站资源\"></a>为什么利用多个域名来存储网站资源</h2>1、CDN缓存更方便</li>\n</ul>\n<p>2、突破浏览器并发限制</p>\n<p>3、节约cookie带宽</p>\n<p>4、节约主域名的连接数，优化页面响应速度</p>\n<p>5、防止不必要的安全问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源</span><br><span class=\"line\">// 突破浏览器并发限制</span><br><span class=\"line\">同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。</span><br></pre></td></tr></table></figure>\n<h2 id=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"><a href=\"#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\" class=\"headerlink\" title=\"一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验\"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h2><ul>\n<li>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>\n<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>\n<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>\n<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>\n</ul>\n<h2 id=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"><a href=\"#以前端角度出发做好SEO（搜索引擎）需要考虑什么？\" class=\"headerlink\" title=\"以前端角度出发做好SEO（搜索引擎）需要考虑什么？\"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h2><ul>\n<li><p>语义化html标签</p>\n</li>\n<li><p>合理的title，description,keywords</p>\n</li>\n<li><p>主要html代码放在前面</p>\n</li>\n<li><p>少用iframe，搜索引擎不会抓取iframe中的内容</p>\n</li>\n<li><p>图片加上Alt</p>\n</li>\n</ul>\n<p>参考链接(了解seo): <a href=\"https://blog.csdn.net/jnshu_it/article/details/80029988\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/jnshu_it/article/details/80029988</a></p>\n<h2 id=\"前端性能优化\"><a href=\"#前端性能优化\" class=\"headerlink\" title=\"前端性能优化\"></a>前端性能优化</h2><h6 id=\"一、减少请求资源大小或者次数\"><a href=\"#一、减少请求资源大小或者次数\" class=\"headerlink\" title=\"一、减少请求资源大小或者次数　\"></a>一、减少请求资源大小或者次数　</h6><p>1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）<br>　　原因:主要是为了减少http请求次数以及减少请求资源的大小<br>　　打包工具:<br>　　webpack<br>　　gulp<br>　　grunt<br>.　　….<br>2、尽量所使用的字体图标或者SVG图标来代替传统png图<br>　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快</p>\n<p>3、采用图片的懒加载（延迟加载）<br>　　目的为了，减少页面第一次加载过程中http的请求次数<br>　　具体步骤:<br>　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图<br>　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息</p>\n<p>4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。<br>　　避免引入第三方大量的库。而自己却只是用里面的一个小功能</p>\n<p>5、使用雪碧图或者是说图片精灵<br>　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用<br>　　图片定位来讲小图展现在页面中（background-position:百分比，数值）</p>\n<p>6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie</p>\n<p>7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势<br>　　目的:是数据处理方便，资源偏小</p>\n<p>8、前端与后端协商，合理使用keep-alive</p>\n<p>9、前端与服务器协商，使用响应资源的压缩</p>\n<p>10、避免使用iframe<br>　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源</p>\n<p>11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个<br>缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据<br>时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）</p>\n<p>二、代码优化相关<br>1、在js中尽量减少闭包的使用<br>　　原因:使用闭包后，闭包所在的上下文不会被释放</p>\n<p>2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）<br>　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）</p>\n<p>3、在js中避免嵌套循环和”死循环”(一旦遇到死循环，浏览器就会直接卡掉)</p>\n<p>4、把css放在body上，把js放在body下面<br>　　让其先加载css（注意:这里关于优化没有多大关系）</p>\n<p>5、减少css表达式的使用</p>\n<p>6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象</p>\n<p>7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。</p>\n<p>9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上</p>\n<p>10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作</p>\n<p>11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画<br>　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout<br>　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间<br>　　缩短</p>\n<p>12、尽量减少使用递归，避免死递归。<br>　　解决:建议使用尾递归</p>\n<p>13、基于script标签下载js文件时，可以使用defer或者async来异步加载</p>\n<p>14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。</p>\n<p>15、减少Flash的使用</p>\n<p>三、存储</p>\n<p>1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs</p>\n<p>2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，<br>　　避免向后台请求数据或者说在离线状态下做一些数据展示。</p>\n<p>四、其他优化</p>\n<p>1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>\n<p>2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢<br>　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的<br>　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示<br>　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数</p>\n<p>3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）<br>　　解决方法:只需要将音视频的<code>preload=none</code>即可。<br>　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源</p>\n<h2 id=\"webSocket如何兼容低浏览器\"><a href=\"#webSocket如何兼容低浏览器\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器\"></a>webSocket如何兼容低浏览器</h2><ul>\n<li>基于长轮询的 XHR</li>\n<li>Adobe Flash Socket</li>\n<li>ActiveX HTMLFile (IE)</li>\n<li>基于 multipart 编码发送 XHR<br>参考链接:<a href=\"https://www.cnblogs.com/pengc/p/8718380.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/pengc/p/8718380.html</a></li>\n</ul>\n<h2 id=\"web开发中会话跟踪的方法\"><a href=\"#web开发中会话跟踪的方法\" class=\"headerlink\" title=\"web开发中会话跟踪的方法\"></a>web开发中会话跟踪的方法</h2><ol>\n<li>隐藏表单域：<input type=\"hidden\">非常适合步需要大量数据存储的会话应用。</li>\n<li>URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。</li>\n<li>Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。</li>\n<li>Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</li>\n<li>IP地址</li>\n</ol>\n<h2 id=\"HTTP-method\"><a href=\"#HTTP-method\" class=\"headerlink\" title=\"HTTP method\"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。</p>\n<ul>\n<li>GET是最常用的方法，通常用于请求服务器发送某个资源。</li>\n<li>HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。</li>\n<li>PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。</li>\n<li>POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li>\n<li>TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li>\n<li>OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>\n<li>DELETE 请求服务器删除请求 URL 指定的资源</li>\n</ul>\n<h2 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h2><table>\n<thead>\n<tr>\n<th>状态码</th>\n<th style=\"text-align:right\">类别</th>\n<th style=\"text-align:center\">原因短语</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td style=\"text-align:right\">Information（信息性状态码）</td>\n<td style=\"text-align:center\">接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td style=\"text-align:right\">Success（成功状态码）</td>\n<td style=\"text-align:center\">请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td style=\"text-align:right\">Redirection（重定向状态码）</td>\n<td style=\"text-align:center\">需要进行附加的操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td style=\"text-align:right\">Client Error（客户端错误状态码）</td>\n<td style=\"text-align:center\">服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td style=\"text-align:right\">Server Error（服务端错误状态码）</td>\n<td style=\"text-align:center\">服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>204     服务器成功处理，但未返回内容。</li>\n<li>304    Not Modified 未修改。    所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>\n<li>400    Bad Request    客户端请求的语法错误，服务器无法理解</li>\n<li>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</li>\n<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面<h2 id=\"什么是同源：协议相同-域名相同-端口相同\"><a href=\"#什么是同源：协议相同-域名相同-端口相同\" class=\"headerlink\" title=\"什么是同源：协议相同 域名相同 端口相同\"></a>什么是同源：协议相同 域名相同 端口相同</h2></li>\n</ul>\n<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>\n<p>如果非同源，共有三种行为受到限制<br>1.Cookie、LocalStorage 和 IndexDB 无法读取。<br>2.DOM 无法获得。<br>3.AJAX 请求不能发送。</p>\n<h2 id=\"爬虫和反爬虫的理解\"><a href=\"#爬虫和反爬虫的理解\" class=\"headerlink\" title=\"爬虫和反爬虫的理解\"></a>爬虫和反爬虫的理解</h2><p>参考链接： <a href=\"https://www.cnblogs.com/tulintao/p/11614577.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/tulintao/p/11614577.html</a></p>\n<ul>\n<li><code>爬虫</code>：为了获得任何信息而采用任何手段对某一网站进行<code>攻击</code>行为，之所以成为攻击行为，因为对网站的爬虫过程会对网站造成不同程度的影响。<br>爬虫与手动点击访问网站数据的主要区别在于这个是批量操作。</li>\n<li><code>反爬虫</code>： 网站为了维护自己的核心安全而采取的抑制爬虫的手段。</li>\n</ul>\n<p>常见的反爬虫机制：</p>\n<ol>\n<li>基于User-Agent反爬</li>\n</ol>\n<ul>\n<li>思想： 服务器后台访问的User-Agent进行同籍，单位时间内同一个User-Agent访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。</li>\n<li>解决：<br>方案一：<br> 将常见的User-Agent封装到一个文件中，别人总结好的常用的User-Agent链接：<a href=\"https://www.cnblogs.com/zrmw/p/9332801.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zrmw/p/9332801.html</a><br> 在爬取的过程中首先导入这个文件，然后随机选择这里面的某一个User-Agent<br>方案二：<br> 在python中使用第三方类库：fake_useragent ，生成随机的User-Agent</li>\n</ul>\n<ol start=\"2\">\n<li>基于IP反爬 </li>\n</ol>\n<ul>\n<li>思想：后端服务器对访问进行统计，单位时间内同一个IP访问的次数超过特定的阈值，就会被不同程度的封禁Ip,从而无法进行爬虫。</li>\n<li>解决<br>使用不同的IP进行访问，设置一定的访问停滞，random.sleep(3)</li>\n</ul>\n<ol start=\"3\">\n<li>动态页面抓包 </li>\n</ol>\n<hr>\n<p>// 下面的还没有看<br>关于建站安全防护</p>\n<p>要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。</p>\n<p>XSS概念:</p>\n<p>译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。<br>XSS预防:</p>\n<p>关键cookie字段设置httpOnly<br>输入检查,特殊字符 &lt; &gt; / &amp;等,对其进行转义后存储<br>CSRF概念：</p>\n<p>本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。<br>CSRF 预防：</p>\n<p>使用验证码，更高级用图灵测试<br>SQL概念：</p>\n<p>通常没有任何过滤，直接把参数存放到了SQL语句当中<br>SQL预防：</p>\n<p>根本上防止SQL注入的方法，就是参数化查询或者做词法分析。<br>DDOS概念：</p>\n<p>利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。<br>DDOS预防：用软硬件结合的方式来防御是最有效的<br>25.对前端工程化的理解</p>\n<p>1.开发规范<br>2.模块化开发<br>3.组件化开发<br>4.组件仓库<br>5.性能优化<br>6.项目部署<br>7.开发流程<br>8.开发工具<br>26.AMD和CMD是什么？它们的区别有哪些？</p>\n<p>AMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。</p>\n<p>27.MVC BFC</p>\n<p>mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。</p>\n<p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。</p>\n<p>28.你如何对网站的文件和资源进行优化？</p>\n<p>期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。<br>29.如果网页内容需要支持多语言，你会怎么做？</p>\n<p>1.应用字符集的选择，选择UTF-8编码<br>2.语言书写习惯&amp;导航结构<br>3.数据库驱动型网站<br>30.如果设计中使用了非标准的字体，你该如何去实现？</p>\n<p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：<br>用图片代替<br>web fonts在线字库，如Google Webfonts，Typekit等等;<a href=\"http://www.chinaz.com/free/20…；\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/free/20…；</a><br>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)<br>31.如何自学一门新编程语言</p>\n<p>(1)了解背景知识：历史、现状、特点、应用领域、发展趋势<br>(2)搭建开发环境，编写HelloWorld<br>(3)声明变量和常量<br>(4)数据类型<br>(5)运算符<br>(6)逻辑结构<br>(7)通用小程序<br>(8)函数和对象<br>(9)第三方库、组件、框架<br>(10)实用项目<br>32.什么是哈希表？</p>\n<p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>\n<p>33.静态网页和动态网页区别：</p>\n<p>静态: 网页内容任何人在任何时间访问都是不变的</p>\n<p>动态: 网页内容不同人在不同时间访问可能是不同的</p>\n<p>34.SQL语句的分类</p>\n<p>DDL:数据定义语句 CREATE/DROP/ALTER…<br>DCL:数据控制语句 GRANT…<br>DML:操作操作语句 INSERT/UPDATE/DELETE<br>DQL:查询语句 SELECT<br>35.什么是弹性布局？</p>\n<p>解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。</p>\n<p>设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!</p>\n<p>display:flex; 属性align-self 定义子元素的位置。</p>\n<p>36.编写响应式？</p>\n<p>1.声明viewport元标签<br>2.使用流式布局<br>3.所有容器使用相对尺寸，不用绝对尺寸<br>4.（最重要原则）使用CSS3 Media Query技术<br>37.常见的浏览器兼容问题？</p>\n<p>1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}<br>2.图片默认有间距使用float属性为img布局<br>3.居中问题（而FF默认为左对齐）margin: 0 auto;<br>4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、<br>5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀<br>38.H5新特性：</p>\n<p>(1)Canvas绘图<br>(2)SVG绘图<br>(3)地理定位<br>(4)Web Worker<br>web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。<br>(5)Web Storage<br>1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）<br>2.（兼容性差,数据8MB,操作简单）sessionStorage<br>3.localStorage<br>(6)Web Socket<br>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。<br>39.C3新特性：</p>\n<p>1.复杂的选择器<br>2.弹性布局<br>3.动画<br>40.什么是typescript</p>\n<p>1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。<br>41.三大框架的区别：</p>\n<p>Angular带有比较强的排它性的<br>React主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。<br>Vue 渐进式的<br>42.spa应用</p>\n<p>优点：用户体验好 、良好的前后端分离。</p>\n<p>缺点：<br>1.不利于SEO。<br>2.初次加载耗时相对增多。<br>3.导航不可用，如果一定要导航需要自行实现前进、后退。<br>43.什么是模块化编程？</p>\n<p>每个模块内部，module变量代表当前模块。</p>\n<p>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>\n<p>44.性能优化？</p>\n<p>1.使用 CDN<br>2.图片懒加载<br>3.使用外部 JavaScript 和 CSS<br>4.压缩 JavaScript 、 CSS 、字体、图片等<br>5.优化 CSS Sprite<br>6.减少 HTTP 请求数<br>7.减少 DNS 查询<br>8.减少 DOM 元素数量<br>9.减少 DOM 操作<br>10.把脚本放在页面底部<br>可以看看这篇文章 关于前端优化的一些方案<br>45.什么是HTTP协议：</p>\n<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。<br>HTTP1.1 和 2.0协议的区别：<br>HTTP1.1不支持 header 数据的压缩，而2.0支持</p>\n"},{"title":"asyncAwit","date":"2019-11-04T06:58:15.000Z","_content":"\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n##### async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n// 或者直接设置成基本变量：\nconst TIMEOUT = 30000;\n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\napi.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api//export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","source":"_drafts/asyncAwit.md","raw":"---\ntitle: asyncAwit\ndate: 2019-11-04 14:58:15\ntags:\n---\n\nAuthor: Echo\nTime: 2019-09-20 10:50:39\n\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\n##### async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\n\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n##### 引入\n\n在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：\n\n\n * http.js: 封装axios\n * api.js: 用来统一管理接口\n\n```\n// 在http.js中引入axios\nimport axios from 'axios'; // 引入axios\nimport QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到\n\n```\n\n##### 环境的切换->配置不同的baseURL\n\n我们的项目环境可能有开发环境、测试环境和生产环境.\n我们通过node的环境变量来匹配我们的默认的接口url前缀\naxios.defaults.baseURL可以设置axios的默认请求地址\n\n```\nconst baseURL_Map = {\n  dev：'https://www.baidu.com',\n  uat: 'https://www.ceshi.com',\n  product: 'https://www.production.com'\n}\naxios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] \n// 或者直接设置成基本变量：\nconst TIMEOUT = 30000;\n```\n扩展：\n###### process.env.NODE_ENV\n* process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()\n* process.env属性返回一个包含用户环境信息的对象\n* process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。\n* 测试环境： uat; 生产环境：product; 开发环境： dev\n\n##### 设置请求超时变量\n```\n// 例如超过了10s，就会告知用户当前请求超时，请刷新等。\n\nconst TIMEOUT = 30000;\n```\n\n扩展： \n* 统一处理所有接口的超时时间： `axios.defaults.timeout = 10000;`\n\n##### 设置post请求头\n```\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';\n```\n\n 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理\n\n##### 定义HTTP响应状态码的范围\n```\n/**\n * 判断 HTTP 请求是否成功\n * @param {number} status - HTTP 状态码\n * @returns {Boolean}\n */\nconst isBadRequest = status => status >= 300;\n```\n\n#### 映射 HTTP 错误时的提示语句\n```\n/**\n * 映射 HTTP 错误时的提示语句\n * @param {enhanceError} error\n * @returns {Object}\n */\nconst badStatusMap = error => ({\n  400: '请求错误',\n  401: '未授权，请登录',\n  403: '拒绝访问',\n  404: `请求地址出错 ${error.response ? error.response.config.url : ''}`,\n  408: '请求超时',\n  500: '服务器内部错误',\n  501: '服务未实现',\n  502: '网关错误',\n  503: '服务不可用',\n  504: '网关超时',\n  505: 'HTTP版本不受支持'\n});\n\n```\n\n##### 封装axios\n\n* http.js\n```\n/**\n * http.js\n * @param {Object} [globalOption]\n */\nimport {\n  mergeWith, omit, isPlainObject\n} from 'lodash';\n\n// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null\n// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 \n// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.\n\n\n/**\n * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题\n *  'utils.merge' in 'node_modules\\axios\\lib\\core\\Axios.js'\n * @param {any} obj\n */\nconst fixAxiosDateMerge = (obj) => {\n  if (!obj) return obj;\n  if (obj instanceof Date) return obj.getTime();\n  if (!isPlainObject(obj)) return obj;\n  Object.keys(obj).forEach((key) => {\n    obj[key] = fixAxiosDateMerge(obj[key]);\n  });\n  return obj;\n};\n\nfunction axiosWrapper(globalOption) {\n  return function(option) {\n    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。\n    option = mergeWith({\n      baseURL: BASE_URL,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Cache-Control': 'no-cache'\n      },\n      timeout: TIMEOUT,\n      withCredentials: true,\n      responseType: '',\n      validateStatus: status => !isBadRequest(status)\n\n      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n    }, globalOption, option);\n\n  \n    if (option.data) {\n      option.data = fixAxiosDateMerge(option.data);\n    }\n    if (option.params) {\n      option.params = fixAxiosDateMerge(option.params);\n    }\n\n    const r = axios.create(option);\n    \n    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"\n\n    // timeout\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        \n        if (error && error.code === 'ECONNABORTED'\n          && ~error.message.indexOf('timeout')) {\n          console.log('[AxiosWrapper] request timeout');\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // other errors // 跳转到对应的报错页面\n    r.interceptors.request.use(\n      config => config,\n      (error) => {\n        const errorInfo = error.response;\n        if (errorInfo) {\n          const errorStatus = errorInfo.status;\n          router.push({\n            path: `/error/${errorStatus}`\n          });\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // make data\n    r.interceptors.request.use(\n      (opt) => {\n        const params = mergeWith({}, opt.data, opt.params); // cloneDeep(opt.data);\n        opt = omit(opt, ['data', 'params']);\n        const needBody = /^(put|post|patch)$/i.test(opt.method);\n        const sendJSON = opt.headers\n          && opt.headers['Content-Type'] === 'application/json';\n          // 根据请求头和method来处理入参的格式\n        if (needBody) {\n          opt.data = sendJSON\n            ? JSON.stringify(params)\n            : qs.stringify(params);\n        } else {\n          opt.params = params;\n        }\n        return opt;\n      }\n    );\n\n    // bad HTTP request\n    r.interceptors.response.use(\n      response => response,\n      (error) => {\n        if (error && error.response) {\n          const { status, statusText } = error.response;\n          if (isBadRequest(status)) {\n            console.warn('[AxiosWrapper] bad HTTP request: status is %s \\n', status, error.response);\n            error.message = badStatusMap(error)[status] || statusText;\n            if (!error.message) {\n              try {\n                error.message = JSON.parse(error.response.request.responseText).errmsg;\n              } catch (ex) {\n                console.log('[AxiosWrapper] json parse error', ex);\n              }\n            }\n            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);\n            return Promise.reject(new Error(error.message));\n          }\n        }\n        return Promise.reject(error);\n      }\n    );\n\n    // check business logic\n    // 请求失败，根据HTTP响应状态码做出对应的messageTip\n    r.interceptors.response.use(\n      (response) => {\n        if (option.responseType === 'arraybuffer') {\n          return response;\n        }\n        const [reqURL, resData] = takeapartResponse(response);\n        const noWarn = 'no-global-config-warn' in response.config.headers\n          && !!response.config.headers['no-global-config-warn'];\n        const isValid = isValidCode(resData.errno);\n        const method = response.config.method.toUpperCase();\n        if (!isValid) {\n          // eslint-disable-next-line prefer-promise-reject-errors\n          return Promise.reject({\n            type: ERR_CODE,\n            reqURL,\n            resData,\n            noWarn,\n            method\n          });\n        }\n        const reqStr = `${method} ${reqURL}`;\n        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。\n        warnByResponse(reqStr, resData, true, noWarn);\n        return resData;\n      }\n    );\n    \n\n    // wrong business logic\n    // r.interceptors.response.use(\n    //   response => response,\n    //   (error) => {\n    //     if (error.type === ERR_CODE) {\n    //       const reqStr = `${error.method} ${error.reqURL}`;\n    //       warnByResponse(reqStr, error.resData, false, error.noWarn);\n    //     }\n    //     return Promise.reject(error.resData);\n    //   }\n    // );\n\n    return r(option);\n  };\n}\n\n```\n\n\n#### 简单的封装axios函数\n\n```\n/**\n * 获得一般的 wrapper\n * @param {Object} [option]\n */\n // `transformResponse` 在传递给 then/catch 前，允许修改响应数据\nexport default option => axiosWrapper({\n  transformResponse: data => void (0), // eslint-disable-line no-unused-vars\n  \n})(option);\n\n```\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n\n因为params是添加到url的请求字符串中的，用于get请求。\n\n而data是添加到请求体（body）中的， 用于post请求。\n\napi.js使用实例： \n```\nimport axios, { download } from './http.js';\nexport const mock = params => axios({\n    url: '/mock',\n    method: 'get',\n    params\n});\n\nexport const upload = data => axios({\n    url: '/upload',\n    method: 'post',\n    data\n});\n```\n##### 用于下载的axiosWrapper\n\n```\nexport const download = option => axiosWrapper({\n  responseType: 'arraybuffer'\n})(option)\n  .then((res) => {\n    const contentType = res.headers['content-type'];\n\n    if (~contentType.indexOf('json')) {\n      const resData = res.data || res.request.response;\n      const text = Buffer.from(resData).toString('utf8');\n      const json = JSON.parse(text);\n      return Promise.reject(json);\n    }\n\n    const disposition = res.headers['content-disposition'];\n    if (disposition && disposition.match(/attachment/)) {\n      let filename = disposition.replace(/attachment;.*filename=/, '').replace(/\"/g, '');\n      filename = filename && filename !== ''\n        ? filename\n        : (option.defaultFilename || 'noname');\n      const blob = new Blob([res.data], { type: contentType });\n      saveAs(blob, filename);\n    }\n\n    return Promise.resolve(res);\n  });\n```\n\n\napi.js使用实例：\n\n```\nimport axios, { download } from './http';\n\nexport const export = (data, defaultFilename) = download({\n  url: '/api//export',\n  method: 'post',\n  data,\n  defaultFilename\n})\n\n```\n\n\n## 封装一个axios的思路\n\n\n* 配置请求基本信息的常量：（用于基本处理）\n BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url\n TIMEOUT: 配置接口请求超时时间。\n headers： 配置请求头\n validateStatus: 定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。\n\n可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。\n\n>扩展：\n  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。\n\n* 请求拦截\n\n timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = \"ECONNABORTED\"，可以根据这个code提示超时报错信息。\n\n token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断\n\n other errors: 根据请求状态`status`,直接promise.reject.路由跳转到对应的报错页面。\n 根据请求头和method来处理入参的格式\n\n在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。\n因为params是添加到url的请求字符串中的，用于get请求。\n而data是添加到请求体（body）中的， 用于post请求。\n\n* 响应拦截\n badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip\n","slug":"asyncAwit","published":0,"updated":"2020-12-14T12:24:36.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiojazke0000o8p3ol2ppan0","content":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>\n<h5 id=\"async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\"><a href=\"#async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\" class=\"headerlink\" title=\"async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\"></a>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</h5><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class=\"line\">// 或者直接设置成基本变量：</span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<p>api.js使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api//export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>\n<h5 id=\"async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\"><a href=\"#async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。\" class=\"headerlink\" title=\"async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。\"></a>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</h5><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<h5 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>\n<ul>\n<li>http.js: 封装axios</li>\n<li>api.js: 用来统一管理接口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 在http.js中引入axios</span><br><span class=\"line\">import axios from &apos;axios&apos;; // 引入axios</span><br><span class=\"line\">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>\n<h5 id=\"环境的切换-gt-配置不同的baseURL\"><a href=\"#环境的切换-gt-配置不同的baseURL\" class=\"headerlink\" title=\"环境的切换-&gt;配置不同的baseURL\"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const baseURL_Map = &#123;</span><br><span class=\"line\">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class=\"line\">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class=\"line\">  product: &apos;https://www.production.com&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class=\"line\">// 或者直接设置成基本变量：</span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展：</p>\n<h6 id=\"process-env-NODE-ENV\"><a href=\"#process-env-NODE-ENV\" class=\"headerlink\" title=\"process.env.NODE_ENV\"></a>process.env.NODE_ENV</h6><ul>\n<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>\n<li>process.env属性返回一个包含用户环境信息的对象</li>\n<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>\n<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>\n</ul>\n<h5 id=\"设置请求超时变量\"><a href=\"#设置请求超时变量\" class=\"headerlink\" title=\"设置请求超时变量\"></a>设置请求超时变量</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class=\"line\"></span><br><span class=\"line\">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>\n<p>扩展： </p>\n<ul>\n<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>\n</ul>\n<h5 id=\"设置post请求头\"><a href=\"#设置post请求头\" class=\"headerlink\" title=\"设置post请求头\"></a>设置post请求头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>\n<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>\n<h5 id=\"定义HTTP响应状态码的范围\"><a href=\"#定义HTTP响应状态码的范围\" class=\"headerlink\" title=\"定义HTTP响应状态码的范围\"></a>定义HTTP响应状态码的范围</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 判断 HTTP 请求是否成功</span><br><span class=\"line\"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class=\"line\"> * @returns &#123;Boolean&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射-HTTP-错误时的提示语句\"><a href=\"#映射-HTTP-错误时的提示语句\" class=\"headerlink\" title=\"映射 HTTP 错误时的提示语句\"></a>映射 HTTP 错误时的提示语句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 映射 HTTP 错误时的提示语句</span><br><span class=\"line\"> * @param &#123;enhanceError&#125; error</span><br><span class=\"line\"> * @returns &#123;Object&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">const badStatusMap = error =&gt; (&#123;</span><br><span class=\"line\">  400: &apos;请求错误&apos;,</span><br><span class=\"line\">  401: &apos;未授权，请登录&apos;,</span><br><span class=\"line\">  403: &apos;拒绝访问&apos;,</span><br><span class=\"line\">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class=\"line\">  408: &apos;请求超时&apos;,</span><br><span class=\"line\">  500: &apos;服务器内部错误&apos;,</span><br><span class=\"line\">  501: &apos;服务未实现&apos;,</span><br><span class=\"line\">  502: &apos;网关错误&apos;,</span><br><span class=\"line\">  503: &apos;服务不可用&apos;,</span><br><span class=\"line\">  504: &apos;网关超时&apos;,</span><br><span class=\"line\">  505: &apos;HTTP版本不受支持&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"封装axios\"><a href=\"#封装axios\" class=\"headerlink\" title=\"封装axios\"></a>封装axios</h5><ul>\n<li>http.js<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * http.js</span><br><span class=\"line\"> * @param &#123;Object&#125; [globalOption]</span><br><span class=\"line\"> */</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  mergeWith, omit, isPlainObject</span><br><span class=\"line\">&#125; from &apos;lodash&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class=\"line\">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class=\"line\">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class=\"line\"> *  &apos;utils.merge&apos; in &apos;node_modules\\axios\\lib\\core\\Axios.js&apos;</span><br><span class=\"line\"> * @param &#123;any&#125; obj</span><br><span class=\"line\"> */</span><br><span class=\"line\">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class=\"line\">  if (!obj) return obj;</span><br><span class=\"line\">  if (obj instanceof Date) return obj.getTime();</span><br><span class=\"line\">  if (!isPlainObject(obj)) return obj;</span><br><span class=\"line\">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class=\"line\">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function axiosWrapper(globalOption) &#123;</span><br><span class=\"line\">  return function(option) &#123;</span><br><span class=\"line\">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class=\"line\">    option = mergeWith(&#123;</span><br><span class=\"line\">      baseURL: BASE_URL,</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class=\"line\">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      timeout: TIMEOUT,</span><br><span class=\"line\">      withCredentials: true,</span><br><span class=\"line\">      responseType: &apos;&apos;,</span><br><span class=\"line\">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class=\"line\"></span><br><span class=\"line\">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class=\"line\">    &#125;, globalOption, option);</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    if (option.data) &#123;</span><br><span class=\"line\">      option.data = fixAxiosDateMerge(option.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (option.params) &#123;</span><br><span class=\"line\">      option.params = fixAxiosDateMerge(option.params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const r = axios.create(option);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    // timeout</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class=\"line\">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class=\"line\">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // other errors // 跳转到对应的报错页面</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      config =&gt; config,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        const errorInfo = error.response;</span><br><span class=\"line\">        if (errorInfo) &#123;</span><br><span class=\"line\">          const errorStatus = errorInfo.status;</span><br><span class=\"line\">          router.push(&#123;</span><br><span class=\"line\">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // make data</span><br><span class=\"line\">    r.interceptors.request.use(</span><br><span class=\"line\">      (opt) =&gt; &#123;</span><br><span class=\"line\">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class=\"line\">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class=\"line\">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class=\"line\">        const sendJSON = opt.headers</span><br><span class=\"line\">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class=\"line\">          // 根据请求头和method来处理入参的格式</span><br><span class=\"line\">        if (needBody) &#123;</span><br><span class=\"line\">          opt.data = sendJSON</span><br><span class=\"line\">            ? JSON.stringify(params)</span><br><span class=\"line\">            : qs.stringify(params);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">          opt.params = params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return opt;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // bad HTTP request</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      response =&gt; response,</span><br><span class=\"line\">      (error) =&gt; &#123;</span><br><span class=\"line\">        if (error &amp;&amp; error.response) &#123;</span><br><span class=\"line\">          const &#123; status, statusText &#125; = error.response;</span><br><span class=\"line\">          if (isBadRequest(status)) &#123;</span><br><span class=\"line\">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \\n&apos;, status, error.response);</span><br><span class=\"line\">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class=\"line\">            if (!error.message) &#123;</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class=\"line\">              &#125; catch (ex) &#123;</span><br><span class=\"line\">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class=\"line\">            return Promise.reject(new Error(error.message));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Promise.reject(error);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    // check business logic</span><br><span class=\"line\">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class=\"line\">    r.interceptors.response.use(</span><br><span class=\"line\">      (response) =&gt; &#123;</span><br><span class=\"line\">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class=\"line\">          return response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class=\"line\">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class=\"line\">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class=\"line\">        const isValid = isValidCode(resData.errno);</span><br><span class=\"line\">        const method = response.config.method.toUpperCase();</span><br><span class=\"line\">        if (!isValid) &#123;</span><br><span class=\"line\">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class=\"line\">          return Promise.reject(&#123;</span><br><span class=\"line\">            type: ERR_CODE,</span><br><span class=\"line\">            reqURL,</span><br><span class=\"line\">            resData,</span><br><span class=\"line\">            noWarn,</span><br><span class=\"line\">            method</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class=\"line\">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class=\"line\">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class=\"line\">        return resData;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    // wrong business logic</span><br><span class=\"line\">    // r.interceptors.response.use(</span><br><span class=\"line\">    //   response =&gt; response,</span><br><span class=\"line\">    //   (error) =&gt; &#123;</span><br><span class=\"line\">    //     if (error.type === ERR_CODE) &#123;</span><br><span class=\"line\">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class=\"line\">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return Promise.reject(error.resData);</span><br><span class=\"line\">    //   &#125;</span><br><span class=\"line\">    // );</span><br><span class=\"line\"></span><br><span class=\"line\">    return r(option);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"简单的封装axios函数\"><a href=\"#简单的封装axios函数\" class=\"headerlink\" title=\"简单的封装axios函数\"></a>简单的封装axios函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 获得一般的 wrapper</span><br><span class=\"line\"> * @param &#123;Object&#125; [option]</span><br><span class=\"line\"> */</span><br><span class=\"line\"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class=\"line\">export default option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;)(option);</span><br></pre></td></tr></table></figure>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>\n<p>因为params是添加到url的请求字符串中的，用于get请求。</p>\n<p>而data是添加到请求体（body）中的， 用于post请求。</p>\n<p>api.js使用实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class=\"line\">export const mock = params =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/mock&apos;,</span><br><span class=\"line\">    method: &apos;get&apos;,</span><br><span class=\"line\">    params</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export const upload = data =&gt; axios(&#123;</span><br><span class=\"line\">    url: &apos;/upload&apos;,</span><br><span class=\"line\">    method: &apos;post&apos;,</span><br><span class=\"line\">    data</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"用于下载的axiosWrapper\"><a href=\"#用于下载的axiosWrapper\" class=\"headerlink\" title=\"用于下载的axiosWrapper\"></a>用于下载的axiosWrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class=\"line\">  responseType: &apos;arraybuffer&apos;</span><br><span class=\"line\">&#125;)(option)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class=\"line\">      const resData = res.data || res.request.response;</span><br><span class=\"line\">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class=\"line\">      const json = JSON.parse(text);</span><br><span class=\"line\">      return Promise.reject(json);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class=\"line\">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class=\"line\">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class=\"line\">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class=\"line\">        ? filename</span><br><span class=\"line\">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class=\"line\">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class=\"line\">      saveAs(blob, filename);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Promise.resolve(res);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>api.js使用实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">export const export = (data, defaultFilename) = download(&#123;</span><br><span class=\"line\">  url: &apos;/api//export&apos;,</span><br><span class=\"line\">  method: &apos;post&apos;,</span><br><span class=\"line\">  data,</span><br><span class=\"line\">  defaultFilename</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"封装一个axios的思路\"><a href=\"#封装一个axios的思路\" class=\"headerlink\" title=\"封装一个axios的思路\"></a>封装一个axios的思路</h2><ul>\n<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>\n</ul>\n<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>\n<blockquote>\n<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>\n</blockquote>\n<ul>\n<li><p>请求拦截</p>\n<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>\n<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>\n<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>\n</li>\n</ul>\n<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>\n<ul>\n<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>\n</ul>\n"},{"title":"v8","date":"2020-03-30T08:45:02.000Z","_content":"\n# v8引擎如何回收内存\n","source":"_drafts/v8.md","raw":"---\ntitle: v8\ndate: 2020-03-30 16:45:02\ntags:\n---\n\n# v8引擎如何回收内存\n","slug":"v8","published":0,"updated":"2020-12-14T12:21:10.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckiojazkj0001o8p397b589r2","content":"<h1 id=\"v8引擎如何回收内存\"><a href=\"#v8引擎如何回收内存\" class=\"headerlink\" title=\"v8引擎如何回收内存\"></a>v8引擎如何回收内存</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"v8引擎如何回收内存\"><a href=\"#v8引擎如何回收内存\" class=\"headerlink\" title=\"v8引擎如何回收内存\"></a>v8引擎如何回收内存</h1>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckioehjp8000278p3kank4rrn","tag_id":"ckioehjpr000578p3h0gv048l","_id":"ckioehjpw000978p30get69gf"},{"post_id":"ckioehjpw000a78p3x55hdanh","tag_id":"ckioehjq2000c78p3b3c8y8gk","_id":"ckioehjqb000g78p3xc7pnzvc"},{"post_id":"ckioehjqd000j78p3256dxgq1","tag_id":"ckioehjqg000l78p3c59l5aih","_id":"ckioehjqm000q78p3ctomkva1"},{"post_id":"ckioehjqh000m78p3c6fp0rhp","tag_id":"ckioehjqm000p78p311wrcui2","_id":"ckioehjqv000v78p3bbyebr2b"},{"post_id":"ckioehjqk000o78p38dgugfct","tag_id":"ckioehjqs000t78p319iyjaoq","_id":"ckioehjqx000y78p3yu2su13r"},{"post_id":"ckioehjqv000w78p3m704mlxd","tag_id":"ckioehjqx000z78p31d5as0ld","_id":"ckioehjr6001478p3pjgnyq59"},{"post_id":"ckioehjqw000x78p3gjme8y81","tag_id":"ckioehjr3001378p3p7y3dpp3","_id":"ckioehjr9001978p3tavorbxu"},{"post_id":"ckioehjr7001678p3m0elzhbs","tag_id":"ckioehjq2000c78p3b3c8y8gk","_id":"ckioehjrc001b78p3f8bbx1v3"},{"post_id":"ckioehjr8001878p34iit4jxk","tag_id":"ckioehjpr000578p3h0gv048l","_id":"ckioehjrd001e78p3qidbr8ku"},{"post_id":"ckioehjqy001078p3tveu0nvh","tag_id":"ckioehjr8001778p3mqr3one5","_id":"ckioehjre001g78p31gpw3oi8"},{"post_id":"ckioehjr2001278p3sabcpgfy","tag_id":"ckioehjrc001c78p3pfx5r8nt","_id":"ckioehjrg001j78p35we7d55a"},{"post_id":"ckioehjrd001f78p3o60l9bh2","tag_id":"ckioehjrc001c78p3pfx5r8nt","_id":"ckioehjrh001l78p367qjka16"},{"post_id":"ckioehjre001i78p308v9bbhx","tag_id":"ckioehjq2000c78p3b3c8y8gk","_id":"ckioehjrk001o78p35nl63k28"},{"post_id":"ckioehjr6001578p3qrwt5jfm","tag_id":"ckioehjre001h78p3501561h0","_id":"ckioehjrl001q78p3dpefkk5s"},{"post_id":"ckioehjrk001p78p3che37v2y","tag_id":"ckioehjpr000578p3h0gv048l","_id":"ckioehjrm001t78p3hu9u89ul"},{"post_id":"ckioehjrb001a78p32pc3okdl","tag_id":"ckioehjrk001n78p3u61nwiec","_id":"ckioehjrn001v78p3lgkqcqqc"},{"post_id":"ckioehjrc001d78p3862w65lp","tag_id":"ckioehjrm001s78p3k4hcknx6","_id":"ckioehjrs001z78p3thh1ejmf"},{"post_id":"ckioehjrq001y78p31nvq3kk4","tag_id":"ckioehjrm001s78p3k4hcknx6","_id":"ckioehjrt002278p35d7nr2tg"},{"post_id":"ckioehjrg001k78p3aavqsfpv","tag_id":"ckioehjrm001s78p3k4hcknx6","_id":"ckioehjru002478p3mcuwt5ah"},{"post_id":"ckioehjrs002078p3djo9j9mk","tag_id":"ckioehjqx000z78p31d5as0ld","_id":"ckioehjrv002678p3zmig45md"},{"post_id":"ckioehjri001m78p3guihpfz0","tag_id":"ckioehjrt002178p3xeumeigj","_id":"ckioehjrw002978p37c8778dg"},{"post_id":"ckioehjru002578p384o6339h","tag_id":"ckioehjrt002178p3xeumeigj","_id":"ckioehjrx002b78p3lxcfrz6z"},{"post_id":"ckioehjrv002878p39n9k15ey","tag_id":"ckioehjqx000z78p31d5as0ld","_id":"ckioehjs0002e78p3w3kj51pl"},{"post_id":"ckioehjrw002a78p3r62sou67","tag_id":"ckioehjqs000t78p319iyjaoq","_id":"ckioehjs2002g78p3zgy61c9x"},{"post_id":"ckioehjrl001r78p3ejxoug8v","tag_id":"ckioehjrv002778p3fege76mp","_id":"ckioehjs4002j78p3z1fesqji"},{"post_id":"ckioehjs0002f78p3edkaf99u","tag_id":"ckioehjrt002178p3xeumeigj","_id":"ckioehjs5002l78p3zl1c7qoa"},{"post_id":"ckioehjs4002k78p37fb5uo3i","tag_id":"ckioehjq2000c78p3b3c8y8gk","_id":"ckioehjs8002q78p3y33cf80v"},{"post_id":"ckioehjrt002378p3dk902e0o","tag_id":"ckioehjs3002i78p3ai2ddcqf","_id":"ckioehjs9002s78p3demmjjxg"},{"post_id":"ckioehjry002c78p3wkb181dv","tag_id":"ckioehjs7002n78p3b7706h58","_id":"ckioehjsa002u78p3ir2y5x6g"},{"post_id":"ckioehjsa002v78p3fw7qkhau","tag_id":"ckioehjs7002n78p3b7706h58","_id":"ckioehjsb002y78p37obygg29"},{"post_id":"ckioehjsc002z78p3befiyz2q","tag_id":"ckioehjrt002178p3xeumeigj","_id":"ckioehjsf003278p3wu9hlb9s"},{"post_id":"ckioehjs9002t78p3qv79xebr","tag_id":"ckioehjsb002w78p3ikg8rhrs","_id":"ckioehjsg003478p3rssiesin"},{"post_id":"ckioehjsd003078p3smjec5v9","tag_id":"ckioehjq2000c78p3b3c8y8gk","_id":"ckioehjsi003678p3hyaj9v46"},{"post_id":"ckioehjsf003378p3b2q2wjgb","tag_id":"ckioehjrt002178p3xeumeigj","_id":"ckioehjsi003778p3puacriqm"},{"post_id":"ckioehjsb002x78p361donsw7","tag_id":"ckioehjsf003178p382hpwm7e","_id":"ckioehjsi003878p3sxzyf64n"},{"post_id":"ckioehjsg003578p3ni5dvjds","tag_id":"ckioehjqm000p78p311wrcui2","_id":"ckioehjsj003978p3zasvxcq4"},{"post_id":"ckioehjs8002r78p3jtyur3np","tag_id":"ckioehjs7002n78p3b7706h58","_id":"ckioeo76v0000hkp326w896ed"},{"post_id":"ckioehjqt000u78p3n97a2qvs","tag_id":"ckioerem40000jkp3b4i9nv12","_id":"ckioerem50001jkp3k3semexa"},{"post_id":"ckioehjqn000s78p3ykr3z6ch","tag_id":"ckioerem40000jkp3b4i9nv12","_id":"ckioeynpg0000v8p36e38jrb3"},{"post_id":"ckioehjqm000r78p3vr4f7s7z","tag_id":"ckiof6pcb000b2ip3pzu6ivr7","_id":"ckiof6pcb000c2ip3hddn7y2l"},{"post_id":"ckioehjro001w78p3qh8o9cm9","tag_id":"ckioehjqx000z78p31d5as0ld","_id":"ckiofb0xu0005abp3u2p7892n"}],"Tag":[{"name":"node","_id":"ckioehjpr000578p3h0gv048l"},{"name":"前端面试题","_id":"ckioehjq2000c78p3b3c8y8gk"},{"name":"proxy","_id":"ckioehjqg000l78p3c59l5aih"},{"name":"web","_id":"ckioehjqm000p78p311wrcui2"},{"name":"js","_id":"ckioehjqs000t78p319iyjaoq"},{"name":"React","_id":"ckioehjqx000z78p31d5as0ld"},{"name":"es6, vue","_id":"ckioehjr3001378p3p7y3dpp3"},{"name":"Axios","_id":"ckioehjr8001778p3mqr3one5"},{"name":"blog-hexo","_id":"ckioehjrc001c78p3pfx5r8nt"},{"name":"git","_id":"ckioehjre001h78p3501561h0"},{"name":"css","_id":"ckioehjrk001n78p3u61nwiec"},{"name":"前端工程化","_id":"ckioehjrm001s78p3k4hcknx6"},{"name":"vue","_id":"ckioehjrt002178p3xeumeigj"},{"name":"npm","_id":"ckioehjrv002778p3fege76mp"},{"name":"npm react typescript","_id":"ckioehjrz002d78p31cpkvwob"},{"name":"es6","_id":"ckioehjs3002i78p3ai2ddcqf"},{"name":"Vue","_id":"ckioehjs7002n78p3b7706h58"},{"name":"vue, vueRouter","_id":"ckioehjsb002w78p3ikg8rhrs"},{"name":"vue test","_id":"ckioehjsf003178p382hpwm7e"},{"name":"Node","_id":"ckioerem40000jkp3b4i9nv12"},{"name":"plugin","_id":"ckiof4dcg00002ip3ws7lfak0"},{"name":"basic","_id":"ckiof4kw200022ip30rguajwi"},{"name":"Basic","_id":"ckiof4mbi00042ip3fe8fv7kx"},{"name":"B","_id":"ckiof4qpc00062ip33snxnvoq"},{"name":"software","_id":"ckiof6nu700092ip3q8b733nr"},{"name":"Software","_id":"ckiof6pcb000b2ip3pzu6ivr7"},{"name":"Reacr","_id":"ckiof9hly0000abp30621i87j"}]}}