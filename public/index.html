<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="blog">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ForwardReverseProxy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/20/ForwardReverseProxy/" class="article-date">
  <time datetime="2019-09-20T03:12:13.000Z" itemprop="datePublished">2019-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-20 11:12:13</p>
<h2 id="ForwardProxy"><a href="#ForwardProxy" class="headerlink" title="ForwardProxy"></a>ForwardProxy</h2><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。</span><br><span class="line"></span><br><span class="line">有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</span><br></pre></td></tr></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png" alt="ForwardProxy"></p>
<h6 id="正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。"><a href="#正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。" class="headerlink" title="正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。"></a>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。</h6><h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><ul>
<li>突破访问限制<br>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</li>
<li>提高访问速度<br>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>
<li>隐藏客户端真实IP<br>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</li>
</ul>
<h2 id="ReverseProxy"><a href="#ReverseProxy" class="headerlink" title="ReverseProxy"></a>ReverseProxy</h2><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于常用的场景，就是我们在Web开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。</span><br></pre></td></tr></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/612653/201902/612653-20190226142038241-1287539351.png" alt="ReverseProxy"></p>
<h6 id="反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。"><a href="#反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。" class="headerlink" title="反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。"></a>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。</h6><h4 id="用途：-1"><a href="#用途：-1" class="headerlink" title="用途："></a>用途：</h4><ul>
<li>负载均衡<br>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</li>
<li>提高访问速度<br>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</li>
<li>隐藏客户端真实IP<br>使用反向代理，可以对客户端隐藏服务器的IP地址。</li>
<li>提供安全保障<br>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/ForwardReverseProxy/" data-id="ck0rk0usn000dd8kclxowhgdv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-virtualDom" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/20/virtualDom/" class="article-date">
  <time datetime="2019-09-20T03:05:02.000Z" itemprop="datePublished">2019-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/20/virtualDom/">虚拟dom</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-20 11:05:02</p>
<h5 id="什么是虚拟DOM树？（Virtual-DOM）"><a href="#什么是虚拟DOM树？（Virtual-DOM）" class="headerlink" title="什么是虚拟DOM树？（Virtual DOM）"></a>什么是虚拟DOM树？（Virtual DOM）</h5><p>virtual，指的是对真实DOM的一种模拟。相对于直接操作真实的DOM结构，我们构建一棵虚拟的树，将各种数据和操作直接应用在这棵虚拟的树上，然后再将对虚拟的树的修改应用到真实的DOM结构上。<br>虚拟DOM树其实就是一个普通的js对象，它是用来描述一段HTML片段的</p>
<ul>
<li>当页面渲染的时候Vue会创建一颗虚拟DOM树</li>
<li>当页面发生改变Vue会再创建一颗新的虚拟DOM树</li>
<li>前后两颗新旧虚拟DOM树进行对比，Vue通过diff算法，去记录差异的地方</li>
<li>将有差异的地方更新到真实的DOM树中<h5 id="虚拟DOM树有什么用？"><a href="#虚拟DOM树有什么用？" class="headerlink" title="虚拟DOM树有什么用？　"></a>虚拟DOM树有什么用？　</h5>vue中的虚拟DOM树只会重新渲染页面修改的地方，大大减少了对真实DOM树的操作。 ——-虚拟DOM树是占内容的，但是可以帮我们提高DOM的性能。</li>
</ul>
<p>可以这样理解，虚拟DOM树是用空间(虚拟DOM树占空间)换时间(虚拟DOM树可以提高DOM效率)。</p>
<h5 id="Vue-v-for-中-key-到底有什么用？"><a href="#Vue-v-for-中-key-到底有什么用？" class="headerlink" title="Vue  v-for 中 :key 到底有什么用？"></a>Vue  v-for 中 :key 到底有什么用？</h5><p>vue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法。<br>key的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元</p>
<p>参考链接： <a href="https://www.cnblogs.com/javascript9527/p/11327924.html" target="_blank" rel="noopener">https://www.cnblogs.com/javascript9527/p/11327924.html</a></p>
<p>实现一个Virtual DOM算法参考链接： <a href="https://www.cnblogs.com/ssw-men/p/10818585.html" target="_blank" rel="noopener">https://www.cnblogs.com/ssw-men/p/10818585.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/virtualDom/" data-id="ck0rk0ut0000od8kc4y50ec0s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-axios" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/20/axios/" class="article-date">
  <time datetime="2019-09-20T02:50:39.000Z" itemprop="datePublished">2019-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/20/axios/">axios封装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>
<p><a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">axios文档地址</a></p>
<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是<code>axios</code>库，它是基于<code>promise</code>的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如<code>拦截请求和响应、取消请求、转换json、客户端防御cSRF</code>等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库.</p>
<p><code>本次封装以vue项目为例做实践。</code></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure>
<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>
<ul>
<li>http.js: 封装axios</li>
<li>api.js: 用来统一管理接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在http.js中引入axios</span><br><span class="line">import axios from &apos;axios&apos;; // 引入axios</span><br><span class="line">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>
<h5 id="环境的切换-gt-配置不同的baseURL"><a href="#环境的切换-gt-配置不同的baseURL" class="headerlink" title="环境的切换-&gt;配置不同的baseURL"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const baseURL_Map = &#123;</span><br><span class="line">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class="line">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class="line">  product: &apos;https://www.production.com&apos;</span><br><span class="line">&#125;</span><br><span class="line">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class="line">// 或者直接设置成基本变量：</span><br><span class="line">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>
<p>扩展：</p>
<h6 id="process-env-NODE-ENV"><a href="#process-env-NODE-ENV" class="headerlink" title="process.env.NODE_ENV"></a>process.env.NODE_ENV</h6><ul>
<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>
<li>process.env属性返回一个包含用户环境信息的对象</li>
<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>
<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>
</ul>
<h5 id="设置请求超时变量"><a href="#设置请求超时变量" class="headerlink" title="设置请求超时变量"></a>设置请求超时变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class="line"></span><br><span class="line">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>
<p>扩展： </p>
<ul>
<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>
</ul>
<h5 id="设置post请求头"><a href="#设置post请求头" class="headerlink" title="设置post请求头"></a>设置post请求头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>
<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>
<h5 id="定义HTTP响应状态码的范围"><a href="#定义HTTP响应状态码的范围" class="headerlink" title="定义HTTP响应状态码的范围"></a>定义HTTP响应状态码的范围</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断 HTTP 请求是否成功</span><br><span class="line"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class="line"> * @returns &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>
<h4 id="映射-HTTP-错误时的提示语句"><a href="#映射-HTTP-错误时的提示语句" class="headerlink" title="映射 HTTP 错误时的提示语句"></a>映射 HTTP 错误时的提示语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 映射 HTTP 错误时的提示语句</span><br><span class="line"> * @param &#123;enhanceError&#125; error</span><br><span class="line"> * @returns &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">const badStatusMap = error =&gt; (&#123;</span><br><span class="line">  400: &apos;请求错误&apos;,</span><br><span class="line">  401: &apos;未授权，请登录&apos;,</span><br><span class="line">  403: &apos;拒绝访问&apos;,</span><br><span class="line">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class="line">  408: &apos;请求超时&apos;,</span><br><span class="line">  500: &apos;服务器内部错误&apos;,</span><br><span class="line">  501: &apos;服务未实现&apos;,</span><br><span class="line">  502: &apos;网关错误&apos;,</span><br><span class="line">  503: &apos;服务不可用&apos;,</span><br><span class="line">  504: &apos;网关超时&apos;,</span><br><span class="line">  505: &apos;HTTP版本不受支持&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h5><ul>
<li>http.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * http.js</span><br><span class="line"> * @param &#123;Object&#125; [globalOption]</span><br><span class="line"> */</span><br><span class="line">import &#123;</span><br><span class="line">  mergeWith, omit, isPlainObject</span><br><span class="line">&#125; from &apos;lodash&apos;;</span><br><span class="line"></span><br><span class="line">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class="line">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class="line">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class="line"> *  &apos;utils.merge&apos; in &apos;node_modules\axios\lib\core\Axios.js&apos;</span><br><span class="line"> * @param &#123;any&#125; obj</span><br><span class="line"> */</span><br><span class="line">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class="line">  if (!obj) return obj;</span><br><span class="line">  if (obj instanceof Date) return obj.getTime();</span><br><span class="line">  if (!isPlainObject(obj)) return obj;</span><br><span class="line">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class="line">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function axiosWrapper(globalOption) &#123;</span><br><span class="line">  return function(option) &#123;</span><br><span class="line">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class="line">    option = mergeWith(&#123;</span><br><span class="line">      baseURL: BASE_URL,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      timeout: TIMEOUT,</span><br><span class="line">      withCredentials: true,</span><br><span class="line">      responseType: &apos;&apos;,</span><br><span class="line">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class="line"></span><br><span class="line">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class="line">    &#125;, globalOption, option);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    if (option.data) &#123;</span><br><span class="line">      option.data = fixAxiosDateMerge(option.data);</span><br><span class="line">    &#125;</span><br><span class="line">    if (option.params) &#123;</span><br><span class="line">      option.params = fixAxiosDateMerge(option.params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const r = axios.create(option);</span><br><span class="line">    </span><br><span class="line">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class="line"></span><br><span class="line">    // timeout</span><br><span class="line">    r.interceptors.request.use(</span><br><span class="line">      config =&gt; config,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class="line">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class="line">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // other errors // 跳转到对应的报错页面</span><br><span class="line">    r.interceptors.request.use(</span><br><span class="line">      config =&gt; config,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        const errorInfo = error.response;</span><br><span class="line">        if (errorInfo) &#123;</span><br><span class="line">          const errorStatus = errorInfo.status;</span><br><span class="line">          router.push(&#123;</span><br><span class="line">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // make data</span><br><span class="line">    r.interceptors.request.use(</span><br><span class="line">      (opt) =&gt; &#123;</span><br><span class="line">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class="line">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class="line">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class="line">        const sendJSON = opt.headers</span><br><span class="line">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class="line">          // 根据请求头和method来处理入参的格式</span><br><span class="line">        if (needBody) &#123;</span><br><span class="line">          opt.data = sendJSON</span><br><span class="line">            ? JSON.stringify(params)</span><br><span class="line">            : qs.stringify(params);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          opt.params = params;</span><br><span class="line">        &#125;</span><br><span class="line">        return opt;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // bad HTTP request</span><br><span class="line">    r.interceptors.response.use(</span><br><span class="line">      response =&gt; response,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        if (error &amp;&amp; error.response) &#123;</span><br><span class="line">          const &#123; status, statusText &#125; = error.response;</span><br><span class="line">          if (isBadRequest(status)) &#123;</span><br><span class="line">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \n&apos;, status, error.response);</span><br><span class="line">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class="line">            if (!error.message) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class="line">              &#125; catch (ex) &#123;</span><br><span class="line">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class="line">            return Promise.reject(new Error(error.message));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // check business logic</span><br><span class="line">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class="line">    r.interceptors.response.use(</span><br><span class="line">      (response) =&gt; &#123;</span><br><span class="line">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class="line">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class="line">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class="line">        const isValid = isValidCode(resData.errno);</span><br><span class="line">        const method = response.config.method.toUpperCase();</span><br><span class="line">        if (!isValid) &#123;</span><br><span class="line">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class="line">          return Promise.reject(&#123;</span><br><span class="line">            type: ERR_CODE,</span><br><span class="line">            reqURL,</span><br><span class="line">            resData,</span><br><span class="line">            noWarn,</span><br><span class="line">            method</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class="line">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class="line">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class="line">        return resData;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // wrong business logic</span><br><span class="line">    // r.interceptors.response.use(</span><br><span class="line">    //   response =&gt; response,</span><br><span class="line">    //   (error) =&gt; &#123;</span><br><span class="line">    //     if (error.type === ERR_CODE) &#123;</span><br><span class="line">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class="line">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return Promise.reject(error.resData);</span><br><span class="line">    //   &#125;</span><br><span class="line">    // );</span><br><span class="line"></span><br><span class="line">    return r(option);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="简单的封装axios函数"><a href="#简单的封装axios函数" class="headerlink" title="简单的封装axios函数"></a>简单的封装axios函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获得一般的 wrapper</span><br><span class="line"> * @param &#123;Object&#125; [option]</span><br><span class="line"> */</span><br><span class="line"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class="line">export default option =&gt; axiosWrapper(&#123;</span><br><span class="line">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class="line">  </span><br><span class="line">&#125;)(option);</span><br></pre></td></tr></table></figure>
<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>
<p>因为params是添加到url的请求字符串中的，用于get请求。</p>
<p>而data是添加到请求体（body）中的， 用于post请求。</p>
<p>api.js使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class="line">export const mock = params =&gt; axios(&#123;</span><br><span class="line">    url: &apos;/mock&apos;,</span><br><span class="line">    method: &apos;get&apos;,</span><br><span class="line">    params</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export const upload = data =&gt; axios(&#123;</span><br><span class="line">    url: &apos;/upload&apos;,</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="用于下载的axiosWrapper"><a href="#用于下载的axiosWrapper" class="headerlink" title="用于下载的axiosWrapper"></a>用于下载的axiosWrapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class="line">  responseType: &apos;arraybuffer&apos;</span><br><span class="line">&#125;)(option)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class="line"></span><br><span class="line">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class="line">      const resData = res.data || res.request.response;</span><br><span class="line">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class="line">      const json = JSON.parse(text);</span><br><span class="line">      return Promise.reject(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class="line">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class="line">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class="line">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class="line">        ? filename</span><br><span class="line">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class="line">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class="line">      saveAs(blob, filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Promise.resolve(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>api.js使用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class="line"></span><br><span class="line">export const export = (data, defaultFilename) = download(&#123;</span><br><span class="line">  url: &apos;/api//export&apos;,</span><br><span class="line">  method: &apos;post&apos;,</span><br><span class="line">  data,</span><br><span class="line">  defaultFilename</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="封装一个axios的思路"><a href="#封装一个axios的思路" class="headerlink" title="封装一个axios的思路"></a>封装一个axios的思路</h2><ul>
<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>
</ul>
<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>
<blockquote>
<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>
</blockquote>
<ul>
<li><p>请求拦截</p>
<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>
<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>
<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>
</li>
</ul>
<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>
<ul>
<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/axios/" data-id="ck0rk0utj0017d8kc0h0c42x0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6-vue/">es6, vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-web" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/web/" class="article-date">
  <time datetime="2019-09-19T12:53:29.000Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/web/">前端面试题汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="页面从输入URL到页面加载显示完成，这个过程中都发生了什么？"><a href="#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="页面从输入URL到页面加载显示完成，这个过程中都发生了什么？"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h5><h5 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h5><h5 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h5><h5 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h5><h5 id="cookies，sessionStorage-和-localStorage-的区别？"><a href="#cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="cookies，sessionStorage 和 localStorage 的区别？"></a>cookies，sessionStorage 和 localStorage 的区别？</h5><h5 id="页面访问cookie的限制条件"><a href="#页面访问cookie的限制条件" class="headerlink" title="页面访问cookie的限制条件"></a>页面访问cookie的限制条件</h5><h5 id="实现浏览器内多个标签页之间的通信"><a href="#实现浏览器内多个标签页之间的通信" class="headerlink" title="实现浏览器内多个标签页之间的通信"></a>实现浏览器内多个标签页之间的通信</h5><h5 id="页面可见性（Page-Visibility-API）-可以有哪些用途"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途"></a>页面可见性（Page Visibility API） 可以有哪些用途</h5><h5 id="网页验证码是做什么的，是为了解决什么安全问题"><a href="#网页验证码是做什么的，是为了解决什么安全问题" class="headerlink" title="网页验证码是做什么的，是为了解决什么安全问题"></a>网页验证码是做什么的，是为了解决什么安全问题</h5><h5 id="为什么利用多个域名来存储网站资源"><a href="#为什么利用多个域名来存储网站资源" class="headerlink" title="为什么利用多个域名来存储网站资源"></a>为什么利用多个域名来存储网站资源</h5><h5 id="一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"><a href="#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验" class="headerlink" title="一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h5><h5 id="以前端角度出发做好SEO（搜索引擎）需要考虑什么？"><a href="#以前端角度出发做好SEO（搜索引擎）需要考虑什么？" class="headerlink" title="以前端角度出发做好SEO（搜索引擎）需要考虑什么？"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h5><h5 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h5><h5 id="webSocket如何兼容低浏览器"><a href="#webSocket如何兼容低浏览器" class="headerlink" title="webSocket如何兼容低浏览器"></a>webSocket如何兼容低浏览器</h5><h5 id="web开发中会话跟踪的方法"><a href="#web开发中会话跟踪的方法" class="headerlink" title="web开发中会话跟踪的方法"></a>web开发中会话跟踪的方法</h5><h5 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h5><h5 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h5><h5 id="什么是同源：协议相同-域名相同-端口相同"><a href="#什么是同源：协议相同-域名相同-端口相同" class="headerlink" title="什么是同源：协议相同 域名相同 端口相同"></a>什么是同源：协议相同 域名相同 端口相同</h5><p>答案参考链接：<a href="https://lujinggirl.github.io/2019/09/02/webTitle/" target="_blank" rel="noopener">https://lujinggirl.github.io/2019/09/02/webTitle/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/web/" data-id="ck0rk0ut5000sd8kcvecsp7ae" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端面试题/">前端面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-css" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/css/" class="article-date">
  <time datetime="2019-09-19T12:53:19.000Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/css/">前端css相关面试题汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="什么是-BFC机制"><a href="#什么是-BFC机制" class="headerlink" title="什么是 BFC机制"></a>什么是 BFC机制</h5><h5 id="CSS3中新增的选择器以及属性"><a href="#CSS3中新增的选择器以及属性" class="headerlink" title="CSS3中新增的选择器以及属性"></a>CSS3中新增的选择器以及属性</h5><h5 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h5><h5 id="清除浮动有哪些方法-各有什么优缺点"><a href="#清除浮动有哪些方法-各有什么优缺点" class="headerlink" title="清除浮动有哪些方法, 各有什么优缺点"></a>清除浮动有哪些方法, 各有什么优缺点</h5><h5 id="用纯CSS创建一个三角形的原理是什么"><a href="#用纯CSS创建一个三角形的原理是什么" class="headerlink" title="用纯CSS创建一个三角形的原理是什么"></a>用纯CSS创建一个三角形的原理是什么</h5><h5 id="实现三栏布局有哪些方法-分别描述一下"><a href="#实现三栏布局有哪些方法-分别描述一下" class="headerlink" title="实现三栏布局有哪些方法, 分别描述一下"></a>实现三栏布局有哪些方法, 分别描述一下</h5><h5 id="css3实现0-5px的细线"><a href="#css3实现0-5px的细线" class="headerlink" title="css3实现0.5px的细线"></a>css3实现0.5px的细线</h5><h5 id="link-与-import-的区别"><a href="#link-与-import-的区别" class="headerlink" title="link 与 @import 的区别"></a>link 与 @import 的区别</h5><h5 id="开发中为什么要初始化css样式"><a href="#开发中为什么要初始化css样式" class="headerlink" title="开发中为什么要初始化css样式"></a>开发中为什么要初始化css样式</h5><p>答案参考链接：<a href="https://lujinggirl.github.io/2019/09/19/cssTitle/" target="_blank" rel="noopener">https://lujinggirl.github.io/2019/09/19/cssTitle/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/css/" data-id="ck0rk0uss000gd8kc9lhxrqcu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端面试题/">前端面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/vue/" class="article-date">
  <time datetime="2019-09-19T12:50:06.000Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/vue/">vue相关面试题汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="孙子组件或更深层次的组件通信（除了props和vuex的其他用法）"><a href="#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）" class="headerlink" title="孙子组件或更深层次的组件通信（除了props和vuex的其他用法）"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h5><h5 id="子组件访问父组件数据（除了props）"><a href="#子组件访问父组件数据（除了props）" class="headerlink" title="子组件访问父组件数据（除了props）"></a>子组件访问父组件数据（除了props）</h5><p>答案参考链接：<a href="https://lujinggirl.github.io/2019/09/03/vueTitle/" target="_blank" rel="noopener">https://lujinggirl.github.io/2019/09/03/vueTitle/</a></p>
<h5 id="new-Vue-做了什么？"><a href="#new-Vue-做了什么？" class="headerlink" title="new Vue()做了什么？"></a>new Vue()做了什么？</h5><h5 id="什么阶段才能访问DOM？"><a href="#什么阶段才能访问DOM？" class="headerlink" title="什么阶段才能访问DOM？"></a>什么阶段才能访问DOM？</h5><h5 id="谈谈你对Vue的生命周期的理解？"><a href="#谈谈你对Vue的生命周期的理解？" class="headerlink" title="谈谈你对Vue的生命周期的理解？"></a>谈谈你对Vue的生命周期的理解？</h5><h5 id="生命周期钩子的合并策略"><a href="#生命周期钩子的合并策略" class="headerlink" title="生命周期钩子的合并策略"></a>生命周期钩子的合并策略</h5><h5 id="新生命周期钩子：serverPrefetch是什么？"><a href="#新生命周期钩子：serverPrefetch是什么？" class="headerlink" title="新生命周期钩子：serverPrefetch是什么？"></a>新生命周期钩子：serverPrefetch是什么？</h5><h5 id="Vue-router-路由模式有几种？"><a href="#Vue-router-路由模式有几种？" class="headerlink" title="Vue-router 路由模式有几种？"></a>Vue-router 路由模式有几种？</h5><h5 id="谈谈你对keep-alive的了解"><a href="#谈谈你对keep-alive的了解" class="headerlink" title="谈谈你对keep-alive的了解"></a>谈谈你对keep-alive的了解</h5><h5 id="vue源码中内置的组件？"><a href="#vue源码中内置的组件？" class="headerlink" title="vue源码中内置的组件？"></a>vue源码中内置的组件？</h5><h5 id="了解Vue2-6-新全局API：Vue-observable-吗？"><a href="#了解Vue2-6-新全局API：Vue-observable-吗？" class="headerlink" title="了解Vue2.6+新全局API：Vue.observable()吗？"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h5><h5 id="了解Vue数据绑定原理？"><a href="#了解Vue数据绑定原理？" class="headerlink" title="了解Vue数据绑定原理？"></a>了解Vue数据绑定原理？</h5><p>答案参考链接：<a href="https://lujinggirl.github.io/2019/09/03/vueSourceCoding/" target="_blank" rel="noopener">https://lujinggirl.github.io/2019/09/03/vueSourceCoding/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/vue/" data-id="ck0rk0usz000md8kcmy7n1zgs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端面试题/">前端面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/js/" class="article-date">
  <time datetime="2019-09-19T12:45:32.000Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/js/">前端js相关面试题汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>答案参考链接：<a href="https://lujinggirl.github.io/2019/08/26/promise/" target="_blank" rel="noopener">https://lujinggirl.github.io/2019/08/26/promise/</a></p>
<h4 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h4><p>答案参考链接：<a href="https://lujinggirl.github.io/2019/08/21/JS-thread/" target="_blank" rel="noopener">https://lujinggirl.github.io/2019/08/21/JS-thread/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/js/" data-id="ck0rk0usv000id8kcpjtdk416" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端面试题/">前端面试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cssTitle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/19/cssTitle/" class="article-date">
  <time datetime="2019-09-19T03:27:51.000Z" itemprop="datePublished">2019-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/19/cssTitle/">css相关面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-19 15:46:24</p>
<h2 id="1-什么是-BFC机制"><a href="#1-什么是-BFC机制" class="headerlink" title="1.什么是 BFC机制"></a>1.什么是 BFC机制</h2><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>
<ul>
<li>触发条件 (以下任意一条)</li>
</ul>
<ol>
<li>float的值不为none</li>
<li>overflow的值不为visible</li>
<li>display的值为table-cell、tabble-caption和inline-block之一</li>
<li>position的值不为static或则releative中的任何一个<br><code>在IE下, Layout,可通过zoom:1 触发</code></li>
</ol>
<ul>
<li>BFC布局与普通文档流布局区别:</li>
</ul>
<h6 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则:"></a>BFC布局规则:</h6><ol>
<li>浮动的元素会被父级计算高度(父级元素触发了BFC)</li>
<li>非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了BFC)</li>
<li>margin不会传递给父级(父级触发BFC)</li>
<li>属于同一个BFC的两个相邻元素上下margin会重叠</li>
<li>普通文档流布局: 浮动的元素是不会被父级计算高度</li>
<li>非浮动元素会覆盖浮动元素的位置</li>
<li>margin会传递给父级元素</li>
<li>两个相邻元素上下的margin会重叠</li>
</ol>
<ul>
<li>开发中的应用</li>
</ul>
<ol>
<li>阻止margin重叠</li>
<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div都位于同一个 BFC 区域之中)</li>
<li>自适应两栏布局</li>
<li>可以阻止元素被浮动元素覆盖</li>
</ol>
<h2 id="2-CSS3中新增的选择器以及属性"><a href="#2-CSS3中新增的选择器以及属性" class="headerlink" title="2. CSS3中新增的选择器以及属性"></a>2. CSS3中新增的选择器以及属性</h2><ul>
<li>属性选择器</li>
</ul>
<table>
<thead>
<tr>
<th>属性选择器</th>
<th style="text-align:right">含义描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>E[att^=”val”]</td>
<td style="text-align:right">属性att的值以”val”开头的元素</td>
</tr>
<tr>
<td>E[att$=”val”]</td>
<td style="text-align:right">属性att的值以”val”结尾的元素</td>
</tr>
<tr>
<td>E[att*=”val”]</td>
<td style="text-align:right">属性att的值包含”val”字符串的元素</td>
</tr>
</tbody>
</table>
<ul>
<li>结构伪类选择器</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th style="text-align:right">含义描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>E:root</td>
<td style="text-align:right">匹配文档的根元素，对于HTML文档，就是HTML元素</td>
</tr>
<tr>
<td>E:nth-child(n)</td>
<td style="text-align:right">匹配其父元素的第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>E:nth-last-child(n)</td>
<td style="text-align:right">匹配其父元素的倒数第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td style="text-align:right">与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>E:nth-last-of-type(n)</td>
<td style="text-align:right">与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>E:last-child</td>
<td style="text-align:right">匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>
</tr>
<tr>
<td>E:first-of-type</td>
<td style="text-align:right">匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td style="text-align:right">匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>
</tr>
<tr>
<td>E:only-child</td>
<td style="text-align:right">匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>
</tr>
<tr>
<td>E:only-of-type</td>
<td style="text-align:right">匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>
</tr>
<tr>
<td>E:empty</td>
<td style="text-align:right">匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>
</tr>
</tbody>
</table>
<p>css3新增属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:right">含义描述</th>
<th style="text-align:right">兼容</th>
</tr>
</thead>
<tbody>
<tr>
<td>transition</td>
<td style="text-align:right">设置过渡效果</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>transform</td>
<td style="text-align:right">变换效果(移动、缩放、转动、拉长或拉伸)</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>animation</td>
<td style="text-align:right">动画效果</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>box-shadow</td>
<td style="text-align:right">阴影效果</td>
<td style="text-align:right">FF3.5, Safari 4, Chrome 3</td>
</tr>
<tr>
<td>text-shadow</td>
<td style="text-align:right">文本阴影</td>
<td style="text-align:right">FF 3.5, Opera 10, Safari 4, Chrome 3</td>
</tr>
<tr>
<td>border-colors</td>
<td style="text-align:right">为边框设置多种颜色</td>
<td style="text-align:right">FF3+</td>
</tr>
<tr>
<td>boder-image</td>
<td style="text-align:right">图片边框</td>
<td style="text-align:right">FF 3.5, Safari 4, Chrome 3</td>
</tr>
<tr>
<td>text-overflow</td>
<td style="text-align:right">文本截断</td>
<td style="text-align:right">IE6+, Safari4, Chrome3, Opera10</td>
</tr>
<tr>
<td>word-wrap</td>
<td style="text-align:right">自动换行</td>
<td style="text-align:right">IE6+, FF 3.5, Safari 4, Chrome 3</td>
</tr>
<tr>
<td>border-radius</td>
<td style="text-align:right">圆角边框</td>
<td style="text-align:right">FF 3+, Safari 4 , Chrome 3</td>
</tr>
<tr>
<td>opacity</td>
<td style="text-align:right">不透明度</td>
<td style="text-align:right">all</td>
</tr>
<tr>
<td>box-sizing</td>
<td style="text-align:right">控制盒模型的组成模式</td>
<td style="text-align:right">FF3+, Opera 10, Safari 4, Chrome 3</td>
</tr>
<tr>
<td>outline</td>
<td style="text-align:right">外边框</td>
<td style="text-align:right">FF3+, safari 4, chrome 3, opera 10</td>
</tr>
<tr>
<td>background-size</td>
<td style="text-align:right">不指定背景图片的尺寸</td>
<td style="text-align:right">safari 4, chrome 3, opera 10</td>
</tr>
<tr>
<td>background-origin</td>
<td style="text-align:right">指定背景图片从哪里开始显示</td>
<td style="text-align:right">safari 4, chrome 3, FF 3+</td>
</tr>
<tr>
<td>background-clip</td>
<td style="text-align:right">指定背景图片从什么位置开始裁切</td>
<td style="text-align:right">safari 4, chrome 3</td>
</tr>
<tr>
<td>rgba</td>
<td style="text-align:right">基于r,g,b三个颜色通道来设置颜色值, 通过a来设置透明度</td>
<td style="text-align:right">safari 4, chrome 3, FF3, opera 10</td>
</tr>
</tbody>
</table>
<h2 id="3-居中布局"><a href="#3-居中布局" class="headerlink" title="3. 居中布局"></a>3. 居中布局</h2><ul>
<li>水平居中</li>
</ul>
<ol>
<li>行内元素: text-align:center</li>
<li>块级元素: margin:0 auto</li>
<li>绝对定位和移动: absolute + transform</li>
<li>绝对定位和负边距: absolute + margin</li>
<li>flex布局: flex + justify-content:center</li>
</ol>
<ul>
<li>垂直居中</li>
</ul>
<ol>
<li>子元素为单行文本: line-height:height;<pre><code>absolute + transform;
flex + align-items:center;
table: display:table-cell; vertical-align: middle;
</code></pre></li>
<li>利用position和top和负margin</li>
</ol>
<ul>
<li>水平垂直居中</li>
</ul>
<ol>
<li><p>已知元素宽高:绝对定位+margin:auto:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> div&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: green;</span><br><span class="line"></span><br><span class="line">    position:absolute;</span><br><span class="line">    left:0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已知元素宽高:  绝对定位+负margin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> div&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background: green;</span><br><span class="line"></span><br><span class="line">    position:absolute;</span><br><span class="line">    left:0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>absolute+transform</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background: green;</span><br><span class="line"></span><br><span class="line">  position:absolute;</span><br><span class="line">  left:50%;    /* 定位父级的50% */</span><br><span class="line">  top:50%;</span><br><span class="line">  transform: translate(-50%,-50%); /*自己的50% */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4.flex + justify-content + align-items<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">   height:600px;</span><br><span class="line"></span><br><span class="line">   display:flex;</span><br><span class="line">   justify-content:center;  //子元素水平居中</span><br><span class="line">   align-items:center;      //子元素垂直居中</span><br><span class="line">     /* aa只要三句话就可以实现不定宽高水平垂直居中。*/</span><br><span class="line">    &#125;</span><br><span class="line">  .box&gt;div&#123;</span><br><span class="line">    background: green;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-清除浮动有哪些方法-各有什么优缺点"><a href="#4-清除浮动有哪些方法-各有什么优缺点" class="headerlink" title="4. 清除浮动有哪些方法, 各有什么优缺点"></a>4. 清除浮动有哪些方法, 各有什么优缺点</h2><ul>
<li>使用clear属性的空元素<br>在浮动元素后使用一个空元素如<div class="clear"></div>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用<br class="clear">或<hr class="clear">来进行清理。</li>
</ul>
<p>优点: 简单, 写少量代码, 兼容性也好 缺点: 添加无语义html元素, 不利于代码语义化, 后期维护成本大</p>
<ul>
<li>使用css的overflow属性<br>给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。</li>
</ul>
<p>优点: 简单, 代码少, 浏览器支持好 缺点: 不能和position配合使用, 因为超出的尺寸会被隐藏overflow:hidden</p>
<ul>
<li>使用CSS的:after伪元素 结合 :after 伪元素<br>（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个    clearfix 的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。</li>
</ul>
<p>优点: 浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点: 代码多，要两句代码结合使用，才能让主流浏览器都支持<br>给父级元素设置高度<br>简单, 代码少,好掌握 缺点: 只适用于高度固定的布局</p>
<h2 id="5-用纯CSS创建一个三角形的原理是什么"><a href="#5-用纯CSS创建一个三角形的原理是什么" class="headerlink" title="5. 用纯CSS创建一个三角形的原理是什么"></a>5. 用纯CSS创建一个三角形的原理是什么</h2><p>之前写三角形, 都是直接记住代码,没有探究原因,我也是直到有一次面试时,面试大哥让我说说css创建三角形的原理,我就……回来就赶紧翻资料.接下来我就将当时我理解的过程列举出来:</p>
<ol>
<li>写一个我们最熟悉的 border应用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">	width:100px;</span><br><span class="line">	height:100px;</span><br><span class="line">	border: 3px solid;</span><br><span class="line">	border-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>效果如下:</p>
<ol start="2">
<li>接下来,我们将border值增大<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">	width:100px;</span><br><span class="line">	height:100px;</span><br><span class="line">	border: 50px solid;</span><br><span class="line">	border-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>很容易发现, border渲染并不是正方形, 而是梯形的.</p>
<ol start="3">
<li>在增大border的基础下, 此时我们将盒子宽高变成0,会产生什么效果呢!<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">	width:0px;</span><br><span class="line">	height:0px;</span><br><span class="line">	border: 50px solid;</span><br><span class="line">	border-color:#1b93fb #1bfb24 #efad48 #ef4848;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>四个三角形拼合成的矩形呈现在我们眼前,那如如果我们只想要一个三角形, 我们是不是可以设想将其他三个设为不可见;</p>
<ol start="4">
<li>设置透明, 隐藏其中三个三角形<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> .box&#123;</span><br><span class="line">	width:0px;</span><br><span class="line">	height:0px;</span><br><span class="line">	border: 50px solid;</span><br><span class="line">	border-color:transparent transparent transparent #ef4848;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>三角形这样就出来, 有木有很简单, 当然我们也可以采用逆向思维来写这个效果, 就是先将所有边框设为透明, 然后需要哪边再对其设置颜色, 效果是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">	width:0px;</span><br><span class="line">	height:0px;</span><br><span class="line">	border: 50px solid transparent;</span><br><span class="line">	border-left:50px solid #ef4848;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样给面试你的人讲,讲明白应该不是问题., 重点就是要理解border的应用</p>
<h2 id="6-实现三栏布局有哪些方法-分别描述一下"><a href="#6-实现三栏布局有哪些方法-分别描述一下" class="headerlink" title="6. 实现三栏布局有哪些方法, 分别描述一下"></a>6. 实现三栏布局有哪些方法, 分别描述一下</h2><p>三栏布局，顾名思义就是两边固定，中间自适应。三栏布局在开发十分常见，那么什么是三栏布局？即左右模块固定宽度，中间模块随浏览器变化自适应，想要完成的最终效果如下图所示：下面列出四种实现方式, 在开发中可以根据实际需求选择适合自己的方法进行编码:</p>
<ul>
<li>Flex 布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background: #eee;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">   width: 200px;</span><br><span class="line">   background-color: red;</span><br><span class="line">   height: 100%;</span><br><span class="line"> &#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简单实用，现在比较流行的方案，但是需要考虑浏览器的兼容性。</p>
<ul>
<li>绝对定位布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  background:#eee;</span><br><span class="line">  height:200px;</span><br><span class="line">	&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">  height: 200px;</span><br><span class="line">  margin: 0 120px;</span><br><span class="line">  background-color: yellow;</span><br><span class="line">	&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  left: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  background-color: red;</span><br><span class="line">	&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: green;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;main&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">```* </span><br><span class="line">这种方案也简单实用, 并且可以将 &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;元素放到第一位,使得主要内容优先加载!</span><br><span class="line"></span><br><span class="line">双飞翼布局</span><br></pre></td></tr></table></figure>
</li>
</ul>
<style>
.content {
  float: left;
  width: 100%;
}
.main {
  height: 200px;
  margin-left: 110px;
  margin-right: 220px;
  background-color: yellow;
}
.left {
  float: left;
  height: 200px;
  width: 100px;
  margin-left: -100%;
  background-color: red;
}
.right {
  width: 200px;
  height: 200px;
  float: right;
  margin-left: -200px;
  background-color: green;
}    

</style>
<div class="content">
  <div class="main"></div>
</div>
<div class="left"></div>
<div class="right"></div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 圣杯布局</span><br></pre></td></tr></table></figure>

<style>
.container {
  margin-left: 120px;
  margin-right: 220px;
}
.main {
  float: left;
  width: 100%;
  height: 300px;
  background-color: yellow;
}
.left {
  float: left;
  width: 100px;
  height: 300px;
  margin-left: -100%;
  position: relative;
  left: -120px;
  background-color: blue;
}
.right {
  float: left;
  width: 200px;
  height: 300px;
  margin-left: -200px;
  position: relative;
  right: -220px;
  background-color: green;
}
</style>
<div class="container">
  <div class="main"></div>
  <div class="left"></div>
  <div class="right"></div>
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 7. css3实现0.5px的细线</span><br></pre></td></tr></table></figure>

<style>
.line {
    position: relative;
}
.line:after {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 1px;
    background-color: #000000;
    -webkit-transform: scaleY(.5);
    transform: scaleY(.5);
}
</style>

<p><div class="line"></div><br><code>`</code></p>
<h2 id="8-link-与-import-的区别"><a href="#8-link-与-import-的区别" class="headerlink" title="8. link 与 @import 的区别"></a>8. link 与 @import 的区别</h2><ul>
<li>从属关系区别<br>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等</li>
<li>加载顺序区别<br>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</li>
<li>兼容性区别<br>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。<br>DOM可控性区别<br>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于DOM方法是基于文档的，无法使用@import的方式插入样式。<br>css部分就整理到这里, 小伙伴们面试还有什么经常遇到的,可以在评论区给我留言, 我有时间就整理出来, IT(挨踢)都是一大家, 方便你我他<h2 id="9-开发中为什么要初始化css样式"><a href="#9-开发中为什么要初始化css样式" class="headerlink" title="9. 开发中为什么要初始化css样式"></a>9. 开发中为什么要初始化css样式</h2></li>
</ul>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<ol start="10">
<li>CSS优化、提高性能的方法有哪些</li>
</ol>
<p>尽量将样式写在单独的css文件里面，在head元素中引用 将代码写成单独的css文件有几点好处：</p>
<ul>
<li>内容和样式分离，易于管理和维护</li>
<li>减少页面体积</li>
<li>css文件可以被缓存、重用，维护成本降低</li>
<li>不使用@import</li>
<li>避免使用复杂的选择器，层级越少越好 建议选择器的嵌套最好不要超过三层，比如：<br>精简页面的样式文件，去掉不用的样式</li>
<li>利用CSS继承减少代码量</li>
<li>避免！important，可以选择其他选择器</li>
</ul>
<p>参考链接：<a href="http://www.pinlue.com/article/2019/05/2002/158990051021.html" target="_blank" rel="noopener">http://www.pinlue.com/article/2019/05/2002/158990051021.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/cssTitle/" data-id="ck0rk0utk0019d8kc80sbbi96" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vueTitle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/vueTitle/" class="article-date">
  <time datetime="2019-09-03T02:10:37.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/vueTitle/">vue相关面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-03 10:10:37</p>
<h3 id="孙子组件或更深层次的组件通信（除了props和vuex的其他用法）"><a href="#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）" class="headerlink" title="孙子组件或更深层次的组件通信（除了props和vuex的其他用法）"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h3><ul>
<li>Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h6>使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护<br>#####1.  父组件使用provide，子组件使用inject</li>
<li>通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.provide就相当于加强版父组件prop</span><br><span class="line">2.inject就相当于加强版子组件的props</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>// 示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&#123;&#123;name&#125;&#125;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &apos;father&apos;,</span><br><span class="line">  // 传入对象写法</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: &apos;bar&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  // 函数写法</span><br><span class="line">	provide () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &apos;foo&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 孙子组件或者深层次组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&#123;&#123;name&#125;&#125;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &apos;Grandson&apos;,</span><br><span class="line">	inject: [name]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>在任意层级都能访问，导致数据变化追踪比较困难。</p>
<h5 id="2-通过-attrs传递属性"><a href="#2-通过-attrs传递属性" class="headerlink" title="2.通过$attrs传递属性"></a>2.通过$attrs传递属性</h5><p>vue api解释说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.$attrs和inheritAttrs</span><br><span class="line">2.4.0 新增</span><br><span class="line">类型：&#123; [key: string]: string &#125;</span><br><span class="line">只读</span><br><span class="line">详细：</span><br><span class="line">包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</span><br></pre></td></tr></table></figure></p>
<p>细节使用示例参考链接：<a href="https://www.jianshu.com/p/ce8ca875c337" target="_blank" rel="noopener">https://www.jianshu.com/p/ce8ca875c337</a></p>
<h5 id="3-通过-listeners传递事件"><a href="#3-通过-listeners传递事件" class="headerlink" title="3.通过$listeners传递事件"></a>3.通过$listeners传递事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.$listeners</span><br><span class="line">2.4.0 新增</span><br><span class="line">类型：&#123; [key: string]: Function | Array&lt;Function&gt; &#125;</span><br><span class="line">只读</span><br><span class="line">详细：</span><br><span class="line">包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。</span><br></pre></td></tr></table></figure>
<h5 id="4-Vue2-6-新全局API：Vue-observable"><a href="#4-Vue2-6-新全局API：Vue-observable" class="headerlink" title="4.Vue2.6+新全局API：Vue.observable()"></a>4.Vue2.6+新全局API：Vue.observable()</h5><h3 id="子组件访问父组件数据（除了props）"><a href="#子组件访问父组件数据（除了props）" class="headerlink" title="子组件访问父组件数据（除了props）"></a>子组件访问父组件数据（除了props）</h3><ul>
<li>使用$parent属性</li>
<li>通过$attrs传递属性</li>
<li>Vue2.6+新全局API：Vue.observable()</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/03/vueTitle/" data-id="ck0rk0ut2000qd8kc8kf1igqa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vueSourceCoding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/vueSourceCoding/" class="article-date">
  <time datetime="2019-09-03T01:47:57.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/vueSourceCoding/">了解vue源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-03 09:47:57</p>
<h2 id="new-Vue-做了什么？"><a href="#new-Vue-做了什么？" class="headerlink" title="new Vue()做了什么？"></a>new Vue()做了什么？</h2><p>new关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是<br><code>/src/core/instance/index.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们跳转追踪至<code>this._init()</code>，即<code>Vue.prototype._init</code>,位于<code>src\core\instance\init.js</code>.<br>在<code>_init()</code>方法的内部有一系列 <code>init*</code> 的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // ...忽略，从第45行看起</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // expose real self</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &apos;created&apos;)</span><br><span class="line">    // ...忽略</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>统一概述一遍new Vue()时做了什么处理:</p>
<ul>
<li><code>initProxy</code>，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)</li>
<li><code>initLifecycle</code>（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。</li>
<li><code>initEvents</code>，用来存放除@hook:生命周期钩子名称=”绑定的函数”事件的对象。如:$on、$emit等。</li>
<li><code>initRender</code>，用于初始化$slots、$attrs、$listeners</li>
<li><code>initInjections</code>，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。</li>
<li><code>initState</code>，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。</li>
<li><code>initProvide</code>，初始化provide。</li>
<li><code>vm.$mount</code>，挂载实例。</li>
</ul>
<h2 id="什么阶段才能访问DOM？"><a href="#什么阶段才能访问DOM？" class="headerlink" title="什么阶段才能访问DOM？"></a>什么阶段才能访问DOM？</h2><p>这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">// 初始化 inject</span><br><span class="line">// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)</span><br><span class="line">// 初始化 provide</span><br><span class="line">callHook(vm, &apos;created&apos;)</span><br><span class="line">// 挂载实例 vm.$mount(vm.$options.el)</span><br><span class="line">// vue实例的数据对象data有了</span><br></pre></td></tr></table></figure></p>
<p>所以当面试官问你:</p>
<ul>
<li>beforeCreate以及 created 调用时，哪些数据能用与否？</li>
<li>什么阶段才能访问DOM？</li>
<li>为什么created之后才挂载实例？</li>
</ul>
<h2 id="谈谈你对Vue的生命周期的理解？"><a href="#谈谈你对Vue的生命周期的理解？" class="headerlink" title="谈谈你对Vue的生命周期的理解？"></a>谈谈你对Vue的生命周期的理解？</h2><p>生命周期函数解释说明（图片）：<a href="https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png" target="_blank" rel="noopener">https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png</a></p>
<h5 id="理解"><a href="#理解" class="headerlink" title="理解:"></a>理解:</h5><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会</p>
<h5 id="生命周期的几个阶段"><a href="#生命周期的几个阶段" class="headerlink" title="生命周期的几个阶段:"></a>生命周期的几个阶段:</h5><ol>
<li>created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁</li>
</ol>
<ul>
<li>beforeCreate &amp; created 看上一题</li>
<li><p>beforeMount &amp; mounted</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line">// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，</span><br><span class="line">callHook(vm, &apos;mounted&apos;)</span><br><span class="line">// vue实例挂载完成，data.message成功渲染</span><br></pre></td></tr></table></figure>
</li>
<li><p>beforeUpdate &amp; updated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data变化会触发beforeUpdate和updated方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>beforeDestroy &amp; destroyed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, &apos;destroyed&apos;)</span><br><span class="line">// data的改变不会再触发周期函数</span><br><span class="line">// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>深入理解源码:</p>
<ol start="2">
<li>Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// v2.6.10 最新版</span><br><span class="line">var LIFECYCLE_HOOKS = [</span><br><span class="line">    &apos;beforeCreate&apos;,</span><br><span class="line">    &apos;created&apos;,</span><br><span class="line">    &apos;beforeMount&apos;,</span><br><span class="line">    &apos;mounted&apos;,</span><br><span class="line">    &apos;beforeUpdate&apos;,</span><br><span class="line">    &apos;updated&apos;,</span><br><span class="line">    &apos;beforeDestroy&apos;,</span><br><span class="line">    &apos;destroyed&apos;,</span><br><span class="line">    &apos;activated&apos;,</span><br><span class="line">    &apos;deactivated&apos;,</span><br><span class="line">    &apos;errorCaptured&apos;,</span><br><span class="line">    // v2.6+ </span><br><span class="line">    &apos;serverPrefetch&apos; //看下一题</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>于是，你可以答多<code>activated &amp; deactivated</code>（keep-alive 组件激活/停用）、<code>errorCaptured</code>（v2.5 以上版本有的一个钩子，用于处理错误）这三个。</p>
<hr>
<h2 id="生命周期钩子的合并策略"><a href="#生命周期钩子的合并策略" class="headerlink" title="生命周期钩子的合并策略"></a>生命周期钩子的合并策略</h2><p><a href="https://www.cnblogs.com/xweizi/p/10572281.html" target="_blank" rel="noopener">https://www.cnblogs.com/xweizi/p/10572281.html</a></p>
<hr>
<p>单独抽出一天来处理</p>
<h2 id="新生命周期钩子：serverPrefetch是什么？"><a href="#新生命周期钩子：serverPrefetch是什么？" class="headerlink" title="新生命周期钩子：serverPrefetch是什么？"></a>新生命周期钩子：serverPrefetch是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// v2.6.10的变化</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>serverPrefetch</code>前身是<code>ssrPrefetch</code>。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。<br><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br>这里我们贴出一段官方例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Item.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-if=&quot;item&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-else&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    item () &#123;</span><br><span class="line">      return this.$store.state.items[this.$route.params.id]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  serverPrefetch () &#123;</span><br><span class="line">    return this.fetchItem()</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    if (!this.item) &#123;</span><br><span class="line">      this.fetchItem()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchItem () &#123;</span><br><span class="line">      // return the Promise from the action</span><br><span class="line">      return this.$store.dispatch(&apos;fetchItem&apos;, this.$route.params.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Vue-router-路由模式有几种？"><a href="#Vue-router-路由模式有几种？" class="headerlink" title="Vue-router 路由模式有几种？"></a>Vue-router 路由模式有几种？</h2><p>三种 “hash” | “history” | “abstract”，一般人只知道两种”hash” | “history”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 源码：</span><br><span class="line"></span><br><span class="line">switch (mode) &#123;</span><br><span class="line">  case &apos;history&apos;:</span><br><span class="line">    this.history = new HTML5History(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  case &apos;hash&apos;:</span><br><span class="line">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class="line">    break</span><br><span class="line">  case &apos;abstract&apos;:</span><br><span class="line">    this.history = new AbstractHistory(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  default:</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h5><ul>
<li>类型: string</li>
<li>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</li>
<li>可选值: “hash” | “history” | “abstract”</li>
</ul>
<p>配置路由模式:</p>
<ul>
<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</li>
<li>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</li>
<li>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h6 id="路由模式解析"><a href="#路由模式解析" class="headerlink" title="路由模式解析"></a>路由模式解析</h6><p>对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.</p>
<p>前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求<br><code>浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。
实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。
其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。</code></p>
<p>.</p>
<ul>
<li>vue-router: hash</li>
</ul>
<p>hash模式中url带有#号，修改成history模式，url中的#自动就去除了。</p>
<p>hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function(event)&#123;</span><br><span class="line">    console.log(event.oldURL, event.newURL);</span><br><span class="line">    let hash = location.hash.slice(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hash模式下，仅hash符号之前的内容会被包含在请求中,如 <a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a>, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.</p>
<ul>
<li>vue-router: history<br>随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。<br>　history api可以分为两大部分：切换和修改</li>
</ul>
<ol>
<li>切换历史状态</li>
</ol>
<p>包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.go(-2);//后退两次</span><br><span class="line">history.go(2);//前进两次</span><br><span class="line">history.back(); //后退</span><br><span class="line">hsitory.forward(); //前进</span><br></pre></td></tr></table></figure></p>
<p><code>坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，
有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页</code></p>
<ol start="2">
<li>修改历史状态<br>包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(stateObj，title，url)</span><br><span class="line">window.onpopstate = function(event)&#123;</span><br><span class="line">    console.log(event.state)</span><br><span class="line">    if(event.state &amp;&amp; event.state.color === &apos;red&apos;)&#123;</span><br><span class="line">        document.body.style.color = &apos;red&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</code></p>
<ol start="3">
<li>popstate实现history路由拦截，监听页面返回事件<br>当活动历史记录条目更改时，将触发popstate事件</li>
</ol>
<ul>
<li><p>如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。</p>
</li>
<li><p>需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；</p>
<p>　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）</p>
</li>
<li>vue-router: abstract<br>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</li>
</ul>
<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式</p>
<h2 id="谈谈你对keep-alive的了解"><a href="#谈谈你对keep-alive的了解" class="headerlink" title="谈谈你对keep-alive的了解"></a>谈谈你对keep-alive的了解</h2><p>先贴一个常规回答：<br>`<br>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>
<p><keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br>`</keep-alive></p>
<p><code>然后你可以开始骚了：</code></p>
<ol>
<li><p><code>&lt;keep-alive&gt;</code>是 Vue 源码中实现的一个全局抽象组件，通过自定义 <code>render</code> 函数并且利用了<code>插槽</code>来实现数据缓存和更新。它的定义在<code>src/core/components/keep-alive.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;keep-alive&apos;,</span><br><span class="line">  abstract: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">  // abstract 即 `ptions.abstract`</span><br><span class="line">  // while 循环查找第一个非抽象的父组件</span><br><span class="line">  while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">    parent = parent.$parent</span><br><span class="line">  &#125;</span><br><span class="line">  parent.$children.push(vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。</keep-alive></p>
<h2 id="vue源码中内置的组件？"><a href="#vue源码中内置的组件？" class="headerlink" title="vue源码中内置的组件？"></a>vue源码中内置的组件？</h2><ul>
<li>component</li>
<li>transition</li>
<li>transition-group</li>
<li>keep-alive</li>
<li>slot<h2 id="了解Vue2-6-新全局API：Vue-observable-吗？"><a href="#了解Vue2-6-新全局API：Vue-observable-吗？" class="headerlink" title="了解Vue2.6+新全局API：Vue.observable()吗？"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h2>Vue2.6+新的全局API是Vue.observable(),它的使用方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 准备个文件store.js - /store/store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">export const store = Vue.observable(&#123; count: 0 &#125;)  //定义一个变量</span><br><span class="line">export const mutations = &#123;  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值</span><br><span class="line">  setCount (count) &#123;</span><br><span class="line">    store.count = count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回的对象可以直接用于<code>渲染函数</code>和<code>计算属性</code>内，并且会在发生改变时触发相应的更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;你点+-，看我能不能根据状态去动态改变&lt;/p&gt;</span><br><span class="line">        &lt;label for=&quot;bookNum&quot;&gt;数量&lt;/label&gt;</span><br><span class="line">        &lt;button @click=&quot;setCount(count+1)&quot;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;setCount(count-1)&quot;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; store, mutations &#125; from &apos;../store/store&apos; // Vue2.6新增API Observable</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Add&apos;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return store.count //用于去渲染之前Observable中定义的变量count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setCount: mutations.setCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="了解Vue数据绑定原理？"><a href="#了解Vue数据绑定原理？" class="headerlink" title="了解Vue数据绑定原理？"></a>了解Vue数据绑定原理？</h2><p>参考Vue.js官网介绍响应式原理图，我们进行分析：</p>
<p>这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。<br>Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。</p>
<p>Vue在初始化组件数据时，在生命周期的<code>beforeCreate</code>与<code>created</code>钩子函数之间实现了对<code>data、props、computed、methods、events</code>以及<code>watch</code>的处理.</p>
<ul>
<li>initData<br>参考源码instance下的state.js文件</li>
</ul>
<p>initData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function initData (vm: Component) &#123;  </span><br><span class="line">  /*得到data数据*/</span><br><span class="line">  let data = vm.$options.data</span><br><span class="line">  data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; </span><br><span class="line">  /*判断是否是对象*/</span><br><span class="line">  if (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(&apos;data functions should return an object:\n&apos; +&apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm)</span><br><span class="line">  &#125;  </span><br><span class="line">  // proxy data on instance</span><br><span class="line">  /*遍历data对象*/</span><br><span class="line">  const keys = Object.keys(data)</span><br><span class="line">  const props = vm.$options.props</span><br><span class="line">  let i = keys.length</span><br><span class="line">  //遍历data中的数据</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class="line">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(`The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +`Use prop default value instead.`,vm)</span><br><span class="line">    &#125; else if (!isReserved(keys[i])) &#123;</span><br><span class="line">      /*判断是否是保留字段*/</span><br><span class="line">      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/</span><br><span class="line">      proxy(vm, `_data`, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // observe data</span><br><span class="line">  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  </span><br><span class="line">  observe(data, true /* asRootData */)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。</p>
<ul>
<li>proxy<br>接下来看一下proxy代理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*添加代理*/</span><br><span class="line">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class="line">  sharedPropertyDefinition.get = function proxyGetter () &#123;</span><br><span class="line">    return this[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = function proxySetter (val) &#123;</span><br><span class="line">    this[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。</p>
<ul>
<li>observe<br>参考源码文件在core文件下oberver的index.js文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> */</span><br><span class="line"> /*</span><br><span class="line"> 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。</span><br><span class="line"> */</span><br><span class="line">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class="line">  /*判断是否是一个对象*/</span><br><span class="line">  if (!isObject(value)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob: Observer | void</span><br><span class="line"></span><br><span class="line">  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/</span><br><span class="line">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; else if (</span><br><span class="line"></span><br><span class="line">    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/</span><br><span class="line">    observerState.shouldConvert &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    Object.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class="line"></span><br><span class="line">    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vue的响应式数据都会有一个<strong>ob</strong>的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。</p>
<ul>
<li>Observer<br>Observer的作用就是遍历对象的所有属性将其进行双向绑定。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Observer class that are attached to each observed</span><br><span class="line"> * object. Once attached, the observer converts target</span><br><span class="line"> * object&apos;s property keys into getter/setters that</span><br><span class="line"> * collect dependencies and dispatches updates.</span><br><span class="line"> */</span><br><span class="line">export class  &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; // number of vms that has this object as root $data</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16</span><br><span class="line">    */</span><br><span class="line">    def(value, &apos;__ob__&apos;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。</span><br><span class="line">          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。</span><br><span class="line">      */</span><br><span class="line">      const augment = hasProto</span><br><span class="line">        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/</span><br><span class="line">        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line"></span><br><span class="line">      /*如果是数组则需要遍历数组的每一个成员进行observe*/</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      /*如果是对象则直接walk进行绑定*/</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Walk through each property and convert them into</span><br><span class="line">   * getter/setters. This method should only be called when</span><br><span class="line">   * value type is Object.</span><br><span class="line">   */</span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line"></span><br><span class="line">    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    /*数组需要便利每一个成员进行observe*/</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。<br>如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。<br>但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？</p>
<p>Vue.js提供的方法是重写 <code>push、pop、shift、unshift、splice、sort、reverse</code>这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * not type checking this file because flow doesn&apos;t play well with</span><br><span class="line"> * dynamically accessing methods on Array prototype</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import &#123; def &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line">/*取得原生数组的原型*/</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span><br><span class="line">export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line"> /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/</span><br><span class="line">;[</span><br><span class="line">  &apos;push&apos;,</span><br><span class="line">  &apos;pop&apos;,</span><br><span class="line">  &apos;shift&apos;,</span><br><span class="line">  &apos;unshift&apos;,</span><br><span class="line">  &apos;splice&apos;,</span><br><span class="line">  &apos;sort&apos;,</span><br><span class="line">  &apos;reverse&apos;</span><br><span class="line">]</span><br><span class="line">.forEach(function (method) &#123;</span><br><span class="line">  // cache original method</span><br><span class="line">  /*将数组的原生方法缓存起来，后面要调用*/</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator () &#123;</span><br><span class="line">    // avoid leaking arguments:</span><br><span class="line">    // http://jsperf.com/closure-with-arguments</span><br><span class="line">    let i = arguments.length</span><br><span class="line">    const args = new Array(i)</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      args[i] = arguments[i]</span><br><span class="line">    &#125;</span><br><span class="line">    /*调用原生的数组方法*/</span><br><span class="line">    const result = original.apply(this, args)</span><br><span class="line"></span><br><span class="line">    /*数组新插入的元素需要重新进行observe才能响应式*/</span><br><span class="line">    const ob = this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &apos;push&apos;:</span><br><span class="line">        inserted = args</span><br><span class="line">        break</span><br><span class="line">      case &apos;unshift&apos;:</span><br><span class="line">        inserted = args</span><br><span class="line">        break</span><br><span class="line">      case &apos;splice&apos;:</span><br><span class="line">        inserted = args.slice(2)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted)</span><br><span class="line">      </span><br><span class="line">    // notify change</span><br><span class="line">    /*dep通知所有注册的观察者进行响应式处理*/</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持<strong>proto</strong>这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。</p>
<p>如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。</p>
<p>在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。</p>
<p>但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。</p>
<ul>
<li>Watcher</li>
</ul>
<p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">export default class Watcher &#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: ISet;</span><br><span class="line">  newDepIds: ISet;</span><br><span class="line">  getter: Function;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    /*_watchers存放订阅者实例*/</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    // options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep = !!options.deep</span><br><span class="line">      this.user = !!options.user</span><br><span class="line">      this.lazy = !!options.lazy</span><br><span class="line">      this.sync = !!options.sync</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.id = ++uid // uid for batching</span><br><span class="line">    this.active = true</span><br><span class="line">    this.dirty = this.lazy // for lazy watchers</span><br><span class="line">    this.deps = []</span><br><span class="line">    this.newDeps = []</span><br><span class="line">    this.depIds = new Set()</span><br><span class="line">    this.newDepIds = new Set()</span><br><span class="line">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &apos;&apos;</span><br><span class="line">    // parse expression for getter</span><br><span class="line">    /*把表达式expOrFn解析成getter*/</span><br><span class="line">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class="line">      this.getter = expOrFn</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter = parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter = function () &#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class="line">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class="line">          &apos;For full control, use a function instead.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   */</span><br><span class="line">   /*获得getter的值并且重新进行依赖收集*/</span><br><span class="line">  get () &#123;</span><br><span class="line">    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span><br><span class="line">    pushTarget(this)</span><br><span class="line">    let value</span><br><span class="line">    const vm = this.vm</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。</span><br><span class="line">      在将Dep.target设置为自生观察者实例以后，执行getter操作。</span><br><span class="line">      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，</span><br><span class="line">      那么在执行getter的时候就会触发a跟c两个数据的getter函数，</span><br><span class="line">      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，</span><br><span class="line">      将该观察者对象放入闭包中的Dep的subs中去。</span><br><span class="line">    */</span><br><span class="line">    if (this.user) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        value = this.getter.call(vm, vm)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      value = this.getter.call(vm, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    // &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">    // dependencies for deep watching</span><br><span class="line">    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span><br><span class="line">    if (this.deep) &#123;</span><br><span class="line">      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*将观察者实例从target栈中取出并设置给Dep.target*/</span><br><span class="line">    popTarget()</span><br><span class="line">    this.cleanupDeps()</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Add a dependency to this directive.</span><br><span class="line">   */</span><br><span class="line">   /*添加一个依赖关系到Deps集合中*/</span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    const id = dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Clean up for dependency collection.</span><br><span class="line">   */</span><br><span class="line">   /*清理依赖收集*/</span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    /*移除所有观察者对象*/</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      const dep = this.deps[i]</span><br><span class="line">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tmp = this.depIds</span><br><span class="line">    this.depIds = this.newDepIds</span><br><span class="line">    this.newDepIds = tmp</span><br><span class="line">    this.newDepIds.clear()</span><br><span class="line">    tmp = this.deps</span><br><span class="line">    this.deps = this.newDeps</span><br><span class="line">    this.newDeps = tmp</span><br><span class="line">    this.newDeps.length = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   */</span><br><span class="line">   /*</span><br><span class="line">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class="line">   */</span><br><span class="line">  update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      /*同步则执行run直接渲染视图*/</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Scheduler job interface.</span><br><span class="line">   * Will be called by the scheduler.</span><br><span class="line">   */</span><br><span class="line">   /*</span><br><span class="line">      调度者工作接口，将被调度者回调。</span><br><span class="line">    */</span><br><span class="line">  run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value = this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !== this.value ||</span><br><span class="line">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class="line">        // when the value is the same, because the value may</span><br><span class="line">        // have mutated.</span><br><span class="line">        /*</span><br><span class="line">            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。</span><br><span class="line">        */</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        // set new value</span><br><span class="line">        const oldValue = this.value</span><br><span class="line">        /*设置新的值*/</span><br><span class="line">        this.value = value</span><br><span class="line"></span><br><span class="line">        /*触发回调渲染视图*/</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            this.cb.call(this.vm, value, oldValue)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the value of the watcher.</span><br><span class="line">   * This only gets called for lazy watchers.</span><br><span class="line">   */</span><br><span class="line">   /*获取观察者的值*/</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    this.value = this.get()</span><br><span class="line">    this.dirty = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   */</span><br><span class="line">   /*收集该watcher的所有deps依赖*/</span><br><span class="line">  depend () &#123;</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class="line">   */</span><br><span class="line">   /*将自身从所有依赖收集订阅列表删除*/</span><br><span class="line">  teardown () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      // remove self from vm&apos;s watcher list</span><br><span class="line">      // this is a somewhat expensive operation so we skip it</span><br><span class="line">      // if the vm is being destroyed.</span><br><span class="line">      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/</span><br><span class="line">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(this.vm._watchers, this)</span><br><span class="line">      &#125;</span><br><span class="line">      let i = this.deps.length</span><br><span class="line">      while (i--) &#123;</span><br><span class="line">        this.deps[i].removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">      this.active = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Dep</li>
</ul>
<p>来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A dep is an observable that can have multiple</span><br><span class="line"> * directives subscribing to it.</span><br><span class="line"> */</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id = uid++</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*添加一个观察者对象*/</span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*移除一个观察者对象*/</span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*依赖收集，当存在Dep.target的时候添加观察者对象*/</span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*通知所有订阅者*/</span><br><span class="line">  notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// the current target watcher being evaluated.</span><br><span class="line">// this is globally unique because there could be only one</span><br><span class="line">// watcher being evaluated at any time.</span><br><span class="line">Dep.target = null</span><br><span class="line">/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/</span><br></pre></td></tr></table></figure>
<ul>
<li>defineReactive</li>
</ul>
<p>接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。<br>触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Define a reactive property on an Object.</span><br><span class="line"> */</span><br><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: Function</span><br><span class="line">) &#123;</span><br><span class="line">  /*在闭包中定义一个dep对象*/</span><br><span class="line">  const dep = new Dep()</span><br><span class="line"></span><br><span class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/</span><br><span class="line">  // cater for pre-defined getter/setters</span><br><span class="line">  const getter = property &amp;&amp; property.get</span><br><span class="line">  const setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  /*对象的子对象递归进行observe并返回子节点的Observer对象*/</span><br><span class="line">  let childOb = observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line"></span><br><span class="line">      /*如果原本对象拥有getter方法则执行*/</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line"></span><br><span class="line">        /*进行依赖收集*/</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line"></span><br><span class="line">          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        if (Array.isArray(value)) &#123;</span><br><span class="line"></span><br><span class="line">          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span><br><span class="line">          dependArray(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line"></span><br><span class="line">      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      /* eslint-disable no-self-compare */</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      /* eslint-enable no-self-compare */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      if (setter) &#123;</span><br><span class="line"></span><br><span class="line">        /*如果原本对象拥有setter方法则执行setter*/</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*新的值需要重新进行observe，保证数据响应式*/</span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line"></span><br><span class="line">      /*dep对象通知所有的观察者*/</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>整篇文章主要参考链接：<a href="https://juejin.im/post/5c959f74f265da610c068fa8" target="_blank" rel="noopener">https://juejin.im/post/5c959f74f265da610c068fa8</a><br>源码解析参考链接：<a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">https://github.com/answershuto/learnVue</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/03/vueSourceCoding/" data-id="ck0rk0uu7001rd8kcsxm5wfb5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog-hexo/">blog-hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6-vue/">es6, vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端面试题/">前端面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/blog-hexo/" style="font-size: 15px;">blog-hexo</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/es6-vue/" style="font-size: 10px;">es6, vue</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/前端面试题/" style="font-size: 20px;">前端面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/20/ForwardReverseProxy/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/09/20/virtualDom/">虚拟dom</a>
          </li>
        
          <li>
            <a href="/2019/09/20/axios/">axios封装</a>
          </li>
        
          <li>
            <a href="/2019/09/19/web/">前端面试题汇总</a>
          </li>
        
          <li>
            <a href="/2019/09/19/css/">前端css相关面试题汇总</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>