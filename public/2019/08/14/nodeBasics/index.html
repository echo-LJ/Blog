<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<!--<![endif]-->

<head>
  <title>node 基础知识 | Echo的博客</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Echo的博客">
    <meta name="author" content="John Doe">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Echo的博客" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
    
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    

    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->

  
  
  

  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close">
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/" target="_BLANK" class="animsition-link">AAA</a></li>
                    
                        <li><a href="/atom.xml" target="_BLANK" class="animsition-link">BBB</a></li>
                    
                </ul>
            </li>
            
            
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="http://go.kieran.top/" class="animsition-link">Kieran</a></li>
                    
                    <li><a href="http://domain.com/" class="animsition-link">Name</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Echo的博客</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->

</div>
      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2019-08-14T07:37:18.000Z" itemprop="datePublished">
          2019-08-14
      </time>
    
    
    | 
    <a href="/tags/node/">node</a>
    
    
</span>
                <h1>node 基础知识</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>
<h1 id="有助于理解前端工具的-node-知识"><a href="#有助于理解前端工具的-node-知识" class="headerlink" title="有助于理解前端工具的 node 知识"></a>有助于理解前端工具的 node 知识</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>
<h2 id="node-初识"><a href="#node-初识" class="headerlink" title="node 初识"></a>node 初识</h2><h4 id="node-是什么"><a href="#node-是什么" class="headerlink" title="node 是什么"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>
<h4 id="node-遵循的规范"><a href="#node-遵循的规范" class="headerlink" title="node 遵循的规范"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./module&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">&#125;</span><br><span class="line">exports.a = 1;</span><br></pre></td></tr></table></figure></p>
<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>
<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16ad4be6bc803f68.png"></p>
<h2 id="require-寻找依赖"><a href="#require-寻找依赖" class="headerlink" title="require 寻找依赖"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./module&apos;); // 带相对路径</span><br><span class="line">require(&apos;/module&apos;); // 带绝对路径</span><br><span class="line">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>
<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>
<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>
<h2 id="node-模块包装"><a href="#node-模块包装" class="headerlink" title="node 模块包装"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">    // module: 表示当前模块</span><br><span class="line">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class="line">    // __dirname: 当前模块的完整绝对路径</span><br><span class="line">    module.exports = exports = this = &#123;&#125;;</span><br><span class="line">    // 我们的代码就在这里...</span><br><span class="line">    return module.exports;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>
<h2 id="node-的应用场景"><a href="#node-的应用场景" class="headerlink" title="node 的应用场景"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>
<ul>
<li>自动化构建等工具</li>
<li>中间层</li>
<li>小项目</li>
</ul>
<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>
<h2 id="node-的优点"><a href="#node-的优点" class="headerlink" title="node 的优点"></a>node 的优点</h2><ul>
<li>适合前端大大们</li>
<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>
<li>性能较好（别人做过性能分析）</li>
</ul>
<h2 id="node-内置模块"><a href="#node-内置模块" class="headerlink" title="node 内置模块"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>
<h3 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// http.js</span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class="line">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class="line">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class="line">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class="line">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>
<h3 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs 文件系统"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class="line">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&apos;写入失败&apos;, err);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;写入成功&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 读取文件：fs.readFile(path, cb);</span><br><span class="line">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&apos;读取失败&apos;, err);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>
<h2 id="path-路径"><a href="#path-路径" class="headerlink" title="path 路径"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class="line">console.log(path.dirname(str)); // 路径</span><br><span class="line">// /root/a/b</span><br><span class="line">console.log(path.extname(str)); // 后缀名</span><br><span class="line">// .html</span><br><span class="line">console.log(path.basename(str)); // 文件名</span><br><span class="line">// index.html</span><br><span class="line"></span><br><span class="line">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class="line">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class="line"></span><br><span class="line">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class="line">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class="line"></span><br><span class="line">console.log(pathOne, pathTwo, __dirname);</span><br><span class="line">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class="line">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class="line">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>
<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>
<h3 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class="line">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class="line"></span><br><span class="line">console.log(pathname, query);</span><br><span class="line">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="querystring-查询字符串"><a href="#querystring-查询字符串" class="headerlink" title="querystring 查询字符串"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const querystring = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class="line">let obj = querystring.parse(query);</span><br><span class="line">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class="line"></span><br><span class="line">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class="line">obj = querystring.parse(query);</span><br><span class="line">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class="line">query = querystring.stringify(obj);</span><br><span class="line">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>
<h3 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert 断言"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// assert.js</span><br><span class="line">const assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class="line">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>
<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// assert.js</span><br><span class="line">const assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class="line">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class="line">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class="line">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class="line">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class="line">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class="line">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class="line">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class="line">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>
<h3 id="stream-流"><a href="#stream-流" class="headerlink" title="stream 流"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 读取流：fs.createReadStream();</span><br><span class="line">// 写入流：fs.createWriteStream();</span><br><span class="line">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class="line">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class="line"></span><br><span class="line">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class="line"></span><br><span class="line">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;成功&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>
<h3 id="zlib-压缩"><a href="#zlib-压缩" class="headerlink" title="zlib 压缩"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const zlib = require(&apos;zlib&apos;);</span><br><span class="line"></span><br><span class="line">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class="line">let gz = zlib.createGzip();</span><br><span class="line">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class="line"></span><br><span class="line">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class="line"></span><br><span class="line">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;成功&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href="https://juejin.im/post/5ccacfb96fb9a03201243cb9" target="_blank" rel="noopener">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="m-pagination col-md-8 col-md-offset-2 col-sm-24" role="pagination">
    
    <a class="pull-left" href="/2019/08/15/message-comp/" style="float: left;">
        ← 模拟element-ui写message组件思路
    </a>
    
    
    <a class="pull-right" href="/2019/07/26/npmBuild/">
        npm 部署自己的组件库 →
    </a>
    
</nav>

        <div class="col-md-8 col-md-offset-2 col-sm-24"><script type="text/javascript">
  /**
   * 搜狐畅言
   */

  /*
  document.write('<div id="SOHUCS" sid="' + window.location.pathname.slice(1) + '" ></div>');

  window.onload = function () {
    (function () {
      var appid = 'cytXXXX';
      var conf = 'prod_xxxxxxxxxxxxxxxxx';
      var width = window.innerWidth || document.documentElement.clientWidth;
      var loadJs = function (d, a, id) {
        var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
        var b = document.createElement("script");
        b.setAttribute("type", "text/javascript");
        b.setAttribute("charset", "UTF-8");
        b.setAttribute("src", d);
        if (id) {
          b.setAttribute("id", id);
        }
        if (typeof a === "function") {
          if (window.attachEvent) {
            b.onreadystatechange = function () {
              var e = b.readyState;
              if (e === "loaded" || e === "complete") {
                b.onreadystatechange = null;
                a()
              }
            }
          } else {
            b.onload = a
          }
        }
        c.appendChild(b)
      };

      loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
        window.changyan.api.config({
          appid: appid,
          conf: conf
        })
      });
    })();
  }
  */

</script>
</div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By John Doe. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://weibo.com/" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };

    resizeHero();

    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$('#intro').find('img').each(function(){
  var alt = this.alt;

  if (alt){
    $(this).after('<span class="caption" style="display:none">' + alt + '</span>');
  }

  $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox" rel="gallery" />');
});
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



      
</body>
</html>
