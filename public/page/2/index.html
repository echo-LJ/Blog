<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="blog">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Front-endEngineering" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/27/Front-endEngineering/" class="article-date">
  <time datetime="2020-05-27T06:55:06.000Z" itemprop="datePublished">2020-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/27/Front-endEngineering/">前端工程化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2020-05-27 14:55:06</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>web应用复杂度的增加，特别是单页面应用的风靡。组件化，工程化，自动化成了前端发展的趋势。<br>每个前端团队都在打造自己的前端开发体系，这通常是一个东拼西凑，逐渐磨合的过程，在技术发展日新月异的今天，这样的过程真的是不可抽象和复制的么？通过拆解前端开发体系,对前端工程化有所理解。</p>
<h1 id="I-前端工程化"><a href="#I-前端工程化" class="headerlink" title="I. 前端工程化"></a>I. 前端工程化</h1><hr>
<p>前端工程本质上是软件工程的一种。软件工程化关注的是性能、稳定性、可用性、可维护性等方面，注重基本的开发效率、运行效率的同时，思考维护效率。一切以这些为目标的工作都是”前端工程化”。</p>
<h6 id="前端工程化面临的问题"><a href="#前端工程化面临的问题" class="headerlink" title="前端工程化面临的问题 ?"></a>前端工程化面临的问题 ?</h6><ol>
<li><p>开发成本<br>大体量：多功能、多页面、多状态、多系统；<br>大规模：多人甚至多团队合作开发；</p>
<ul>
<li>提高开发生产效率</li>
<li>降低维护难度</li>
</ul>
</li>
</ol>
<p>这两个问题的解决方案有两点：</p>
<ul>
<li>制定开发规范，提高团队协作能力；</li>
<li>分治。软件工程中有个很重要的概念叫做<code>模块化开发</code>其中心思想就是分治。<ol start="2">
<li>部署<br>从部署角度，要解决的问题主要是资源管理，包括：</li>
</ol>
</li>
<li>代码审查</li>
<li>压缩打包</li>
<li>增量更新</li>
<li>单元测试</li>
</ul>
<ol start="3">
<li>高性能<br>CDN 部署、缓存控制、文件指纹、缓存复用、请求合并、按需加载、同步/异步加载、移动端首屏 CSS 内嵌、HTTP 2.0 服务端资源推送。<h6 id="如何做”前端工程化”？"><a href="#如何做”前端工程化”？" class="headerlink" title="如何做”前端工程化”？"></a>如何做”前端工程化”？</h6>前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从模块化、组件化、规范化、自动化四个方面思考。</li>
</ol>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><hr>
<blockquote>
<p>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。</p>
</blockquote>
<h6 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h6><p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。<br>现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。</p>
<ul>
<li>用 Webpack + Babel 将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；</li>
<li>用 System+Babel 主要是分模块异步加载；</li>
<li>用浏览器的<script type="module">加载。<h6 id="CSS的模块化"><a href="#CSS的模块化" class="headerlink" title="CSS的模块化"></a>CSS的模块化</h6>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</li>
</ul>
<p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p>
<p>为了避免全局选择器的冲突，需要制定CSS命名风格：</p>
<ul>
<li>BEM风格</li>
<li>Bootstrap风格</li>
<li>团队CSS规范</li>
</ul>
<p>但是这毕竟是弱约束。所以很赞同一句话：</p>
<blockquote>
<p>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</p>
</blockquote>
<p>从工具层面，社区又创造出<code>Shadow DOM</code>、<code>CSS in JS</code>和<code>CSS Modules</code>三种解决方案。</p>
<ul>
<li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li>
<li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li>
<li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的<code>scoped</code> style也算是一种。<h6 id="资源的模块化"><a href="#资源的模块化" class="headerlink" title="资源的模块化"></a>资源的模块化</h6>Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。</li>
<li><code>依赖关系单一化</code>。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li>
<li><code>资源处理集成化</code>。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；</li>
<li><code>项目结构清晰化</code>。使用Webpack后，你的项目结构总可以表示成这样的函数： <code>dest = webpack(src, config)</code>。<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3></li>
</ul>
<hr>
<p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p>
<blockquote>
<p><code>组件化≠模块化</code>。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p>
</blockquote>
<p>随着 web 应用规模越来越大，模块/组件化开发的需求就显得越来越迫切。模块/组件化开发的核心思想是分治，主要针对的是开发和维护阶段。</p>
<ol>
<li>Web 应用的组件化开发。<a href="http://blog.jobbole.com/56161/">http://blog.jobbole.com/56161/</a></li>
<li>前端组件化开发实践。<a href="http://web.jobbole.com/82689/">http://web.jobbole.com/82689/</a></li>
<li>大规模的前端组件化与模块化。<a href="http://www.infoq.com/cn/news/2014/04/front-end-modular">http://www.infoq.com/cn/news/…</a></li>
</ol>
<h6 id="为什么搭建私有组件库"><a href="#为什么搭建私有组件库" class="headerlink" title="为什么搭建私有组件库?"></a>为什么搭建私有组件库?</h6><ul>
<li>可复用 跨项目可以使用同一套私有组件库</li>
<li>方便维护 如需组件调整 只需要修改组件库 不需要跨项目重复修改</li>
</ul>
<h5 id="添加新组件原则"><a href="#添加新组件原则" class="headerlink" title="添加新组件原则"></a>添加新组件原则</h5><ul>
<li>组件应先存在于具体项目中，经过重复验证后再抽象、沉淀到本组件库中</li>
<li>Vue component 只应负责渲染数据和内部逻辑，尽可能不包含 &dollar;t 国际化、ajax 请求等业务数据和逻辑</li>
<li>组件和其他模块应尽可能的搭配单元测试、可运行的 storybook 例子</li>
<li>应该在 CHANGELOG 中记录每次增删改的组件信息等</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><hr>
<p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p>
<p>比如：</p>
<ul>
<li>######目录结构的制定</li>
<li>######编码规范<br>  制定一套良好的编码规范可以增强团队开发协作、提高代码质量。<br><code>推荐参考</code><br><strong>凹凸实验室</strong>打造的<a href="https://guide.aotu.io/docs/index.html">前端代码规范</a>。<br><strong>Javascript Airbnb</strong> 开发规范 <a href="https://github.com/airbnb/javascript">https://github.com/airbnb/jav…</a><ul>
<li>HTML规范</li>
<li>CSS规范</li>
<li>JS规范</li>
<li>图片规范</li>
<li>命名规范</li>
</ul>
</li>
<li><p>######前后端接口规范<br>“基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。</p>
<p>接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。</p>
</li>
<li><h6 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h6></li>
<li><h6 id="组件管理"><a href="#组件管理" class="headerlink" title="组件管理"></a>组件管理</h6></li>
<li><h6 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h6></li>
<li><h6 id="commit描述规范"><a href="#commit描述规范" class="headerlink" title="commit描述规范"></a>commit描述规范</h6></li>
<li><h6 id="定期-CodeReview"><a href="#定期-CodeReview" class="headerlink" title="定期 CodeReview"></a>定期 CodeReview</h6></li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><hr>
<p>   前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:</p>
<blockquote>
<p>任何简单机械的重复劳动都应该让机器去完成。</p>
</blockquote>
<ul>
<li><p>图标合并</p>
</li>
<li><p>持续继承</p>
</li>
<li><p>自动化构建</p>
</li>
<li><p>自动化部署</p>
</li>
<li><p>自动化测试</p>
</li>
</ul>
<h1 id="II-工程化具体方法"><a href="#II-工程化具体方法" class="headerlink" title="II. 工程化具体方法"></a>II. 工程化具体方法</h1><hr>
<h2 id="1-性能优化"><a href="#1-性能优化" class="headerlink" title="1. 性能优化"></a>1. 性能优化</h2><p>浏览器缓存是 Web 性能优化的重要方式。那么浏览器缓存的过程究竟是怎么样的呢？</p>
<p>浏览器缓存主要分为<code>强强缓存（也称本地缓存）</code>和<code>协商缓存（也称弱缓存）</code>。</p>
<p> ######强缓存</p>
<ul>
<li><p>Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。如我现在这个网页的 Expires 值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现 Cache-Control:max-age 和 Expires，那么 max-age 优先级更高。</p>
<ul>
<li>Cache-Control 是在 http1.1 中出现的，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 Cache-Control:max-age=3600，代表着资源的有效期是 3600 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</li>
</ul>
<p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>
<p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>
<p>public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。<br>private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。<br>Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候   Cache-Control 优先级高。<br>######弱缓存/协商缓存<br><strong>Etag 和 If-None-Match</strong></p>
</li>
</ul>
<p>Etag/If-None-Match 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If-None-Match 值来判断是否命中缓存</p>
<p>与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</p>
<p><strong>Last-Modify/If-Modify-Since</strong></p>
<p>浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间，例如 Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。</p>
<p>当浏览器再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</p>
<p>如果命中缓存，则返回 304，并且不会返回资源内容，并且不会返回 Last-Modify。</p>
<p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag</p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-c4678e7b6821f8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-4c9053e0fd74c93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="访问量和性能指标"><a href="#访问量和性能指标" class="headerlink" title="访问量和性能指标"></a>访问量和性能指标</h4><p>a.css 的请求，如果每次用户访问页面都要加载，很影响性能，很浪费带宽</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-41104d7c231d27e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<p>利用 304，让浏览器使用本地缓存。304 叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-2fd0094493df3b08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>强制浏览器使用本地缓存（cache-control/expires），不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？</p>
<p>很好，相信有人想到了办法：通过<code>更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源</code>。好像这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-577a64c93602bf2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="`"></p>
<p>页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css，c.css 的缓存也失效，那岂不是又有浪费了？！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-c3a7badbd331fd6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>重新开启变态模式，我们不难发现，要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。</p>
<p>什么东西与文件内容相关呢？我们会很自然的联想到利用  <code>数据摘要算法</code> 对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把 url 改成带摘要信息的：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-027cf303a23fc22f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到 CDN 节点上，网页中引用的资源也会变成对应的部署路径：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-ae5c4239f5b12df1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这次发布，同时改了页面结构和样式，也更新了静态资源对应的 url 地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-f05ceb812e53f51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><strong>先部署页面，再部署资源</strong>：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。</li>
<li><strong>先部署资源，再部署页面</strong>：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。</li>
</ul>
<hr>
<p>好的，上面一坨分析想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。<br>有些公司超变态，没有这样的“绝对低峰期”，只有“相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！</p>
<p>这个奇葩问题，起源于资源的 覆盖式发布，用 待发布资源 覆盖 已发布资源，就有这种问题。解决它也好办，就是实现 非覆盖式发布。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-3f21dab466192813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。</p>
<hr>
<p>所以，静态资源优化方案，基本上要实现这么几个东西：</p>
<p>配置超长时间的本地缓存 —— 节省带宽，提高性能<br>采用内容摘要作为缓存更新依据 —— 精确的缓存控制<br>静态资源 CDN 部署 —— 优化网络请求<br>更资源发布路径实现非覆盖式发布 —— 平滑升级</p>
<h2 id="总之，前端性能优化绝逼是一个工程问题！"><a href="#总之，前端性能优化绝逼是一个工程问题！" class="headerlink" title="总之，前端性能优化绝逼是一个工程问题！"></a>总之，前端性能优化绝逼是一个工程问题！</h2><h2 id="2-静态资源部署-CDN"><a href="#2-静态资源部署-CDN" class="headerlink" title="2. 静态资源部署 CDN"></a>2. 静态资源部署 CDN</h2><p>CDN[Content Delivery Network] 内容分发网络 主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容<br><img src="https://upload-images.jianshu.io/upload_images/11846892-80610fe2d3c9090e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>总结一下 CDN 的工作原理：通过权威 DNS 服务器来实现最优节点的选择，通过缓存来减少源站的压力。</p>
<hr>
<p>CDN 应用场景：</p>
<p>静态网页<br>图片小文件、博客<br>大文件下载<br>软件下载、视频点播或图片存储网站<br>动态加速<br>直播网站<br>应用加速<br>手机 APP<br>除却 CDN 自身的优势，在前端工程中，将静态文件放到 CDN 上，可以直观地减小资源包大小，同时加快首屏加载。</p>
<p>若不使用 CDN，则所有的资源都会被打包到 app.js 和 vendor.js 中，页面需要等到这两个包下载完成才可以显示。<br>若使用 CDN，则可以利用浏览器多线程的优势，同时下载若干静态文件以及剩下的 app.js 和 vendor.js，以此达到加快加载的目的。</p>
<hr>
<h3 id="3-自动化文档生成"><a href="#3-自动化文档生成" class="headerlink" title="3. 自动化文档生成"></a>3. 自动化文档生成</h3><p><code>commit message</code> 作用</p>
<ul>
<li>提供更多的历史信息，方便快速浏览</li>
<li>过滤某些 commit（比如文档改动），便于快速查找信息</li>
<li>直接从 commit 生成 Change log</li>
<li>可读性好，清晰，不必深入看代码即可了解当前 commit 的作用。</li>
<li>为 Code Reviewing（代码审查）做准备</li>
<li>方便跟踪工程历史</li>
<li>提高项目的整体质量，提高个人工程素质</li>
</ul>
<p>目前，社区有多种 Commit message 的写法规范，我们介绍的工具是 commitizen，它使用的是 Angular 规范<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">AngularJS Git Commit Message Conventions</a>，这是目前使用最广的写法，并且有对应的工具去生成 change log。</p>
<p><strong>标准说明</strong></p>
<p>每次提交， Commit message 都包括 Header, Body 和 Footer 三个部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Header</strong> 部分只有一行，包括三个字段：type, scope 和 subject 。<br>type 用于说明提交的类别，只运行使用下面几种，</p>
<ul>
<li>feat: 新功能</li>
<li>fix: 修复 bug</li>
<li>docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等等</li>
<li>style: 格式更新（不影响代码运行的变动）</li>
<li>refactor: 重构（既不是新增功能，又不是 bug 修复）</li>
<li>test: 添加测试</li>
<li>chore: 构建过程或辅助工具的变动</li>
<li>perf: 优化相关，比如提升性能、体验</li>
<li>revert: 回滚到上一个版本</li>
<li>ci：自动化流程配置修改</li>
</ul>
<p>如果是 feat 和 fix ，则这个 commit 将肯定出现在 change log 中，其它情况可自行决定是否放入。</p>
<p>scope 用于说明 commit 影响的范围 比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>subject 是 commit 目的的简短描述，不超过 50 个字符。</p>
<ul>
<li>以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes</li>
<li>第一个字母小写</li>
<li>结尾不要加句号</li>
</ul>
<hr>
<p><strong>Body</strong> 部分是对本次 commit 的详细描述，可分成多行。但是一般我都不写。</p>
<p><strong>Footer</strong> 部分只用于两种情况。</p>
<p>不兼容变动</p>
<p>如果当前代码与上一个版本不兼容，则 Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BREAKING CHANGE: isolate scope bindings definition has changed.</span><br><span class="line"></span><br><span class="line">    To migrate the code follow the example below:</span><br><span class="line"></span><br><span class="line">    Before:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &apos;attribute&apos;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    After:</span><br><span class="line"></span><br><span class="line">    scope: &#123;</span><br><span class="line">      myAttr: &apos;@&apos;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</span><br></pre></td></tr></table></figure>
<hr>
<p>关闭 Issue<br>如果当前 commit 针对某个 issue ，那么可以在 Footer 部分关闭这个 issue 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #1234</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #1234, $1235, #1236</span><br></pre></td></tr></table></figure>
<p><strong>Revert</strong></p>
<p>如果当前 commit 用于撤销以前的 commit，则必须以 revert:开头，后面跟着被撤销 Commit 的 Header</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &apos;graphiteWidth&apos; option</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure>
<ul>
<li>Body 部分的格式是固定的，必须写成 This reverts commit .，其中的 hash 是被撤销 commit 的 SHA 标识符。</li>
<li>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 Reverts 小标题下面。</li>
</ul>
<hr>
<h5 id="自动生成-changelog-文档"><a href="#自动生成-changelog-文档" class="headerlink" title="自动生成 changelog 文档"></a>自动生成 changelog 文档</h5><h6 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h6><p>Commitizen 是一个撰写合格 Commit message 的工具。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen</span><br><span class="line"># 在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。</span><br><span class="line">commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure>
<p>用 git cz -m 代替 git commit -m 就可以轻松的写出 Angular 规范的 commit message 了。</p>
<h6 id="validate-commit-msg"><a href="#validate-commit-msg" class="headerlink" title="validate-commit-msg"></a>validate-commit-msg</h6><p>用于检查 Node 项目的 Commit message 是否符合格式。</p>
<h6 id="conventional-changelog"><a href="#conventional-changelog" class="headerlink" title="conventional-changelog"></a>conventional-changelog</h6><p>生成 Change log 的工具，运行下面的命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog-cli</span><br><span class="line">cd my-project</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -s</span><br></pre></td></tr></table></figure>
<hr>
<p>如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成</p>
<p>生成的文档包括以下三个部分。</p>
<ul>
<li>New features</li>
<li>Bug fixes</li>
<li>Breaking changes.</li>
</ul>
<p>每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p>
<p>为了方便使用，可以将其写入 package.json 的 scripts 字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run changelog</span><br></pre></td></tr></table></figure>
<h3 id="4-前端埋点"><a href="#4-前端埋点" class="headerlink" title="4. 前端埋点"></a>4. 前端埋点</h3><p><strong>目的</strong><br>获取用户基本信息、行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向。<br><strong>前端监控类别</strong><br>前端监控可以分为三类：数据监控、性能监控和异常监控。<br><code>数据监控</code>就是监听用户信息和行为，常见的监控项有</p>
<p>*PV(page view 页面访问量)：即页面浏览量或点击量</p>
<ul>
<li>UV(unique visitor 独立访客)：指访问某个站点或点击某条新闻的不同 IP 地址的人数</li>
<li>用户在每一个页面的停留时间</li>
<li>用户通过什么入口来访问该网页</li>
<li>用户在相应的页面中触发的行为<br>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</li>
</ul>
<p><code>性能监控</code>指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控项包括：</p>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>http 等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间<br>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</li>
</ul>
<p><code>异常监控</code>由于产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 try catch 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>
<ul>
<li>Javascript 的异常监控</li>
<li>样式丢失的异常监控</li>
<li>服务器请求的异常监控<br>我们说完了前端监控的三个分类，现在就来聊聊怎么实现前端监控。实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台，最后进行数据分析。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。</li>
</ul>
<hr>
<p>#####前端埋点分类</p>
<p>收集监控数据我们是通过前端埋点来实现的，目前常见的前端埋点方法有三种：<code></code>手动埋点<code>、</code>可视化埋点<code>和</code>无埋点`。<br><strong>手动埋点</strong>，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像友盟、百度统计等第三方数据统计服务商大都采用这种方案。<br>优势:</p>
<ul>
<li>可自定义属性，自定义事件<ul>
<li>可以细化需求</li>
<li>相比其他埋点方式减少服务器压力</li>
</ul>
</li>
</ul>
<p>缺陷:</p>
<ul>
<li>工程量大的话，手动埋点会出现疏漏，不方便审查。</li>
<li>需求变更要重新埋点，成本高。</li>
<li>每次需求变更都要重新发布版本，对线上系统稳定性有一定危害</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(() =&gt; &#123;</span><br><span class="line">  // ... 这里是你的业务逻辑代码</span><br><span class="line">  sendData(params) //这里是发送你的埋点数据，params是你封装的埋点数据</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>前端框架式手动埋点</strong></p>
<p>如果使用 Vue 或者 React 等前端框架，这些框架都有自己的各种生命周期，为了减少重复性的手动埋点次数，可以在各个生命周期位置，根据你的需求封装你所需的埋点。比如你是 SPA 单页应用，你希望在每一个页面的 componentDidMount 埋点，并由此确定用户已经打开了页面。</p>
<p>css 埋点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.link:active::after &#123;</span><br><span class="line">  content: url(&apos;http://www.example.com?action=yourdata&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;a class=&quot;link&quot;&gt;点击我，会发埋点数据&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>可视化埋点</strong>解决了纯手动埋点的开发成本和更新成本，通过可视化工具快速配置采集节点（圈点），在前端自动解析配置，并根据配置上传埋点数据，比起手动埋点看起来更无痕，</p>
<p>比如国外比较早做可视化的是 Mixpanel，国内较早支持可视化埋点的有 TalkingData、诸葛 IO，2017 年腾讯的 MTA 也宣布支持可视化埋点；</p>
<hr>
<p><strong>无埋点</strong>则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>
<p>优点:<br>前端只要一次加载埋点脚本</p>
<p>缺点:<br>服务器性能压力山大</p>
<p>采用无埋点技术的有主流的 GrowingIO、神策。无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。</p>
<h2 id="VI-总结"><a href="#VI-总结" class="headerlink" title="#VI. 总结"></a>#VI. 总结</h2><p>在业界内有这么一句话：任何简单机械的重复劳动都应该让机器去完成。现代前端技术不再是以前刀耕火种的年代了。所以前端工程化的很多脏活累活都应该交给自动化工具来完成。</p>
<p>如何选型技术、如何定制规范、如何分治系统、如何优化性能、如何加载资源，当你从切图开始转变为思考这些问题的时候，我想说：</p>
<p>你好，工程师！</p>
<p>参考链接：</p>
<ol>
<li><a href="https://www.jianshu.com/p/88ed70476adb">前端工程化的理解</a></li>
<li><a href="[https://www.zhihu.com/question/20790576/answer/32602154]">大公司里怎样开发和部署前端代码？</a></li>
<li><a href="http://www.imooc.com/article/27151">前端埋点的那些事</a></li>
<li><a href="https://www.jianshu.com/p/645a26619508">小谈前端埋点</a></li>
<li><a href="https://github.com/fouber/blog/issues/10">前端工程——基础篇</a></li>
<li><a href="https://www.jianshu.com/p/a248b146c55a">http-proxy-middleware</a></li>
<li><a href="https://www.jianshu.com/p/3bdff821f859">Webpack dev server 使用 http-proxy 解决跨域问题</a></li>
<li><a href="https://github.com/chimurai/http-proxy-middleware">chimurai/http-proxy-middleware</a></li>
<li><a href="https://www.jb51.net/article/137608.htm">详解 webpack-dev-server 的简单使用</a></li>
<li><a href="https://github.com/jantimon/html-webpack-plugin">html-webpack-plugin</a></li>
<li><a href="https://www.jianshu.com/p/9248db0349fb">webpack 使用 HtmlWebpackPlugin 进行 cdn 配置</a></li>
<li><a href="https://blog.csdn.net/const_ly/article/details/79788728">CDN 是什么？使用 CDN 有什么优势？</a></li>
<li><a href="https://www.codercto.com/a/76835.html">webpack4-06-开发、生产环境、动态 CDN 配置</a></li>
<li><a href="https://segmentfault.com/a/1190000008956069">HTTP 强缓存和协商缓存</a></li>
<li><a href="https://www.jianshu.com/p/1744780ddda0">Cache-Control 之 no-cache 和 max-age=0</a></li>
<li><a href="https://segmentfault.com/a/1190000019579621">Commit message 代码提交规范</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南</a></li>
<li><a href="https://www.cnblogs.com/zivxiaowei/p/10089201.html">git commit 、CHANGELOG 和版本发布的标准自动化</a></li>
</ol>
</script></li></ul>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/27/Front-endEngineering/" data-id="ckd4b4q0u000jt2p39z79p2mz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ssr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/19/ssr/" class="article-date">
  <time datetime="2020-05-19T03:13:15.000Z" itemprop="datePublished">2020-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/19/ssr/">搭建Vue的SSR服务端渲染</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2020-05-19 11:13:15</p>
<h2 id="SSR是什么"><a href="#SSR是什么" class="headerlink" title="SSR是什么"></a>SSR是什么</h2><hr>
<p><code>SSR</code>：Server Side Rendering<br>服务端渲染，由服务器进行渲染并返回给客户端渲染完成的html</p>
<ul>
<li>优点<br>超快的响应速度<br>易做SEO</li>
<li>缺点<br>增加服务器压力</li>
<li>主流框架<br>Next.js —— React的SSR方案<br>Nuxt.js —— Vue的SSR方案<h3 id="SPA是什么"><a href="#SPA是什么" class="headerlink" title="SPA是什么"></a>SPA是什么</h3></li>
</ul>
<hr>
<p>SPA：single page application<br>按照字面意思就是单页面应用，通俗点就是整个网站由一个html页面构成。</p>
<h6 id="传统的vue-react项目纯浏览器渲染步骤"><a href="#传统的vue-react项目纯浏览器渲染步骤" class="headerlink" title="传统的vue/react项目纯浏览器渲染步骤"></a>传统的vue/react项目纯浏览器渲染步骤</h6><ol>
<li>浏览器输入url  -&gt; 发送请求到服务器</li>
<li>服务器接收到请求 -&gt; 发送项目的index.html + app.bundle.js文件给浏览器</li>
<li>浏览器执行js,生成dom，渲染dom,发送请求，接收请求，解析数据，操作数据，重新渲染</li>
</ol>
<ul>
<li>SPA缺点 </li>
</ul>
<ol>
<li>如果没有进行异步请求，首屏加载过慢。（因为要一次性加载多种依赖和包）<br>2.缺少SEO， 难以进行搜索引擎优化（对于爬虫来说，它仅仅获取到了2个标签，而没有页面真实呈现内容的信息）</li>
<li>性能问题</li>
</ol>
<ul>
<li>SPA优点</li>
</ul>
<ol>
<li>带来接近原生的体验</li>
<li>前后端分离</li>
<li>服务器压力小 响应速度快</li>
</ol>
<h6 id="进行ssr的vue-react项目浏览器渲染步骤"><a href="#进行ssr的vue-react项目浏览器渲染步骤" class="headerlink" title="进行ssr的vue/react项目浏览器渲染步骤"></a>进行ssr的vue/react项目浏览器渲染步骤</h6><ol>
<li>浏览器输入url  -&gt; 发送请求到服务器</li>
<li>服务器(node服务)接收到请求 -&gt; 解析对应的js文件，生成对应的html-&gt;发送给浏览器</li>
<li>浏览器接收并渲染html</li>
</ol>
<h2 id="SSR需要哪些配置"><a href="#SSR需要哪些配置" class="headerlink" title="SSR需要哪些配置"></a>SSR需要哪些配置</h2><p><img src="https://upload-images.jianshu.io/upload_images/11846892-5d9692de712dd7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="搭建Vue的SSR服务端渲染"><a href="#搭建Vue的SSR服务端渲染" class="headerlink" title="搭建Vue的SSR服务端渲染"></a>搭建Vue的SSR服务端渲染</h4><hr>
<p>在vue项目过中安装vue-server-renderer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $ npm i vue-server-renderer</span><br><span class="line">$ npm i server</span><br></pre></td></tr></table></figure></p>
<p>在vue项目中创建server.js文件<br>server.js文件的内容为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/* server.js */</span><br><span class="line">const Vue = require(&apos;vue&apos;);</span><br><span class="line">const server = require(&apos;express&apos;)();</span><br><span class="line">const renderer = require(&apos;vue-server-renderer&apos;).createRenderer();</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">function createApp(url) &#123;</span><br><span class="line">  if (url == &apos;/&apos;) &#123;</span><br><span class="line">    url = &apos;/index&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  let json = fs.readFileSync(`json$&#123;url&#125;.json`,&apos;utf_8&apos;);</span><br><span class="line">  let template = fs.readFileSync(`template$&#123;url&#125;.html`,&apos;utf_8&apos;);</span><br><span class="line">  return new Vue(&#123;</span><br><span class="line">    template: template,</span><br><span class="line">    data: JSON.parse(json).data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 响应路由请求</span><br><span class="line">server.get(&apos;*&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  if (req.url !==&apos;/favicon.ico&apos;) &#123;</span><br><span class="line">    const app = createApp(req.url);</span><br><span class="line">    renderer.renderToString(app, (err, html) =&gt; &#123;</span><br><span class="line">      if (err) &#123; return res.state(500).end(&apos;运行时错误&apos;) &#125;</span><br><span class="line">      res.send(html);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 服务器监听地址</span><br><span class="line">server.listen(8080, () =&gt; &#123;</span><br><span class="line">    console.log(&apos;服务器已启动！&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>目录结构<br><img src="https://upload-images.jianshu.io/upload_images/11846892-73a701ecb005919f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/11846892-7853336351f039c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* index.js */</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &#123;&#123;a&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">/* index.json */</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;&quot;a&quot;: 1&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br></pre></td></tr></table></figure></p>
<p>打开浏览器，地址栏输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:8080</span><br></pre></td></tr></table></figure>
<p>我们可以看到，页面加载成功<br><img src="https://upload-images.jianshu.io/upload_images/11846892-94029c331dae155a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/11846892-106520d374bea6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="对原有的Vue项目改造成SSR"><a href="#对原有的Vue项目改造成SSR" class="headerlink" title="对原有的Vue项目改造成SSR"></a>对原有的Vue项目改造成SSR</h4><hr>
<ol>
<li>在src文件下新建<code>server.js</code> + <code>client.js</code></li>
<li>在根目录下新建<code>index.ssr.html</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* index.ssr.html*/</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 注意⚠️！！！⬇️下面注释不能少：如果没有，服务器就不知道将生成好的html代码插在什么位置--&gt;</span><br><span class="line">  &lt;!--vue-ssr-outlet--&gt;</span><br><span class="line">  &lt;script type=&quot;text/javescript&quot; src=&quot;&lt;%= htmlWebpackPlugin.options.files.js %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对router部分进行改造</li>
</ol>
<ul>
<li>将路由改造成方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// export default router;</span><br><span class="line">export function createRouter()&#123;</span><br><span class="line">  return new VueRouter(&#123;</span><br><span class="line">    mode: &quot;history&quot;,</span><br><span class="line">    base: process.env.BASE_URL,</span><br><span class="line">    routes</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>对main.js进行改造</li>
</ol>
<ul>
<li>引入createRouter</li>
<li>将main.js改造成方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import App from &quot;./App.vue&quot;;</span><br><span class="line">// import router from &quot;./router&quot;;</span><br><span class="line">import &#123; createRouter &#125; from &quot;./router&quot;;</span><br><span class="line">const router = createRouter();</span><br><span class="line">// new Vue(&#123;</span><br><span class="line">//   router,</span><br><span class="line">//   store,</span><br><span class="line">//   render: h =&gt; h(App)</span><br><span class="line">// &#125;).$mount(&quot;#app&quot;);</span><br><span class="line">export function createApp()&#123;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">  &#125;);</span><br><span class="line">  return &#123;app, router&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong> 为什么将main.js和router改造成方法？ 回答：方便调用！</strong></p>
<ol start="5">
<li><p>server.js<br>由于sever.js是在服务端运行，我们将代码形成node格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;./main&quot;;</span><br><span class="line">// context = req (服务端的request)</span><br><span class="line">export function context=&gt;&#123;</span><br><span class="line">  return new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">    const &#123;app, router&#125; = createApp();</span><br><span class="line">    // 将当前的请求路径添加到路由表中，</span><br><span class="line">    router.push(context.url);</span><br><span class="line">    router.onReady(() =&gt; &#123;</span><br><span class="line">      const matchCcmponents = router.getMatchedComponents(path);</span><br><span class="line">      if (!matchCcmponents.length) &#123;</span><br><span class="line">        return reject(&#123;code: 404&#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(app)</span><br><span class="line">    &#125;, reject);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>client.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;./main&quot;;</span><br><span class="line">const &#123;app, router&#125; = createApp();</span><br><span class="line">router.onReady(() =&gt; &#123;</span><br><span class="line">  // 手动挂载;</span><br><span class="line">  app.$mount(&apos;#app&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在build新建<code>webpack.buildclinet.js</code>+<code>webpack.buildserver.js</code></p>
</li>
<li>webpack.buildserver.js<br><code>webpack.buildserver.js</code>类似于<code>webpack.prod.conf.js</code><br>对部分内容进行改造：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var VueSSRServerPlugin = require(&apos;vue-server-renderer/server-plugin&apos;)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/server.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 打包之后的结果是在服务端运行的。</span><br><span class="line">  target: &apos;node&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 打包之后的文件的模块化规范，遵循node的模块化规范</span><br><span class="line">    libraryTarget: &quot;commonjs2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">   new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &apos;index.srr.html&apos;,</span><br><span class="line">      template: &apos;index.srr.html&apos;,</span><br><span class="line">      inject: true,</span><br><span class="line">      files: &#123;</span><br><span class="line">        js: &apos;app.js&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">     // 注意⚠️！！！删除掉压缩部分配置代码⬇️：为什么不能压缩，看第2步的解释（你能找到解释么？嘿嘿）！</span><br><span class="line">      // minify: &#123;</span><br><span class="line">        //removeComments: true,</span><br><span class="line">         //collapseWhitespace: true,</span><br><span class="line">        //removeAttributeQuotes: true</span><br><span class="line">      //&#125;,</span><br><span class="line">      chunksSortMode: &apos;dependency&apos;</span><br><span class="line">   &#125;),</span><br><span class="line">  plugins: [</span><br><span class="line">    // 插件作用：对服务端代码进行打包</span><br><span class="line">    new VueSSRServerPlugin(),</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>
<ol start="9">
<li><p>webpack.buildclient.js<br><code>webpack.buildclient.js</code>类似于<code>webpack.prod.conf.js</code><br>对部分内容进行改造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var VueSSRClientPlugin = require(&apos;vue-server-renderer/client-plugin&apos;)</span><br><span class="line"></span><br><span class="line">// 指定entry,传统SPA打包配置文件没有entry,打包时是使用webpack.base.conf.js + webpack.prod.conf.js合并之后的entry</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/client.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">// 注意⚠️！！！删掉出口配置output:</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    // 插件作用：对客户端代码进行打包</span><br><span class="line">    new VueSSRClientPlugin(),</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加打包命令</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;build:client&quot;: &quot;webpack --config build/webpack.buildclient.js&quot;</span><br><span class="line">&quot;build:server&quot;: &quot;webpack --config build/webpack.buildserver.js&quot;</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>执行打包命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build:server</span><br><span class="line">$ npm run build:client</span><br></pre></td></tr></table></figure>
<p>打包之后结果<br><img src="https://upload-images.jianshu.io/upload_images/11846892-c96aecf8bdcde96c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/11846892-2bcceeefe888efaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="12-编写server"><a href="#12-编写server" class="headerlink" title="12 编写server"></a>12 编写server</h2><ul>
<li>在根目录下新建server文件夹 + <code>server.js</code><br>server.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const server = express();</span><br><span class="line">const &#123;createBundleRenderer&#125; = require(&apos;vue-server-renderder&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const serverBundle = require(path.resolve(__dirname, &apos;../dist/vue-ssr-server-bundle.json&apos;));</span><br><span class="line">const clientManifest = require(path.resolve(__dirname, &apos;../dist/vue-ssr-client-manifest.json&apos;));</span><br><span class="line">const template= fs.readFileSync(path.resolve(__dirname, &apos;..dist/index.ssr.html&apos;), &apos;utf-8&apos;);</span><br><span class="line">// 打包出来的json的作用：通知服务器如何分割js,部分js用于客户端执行，部分js用于服务端运行。</span><br><span class="line">const renderer = createBundleRenderer(serverBundle,&#123;</span><br><span class="line">  runInNewContext: false,</span><br><span class="line">  template:template,</span><br><span class="line">  clientManifest:clientManifest</span><br><span class="line">&#125;);</span><br><span class="line">// 设置静态目录，以dist文件夹为静态目录，dist文件夹在服务开始之后可以访问</span><br><span class="line">server.use(express.static(path.resolve(__dirname, &apos;../dist&apos;)));</span><br><span class="line">// 设置路由</span><br><span class="line">server.get(&apos;*&apos;,(req,res)=&gt;&#123;</span><br><span class="line">  if (req.url !==&apos;/favicon.ico&apos;) &#123;</span><br><span class="line">    const context = &#123;url: req.url&#125;;</span><br><span class="line">    // 在项目中生成的html文件巨大，通过流的方式处理大的文件</span><br><span class="line">    const ssrstream = renderer.renderToStream(context);</span><br><span class="line">    let buffers = [];</span><br><span class="line">    ssrstream.on(&apos;error&apos;, (err) =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">    ssrstream.on(&apos;data&apos;, (data) =&gt; buffers.push(data));</span><br><span class="line">    ssrstream.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      res.end(Buffer.concat(buffers));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(2000);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="13-node-运行server-js"><a href="#13-node-运行server-js" class="headerlink" title="13 node 运行server.js"></a>13 node 运行server.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br></pre></td></tr></table></figure>
<p>项目运行之后，会发现切换页面，都会重新请求页面刷新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/19/ssr/" data-id="ckd4b4q2k001xt2p3czy1pfzw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vueRouter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/13/vueRouter/" class="article-date">
  <time datetime="2020-05-13T08:30:54.000Z" itemprop="datePublished">2020-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/13/vueRouter/">探究vue-router的源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2020-05-13 16:30:54</p>
<h2 id="一个vue路由的工作流程"><a href="#一个vue路由的工作流程" class="headerlink" title="一个vue路由的工作流程"></a>一个vue路由的工作流程</h2><hr>
<h4 id="前端路由和后端路由的区别"><a href="#前端路由和后端路由的区别" class="headerlink" title="前端路由和后端路由的区别"></a>前端路由和后端路由的区别</h4><ul>
<li>后端路由<br>输入url  –&gt;  请求发送到服务器 –&gt; 服务器解析请求的路径 –&gt; 浏览器拿取对应页面 –&gt; 页面渲染</li>
<li>前端路由<br>输入url  –&gt;  js解析地址 –&gt; 找到对应地址的页面 –&gt; 执行页面生成的js –&gt; 页面渲染</li>
</ul>
<h4 id="vue-router的工作流程"><a href="#vue-router的工作流程" class="headerlink" title="vue-router的工作流程"></a>vue-router的工作流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/11846892-ae149ebe3bad8a05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Hash与History"><a href="#Hash与History" class="headerlink" title="Hash与History"></a>Hash与History</h4><h6 id="hash和history的使用"><a href="#hash和history的使用" class="headerlink" title="hash和history的使用"></a>hash和history的使用</h6><p><code>hash:</code></p>
<ul>
<li><code>#</code>号后面的就是hash的内容</li>
<li>通过location.hash来获取</li>
<li>通过onhashchange监听hash的改变</li>
</ul>
<p><code>history:</code></p>
<ul>
<li>history即正常的路径</li>
<li>通过location.pathname来获取</li>
<li>通过onpopstate监听history的改变</li>
</ul>
<h2 id="实现vue-router源码实例"><a href="#实现vue-router源码实例" class="headerlink" title="##实现vue-router源码实例"></a>##实现vue-router源码实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">class HistoryRoute &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.current = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * options: newRouter时传入的参数；</span><br><span class="line">*/</span><br><span class="line">class VueRouter&#123;</span><br><span class="line">  constructor(options)&#123;</span><br><span class="line">    this.mode = options.mode || &apos;hash&apos;;</span><br><span class="line">    this.routes= options.routes || [];</span><br><span class="line">    // 此处可以直接令this.history.current = null；但是为了记录前后路由跳转历史，生成HistoryRoute类</span><br><span class="line">    this.history = new HistoryRoute;</span><br><span class="line">    this.routesMap =  this.creatMap(this.routes);</span><br><span class="line">    this.init(); //初始化路由</span><br><span class="line">  &#125;,</span><br><span class="line">  init () &#123;</span><br><span class="line">    // 触发监听事件</span><br><span class="line">    // 改变vue-router中的current变量</span><br><span class="line">    if (this.mode == &apos;hash&apos;) &#123;</span><br><span class="line">      // 根据hash的值自动在url上增加hash</span><br><span class="line">      location.hash ? &apos;&apos;: location.hash = &apos;/&apos;;</span><br><span class="line">      window.addEventListener(&apos;load&apos;,() =&gt; &#123;</span><br><span class="line">        this.history.current = location.hash.slice(1);</span><br><span class="line">      &#125;)</span><br><span class="line">      window.addEventListener(&apos;hashchange&apos;,() =&gt; &#123;</span><br><span class="line">        this.history.current = location.hash.slice(1);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 根据hash的值自动在url上增加hash</span><br><span class="line">      location.pathname ? &apos;&apos;: location.pathname = &apos;/&apos;;</span><br><span class="line">      window.addEventListener(&apos;load&apos;,() =&gt; &#123;</span><br><span class="line">        this.history.current = location.pathname;</span><br><span class="line">      &#125;)</span><br><span class="line">      window.addEventListener(&apos;hashchange&apos;,() =&gt; &#123;</span><br><span class="line">        this.history.current = location.pathname;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  creatMap(routes)&#123;</span><br><span class="line">    // 将routes转化成键值对形式 ‘/’: Hello</span><br><span class="line">    // reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class="line">    // 参数一：初始值, 或者计算结束后的返回值。</span><br><span class="line">    // 参数二：当前元素</span><br><span class="line">    return routes.reduce((memo, current)=&gt; &#123;</span><br><span class="line">      memo[current.path] = current.component;</span><br><span class="line">      return memo</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">VueRouter.install = function (Vue) &#123;</span><br><span class="line">  // 监视current变量的监视者</span><br><span class="line">  Vue.mixin(&#123; //mixin会注入到每个组件</span><br><span class="line">    // 查找到在根实例上放入的VueRouter对象，然后注入到每个组件。</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      // this.$option &amp;&amp; this.$options.router:当前这个组件的配置&amp;&amp; 当前组件上已经加载过route路由对象</span><br><span class="line">      if (this.$options &amp;&amp; this.$options.router) &#123;</span><br><span class="line">        // 将当前的实例，挂在到当前实例的_root变量上。</span><br><span class="line">        this._root = this;</span><br><span class="line">        // 将当前router 注入到当前实例（组件）的_router上。</span><br><span class="line">        this._router = this.$options.router;</span><br><span class="line">        // 在当前组件this下面中的this._router.history变量上对current进行监听</span><br><span class="line">        Vue.util.defineReactive(this,&apos;current&apos;, this._router.history);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 逐级向上查找是否挂载</span><br><span class="line">        this._root = this.$parent._root;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 扩展知识 组件使用this.$router和this.$route</span><br><span class="line">      // 在this上注册$router属性，并且不能更改。</span><br><span class="line">      Object.defineProperty(this, &apos;$router&apos;, &#123;</span><br><span class="line">        get () &#123;</span><br><span class="line">          return this._root._router;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      Object.defineProperty(this, &apos;$route&apos;, &#123;</span><br><span class="line">        get () &#123;</span><br><span class="line">          return this._root._router.history.current;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  Vue.component(&apos;route-view&apos;, &#123;</span><br><span class="line">    render(h)&#123;</span><br><span class="line">      // 根据当前current获取到对应的路径;</span><br><span class="line">      // _self是vue自带的，_self指向实例自身；</span><br><span class="line">      let current = this._self._root._router.history.current;</span><br><span class="line">      let routeMap = this._self._root._router.routesMap;</span><br><span class="line">      return h(routeMap[current]) //h：渲染作用</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">// 暴露vue类</span><br><span class="line">export default VueRouter;</span><br></pre></td></tr></table></figure>
<p>直接在项目中引入就可以啦！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/13/vueRouter/" data-id="ckd4b4q2s0029t2p3vyh3b2b7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue-vueRouter/">vue, vueRouter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-optimizaProject" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/08/optimizaProject/" class="article-date">
  <time datetime="2020-05-08T07:20:06.000Z" itemprop="datePublished">2020-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/08/optimizaProject/">优化项目的实用技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一些有意思的loader-和-plugins"><a href="#一些有意思的loader-和-plugins" class="headerlink" title="一些有意思的loader 和 plugins"></a>一些有意思的loader 和 plugins</h2><hr>
<h4 id="如何自动加载"><a href="#如何自动加载" class="headerlink" title="如何自动加载"></a>如何自动加载</h4><p><code>require.context</code>：根据自定的规则获取需要的内容。</p>
<blockquote>
<p>解决困扰：新增或减少页面每次需要更改路由配置？</p>
</blockquote>
<ul>
<li>以vue项目为例，实现动态配置路由。</li>
</ul>
<p>在vue的component中按照如下格式配置页面。<br><img src="https://upload-images.jianshu.io/upload_images/11846892-47016d33b4647d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>mode (模块名称)</p>
<blockquote>
<p>index.routes.js (该模块下路由解析配置)<br>pages (文件统一名称)</p>
<blockquote>
<p>mode.index.vue (模块下默认页面)<br>mode.resource.vue  (模块下其他页面)</p>
</blockquote>
</blockquote>
</blockquote>
<p>在mode中的index.routes.js中配置路由解析代码,会自动生成routes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 第1个参数： 路径</span><br><span class="line">// 第2个参数: 是否遍历1参数下面的子文件夹</span><br><span class="line">// 第3个参数： 正则匹配对应后缀的文件</span><br><span class="line"></span><br><span class="line">let r = require.context(&apos;./pages&apos;, false, /.vue/);</span><br><span class="line">// r是一个func,直接调用会报错。</span><br><span class="line">let routesArr = [];</span><br><span class="line">r.keys().forEach((key) =&gt; &#123;</span><br><span class="line">  console.log(r(key))</span><br><span class="line">  let _keyArr = key.split(&apos;.&apos;);</span><br><span class="line">  if (key.indexOf(&apos;index&apos;) != -1) &#123;</span><br><span class="line">    routesArr.push (&#123;</span><br><span class="line">      path: _keyArr[1],</span><br><span class="line">      name: _keyArr[1],</span><br><span class="line">      component: r(key).default</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    routesArr.push (&#123;</span><br><span class="line">      path: `$&#123;_keyArr[1]&#125;/$&#123;_keyArr[2]&#125;`,</span><br><span class="line">      name: _keyArr[1],</span><br><span class="line">      component: r(key).default</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default routesArr</span><br></pre></td></tr></table></figure></p>
<p>在总路由地址下引用各个模块下面的路由：</p>
<p>在router &gt; index.js配置如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let r = require.context(&apos;./components&apos;, true, /\.routes\.js/);</span><br><span class="line">let routesArr: any[] = [];</span><br><span class="line">r.keys().forEach((key) =&gt; &#123;</span><br><span class="line">  console.log(r(key));</span><br><span class="line">  routesArr = routesArr.concat(r(key).defalut);</span><br><span class="line">&#125;)</span><br><span class="line">export const routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: &quot;/&quot;,</span><br><span class="line">    name: &apos;Home&apos;,</span><br><span class="line">    components:Home</span><br><span class="line">  &#125;,</span><br><span class="line">  ...routesArr</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>缺点：<br>  1.不能按需引入<br>  2.不能实现动态路由。<br>优点：<br>  1.规范项目结构+文件命名+路由命名<br>  2.减少配置路由的困扰</p>
<h2 id="如何优化打包"><a href="#如何优化打包" class="headerlink" title="如何优化打包"></a>如何优化打包</h2><hr>
<h4 id="Dll优化"><a href="#Dll优化" class="headerlink" title="Dll优化"></a>Dll优化</h4><p>原理： 减少处理内容和步骤<br>js - 第三方库： vue / vue-router / axios /loadsh (只压缩打包一次,缓存到静态文件中)</p>
<p>步骤： 预处理第三方库 -&gt; 打包其他文件。</p>
<ul>
<li>以vue项目为例，封装Dll优化。</li>
</ul>
<p>在vue项目的bulid文件下新建webpack.dll.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;)</span><br><span class="line">var webpack = require(&apos;webpack&apos;)</span><br><span class="line">var config = require(&apos;../config&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    // 定义提前处理的文件</span><br><span class="line">    vendor: [&apos;vue/dist/vue.esm.js&apos;, &apos;vue-router&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 将预处理打包好的文件资源，放在静态文件夹中。</span><br><span class="line">    path: path.join(__dirname, &apos;../static/js&apos;),</span><br><span class="line">    filename: &apos;[name].dll.js&apos;,</span><br><span class="line">    library: &apos;[name]_library&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 在当前目录下生成一个通知，命名为[name]_manifest.json</span><br><span class="line">    new webpack.DllPlugin(&#123;</span><br><span class="line">      path:path.join(__dirname,&apos;.&apos;, &apos;[name]-manifest.json&apos;),</span><br><span class="line">      name: &apos;[name]_library&apos; // 对应output中的library</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在package.json 的 <code>scripts</code>中配置npm run dll 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dll&quot;: &quot;webpack --config build/webpack.dll.js&quot;</span><br></pre></td></tr></table></figure></p>
<p>然后执行<code>npm run dll</code>命令看一下打包所需要的时间<br><img src="https://upload-images.jianshu.io/upload_images/11846892-fafb831343c335b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在执行一下<code>npm run build</code> 命令查看一下原始打包所需要的时间<br><img src="https://upload-images.jianshu.io/upload_images/11846892-d5d9ff566fdbde19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>执行<code>npm run dll</code>命令之后会发现在<code>bulid</code>文件夹下生成了<br><code>vendor-manifest.json</code>,在<code>static/js</code>下生成了<code>vendor.dll.js</code>。<br><img src="https://upload-images.jianshu.io/upload_images/11846892-4cf356217f7b1eb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/11846892-4e1610e26c92530e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在<code>bulid/webpack.prod.conf.js</code>中配置正常打包下的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.DllReferencePlugin(&#123;</span><br><span class="line">      //context: 在html中引入的路径。</span><br><span class="line">      context: path.join(__dirname, &apos;..&apos;),</span><br><span class="line">      manifest: require(&apos;./vendor-manifest.json&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>最后在执行一下<code>npm run build</code> 命令查看一下dll处理之后打包所需要的时间<br><img src="https://upload-images.jianshu.io/upload_images/11846892-cd9552fdd529d347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>很完美的节约了一些时间，时间就是金钱，时间就是生命。</p>
<h4 id="如何开发插件与loader"><a href="#如何开发插件与loader" class="headerlink" title="如何开发插件与loader"></a>如何开发插件与loader</h4><hr>
<blockquote>
<p>示例问题：项目vuex过大，导致打包结果过大。<br>处理： 按组件异步加载vuex</p>
</blockquote>
<p>在src/store文件夹下index文件中存储首屏加载的vuex数据;<br>在src/store/model/.. 文件夹下存储其他模块需要懒加载的vuex数据;<br><img src="https://upload-images.jianshu.io/upload_images/11846892-5b5262f39bc46f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在src下新建vuePlugins/index封装插件<br><img src="https://upload-images.jianshu.io/upload_images/11846892-8799f362b4bdfdff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  install:function(vue) &#123;</span><br><span class="line">    vue.mixin(&#123;</span><br><span class="line">      beforeCreate:function()&#123;</span><br><span class="line">        if (this.$options.isVuex) &#123;</span><br><span class="line">          // 在对应页面中配置store</span><br><span class="line">          // store中存储需要按需加载的vuex相关的js文件</span><br><span class="line">          let store = this.$options.store;</span><br><span class="line">          // 动态引入vuex</span><br><span class="line">          // 注意：import的参数不能传入变量。</span><br><span class="line">          import(&apos;../store/model/&apos;+ store).then((res) =&gt; &#123;</span><br><span class="line">            // registerModul方法是vuex的方法;</span><br><span class="line">            this.$store.registerModule(store, res.default);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default a;</span><br></pre></td></tr></table></figure></p>
<p>在main.js引入插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vuepl from &quot;./vuePlugins&quot;;</span><br><span class="line">Vue.use(Vuepl);</span><br></pre></td></tr></table></figure></p>
<p>在需要懒加载vuex的页面配置<br><img src="https://upload-images.jianshu.io/upload_images/11846892-c4e24d770a72ec58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isVuex:true;</span><br><span class="line">store: &apos;modelIndex&apos;;</span><br></pre></td></tr></table></figure></p>
<p>👌了！以上就是vuex实现按需加载的栗子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/08/optimizaProject/" data-id="ckd4b4q2f001ot2p31tphnzi5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vueTest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/06/vueTest/" class="article-date">
  <time datetime="2020-05-06T07:15:23.000Z" itemprop="datePublished">2020-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/06/vueTest/">vueTest</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2020-05-06 15:15:23</p>
<h2 id="组件单元测试的好处"><a href="#组件单元测试的好处" class="headerlink" title="组件单元测试的好处"></a>组件单元测试的好处</h2><ul>
<li>提供描述组件行为的文档</li>
<li>节省手动测试的时间</li>
<li>减少研发新特性时产生的bug</li>
<li>改进设计</li>
<li>促进重构</li>
</ul>
<p>自动化测试使得大团队中的开发者可以维护复杂的基础代码。</p>
<h2 id="I-单元测试简介"><a href="#I-单元测试简介" class="headerlink" title="I. 单元测试简介"></a>I. 单元测试简介</h2><hr>
<blockquote>
<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。</p>
</blockquote>
<p>简单来说，<code>单元</code>就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>
<p>对于开发活动中的各种测试，最常见的划分方法：从下至上依次为 <strong>单元测试-&gt;集成测试-&gt;端到端测试</strong> ，随着其集成度的递增，对应的自动化程度递减。</p>
<p>端到端（在浏览器等真实场景中走通功能而把程序当成黑盒子的测试）与集成测试（集合多个测试过的单元一起测试）的反馈与修复的周期比较长、运行速度慢，测试运行不稳定，由于很多时候还要靠人工手动进行，维护成本也很高。而单元测试只针对具体一个方法或API，定位准确，采用 mock 机制，运行速度非常快（毫秒级），又是开发人员在本地执行，反馈修复及时，成本较低。</p>
<p>我们把绝大部分能在单元测试里覆盖的用例都放在单元测试覆盖，只有单元测试测不了的，才会通过端到端与集成测试来覆盖。</p>
<p><strong>讲解单元测试的具体概念之前，先 咀个栗子 直观了解下：</strong></p>
<p>比如我们有这样一个模块，暴露两个方法用以对菜单路径进行一些处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// src/menuChecker.js</span><br><span class="line"></span><br><span class="line">export function getRoutePath(str) &#123;</span><br><span class="line">  let to = &quot;&quot;</span><br><span class="line">  //...</span><br><span class="line">  return to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function getHighlight(str) &#123;</span><br><span class="line">  let hl = &quot;&quot;;</span><br><span class="line">  //...</span><br><span class="line">  return hl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写对应的测试文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  getRoutePath,</span><br><span class="line">  getHighlight</span><br><span class="line">&#125; from &quot;@/menuChecker&quot;;</span><br><span class="line"></span><br><span class="line">describe(&quot;检查菜单路径相关函数&quot;, ()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;应该获得正确高亮值&quot;, ()=&gt;&#123;</span><br><span class="line">    expect( getHighlight(&quot;/myworksheet/(.*)&quot;) ).toBe(&quot;myTickets&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;应该为未知路径取得默认的高亮值&quot;, ()=&gt;&#123;</span><br><span class="line">    expect( getHighlight(&quot;/myworksheet/ccc/aaa&quot;) ).toBe(&quot;mydefaulthl111&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;应该补齐开头的斜杠&quot;, ()=&gt;&#123;</span><br><span class="line">    expect( getRoutePath(&quot;/worksheet/list&quot;) ).toBe(&apos;/worksheet/list&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;应该能修正非法的路径&quot;, ()=&gt;&#123;</span><br><span class="line">    expect( getRoutePath(&quot;/myworksheet/(.*)&quot;) ).toBe(&quot;/myworksheet/list&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行该测试文件，得到如下输出：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-e6bc2edad5dc4097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![20200506151145.png](https://upload-images.jianshu.io/upload_images/11846892-1dec9c605aeb4dcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
"></p>
<p>由此，我们对一次单元测试的过程有了基本的了解。</p>
<h2 id="断言-assertions"><a href="#断言-assertions" class="headerlink" title="断言(assertions)"></a>断言(assertions)</h2><p>断言是单元测试框架中核心的部分，断言失败会导致测试不通过，或报告错误信息。</p>
<p>对于常见的断言，举一些例子如下：</p>
<ul>
<li><p>同等性断言 Equality Asserts</p>
<pre><code>1. expect(sth).toEqual(value)
2. expect(sth).not.toEqual(value)
</code></pre></li>
<li><p>比较性断言 Comparison Asserts</p>
<pre><code>1. expect(sth).toBeGreaterThan(number)
2. expect(sth).toBeLessThanOrEqual(number)
</code></pre></li>
<li><p>类型性断言 Type Asserts</p>
<pre><code>1. expect(sth).toBeInstanceOf(Class)
</code></pre></li>
<li><p>条件性测试 Condition Test</p>
<pre><code>1. expect(sth).toBeTruthy()
2. expect(sth).toBeFalsy()
3. expect(sth).toBeDefined()
</code></pre></li>
</ul>
<h2 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h2><p>断言库主要提供上述断言的语义化方法，用于对参与测试的值做各种各样的判断。这些语义化方法会返回测试的结果，要么成功、要么失败。常见的断言库有 Should.js, Chai.js 等。</p>
<h2 id="测试用例-test-case"><a href="#测试用例-test-case" class="headerlink" title="测试用例 test case"></a>测试用例 test case</h2><p>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。</p>
<p>一般的形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;should ...&apos;, function() &#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    expect(sth).toEqual(sth);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="测试套件-test-suite"><a href="#测试套件-test-suite" class="headerlink" title="测试套件 test suite"></a>测试套件 test suite</h2><p>通常把一组相关的测试称为一个测试套件</p>
<p>一般的形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;test ...&apos;, function() &#123;</span><br><span class="line">    </span><br><span class="line">    it(&apos;should ...&apos;, function() &#123; ... &#125;);</span><br><span class="line">    </span><br><span class="line">    it(&apos;should ...&apos;, function() &#123; ... &#125;);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="spy"><a href="#spy" class="headerlink" title="spy"></a>spy</h2><blockquote>
<p>正如 spy 字面的意思一样，我们用这种“间谍”来“监视”函数的调用情况</p>
</blockquote>
<p>通过对监视的函数进行包装，可以通过它清楚的知道该函数被调用过几次、传入什么参数、返回什么结果，甚至是抛出的异常情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var spy = sinon.spy(MyComp.prototype, &apos;someMethod&apos;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">expect(spy.callCount).toEqual(1);</span><br></pre></td></tr></table></figure>
<h2 id="stub"><a href="#stub" class="headerlink" title="stub"></a>stub</h2><blockquote>
<p>有时候会使用stub来嵌入或者直接替换掉一些代码，来达到隔离的目的</p>
</blockquote>
<p>一个stub可以使用最少的依赖方法来模拟该单元测试。比如一个方法可能依赖另一个方法的执行，而后者对我们来说是透明的。好的做法是使用stub 对它进行隔离替换。这样就实现了更准确的单元测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">    prop: function() &#123;</span><br><span class="line">        return &apos;foo&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sinon.stub(myObj, &apos;prop&apos;).callsFake(function() &#123;</span><br><span class="line">    return &apos;bar&apos;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObj.prop(); // &apos;bar&apos;</span><br></pre></td></tr></table></figure>
<h2 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h2><p><code>mock</code>一般指在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法</p>
<p>广义的讲，以上的 spy 和 stub 等，以及一些对模块的模拟，对 ajax 返回值的模拟、对 timer 的模拟，都叫做 mock 。</p>
<h2 id="测试覆盖率-code-coverage"><a href="#测试覆盖率-code-coverage" class="headerlink" title="测试覆盖率(code coverage)"></a>测试覆盖率(code coverage)</h2><p>用于统计测试用例对代码的测试情况，生成相应的报表，比如 <code>istanbul</code> 是常见的测试覆盖率统计工具。</p>
<p><code>istanbul</code> 也就是土耳其首都 “伊斯坦布尔”，这样命名是因为土耳其地毯世界闻名，而地毯是用来”覆盖”的😷。</p>
<p>回顾一下上面的图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-8cc2514fc4359845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20200506151145.png"></p>
<p>表格中的第2列至第5列，分别对应了四个衡量维度：</p>
<ul>
<li>语句覆盖率（statement coverage）：是否每个语句都执行了</li>
<li>分支覆盖率（branch coverage）：是否每个<code>if</code>代码块都执行了</li>
<li>函数覆盖率（function coverage）：是否每个函数都调用了</li>
<li>行覆盖率（line coverage）：是否每一行都执行了</li>
</ul>
<p>测试结果根据覆盖率被分为“绿色、黄色、红色”三种，应该关注这些指标，测试越全面，就能提供更高的保证。</p>
<p>同时也没有必要一味追求行覆盖率，因为它会导致我们过分关注组件的内部实现细节，从而导致琐碎的测试。</p>
<h2 id="II-Vue-js-中的单元测试工具"><a href="#II-Vue-js-中的单元测试工具" class="headerlink" title="II. Vue.js 中的单元测试工具"></a>II. Vue.js 中的单元测试工具</h2><hr>
<h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><p>不同于”传统的”(其实也没出现几年)的 jasmine / Mocha / Chai 等前端测试框架；Jest的使用更简单（也许就是这个单词的本意“俏皮话、玩笑话”的意思），并且提供了更高的集成度、更丰富的功能。</p>
<p>Jest 是一个由 Facebook 开发的测试运行器，相对其他测试框架，其特点就是就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用。</p>
<p>此外， Jest 的测试用例是并行执行的，而且只执行发生改变的文件所对应的测试，提升了测试速度。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Jest 号称自己是一个 “Zero configuration testing platform”，只需在 npm scripts里面配置了test: jest，即可运行npm test，自动识别并测试符合其规则的（ Vue.js 项目中一般是 <strong>tests</strong> 目录下的）用例文件。</p>
<p>实际使用中，适当的在 package.json 的 jest 字段或独立的 jest.config.js 里自定义配置一下，会得到更适合我们的测试场景。</p>
<p>参考文档 <a href="https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html" target="_blank" rel="noopener">https://vue-test-utils.vuejs.org/zh/guides/testing-single-file-components-with-jest.html</a> ，可以很快在 Vue.js 项目中配置好 Jest 测试环境</p>
<h4 id="四个基础单词"><a href="#四个基础单词" class="headerlink" title="四个基础单词"></a>四个基础单词</h4><p>编写单元测试的语法通常非常简单；对于jest来说，由于其内部使用了 Jasmine 2 来进行测试，故其用例语法与 Jasmine 相同。</p>
<p>实际上，只要先记这住四个单词，就足以应付大多数测试情况了：</p>
<ul>
<li>describe： 定义一个测试套件</li>
<li>it：定义一个测试用例</li>
<li>expect：断言的判断条件</li>
<li>toEqual：断言的比较结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;test ...&apos;, function() &#123;</span><br><span class="line">    it(&apos;should ...&apos;, function() &#123;</span><br><span class="line">        expect(sth).toEqual(sth);</span><br><span class="line">        expect(sth.length).toEqual(1);</span><br><span class="line">        expect(sth &gt; oth).toEqual(true);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Vue-Test-Utils"><a href="#Vue-Test-Utils" class="headerlink" title="Vue Test Utils"></a>Vue Test Utils</h2><blockquote>
<p>Vue Test Utils 是 Vue.js 官方的单元测试实用工具库</p>
</blockquote>
<p>它模拟了一部分类似 jQuery 的 API，非常直观并且易于使用和学习，提供了一些接口和几个方法来减少测试的样板代码，方便判断、操纵和遍历 Vue Component 的输出，并且减少了测试代码和实现代码之间的耦合。</p>
<p>一般使用其 mount() 或 shallowMount() 方法，将目标组件转化为一个 Wrapper 对象，并在测试中调用其各种方法，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mount &#125; from &apos;@vue/test-utils&apos;</span><br><span class="line">import Foo from &apos;./Foo.vue&apos;</span><br><span class="line"></span><br><span class="line">describe(&apos;Foo&apos;, () =&gt; &#123;</span><br><span class="line">  it(&apos;renders a div&apos;, () =&gt; &#123;</span><br><span class="line">    const wrapper = mount(Foo)</span><br><span class="line">    expect(wrapper.contains(&apos;div&apos;)).toBe(true)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="V-将单元测试整合到工作流中"><a href="#V-将单元测试整合到工作流中" class="headerlink" title="V. 将单元测试整合到工作流中"></a>V. 将单元测试整合到工作流中</h2><hr>
<p>写好的单元测试，如果仅仅要靠每次 npm test 手动执行，必然会有日久忘记、逐渐过时，最后甚至无法执行的情况。</p>
<p>有多个时间点可以作为选择，插入自动执行单元测试 – 例如每次保存文件、每次执行 build 等；此处我们选择了一种很简单的配置办法：</p>
<p>首先在项目中安装 pre-commit 依赖包；然后在 package.json 中配置 npm scripts ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;pre-commit&quot;: [</span><br><span class="line">  &quot;test&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>这样在每次 git commit 之前，项目中存在的单元测试就会自动执行一次，往往就避免了 “改一个 bug，送十个新 bug” 的窘况。</p>
<h2 id="VI-总结"><a href="#VI-总结" class="headerlink" title="VI. 总结"></a>VI. 总结</h2><hr>
<p>单元测试作为一种经典的开发和重构手段，在软件开发领域被广泛认可和采用；前端领域也逐渐积累起了丰富的测试框架和方法。</p>
<p>单元测试可以为我们的开发和维护提供基础保障，使我们在思路清晰、心中有底的情况下完成对代码的搭建和重构。</p>
<p>封装好则测试易，反之不恰当的封装让测试变得困难。</p>
<p>可测试性是一个检验组件结构良好程度的实践标准。</p>
<p>参考资料：<br>  wx公众号：云前端<br>  文章: 实例入门 Vue.js 单元测试</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/06/vueTest/" data-id="ckd4b4q2v002et2p3mv1gt52o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue-test/">vue test</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-reactive" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/reactive/" class="article-date">
  <time datetime="2020-03-30T08:55:06.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/reactive/">Vue响应式原理解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="vue从改变一个数据到发生改变的过程"><a href="#vue从改变一个数据到发生改变的过程" class="headerlink" title="vue从改变一个数据到发生改变的过程"></a>vue从改变一个数据到发生改变的过程</h3><ul>
<li>数据改变触发set</li>
<li>Set部分触发notify(更新和通知) -&gt; Get部分收集依赖</li>
<li>更改对应的虚拟dom</li>
<li>重新render<h4 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h4></li>
<li>defineProperty<br>defineProperty不仅仅用来做响应式，他的作用可以用来给对象中的属性配置操作权限。其中get和set实现了响应式原理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let ob = &#123;</span><br><span class="line">  a:1</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(ob, &apos;a&apos;, &#123;</span><br><span class="line">  writable:false, // 属性值是否可写</span><br><span class="line">  enumerable: false, // 属性值是否可循环</span><br><span class="line">  configurable: false //属性值是否可以delete</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(ob, &apos;a&apos;); // 读取对象的属性值</span><br></pre></td></tr></table></figure>
<ul>
<li>get &amp; set <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let _value = ob.a;</span><br><span class="line">// 如果想要使用get&amp;set方法实现读取和存储，必须将属性值重新赋值给新的变量，来实现储存和中转，这也是defineProperty不优雅的一点。</span><br><span class="line">// get &amp; set 必须配合return方法使用。</span><br><span class="line">Object.defineProperty(ob, &apos;a&apos;, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    return _value;</span><br><span class="line">  &#125;,</span><br><span class="line">  set (newValue) &#123;</span><br><span class="line">    _value = newValue</span><br><span class="line">    return _value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 实现vue简易版的双向原理</span><br><span class="line">function Vue () &#123;</span><br><span class="line">  this.$data = &#123;a:1&#125;;</span><br><span class="line">  this.el = document.getElementById(&apos;app&apos;);</span><br><span class="line">  this.vritualDom = &apos;&apos;;</span><br><span class="line">  this.observer(this.$data); //注册监听</span><br><span class="line">  this.render();</span><br><span class="line">&#125;</span><br><span class="line">// 注册get和set</span><br><span class="line">Vue.prototype.observer = function (obj) &#123;</span><br><span class="line">  var value;</span><br><span class="line">  var self = this;</span><br><span class="line">  for (var key in obj) &#123;</span><br><span class="line">    value = obj[key];</span><br><span class="line">    if (typeof value === &apos;object&apos;) &#123;</span><br><span class="line">      this.observer(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Object.defineProperty(obj, key, &#123;</span><br><span class="line">        get()&#123;</span><br><span class="line">          // 进行依赖收集</span><br><span class="line">          // 为什么要收集依赖？</span><br><span class="line">          // 数据可能只在局部位置使用，找到对应依赖，只更新依赖于变量的组件。</span><br><span class="line">          return value;</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newvalue)&#123;</span><br><span class="line">          value = newvalue;</span><br><span class="line">          self.render()</span><br><span class="line">          return value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.prototype.render = function (obj) &#123;</span><br><span class="line">  this.vritualDom = &apos;i am&apos; + this.$data.a;</span><br><span class="line">  this.el.innerHTML = this.vritualDom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="defineProperty中的get和set是对象的属性，对数组如何实现处理？"><a href="#defineProperty中的get和set是对象的属性，对数组如何实现处理？" class="headerlink" title="defineProperty中的get和set是对象的属性，对数组如何实现处理？"></a>defineProperty中的get和set是对象的属性，对数组如何实现处理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 数组的双向绑定就是做了一个设计者模式；</span><br><span class="line">// 取出数组的原型链并拷贝;</span><br><span class="line">var arraypro = Array.prototype;</span><br><span class="line">var arrob =Object.create(arraypro);</span><br><span class="line">var arrFun = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;];</span><br><span class="line"></span><br><span class="line">arrFun.forEach((method .index) =&gt; &#123;</span><br><span class="line">  arrob[method] = function () &#123;</span><br><span class="line">    var ret = arraypro[method].apply(this, arguments);</span><br><span class="line">    dep.notify() // 触发试图更新</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><ul>
<li>Proxy对象用于定义基本操作的自定义行为（和defineProperty类似，用法不同）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  a:1,</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Proxy(ob, &#123;</span><br><span class="line">  get (target, key, receiver) &#123;</span><br><span class="line">    return target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value, receiver) &#123;</span><br><span class="line">    return Reflect.set(target, key, value)</span><br><span class="line">    // return target[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// vue简易版的实现双向原理</span><br><span class="line">function Vue () &#123;</span><br><span class="line">  var self = this;</span><br><span class="line">  this.$data = new Proxy(this.$data, &#123;</span><br><span class="line">    get (target, key, receiver) &#123;</span><br><span class="line">      return target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    set (target, key, value, receiver) &#123;</span><br><span class="line">      target[key] = value;</span><br><span class="line">      self.render();</span><br><span class="line">      return target[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="proxy的其他作用？"><a href="#proxy的其他作用？" class="headerlink" title="proxy的其他作用？"></a>proxy的其他作用？</h4><ul>
<li><p>校验类型<br>// 创建一个对象，对象有name和age两个属性;name是中文 age是数字且大于18;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var validtor = &#123;</span><br><span class="line">  // 策略模式</span><br><span class="line">  name: function (value) &#123;</span><br><span class="line">    var reg = /^[\u4E00-\u9FA5]+$/;</span><br><span class="line">    if (typeof value == &apos;string&apos; &amp;&amp; reg.test(value)) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;,</span><br><span class="line">  age: function (value) &#123;</span><br><span class="line">    if (typeof value == &apos;number&apos; &amp;&amp; value &gt;= 18) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">function preson (age, name) &#123;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.name = name;</span><br><span class="line">  return new Proxy(this, &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      return targe[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set (target, key, value) &#123;</span><br><span class="line">      if (validtor[key](value)) &#123;</span><br><span class="line">        return Reflect.set(target, key, value);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw new Error(key + &apos;is not right&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>真正私有属性</p>
</li>
</ul>
<h4 id="defineProperty-和-Proxy的区别"><a href="#defineProperty-和-Proxy的区别" class="headerlink" title="defineProperty 和 Proxy的区别"></a>defineProperty 和 Proxy的区别</h4><ol>
<li>defineProperty只能监听对象的某个属性，不能监听全对象；</li>
<li>可以省去defineProperty 中的for in 循环，节省性能</li>
<li>可以监听数组，不需要再去单独的对数组进行特异性处理；</li>
<li>不需要借助外部变量实现存储和读取（完善了vue2中defineProperty的不优雅的地方）</li>
<li>不会污染原对象(proxy对原对象进行代理，生成新的代理对象)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/30/reactive/" data-id="ckd4b4q2g001qt2p3xlbhmt96" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-v8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/30/v8/" class="article-date">
  <time datetime="2020-03-30T08:45:02.000Z" itemprop="datePublished">2020-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/30/v8/">v8</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="v8引擎如何回收内存"><a href="#v8引擎如何回收内存" class="headerlink" title="v8引擎如何回收内存"></a>v8引擎如何回收内存</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/30/v8/" data-id="ckd4b4q2p0024t2p34am9z1gv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vueCliMd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/15/vueCliMd/" class="article-date">
  <time datetime="2020-01-15T07:05:46.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/15/vueCliMd/">vue-cli3项目展示本地Markdown文件的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【版本】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue-cli3</span><br><span class="line">webpack@4.33.0</span><br></pre></td></tr></table></figure></p>
<p>【步骤】</p>
<ol>
<li><p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install markdown-it --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建markdownLoader.js文件(自定义loader)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const markdown = require(&apos;markdown-it&apos;);</span><br><span class="line"></span><br><span class="line">function markLoader(src) &#123;</span><br><span class="line">  const md = markdown(&#123;</span><br><span class="line">    html: true,</span><br><span class="line">    typographer: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  const html = md.render(src);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &apos;&lt;template&gt;\n&apos;</span><br><span class="line">    + `&lt;div class=&quot;markdown&quot;&gt;$&#123;html&#125;&lt;/div&gt;\n`</span><br><span class="line">    + &apos;&lt;/template&gt;\n&apos;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">module.exports = markLoader;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在vue.config.js(如果没有,在根目录下自行创建)文件中配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  configureWebpack: config =&gt; &#123;</span><br><span class="line">    config.module.rules.push(&#123;</span><br><span class="line">      // 处理markdown文件</span><br><span class="line">      test: /\.md$/,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: &quot;vue-loader&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: require.resolve(&quot;./src/common/markdownLoader&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4.保存后重新启动项目(尤其是修改自定义lodaer和vue.config.js配置文件,必须重新启动项目生效)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/15/vueCliMd/" data-id="ckd4b4q2q0026t2p3rgycn1rq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-asyncAwit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/04/asyncAwit/" class="article-date">
  <time datetime="2019-11-04T06:58:15.000Z" itemprop="datePublished">2019-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/04/asyncAwit/">asyncAwit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-20 10:50:39</p>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。<br>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</p>
<h5 id="async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。"><a href="#async函数完全可以看作多个异步操作，包装成的一个-Promise-对象，而await命令就是内部then命令的语法糖。" class="headerlink" title="async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。"></a>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</h5><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><p>在项目的src目录下新建文件夹request,文件夹下新建http.js和api.js文件：</p>
<ul>
<li>http.js: 封装axios</li>
<li>api.js: 用来统一管理接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 在http.js中引入axios</span><br><span class="line">import axios from &apos;axios&apos;; // 引入axios</span><br><span class="line">import QS from &apos;qs&apos;; // 引入qs模块，用来序列化post类型的数据，后面会提到</span><br></pre></td></tr></table></figure>
<h5 id="环境的切换-gt-配置不同的baseURL"><a href="#环境的切换-gt-配置不同的baseURL" class="headerlink" title="环境的切换-&gt;配置不同的baseURL"></a>环境的切换-&gt;配置不同的baseURL</h5><p>我们的项目环境可能有开发环境、测试环境和生产环境.<br>我们通过node的环境变量来匹配我们的默认的接口url前缀<br>axios.defaults.baseURL可以设置axios的默认请求地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const baseURL_Map = &#123;</span><br><span class="line">  dev：&apos;https://www.baidu.com&apos;,</span><br><span class="line">  uat: &apos;https://www.ceshi.com&apos;,</span><br><span class="line">  product: &apos;https://www.production.com&apos;</span><br><span class="line">&#125;</span><br><span class="line">axios.defaults.baseURL = baseURL_Map[process.env.NODE_ENV] </span><br><span class="line">// 或者直接设置成基本变量：</span><br><span class="line">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>
<p>扩展：</p>
<h6 id="process-env-NODE-ENV"><a href="#process-env-NODE-ENV" class="headerlink" title="process.env.NODE_ENV"></a>process.env.NODE_ENV</h6><ul>
<li>process对象是全局变量: 提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()</li>
<li>process.env属性返回一个包含用户环境信息的对象</li>
<li>process.env.NODE_ENV:不是process.env对象上原有的属性，是我们自己添加进去的一个环境变量，用来确定当前所处的开发阶段。</li>
<li>测试环境： uat; 生产环境：product; 开发环境： dev</li>
</ul>
<h5 id="设置请求超时变量"><a href="#设置请求超时变量" class="headerlink" title="设置请求超时变量"></a>设置请求超时变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 例如超过了10s，就会告知用户当前请求超时，请刷新等。</span><br><span class="line"></span><br><span class="line">const TIMEOUT = 30000;</span><br></pre></td></tr></table></figure>
<p>扩展： </p>
<ul>
<li>统一处理所有接口的超时时间： <code>axios.defaults.timeout = 10000;</code></li>
</ul>
<h5 id="设置post请求头"><a href="#设置post请求头" class="headerlink" title="设置post请求头"></a>设置post请求头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded;charset=UTF-8&apos;;</span><br></pre></td></tr></table></figure>
<p> 此处无需设置，在下面封装的时候会针对get和post请求做统一对应处理</p>
<h5 id="定义HTTP响应状态码的范围"><a href="#定义HTTP响应状态码的范围" class="headerlink" title="定义HTTP响应状态码的范围"></a>定义HTTP响应状态码的范围</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断 HTTP 请求是否成功</span><br><span class="line"> * @param &#123;number&#125; status - HTTP 状态码</span><br><span class="line"> * @returns &#123;Boolean&#125;</span><br><span class="line"> */</span><br><span class="line">const isBadRequest = status =&gt; status &gt;= 300;</span><br></pre></td></tr></table></figure>
<h4 id="映射-HTTP-错误时的提示语句"><a href="#映射-HTTP-错误时的提示语句" class="headerlink" title="映射 HTTP 错误时的提示语句"></a>映射 HTTP 错误时的提示语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 映射 HTTP 错误时的提示语句</span><br><span class="line"> * @param &#123;enhanceError&#125; error</span><br><span class="line"> * @returns &#123;Object&#125;</span><br><span class="line"> */</span><br><span class="line">const badStatusMap = error =&gt; (&#123;</span><br><span class="line">  400: &apos;请求错误&apos;,</span><br><span class="line">  401: &apos;未授权，请登录&apos;,</span><br><span class="line">  403: &apos;拒绝访问&apos;,</span><br><span class="line">  404: `请求地址出错 $&#123;error.response ? error.response.config.url : &apos;&apos;&#125;`,</span><br><span class="line">  408: &apos;请求超时&apos;,</span><br><span class="line">  500: &apos;服务器内部错误&apos;,</span><br><span class="line">  501: &apos;服务未实现&apos;,</span><br><span class="line">  502: &apos;网关错误&apos;,</span><br><span class="line">  503: &apos;服务不可用&apos;,</span><br><span class="line">  504: &apos;网关超时&apos;,</span><br><span class="line">  505: &apos;HTTP版本不受支持&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h5><ul>
<li>http.js<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * http.js</span><br><span class="line"> * @param &#123;Object&#125; [globalOption]</span><br><span class="line"> */</span><br><span class="line">import &#123;</span><br><span class="line">  mergeWith, omit, isPlainObject</span><br><span class="line">&#125; from &apos;lodash&apos;;</span><br><span class="line"></span><br><span class="line">// isPlainObject ： checks if value is a plain object, that is, an object created by the Object constructor or one with a [[Prototype]] of null</span><br><span class="line">// mergeWith 是用于递归合并来源对象的自身和继承的可枚举属性到目标对象。 </span><br><span class="line">// 基本意思就是将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 修复 axios 转换 bug，如可能把请求中的日期等转成空对象的问题</span><br><span class="line"> *  &apos;utils.merge&apos; in &apos;node_modules\axios\lib\core\Axios.js&apos;</span><br><span class="line"> * @param &#123;any&#125; obj</span><br><span class="line"> */</span><br><span class="line">const fixAxiosDateMerge = (obj) =&gt; &#123;</span><br><span class="line">  if (!obj) return obj;</span><br><span class="line">  if (obj instanceof Date) return obj.getTime();</span><br><span class="line">  if (!isPlainObject(obj)) return obj;</span><br><span class="line">  Object.keys(obj).forEach((key) =&gt; &#123;</span><br><span class="line">    obj[key] = fixAxiosDateMerge(obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function axiosWrapper(globalOption) &#123;</span><br><span class="line">  return function(option) &#123;</span><br><span class="line">    // 此处的操作相对与开放一点，把baseURL、timeout、responseType、可以根据接口不同做单独配置。</span><br><span class="line">    option = mergeWith(&#123;</span><br><span class="line">      baseURL: BASE_URL,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</span><br><span class="line">        &apos;Cache-Control&apos;: &apos;no-cache&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      timeout: TIMEOUT,</span><br><span class="line">      withCredentials: true,</span><br><span class="line">      responseType: &apos;&apos;,</span><br><span class="line">      validateStatus: status =&gt; !isBadRequest(status)</span><br><span class="line"></span><br><span class="line">      // 可以定义HTTP响应状态码的范围。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被拒绝。</span><br><span class="line">    &#125;, globalOption, option);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    if (option.data) &#123;</span><br><span class="line">      option.data = fixAxiosDateMerge(option.data);</span><br><span class="line">    &#125;</span><br><span class="line">    if (option.params) &#123;</span><br><span class="line">      option.params = fixAxiosDateMerge(option.params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const r = axios.create(option);</span><br><span class="line">    </span><br><span class="line">    // 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = &quot;ECONNABORTED&quot;</span><br><span class="line"></span><br><span class="line">    // timeout</span><br><span class="line">    r.interceptors.request.use(</span><br><span class="line">      config =&gt; config,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        if (error &amp;&amp; error.code === &apos;ECONNABORTED&apos;</span><br><span class="line">          &amp;&amp; ~error.message.indexOf(&apos;timeout&apos;)) &#123;</span><br><span class="line">          console.log(&apos;[AxiosWrapper] request timeout&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // other errors // 跳转到对应的报错页面</span><br><span class="line">    r.interceptors.request.use(</span><br><span class="line">      config =&gt; config,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        const errorInfo = error.response;</span><br><span class="line">        if (errorInfo) &#123;</span><br><span class="line">          const errorStatus = errorInfo.status;</span><br><span class="line">          router.push(&#123;</span><br><span class="line">            path: `/error/$&#123;errorStatus&#125;`</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // make data</span><br><span class="line">    r.interceptors.request.use(</span><br><span class="line">      (opt) =&gt; &#123;</span><br><span class="line">        const params = mergeWith(&#123;&#125;, opt.data, opt.params); // cloneDeep(opt.data);</span><br><span class="line">        opt = omit(opt, [&apos;data&apos;, &apos;params&apos;]);</span><br><span class="line">        const needBody = /^(put|post|patch)$/i.test(opt.method);</span><br><span class="line">        const sendJSON = opt.headers</span><br><span class="line">          &amp;&amp; opt.headers[&apos;Content-Type&apos;] === &apos;application/json&apos;;</span><br><span class="line">          // 根据请求头和method来处理入参的格式</span><br><span class="line">        if (needBody) &#123;</span><br><span class="line">          opt.data = sendJSON</span><br><span class="line">            ? JSON.stringify(params)</span><br><span class="line">            : qs.stringify(params);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          opt.params = params;</span><br><span class="line">        &#125;</span><br><span class="line">        return opt;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // bad HTTP request</span><br><span class="line">    r.interceptors.response.use(</span><br><span class="line">      response =&gt; response,</span><br><span class="line">      (error) =&gt; &#123;</span><br><span class="line">        if (error &amp;&amp; error.response) &#123;</span><br><span class="line">          const &#123; status, statusText &#125; = error.response;</span><br><span class="line">          if (isBadRequest(status)) &#123;</span><br><span class="line">            console.warn(&apos;[AxiosWrapper] bad HTTP request: status is %s \n&apos;, status, error.response);</span><br><span class="line">            error.message = badStatusMap(error)[status] || statusText;</span><br><span class="line">            if (!error.message) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                error.message = JSON.parse(error.response.request.responseText).errmsg;</span><br><span class="line">              &#125; catch (ex) &#123;</span><br><span class="line">                console.log(&apos;[AxiosWrapper] json parse error&apos;, ex);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Vue.prototype.Config.ROOT_VUE.$message.error(error.message);</span><br><span class="line">            return Promise.reject(new Error(error.message));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // check business logic</span><br><span class="line">    // 请求失败，根据HTTP响应状态码做出对应的messageTip</span><br><span class="line">    r.interceptors.response.use(</span><br><span class="line">      (response) =&gt; &#123;</span><br><span class="line">        if (option.responseType === &apos;arraybuffer&apos;) &#123;</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line">        const [reqURL, resData] = takeapartResponse(response);</span><br><span class="line">        const noWarn = &apos;no-global-config-warn&apos; in response.config.headers</span><br><span class="line">          &amp;&amp; !!response.config.headers[&apos;no-global-config-warn&apos;];</span><br><span class="line">        const isValid = isValidCode(resData.errno);</span><br><span class="line">        const method = response.config.method.toUpperCase();</span><br><span class="line">        if (!isValid) &#123;</span><br><span class="line">          // eslint-disable-next-line prefer-promise-reject-errors</span><br><span class="line">          return Promise.reject(&#123;</span><br><span class="line">            type: ERR_CODE,</span><br><span class="line">            reqURL,</span><br><span class="line">            resData,</span><br><span class="line">            noWarn,</span><br><span class="line">            method</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        const reqStr = `$&#123;method&#125; $&#123;reqURL&#125;`;</span><br><span class="line">        // warnByResponse 函数是根据业务针对不同接口返回不同的错误提示。这个函数可以根据业务自行处理。</span><br><span class="line">        warnByResponse(reqStr, resData, true, noWarn);</span><br><span class="line">        return resData;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    // wrong business logic</span><br><span class="line">    // r.interceptors.response.use(</span><br><span class="line">    //   response =&gt; response,</span><br><span class="line">    //   (error) =&gt; &#123;</span><br><span class="line">    //     if (error.type === ERR_CODE) &#123;</span><br><span class="line">    //       const reqStr = `$&#123;error.method&#125; $&#123;error.reqURL&#125;`;</span><br><span class="line">    //       warnByResponse(reqStr, error.resData, false, error.noWarn);</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return Promise.reject(error.resData);</span><br><span class="line">    //   &#125;</span><br><span class="line">    // );</span><br><span class="line"></span><br><span class="line">    return r(option);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="简单的封装axios函数"><a href="#简单的封装axios函数" class="headerlink" title="简单的封装axios函数"></a>简单的封装axios函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获得一般的 wrapper</span><br><span class="line"> * @param &#123;Object&#125; [option]</span><br><span class="line"> */</span><br><span class="line"> // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class="line">export default option =&gt; axiosWrapper(&#123;</span><br><span class="line">  transformResponse: data =&gt; void (0), // eslint-disable-line no-unused-vars</span><br><span class="line">  </span><br><span class="line">&#125;)(option);</span><br></pre></td></tr></table></figure>
<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。</p>
<p>因为params是添加到url的请求字符串中的，用于get请求。</p>
<p>而data是添加到请求体（body）中的， 用于post请求。</p>
<p>api.js使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import axios, &#123; download &#125; from &apos;./http.js&apos;;</span><br><span class="line">export const mock = params =&gt; axios(&#123;</span><br><span class="line">    url: &apos;/mock&apos;,</span><br><span class="line">    method: &apos;get&apos;,</span><br><span class="line">    params</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export const upload = data =&gt; axios(&#123;</span><br><span class="line">    url: &apos;/upload&apos;,</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h5 id="用于下载的axiosWrapper"><a href="#用于下载的axiosWrapper" class="headerlink" title="用于下载的axiosWrapper"></a>用于下载的axiosWrapper</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export const download = option =&gt; axiosWrapper(&#123;</span><br><span class="line">  responseType: &apos;arraybuffer&apos;</span><br><span class="line">&#125;)(option)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    const contentType = res.headers[&apos;content-type&apos;];</span><br><span class="line"></span><br><span class="line">    if (~contentType.indexOf(&apos;json&apos;)) &#123;</span><br><span class="line">      const resData = res.data || res.request.response;</span><br><span class="line">      const text = Buffer.from(resData).toString(&apos;utf8&apos;);</span><br><span class="line">      const json = JSON.parse(text);</span><br><span class="line">      return Promise.reject(json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const disposition = res.headers[&apos;content-disposition&apos;];</span><br><span class="line">    if (disposition &amp;&amp; disposition.match(/attachment/)) &#123;</span><br><span class="line">      let filename = disposition.replace(/attachment;.*filename=/, &apos;&apos;).replace(/&quot;/g, &apos;&apos;);</span><br><span class="line">      filename = filename &amp;&amp; filename !== &apos;&apos;</span><br><span class="line">        ? filename</span><br><span class="line">        : (option.defaultFilename || &apos;noname&apos;);</span><br><span class="line">      const blob = new Blob([res.data], &#123; type: contentType &#125;);</span><br><span class="line">      saveAs(blob, filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Promise.resolve(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>api.js使用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import axios, &#123; download &#125; from &apos;./http&apos;;</span><br><span class="line"></span><br><span class="line">export const export = (data, defaultFilename) = download(&#123;</span><br><span class="line">  url: &apos;/api//export&apos;,</span><br><span class="line">  method: &apos;post&apos;,</span><br><span class="line">  data,</span><br><span class="line">  defaultFilename</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="封装一个axios的思路"><a href="#封装一个axios的思路" class="headerlink" title="封装一个axios的思路"></a>封装一个axios的思路</h2><ul>
<li>配置请求基本信息的常量：（用于基本处理）<br>BASE_URL ：根据环境变量，针对生成、测试、开发环境配置对应的url<br>TIMEOUT: 配置接口请求超时时间。<br>headers： 配置请求头<br>validateStatus: 定义HTTP响应状态码的范围。如果<code>validateStatus</code>返回<code>true</code>（或被设置为<code>null</code> promise将被解析;否则，promise将被拒绝。</li>
</ul>
<p>可以请求接口的不同，封装axios的时候，将 请求基本信息的常量 通过 参数 的方式单独进行配置。</p>
<blockquote>
<p>扩展：<br>  具体方法：通过lodash的mergeWith方法将默认的option配置和手动配置的globalOption，通过递归的形式合并成一个option。</p>
</blockquote>
<ul>
<li><p>请求拦截</p>
<p>timeout: 在axios的源代码中，超时后, 会在拦截器那里 axios.interceptors.response 捕抓到错误信息, 且 error.code = “ECONNABORTED”，可以根据这个code提示超时报错信息。</p>
<p>token：统一在http请求的header都加上token，这样后台根据token判断你的登录情况，即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断</p>
<p>other errors: 根据请求状态<code>status</code>,直接promise.reject.路由跳转到对应的报错页面。<br>根据请求头和method来处理入参的格式</p>
</li>
</ul>
<p>在使用axios时，注意到配置选项中包含params和data两者，以为他们是相同的，实则不然。<br>因为params是添加到url的请求字符串中的，用于get请求。<br>而data是添加到请求体（body）中的， 用于post请求。</p>
<ul>
<li>响应拦截<br>badStatusMap: 请求失败，根据HTTP响应状态码做出对应的messageTip</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/04/asyncAwit/" data-id="ckd4b4q1e000zt2p3y1xf4lzc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-express" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/20/express/" class="article-date">
  <time datetime="2019-09-20T09:29:05.000Z" itemprop="datePublished">2019-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/20/express/">express： 实现本地代码+本地mock+环境接口数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-20 17:29:05</p>
<h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><ul>
<li>简介<br>基于 Node.js 平台，快速、开放、极简的 Web 开发框架</li>
</ul>
<p>简单来说，封装了node中http核心模块，专注于业务逻辑的开发.</p>
<p>express中间件的本质就是请求处理方法，把用户从请求到响应的整个过程分发到多个中间件中去处理，提高代码灵活性，动态可扩展</p>
<ul>
<li>安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; npm install express --save-dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>以vue项目为例<br>在根目录下新建api文件-&gt;server.js文件。</p>
</blockquote>
<h6 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖:"></a>安装其他依赖:</h6><ul>
<li><p>body-parser<br>一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL - encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。</p>
</li>
<li><p>request: Request - Simplified HTTP client</p>
</li>
<li>klaw-sync：klaw-sync is a Node.js recursive and fast file system walker</li>
</ul>
<p>实例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line"></span><br><span class="line">const request = require(&apos;request&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const walk = require(&apos;klaw-sync&apos;);</span><br><span class="line">const config = require(&quot;../vue.config&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const origin_proxy_url = &apos;http://origin_proxy_url.jdcloud.com&apos;; //测试接口url</span><br><span class="line">const local_proxy_port = 3002;                                  //本地server端口</span><br><span class="line">const local_proxy_url = `http://localhost:$&#123;local_proxy_port&#125;`; //本地接口url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">//  创建 application/x-www-form-urlencoded 解析 :解析UTF-8的编码的数据</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: false &#125;)); </span><br><span class="line">// 当设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// create application/json parser</span><br><span class="line">app.use(bodyParser.json());</span><br><span class="line">app.use(function (req, res, next) &#123;</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let _existRoutes = [];</span><br><span class="line">app.use((req, res, next) =&gt; &#123; //TODO post和上传还有问题</span><br><span class="line">  const &#123; url, body, method &#125; = req;</span><br><span class="line">  if (!~_existRoutes.indexOf(req.path)) &#123;</span><br><span class="line">    const rurl = origin_proxy_url.replace(/\/$/, &apos;&apos;) + url;</span><br><span class="line">    let r = method === &apos;POST&apos;</span><br><span class="line">      ? request.post(&#123; url: rurl, form: body &#125;, (err, httpRes, reqBody) =&gt; &#123;</span><br><span class="line">        console.log(err, reqBody, body)</span><br><span class="line">      &#125;)</span><br><span class="line">      : request(rurl);</span><br><span class="line">    console.log(`本地未定义的请求，跳转到 $&#123;method&#125; $&#123;rurl&#125;`);</span><br><span class="line">    req.pipe(r).pipe(res);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//遍历本目录下的 *.api.js</span><br><span class="line">walk(path.resolve(&apos;./&apos;))</span><br><span class="line">  .filter(p =&gt; /\.api\.js$/.test(p.path))</span><br><span class="line">  .map(p =&gt; p.path)</span><br><span class="line">  .forEach(part =&gt; require(part)(app));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//全局配置，只在应用启动时读取一次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//记录注册过的路由</span><br><span class="line">_existRoutes = app._router.stack.filter(s =&gt; s.route).map(s =&gt; s.route.path);</span><br><span class="line"></span><br><span class="line">app.listen(local_proxy_port, () =&gt; &#123;</span><br><span class="line">  console.log(`\n\n local server running at $&#123;local_proxy_url&#125; \n\n`);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="运行express服务器"><a href="#运行express服务器" class="headerlink" title="运行express服务器"></a>运行express服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 启动本地项目： 如果配置了代理，请求的是本地代码+测试接口</span><br><span class="line"></span><br><span class="line">    // express 相关命令</span><br><span class="line">    &quot;server&quot;: &quot;nodemon api/server.js&quot;, //  本地express服务器</span><br><span class="line">    &quot;devlocal&quot;: &quot;shell-exec --colored-output \&quot;npm run serve --local\&quot; \&quot;npm run server\&quot;&quot; </span><br><span class="line">    // 启动本地项目: 本地代码+ 本地mock接口/测试接口</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>安装运行依赖<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install shell-executor --save-dev</span><br><span class="line">$ npm install nodemon --save-dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>shell-executor: A small nodejs module to execute shell commands in parallel<br>nodemon: 用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中</p>
</blockquote>
<ul>
<li>运行项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run devlocal</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/express/" data-id="ckd4b4q1r001bt2p3d5j8y3up" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog-hexo/">blog-hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6-vue/">es6, vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm-react-typescript/">npm react typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue-test/">vue test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue-vueRouter/">vue, vueRouter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端面试题/">前端面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/blog-hexo/" style="font-size: 13.33px;">blog-hexo</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/es6-vue/" style="font-size: 10px;">es6, vue</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/js/" style="font-size: 13.33px;">js</a> <a href="/tags/node/" style="font-size: 13.33px;">node</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/npm-react-typescript/" style="font-size: 10px;">npm react typescript</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/vue-test/" style="font-size: 10px;">vue test</a> <a href="/tags/vue-vueRouter/" style="font-size: 10px;">vue, vueRouter</a> <a href="/tags/web/" style="font-size: 13.33px;">web</a> <a href="/tags/前端面试题/" style="font-size: 16.67px;">前端面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/27/vueI18/">vue项目中引入&amp;使用国际化</a>
          </li>
        
          <li>
            <a href="/2020/07/27/fixProject/">如何优化项目</a>
          </li>
        
          <li>
            <a href="/2020/07/27/axios1/">Axios源码解析</a>
          </li>
        
          <li>
            <a href="/2020/07/27/reactCom2/">使用react搭建组件库--radio组件</a>
          </li>
        
          <li>
            <a href="/2020/07/27/reactCom1/">使用react搭建组件库--icon组件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>