<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="blog">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vueTitle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/vueTitle/" class="article-date">
  <time datetime="2019-09-03T02:10:37.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/vueTitle/">vue相关面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-03 10:10:37</p>
<h3 id="孙子组件或更深层次的组件通信（除了props和vuex的其他用法）"><a href="#孙子组件或更深层次的组件通信（除了props和vuex的其他用法）" class="headerlink" title="孙子组件或更深层次的组件通信（除了props和vuex的其他用法）"></a>孙子组件或更深层次的组件通信（除了props和vuex的其他用法）</h3><ul>
<li>Vue Event Bus，使用Vue的实例，实现事件的监听和发布，实现组件之间的传递<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h6>使用在实际的项目操作中发现，如不能实现很好的事件监听与发布的管理，往往容易导致数据流的混乱，在多人协作的项目中，不利于项目的维护<br>#####1.  父组件使用provide，子组件使用inject</li>
<li>通过inject直接访问其两个层级上的数据，其用法与props完全相同，同样可以参数校验等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.provide就相当于加强版父组件prop</span><br><span class="line">2.inject就相当于加强版子组件的props</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>// 示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&#123;&#123;name&#125;&#125;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &apos;father&apos;,</span><br><span class="line">  // 传入对象写法</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: &apos;bar&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  // 函数写法</span><br><span class="line">	provide () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &apos;foo&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 孙子组件或者深层次组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&#123;&#123;name&#125;&#125;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	name: &apos;Grandson&apos;,</span><br><span class="line">	inject: [name]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><p>在任意层级都能访问，导致数据变化追踪比较困难。</p>
<h5 id="2-通过-attrs传递属性"><a href="#2-通过-attrs传递属性" class="headerlink" title="2.通过$attrs传递属性"></a>2.通过$attrs传递属性</h5><p>vue api解释说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.$attrs和inheritAttrs</span><br><span class="line">2.4.0 新增</span><br><span class="line">类型：&#123; [key: string]: string &#125;</span><br><span class="line">只读</span><br><span class="line">详细：</span><br><span class="line">包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</span><br></pre></td></tr></table></figure></p>
<p>细节使用示例参考链接：<a href="https://www.jianshu.com/p/ce8ca875c337" target="_blank" rel="noopener">https://www.jianshu.com/p/ce8ca875c337</a></p>
<h5 id="3-通过-listeners传递事件"><a href="#3-通过-listeners传递事件" class="headerlink" title="3.通过$listeners传递事件"></a>3.通过$listeners传递事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm.$listeners</span><br><span class="line">2.4.0 新增</span><br><span class="line">类型：&#123; [key: string]: Function | Array&lt;Function&gt; &#125;</span><br><span class="line">只读</span><br><span class="line">详细：</span><br><span class="line">包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。</span><br></pre></td></tr></table></figure>
<h5 id="4-Vue2-6-新全局API：Vue-observable"><a href="#4-Vue2-6-新全局API：Vue-observable" class="headerlink" title="4.Vue2.6+新全局API：Vue.observable()"></a>4.Vue2.6+新全局API：Vue.observable()</h5><h3 id="子组件访问父组件数据（除了props）"><a href="#子组件访问父组件数据（除了props）" class="headerlink" title="子组件访问父组件数据（除了props）"></a>子组件访问父组件数据（除了props）</h3><ul>
<li>使用$parent属性</li>
<li>通过$attrs传递属性</li>
<li>Vue2.6+新全局API：Vue.observable()</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/03/vueTitle/" data-id="ck0rxd4ta000sygkc81rfw2q3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vueSourceCoding" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/vueSourceCoding/" class="article-date">
  <time datetime="2019-09-03T01:47:57.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/vueSourceCoding/">了解vue源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-03 09:47:57</p>
<h2 id="new-Vue-做了什么？"><a href="#new-Vue-做了什么？" class="headerlink" title="new Vue()做了什么？"></a>new Vue()做了什么？</h2><p>new关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是<br><code>/src/core/instance/index.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Vue (options) &#123;</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    !(this instanceof Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  this._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们跳转追踪至<code>this._init()</code>，即<code>Vue.prototype._init</code>,位于<code>src\core\instance\init.js</code>.<br>在<code>_init()</code>方法的内部有一系列 <code>init*</code> 的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = function (options?: Object) &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    // ...忽略，从第45行看起</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    // expose real self</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">    initInjections(vm) // resolve injections before data/props</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) // resolve provide after data/props</span><br><span class="line">    callHook(vm, &apos;created&apos;)</span><br><span class="line">    // ...忽略</span><br><span class="line">    if (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>统一概述一遍new Vue()时做了什么处理:</p>
<ul>
<li><code>initProxy</code>，作用域代理，拦截组件内访问其它组件的数据。(支持Proxy且处于开发环境下, 对未声明就使用的属性进行提示)</li>
<li><code>initLifecycle</code>（初始生命周期）, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如:$children、$refs、_isMounted等。</li>
<li><code>initEvents</code>，用来存放除@hook:生命周期钩子名称=”绑定的函数”事件的对象。如:$on、$emit等。</li>
<li><code>initRender</code>，用于初始化$slots、$attrs、$listeners</li>
<li><code>initInjections</code>，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。</li>
<li><code>initState</code>，是很多选项初始化的汇总，包括:props、methods、data、computed 和 watch 等。</li>
<li><code>initProvide</code>，初始化provide。</li>
<li><code>vm.$mount</code>，挂载实例。</li>
</ul>
<h2 id="什么阶段才能访问DOM？"><a href="#什么阶段才能访问DOM？" class="headerlink" title="什么阶段才能访问DOM？"></a>什么阶段才能访问DOM？</h2><p>这个回答可以从beforeCreate以及 created 的调用时机谈起，我们根据上面的概述，来简化下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, &apos;beforeCreate&apos;)</span><br><span class="line">// 初始化 inject</span><br><span class="line">// 初始化 props、methods、data、computed、watch和挂载元素$el(都为undefined)</span><br><span class="line">// 初始化 provide</span><br><span class="line">callHook(vm, &apos;created&apos;)</span><br><span class="line">// 挂载实例 vm.$mount(vm.$options.el)</span><br><span class="line">// vue实例的数据对象data有了</span><br></pre></td></tr></table></figure></p>
<p>所以当面试官问你:</p>
<ul>
<li>beforeCreate以及 created 调用时，哪些数据能用与否？</li>
<li>什么阶段才能访问DOM？</li>
<li>为什么created之后才挂载实例？</li>
</ul>
<h2 id="谈谈你对Vue的生命周期的理解？"><a href="#谈谈你对Vue的生命周期的理解？" class="headerlink" title="谈谈你对Vue的生命周期的理解？"></a>谈谈你对Vue的生命周期的理解？</h2><p>生命周期函数解释说明（图片）：<a href="https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png" target="_blank" rel="noopener">https://img2018.cnblogs.com/blog/1475079/201810/1475079-20181015102951341-1694919323.png</a></p>
<h5 id="理解"><a href="#理解" class="headerlink" title="理解:"></a>理解:</h5><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会</p>
<h5 id="生命周期的几个阶段"><a href="#生命周期的几个阶段" class="headerlink" title="生命周期的几个阶段:"></a>生命周期的几个阶段:</h5><ol>
<li>created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁</li>
</ol>
<ul>
<li>beforeCreate &amp; created 看上一题</li>
<li><p>beforeMount &amp; mounted</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line">// vue实例的$el和data都初始化完成， 挂载之前为虚拟的dom节点，</span><br><span class="line">callHook(vm, &apos;mounted&apos;)</span><br><span class="line">// vue实例挂载完成，data.message成功渲染</span><br></pre></td></tr></table></figure>
</li>
<li><p>beforeUpdate &amp; updated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data变化会触发beforeUpdate和updated方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>beforeDestroy &amp; destroyed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, &apos;destroyed&apos;)</span><br><span class="line">// data的改变不会再触发周期函数</span><br><span class="line">// vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>深入理解源码:</p>
<ol start="2">
<li>Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// v2.6.10 最新版</span><br><span class="line">var LIFECYCLE_HOOKS = [</span><br><span class="line">    &apos;beforeCreate&apos;,</span><br><span class="line">    &apos;created&apos;,</span><br><span class="line">    &apos;beforeMount&apos;,</span><br><span class="line">    &apos;mounted&apos;,</span><br><span class="line">    &apos;beforeUpdate&apos;,</span><br><span class="line">    &apos;updated&apos;,</span><br><span class="line">    &apos;beforeDestroy&apos;,</span><br><span class="line">    &apos;destroyed&apos;,</span><br><span class="line">    &apos;activated&apos;,</span><br><span class="line">    &apos;deactivated&apos;,</span><br><span class="line">    &apos;errorCaptured&apos;,</span><br><span class="line">    // v2.6+ </span><br><span class="line">    &apos;serverPrefetch&apos; //看下一题</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>于是，你可以答多<code>activated &amp; deactivated</code>（keep-alive 组件激活/停用）、<code>errorCaptured</code>（v2.5 以上版本有的一个钩子，用于处理错误）这三个。</p>
<hr>
<h2 id="生命周期钩子的合并策略"><a href="#生命周期钩子的合并策略" class="headerlink" title="生命周期钩子的合并策略"></a>生命周期钩子的合并策略</h2><p><a href="https://www.cnblogs.com/xweizi/p/10572281.html" target="_blank" rel="noopener">https://www.cnblogs.com/xweizi/p/10572281.html</a></p>
<hr>
<p>单独抽出一天来处理</p>
<h2 id="新生命周期钩子：serverPrefetch是什么？"><a href="#新生命周期钩子：serverPrefetch是什么？" class="headerlink" title="新生命周期钩子：serverPrefetch是什么？"></a>新生命周期钩子：serverPrefetch是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// v2.6.10的变化</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>serverPrefetch</code>前身是<code>ssrPrefetch</code>。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。<br><img src="https://user-gold-cdn.xitu.io/2019/3/25/169b418d400ff0b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br>这里我们贴出一段官方例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Item.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div v-if=&quot;item&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-else&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    item () &#123;</span><br><span class="line">      return this.$store.state.items[this.$route.params.id]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  serverPrefetch () &#123;</span><br><span class="line">    return this.fetchItem()</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    if (!this.item) &#123;</span><br><span class="line">      this.fetchItem()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchItem () &#123;</span><br><span class="line">      // return the Promise from the action</span><br><span class="line">      return this.$store.dispatch(&apos;fetchItem&apos;, this.$route.params.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Vue-router-路由模式有几种？"><a href="#Vue-router-路由模式有几种？" class="headerlink" title="Vue-router 路由模式有几种？"></a>Vue-router 路由模式有几种？</h2><p>三种 “hash” | “history” | “abstract”，一般人只知道两种”hash” | “history”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 源码：</span><br><span class="line"></span><br><span class="line">switch (mode) &#123;</span><br><span class="line">  case &apos;history&apos;:</span><br><span class="line">    this.history = new HTML5History(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  case &apos;hash&apos;:</span><br><span class="line">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class="line">    break</span><br><span class="line">  case &apos;abstract&apos;:</span><br><span class="line">    this.history = new AbstractHistory(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  default:</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h5><ul>
<li>类型: string</li>
<li>默认值: “hash” (浏览器环境) | “abstract” (Node.js 环境)</li>
<li>可选值: “hash” | “history” | “abstract”</li>
</ul>
<p>配置路由模式:</p>
<ul>
<li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</li>
<li>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</li>
<li>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h6 id="路由模式解析"><a href="#路由模式解析" class="headerlink" title="路由模式解析"></a>路由模式解析</h6><p>对于Vue 这类渐进式前端开发框架，为了构建SPA（单页面应用），需要引入前端路由系统，这也就是Vue-router存在的意义.</p>
<p>前端路由的核心，就在于——— 改变视图的同时不会向后端发出请求<br><code>浏览器对页面的访问是无状态的，所以我们在切换不同的页面时都会重新进行请求。
实际运用vue和vue-router开发就会发现，在切换页面时是没有重新请求的，使用起来就好像页面是有状态的。
其实是借助浏览器的History API来实现的，可以使页面跳转而不刷新，页面的状态就维持在浏览器中了。</code></p>
<p>.</p>
<ul>
<li>vue-router: hash</li>
</ul>
<p>hash模式中url带有#号，修改成history模式，url中的#自动就去除了。</p>
<p>hash模式背后的原理是onhashchange事件，可以在window对象上监听这个事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function(event)&#123;</span><br><span class="line">    console.log(event.oldURL, event.newURL);</span><br><span class="line">    let hash = location.hash.slice(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hash模式下，仅hash符号之前的内容会被包含在请求中,如 <a href="http://www.abc.com" target="_blank" rel="noopener">http://www.abc.com</a>, 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回404错误,因此改变hash不会重新加载页面.</p>
<ul>
<li>vue-router: history<br>随着history api的到来，前端路由开始进化了，前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由。<br>　history api可以分为两大部分：切换和修改</li>
</ul>
<ol>
<li>切换历史状态</li>
</ol>
<p>包括back、forward、go三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.go(-2);//后退两次</span><br><span class="line">history.go(2);//前进两次</span><br><span class="line">history.back(); //后退</span><br><span class="line">hsitory.forward(); //前进</span><br></pre></td></tr></table></figure></p>
<p><code>坑1：此处有一个开发的坑：在我们项目中，开发人员会在某个详情页面按钮上绑定history.go(-1)用来进入详情的主页面，
有时测试人员会直接输入url进入详情页，这样点击按钮就会出现问题，跳转的就不是项目中的主页面，就会是浏览器历史记录中的上一页</code></p>
<ol start="2">
<li>修改历史状态<br>包括了pushState、replaceState两个方法，这两个方法接收三个参数：stateObj，title，url<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(stateObj，title，url)</span><br><span class="line">window.onpopstate = function(event)&#123;</span><br><span class="line">    console.log(event.state)</span><br><span class="line">    if(event.state &amp;&amp; event.state.color === &apos;red&apos;)&#123;</span><br><span class="line">        document.body.style.color = &apos;red&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>坑2：通过history api，我们丢掉了丑陋的#，但是它也有个毛病：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话），因为刷新是实实在在地去请求服务器的。在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</code></p>
<ol start="3">
<li>popstate实现history路由拦截，监听页面返回事件<br>当活动历史记录条目更改时，将触发popstate事件</li>
</ol>
<ul>
<li><p>如果被激活的历史记录条目是通过对  history.pushState()  的调用创建的，或者受到对  history.replaceState()  的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。</p>
</li>
<li><p>需要注意的是调用  history.pushState()  或  history.replaceState()  用来在浏览历史中添加或修改记录，不会触发popstate事件；</p>
<p>　　只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）</p>
</li>
<li>vue-router: abstract<br>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</li>
</ul>
<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式</p>
<h2 id="谈谈你对keep-alive的了解"><a href="#谈谈你对keep-alive的了解" class="headerlink" title="谈谈你对keep-alive的了解"></a>谈谈你对keep-alive的了解</h2><p>先贴一个常规回答：<br>`<br>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>
<p><keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。<br>`</keep-alive></p>
<p><code>然后你可以开始骚了：</code></p>
<ol>
<li><p><code>&lt;keep-alive&gt;</code>是 Vue 源码中实现的一个全局抽象组件，通过自定义 <code>render</code> 函数并且利用了<code>插槽</code>来实现数据缓存和更新。它的定义在<code>src/core/components/keep-alive.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;keep-alive&apos;,</span><br><span class="line">  abstract: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">  // abstract 即 `ptions.abstract`</span><br><span class="line">  // while 循环查找第一个非抽象的父组件</span><br><span class="line">  while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">    parent = parent.$parent</span><br><span class="line">  &#125;</span><br><span class="line">  parent.$children.push(vm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 <keep-alive> 树内的所有嵌套组件中触发。</keep-alive></p>
<h2 id="vue源码中内置的组件？"><a href="#vue源码中内置的组件？" class="headerlink" title="vue源码中内置的组件？"></a>vue源码中内置的组件？</h2><ul>
<li>component</li>
<li>transition</li>
<li>transition-group</li>
<li>keep-alive</li>
<li>slot<h2 id="了解Vue2-6-新全局API：Vue-observable-吗？"><a href="#了解Vue2-6-新全局API：Vue-observable-吗？" class="headerlink" title="了解Vue2.6+新全局API：Vue.observable()吗？"></a>了解Vue2.6+新全局API：Vue.observable()吗？</h2>Vue2.6+新的全局API是Vue.observable(),它的使用方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 准备个文件store.js - /store/store.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">export const store = Vue.observable(&#123; count: 0 &#125;)  //定义一个变量</span><br><span class="line">export const mutations = &#123;  //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值</span><br><span class="line">  setCount (count) &#123;</span><br><span class="line">    store.count = count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>返回的对象可以直接用于<code>渲染函数</code>和<code>计算属性</code>内，并且会在发生改变时触发相应的更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;你点+-，看我能不能根据状态去动态改变&lt;/p&gt;</span><br><span class="line">        &lt;label for=&quot;bookNum&quot;&gt;数量&lt;/label&gt;</span><br><span class="line">        &lt;button @click=&quot;setCount(count+1)&quot;&gt;+&lt;/button&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;button @click=&quot;setCount(count-1)&quot;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; store, mutations &#125; from &apos;../store/store&apos; // Vue2.6新增API Observable</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Add&apos;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      return store.count //用于去渲染之前Observable中定义的变量count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setCount: mutations.setCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="了解Vue数据绑定原理？"><a href="#了解Vue数据绑定原理？" class="headerlink" title="了解Vue数据绑定原理？"></a>了解Vue数据绑定原理？</h2><p>参考Vue.js官网介绍响应式原理图，我们进行分析：</p>
<p>这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。<br>Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。</p>
<p>Vue在初始化组件数据时，在生命周期的<code>beforeCreate</code>与<code>created</code>钩子函数之间实现了对<code>data、props、computed、methods、events</code>以及<code>watch</code>的处理.</p>
<ul>
<li>initData<br>参考源码instance下的state.js文件</li>
</ul>
<p>initData主要是初始化data中的数据，将数据进行observe，监听数据的变化，其他的监视原理一致，这里以data为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function initData (vm: Component) &#123;  </span><br><span class="line">  /*得到data数据*/</span><br><span class="line">  let data = vm.$options.data</span><br><span class="line">  data = vm._data = typeof data === &apos;function&apos; ? getData(data, vm) : data || &#123;&#125; </span><br><span class="line">  /*判断是否是对象*/</span><br><span class="line">  if (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(&apos;data functions should return an object:\n&apos; +&apos;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&apos;, vm)</span><br><span class="line">  &#125;  </span><br><span class="line">  // proxy data on instance</span><br><span class="line">  /*遍历data对象*/</span><br><span class="line">  const keys = Object.keys(data)</span><br><span class="line">  const props = vm.$options.props</span><br><span class="line">  let i = keys.length</span><br><span class="line">  //遍历data中的数据</span><br><span class="line">  while (i--) &#123;</span><br><span class="line">    /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/    if (props &amp;&amp; hasOwn(props, keys[i])) &#123;</span><br><span class="line">      process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(`The data property &quot;$&#123;keys[i]&#125;&quot; is already declared as a prop. ` +`Use prop default value instead.`,vm)</span><br><span class="line">    &#125; else if (!isReserved(keys[i])) &#123;</span><br><span class="line">      /*判断是否是保留字段*/</span><br><span class="line">      /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/</span><br><span class="line">      proxy(vm, `_data`, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // observe data</span><br><span class="line">  /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/  </span><br><span class="line">  observe(data, true /* asRootData */)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据(data对象中的深层次数据，以及props)变成observable。</p>
<ul>
<li>proxy<br>接下来看一下proxy代理。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*添加代理*/</span><br><span class="line">export function proxy (target: Object, sourceKey: string, key: string) &#123;</span><br><span class="line">  sharedPropertyDefinition.get = function proxyGetter () &#123;</span><br><span class="line">    return this[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = function proxySetter (val) &#123;</span><br><span class="line">    this[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。</p>
<ul>
<li>observe<br>参考源码文件在core文件下oberver的index.js文件中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> */</span><br><span class="line"> /*</span><br><span class="line"> 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。</span><br><span class="line"> */</span><br><span class="line">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class="line">  /*判断是否是一个对象*/</span><br><span class="line">  if (!isObject(value)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob: Observer | void</span><br><span class="line"></span><br><span class="line">  /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/</span><br><span class="line">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; else if (</span><br><span class="line"></span><br><span class="line">    /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/</span><br><span class="line">    observerState.shouldConvert &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    Object.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class="line"></span><br><span class="line">    /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vue的响应式数据都会有一个<strong>ob</strong>的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。</p>
<ul>
<li>Observer<br>Observer的作用就是遍历对象的所有属性将其进行双向绑定。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Observer class that are attached to each observed</span><br><span class="line"> * object. Once attached, the observer converts target</span><br><span class="line"> * object&apos;s property keys into getter/setters that</span><br><span class="line"> * collect dependencies and dispatches updates.</span><br><span class="line"> */</span><br><span class="line">export class  &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; // number of vms that has this object as root $data</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16</span><br><span class="line">    */</span><br><span class="line">    def(value, &apos;__ob__&apos;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">          如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。</span><br><span class="line">          这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。</span><br><span class="line">      */</span><br><span class="line">      const augment = hasProto</span><br><span class="line">        ? protoAugment  /*直接覆盖原型的方法来修改目标对象*/</span><br><span class="line">        : copyAugment   /*定义（覆盖）目标对象或数组的某一个方法*/</span><br><span class="line">      augment(value, arrayMethods, arrayKeys)</span><br><span class="line"></span><br><span class="line">      /*如果是数组则需要遍历数组的每一个成员进行observe*/</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      /*如果是对象则直接walk进行绑定*/</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Walk through each property and convert them into</span><br><span class="line">   * getter/setters. This method should only be called when</span><br><span class="line">   * value type is Object.</span><br><span class="line">   */</span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line"></span><br><span class="line">    /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    /*数组需要便利每一个成员进行observe*/</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。<br>如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。<br>但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？</p>
<p>Vue.js提供的方法是重写 <code>push、pop、shift、unshift、splice、sort、reverse</code>这七个数组方法。修改数组原型方法的代码可以参考observer/array.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * not type checking this file because flow doesn&apos;t play well with</span><br><span class="line"> * dynamically accessing methods on Array prototype</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import &#123; def &#125; from &apos;../util/index&apos;</span><br><span class="line"></span><br><span class="line">/*取得原生数组的原型*/</span><br><span class="line">const arrayProto = Array.prototype</span><br><span class="line">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span><br><span class="line">export const arrayMethods = Object.create(arrayProto)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Intercept mutating methods and emit events</span><br><span class="line"> */</span><br><span class="line"> /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/</span><br><span class="line">;[</span><br><span class="line">  &apos;push&apos;,</span><br><span class="line">  &apos;pop&apos;,</span><br><span class="line">  &apos;shift&apos;,</span><br><span class="line">  &apos;unshift&apos;,</span><br><span class="line">  &apos;splice&apos;,</span><br><span class="line">  &apos;sort&apos;,</span><br><span class="line">  &apos;reverse&apos;</span><br><span class="line">]</span><br><span class="line">.forEach(function (method) &#123;</span><br><span class="line">  // cache original method</span><br><span class="line">  /*将数组的原生方法缓存起来，后面要调用*/</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, function mutator () &#123;</span><br><span class="line">    // avoid leaking arguments:</span><br><span class="line">    // http://jsperf.com/closure-with-arguments</span><br><span class="line">    let i = arguments.length</span><br><span class="line">    const args = new Array(i)</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      args[i] = arguments[i]</span><br><span class="line">    &#125;</span><br><span class="line">    /*调用原生的数组方法*/</span><br><span class="line">    const result = original.apply(this, args)</span><br><span class="line"></span><br><span class="line">    /*数组新插入的元素需要重新进行observe才能响应式*/</span><br><span class="line">    const ob = this.__ob__</span><br><span class="line">    let inserted</span><br><span class="line">    switch (method) &#123;</span><br><span class="line">      case &apos;push&apos;:</span><br><span class="line">        inserted = args</span><br><span class="line">        break</span><br><span class="line">      case &apos;unshift&apos;:</span><br><span class="line">        inserted = args</span><br><span class="line">        break</span><br><span class="line">      case &apos;splice&apos;:</span><br><span class="line">        inserted = args.slice(2)</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    if (inserted) ob.observeArray(inserted)</span><br><span class="line">      </span><br><span class="line">    // notify change</span><br><span class="line">    /*dep通知所有注册的观察者进行响应式处理*/</span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    return result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持<strong>proto</strong>这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。</p>
<p>如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。</p>
<p>在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。</p>
<p>但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，Vue.js提供了$set()及$remove()方法。</p>
<ul>
<li>Watcher</li>
</ul>
<p>Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由于Deps通知Watcher实例，然后由Watcher实例回调cb进行实图的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">export default class Watcher &#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: ISet;</span><br><span class="line">  newDepIds: ISet;</span><br><span class="line">  getter: Function;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: Object</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    /*_watchers存放订阅者实例*/</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    // options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep = !!options.deep</span><br><span class="line">      this.user = !!options.user</span><br><span class="line">      this.lazy = !!options.lazy</span><br><span class="line">      this.sync = !!options.sync</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.id = ++uid // uid for batching</span><br><span class="line">    this.active = true</span><br><span class="line">    this.dirty = this.lazy // for lazy watchers</span><br><span class="line">    this.deps = []</span><br><span class="line">    this.newDeps = []</span><br><span class="line">    this.depIds = new Set()</span><br><span class="line">    this.newDepIds = new Set()</span><br><span class="line">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &apos;&apos;</span><br><span class="line">    // parse expression for getter</span><br><span class="line">    /*把表达式expOrFn解析成getter*/</span><br><span class="line">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class="line">      this.getter = expOrFn</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter = parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter = function () &#123;&#125;</span><br><span class="line">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class="line">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class="line">          &apos;For full control, use a function instead.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   */</span><br><span class="line">   /*获得getter的值并且重新进行依赖收集*/</span><br><span class="line">  get () &#123;</span><br><span class="line">    /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span><br><span class="line">    pushTarget(this)</span><br><span class="line">    let value</span><br><span class="line">    const vm = this.vm</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。</span><br><span class="line">      在将Dep.target设置为自生观察者实例以后，执行getter操作。</span><br><span class="line">      譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，</span><br><span class="line">      那么在执行getter的时候就会触发a跟c两个数据的getter函数，</span><br><span class="line">      在getter函数中即可判断Dep.target是否存在然后完成依赖收集，</span><br><span class="line">      将该观察者对象放入闭包中的Dep的subs中去。</span><br><span class="line">    */</span><br><span class="line">    if (this.user) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        value = this.getter.call(vm, vm)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      value = this.getter.call(vm, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    // &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">    // dependencies for deep watching</span><br><span class="line">    /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/</span><br><span class="line">    if (this.deep) &#123;</span><br><span class="line">      /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*将观察者实例从target栈中取出并设置给Dep.target*/</span><br><span class="line">    popTarget()</span><br><span class="line">    this.cleanupDeps()</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Add a dependency to this directive.</span><br><span class="line">   */</span><br><span class="line">   /*添加一个依赖关系到Deps集合中*/</span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    const id = dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Clean up for dependency collection.</span><br><span class="line">   */</span><br><span class="line">   /*清理依赖收集*/</span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    /*移除所有观察者对象*/</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      const dep = this.deps[i]</span><br><span class="line">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tmp = this.depIds</span><br><span class="line">    this.depIds = this.newDepIds</span><br><span class="line">    this.newDepIds = tmp</span><br><span class="line">    this.newDepIds.clear()</span><br><span class="line">    tmp = this.deps</span><br><span class="line">    this.deps = this.newDeps</span><br><span class="line">    this.newDeps = tmp</span><br><span class="line">    this.newDeps.length = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   */</span><br><span class="line">   /*</span><br><span class="line">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class="line">   */</span><br><span class="line">  update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      /*同步则执行run直接渲染视图*/</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Scheduler job interface.</span><br><span class="line">   * Will be called by the scheduler.</span><br><span class="line">   */</span><br><span class="line">   /*</span><br><span class="line">      调度者工作接口，将被调度者回调。</span><br><span class="line">    */</span><br><span class="line">  run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value = this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !== this.value ||</span><br><span class="line">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class="line">        // when the value is the same, because the value may</span><br><span class="line">        // have mutated.</span><br><span class="line">        /*</span><br><span class="line">            即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。</span><br><span class="line">        */</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        // set new value</span><br><span class="line">        const oldValue = this.value</span><br><span class="line">        /*设置新的值*/</span><br><span class="line">        this.value = value</span><br><span class="line"></span><br><span class="line">        /*触发回调渲染视图*/</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            this.cb.call(this.vm, value, oldValue)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the value of the watcher.</span><br><span class="line">   * This only gets called for lazy watchers.</span><br><span class="line">   */</span><br><span class="line">   /*获取观察者的值*/</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    this.value = this.get()</span><br><span class="line">    this.dirty = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   */</span><br><span class="line">   /*收集该watcher的所有deps依赖*/</span><br><span class="line">  depend () &#123;</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class="line">   */</span><br><span class="line">   /*将自身从所有依赖收集订阅列表删除*/</span><br><span class="line">  teardown () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      // remove self from vm&apos;s watcher list</span><br><span class="line">      // this is a somewhat expensive operation so we skip it</span><br><span class="line">      // if the vm is being destroyed.</span><br><span class="line">      /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/</span><br><span class="line">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(this.vm._watchers, this)</span><br><span class="line">      &#125;</span><br><span class="line">      let i = this.deps.length</span><br><span class="line">      while (i--) &#123;</span><br><span class="line">        this.deps[i].removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">      this.active = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Dep</li>
</ul>
<p>来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A dep is an observable that can have multiple</span><br><span class="line"> * directives subscribing to it.</span><br><span class="line"> */</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id = uid++</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*添加一个观察者对象*/</span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*移除一个观察者对象*/</span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*依赖收集，当存在Dep.target的时候添加观察者对象*/</span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*通知所有订阅者*/</span><br><span class="line">  notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// the current target watcher being evaluated.</span><br><span class="line">// this is globally unique because there could be only one</span><br><span class="line">// watcher being evaluated at any time.</span><br><span class="line">Dep.target = null</span><br><span class="line">/*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/</span><br></pre></td></tr></table></figure>
<ul>
<li>defineReactive</li>
</ul>
<p>接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。<br>触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Define a reactive property on an Object.</span><br><span class="line"> */</span><br><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: Function</span><br><span class="line">) &#123;</span><br><span class="line">  /*在闭包中定义一个dep对象*/</span><br><span class="line">  const dep = new Dep()</span><br><span class="line"></span><br><span class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/</span><br><span class="line">  // cater for pre-defined getter/setters</span><br><span class="line">  const getter = property &amp;&amp; property.get</span><br><span class="line">  const setter = property &amp;&amp; property.set</span><br><span class="line"></span><br><span class="line">  /*对象的子对象递归进行observe并返回子节点的Observer对象*/</span><br><span class="line">  let childOb = observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line"></span><br><span class="line">      /*如果原本对象拥有getter方法则执行*/</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line"></span><br><span class="line">        /*进行依赖收集*/</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line"></span><br><span class="line">          /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">        &#125;</span><br><span class="line">        if (Array.isArray(value)) &#123;</span><br><span class="line"></span><br><span class="line">          /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span><br><span class="line">          dependArray(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line"></span><br><span class="line">      /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      /* eslint-disable no-self-compare */</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      /* eslint-enable no-self-compare */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      if (setter) &#123;</span><br><span class="line"></span><br><span class="line">        /*如果原本对象拥有setter方法则执行setter*/</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*新的值需要重新进行observe，保证数据响应式*/</span><br><span class="line">      childOb = observe(newVal)</span><br><span class="line"></span><br><span class="line">      /*dep对象通知所有的观察者*/</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>整篇文章主要参考链接：<a href="https://juejin.im/post/5c959f74f265da610c068fa8" target="_blank" rel="noopener">https://juejin.im/post/5c959f74f265da610c068fa8</a><br>源码解析参考链接：<a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">https://github.com/answershuto/learnVue</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/03/vueSourceCoding/" data-id="ck0rxd4ud001qygkcjk7aoyc5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-webTitle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/02/webTitle/" class="article-date">
  <time datetime="2019-09-02T02:42:59.000Z" itemprop="datePublished">2019-09-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/02/webTitle/">前端面试题整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-09-02 10:42:59</p>
<h2 id="页面从输入URL到页面加载显示完成，这个过程中都发生了什么？"><a href="#页面从输入URL到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="页面从输入URL到页面加载显示完成，这个过程中都发生了什么？"></a>页面从输入URL到页面加载显示完成，这个过程中都发生了什么？</h2><p>1.输入域名地址<br>2.发送至DNS服务器并获得域名对应的WEB服务器IP地址；<br>3.与WEB服务器建立TCP连接；<br>4.服务器的永久重定向响应（从 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 到 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a><br>5.浏览器跟踪重定向地址<br>6.服务器处理请求<br>7.服务器返回一个HTTP响应<br>8.浏览器显示 HTML<br>9.浏览器发送请求获取的资源（如图片、音频、视频、CSS、JS等等）<br>10.浏览器发送异步请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DNS服务器: 域名服务器，是进行域名和与之对应的IP地址转换的服务器。</span><br><span class="line">TCP: 传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议。</span><br></pre></td></tr></table></figure>
<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><ol>
<li><p><code>用户界面</code> － 包括地址栏、后退/前进按钮、书签目录等，也就是所看到的除了用来显示所请求页面的主窗口之外的其他部分。</p>
</li>
<li><p><code>浏览器引擎</code> － 用来查询及操作渲染引擎的接口。</p>
</li>
<li><p><code>渲染引擎</code> － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。</p>
</li>
<li><p><code>网络</code> － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。</p>
</li>
<li><p><code>UI后端</code> － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。</p>
</li>
<li><p><code>JS解释器</code> － 用来解释执行JS代码。</p>
</li>
<li><p><code>数据存储</code> － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术<br><img src="https://pic.xiaohuochai.site/blog/browserRender1.png" alt="image"></p>
</li>
</ol>
<p>参考链接:<a href="https://www.cnblogs.com/xiaohuochai/p/9174471.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuochai/p/9174471.html</a></p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>主要分成两部分:<code>渲染引擎</code>(layout engineer或Rendering Engine)和<code>JS引擎</code>。</p>
<p><code>渲染引擎</code>:负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p><code>JS引擎</code>:解析和执行javascript来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h2 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h2><p>Trident内核:IE，360…. (微软开发的一种排版引擎)<br>Gecko内核:Firefox<br>Presto内核:Opera(已经废弃了)<br>Blink内核:Opera；<br>Webkit内核:Safari，Chrome。</p>
<h2 id="cookies，sessionStorage-和-localStorage-的区别？"><a href="#cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="cookies，sessionStorage 和 localStorage 的区别？"></a>cookies，sessionStorage 和 localStorage 的区别？</h2><p><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），数据会在浏览器和服务器间来回传递。<br><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>
<h5 id="存储大小"><a href="#存储大小" class="headerlink" title="存储大小:"></a>存储大小:</h5><ul>
<li>cookie数据大小不能超过4k。</li>
<li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到 5M 或更大。<h5 id="存储时间"><a href="#存储时间" class="headerlink" title="存储时间:"></a>存储时间:</h5></li>
<li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据;</li>
<li>sessionStorage 数据在当前浏览器窗口关闭后自动删除.</li>
<li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 存储内容类型: </span><br><span class="line">sessionStorage和localStorage只能存储字符串类型</span><br><span class="line">// 获取方式:</span><br><span class="line">localStorage:window.localStorage;；sessionStorage:window.sessionStorage;</span><br><span class="line">// WebStorage提供了一些方法，数据操作比cookie方便；</span><br><span class="line">setItem (key, value) ——  保存数据，以键值对的方式储存信息。</span><br><span class="line">getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。</span><br><span class="line">removeItem (key) ——  删除单个数据，根据键值移除对应的信息。</span><br><span class="line">clear () ——  删除所有的数据</span><br><span class="line">key (index) —— 获取某个索引的key</span><br><span class="line">// cookie需要自己封装接口setCookie. getCookit</span><br></pre></td></tr></table></figure>
<h2 id="页面访问cookie的限制条件"><a href="#页面访问cookie的限制条件" class="headerlink" title="页面访问cookie的限制条件"></a>页面访问cookie的限制条件</h2><p>跨域问题，设置了HttpOnly</p>
<p>参考链接:<a href="https://www.cnblogs.com/hujunzheng/p/5744755.html" target="_blank" rel="noopener">https://www.cnblogs.com/hujunzheng/p/5744755.html</a></p>
<h2 id="实现浏览器内多个标签页之间的通信"><a href="#实现浏览器内多个标签页之间的通信" class="headerlink" title="实现浏览器内多个标签页之间的通信"></a>实现浏览器内多个标签页之间的通信</h2><ul>
<li><p>localstorge<br>localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// a:click</span><br><span class="line">$(&quot;#btn&quot;).click(function()&#123;  </span><br><span class="line">  var name=$(&quot;#name&quot;).val();  </span><br><span class="line">  localStorage.setItem(&quot;name&quot;, name); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">// b:watch</span><br><span class="line">window.addEventListener(&quot;storage&quot;, function(event)&#123;   console.log(event.key + &quot;=&quot; + event.newValue);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>cookie+setInterval<br>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息</p>
</li>
<li><p>websocket协议<br>1.首先我们得了解websocket是什么？<br>它是一种网络通信协议<br>2.为什么会用到websocket?<br>因为http有缺陷，通信只可以由客户端发起，服务器无法主动向客户端发送消息。<br>但如果这时，服务器有连续变化的状态，那么就只能使用轮询的方式来访问。<br>轮询:每隔一段时间，就发出一个询问.<br>因为websocket拥有全双工(full-duplex)通信自然可以实现多个标签页之间的通信.</p>
</li>
<li>html5浏览器的新特性SharedWorker</li>
</ul>
<p>参考链接:<a href="https://segmentfault.com/a/1190000018354650" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018354650</a></p>
<h2 id="页面可见性（Page-Visibility-API）-可以有哪些用途"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途"></a>页面可见性（Page Visibility API） 可以有哪些用途</h2><p>通过 visibilityState 的值检测页面</p>
<ul>
<li>当前是否可见</li>
<li>打开网页的时间</li>
<li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放等<h2 id="网页验证码是做什么的，是为了解决什么安全问题"><a href="#网页验证码是做什么的，是为了解决什么安全问题" class="headerlink" title="网页验证码是做什么的，是为了解决什么安全问题"></a>网页验证码是做什么的，是为了解决什么安全问题</h2>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；<br>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试<h2 id="为什么利用多个域名来存储网站资源"><a href="#为什么利用多个域名来存储网站资源" class="headerlink" title="为什么利用多个域名来存储网站资源"></a>为什么利用多个域名来存储网站资源</h2>1、CDN缓存更方便</li>
</ul>
<p>2、突破浏览器并发限制</p>
<p>3、节约cookie带宽</p>
<p>4、节约主域名的连接数，优化页面响应速度</p>
<p>5、防止不必要的安全问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CDN:是构建在网络之上的内容发布网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容发布、调度等功能模块，是用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要是内容存储和分布技术。简单来说，CDN主要用来使用户就近获取资源</span><br><span class="line">// 突破浏览器并发限制</span><br><span class="line">同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。因而后来衍生了domain dash来加大并发数，但是过多的域名会使DNS解析负担加重，因此一般控制在2-4个。对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。</span><br></pre></td></tr></table></figure>
<h2 id="一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"><a href="#一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验" class="headerlink" title="一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验"></a>一个页面上有大量的图片，加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</h2><ul>
<li>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>
<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>
<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>
<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>
</ul>
<h2 id="以前端角度出发做好SEO（搜索引擎）需要考虑什么？"><a href="#以前端角度出发做好SEO（搜索引擎）需要考虑什么？" class="headerlink" title="以前端角度出发做好SEO（搜索引擎）需要考虑什么？"></a>以前端角度出发做好SEO（搜索引擎）需要考虑什么？</h2><ul>
<li><p>语义化html标签</p>
</li>
<li><p>合理的title，description,keywords</p>
</li>
<li><p>主要html代码放在前面</p>
</li>
<li><p>少用iframe，搜索引擎不会抓取iframe中的内容</p>
</li>
<li><p>图片加上Alt</p>
</li>
</ul>
<p>参考链接(了解seo): <a href="https://blog.csdn.net/jnshu_it/article/details/80029988" target="_blank" rel="noopener">https://blog.csdn.net/jnshu_it/article/details/80029988</a></p>
<h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><h6 id="一、减少请求资源大小或者次数"><a href="#一、减少请求资源大小或者次数" class="headerlink" title="一、减少请求资源大小或者次数　"></a>一、减少请求资源大小或者次数　</h6><p>1、尽量合并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）<br>　　原因:主要是为了减少http请求次数以及减少请求资源的大小<br>　　打包工具:<br>　　webpack<br>　　gulp<br>　　grunt<br>.　　….<br>2、尽量所使用的字体图标或者SVG图标来代替传统png图<br>　　因为字体图标或者SVG是矢量图，代码编写出来的，放不会变形，而且渲染速度快</p>
<p>3、采用图片的懒加载（延迟加载）<br>　　目的为了，减少页面第一次加载过程中http的请求次数<br>　　具体步骤:<br>　　　　1、页面开始加载时不去发送http请求，而是放置一张占位图<br>　　　　2、当页面加载完时，并且图片在可视区域再去请求加载图片信息</p>
<p>4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。<br>　　避免引入第三方大量的库。而自己却只是用里面的一个小功能</p>
<p>5、使用雪碧图或者是说图片精灵<br>　　把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用<br>　　图片定位来讲小图展现在页面中（background-position:百分比，数值）</p>
<p>6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果设置不当，每次发送请求都将会携带cookie</p>
<p>7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml 来说传输有这个优势<br>　　目的:是数据处理方便，资源偏小</p>
<p>8、前端与后端协商，合理使用keep-alive</p>
<p>9、前端与服务器协商，使用响应资源的压缩</p>
<p>10、避免使用iframe<br>　　不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源</p>
<p>11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个<br>缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据<br>时，取得就是上一次缓存的数据。（注意:很少使用，一般都会清空。根据需求来做）</p>
<p>二、代码优化相关<br>1、在js中尽量减少闭包的使用<br>　　原因:使用闭包后，闭包所在的上下文不会被释放</p>
<p>2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）<br>　　关于重排（回流）的分离读写:如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）</p>
<p>3、在js中避免嵌套循环和”死循环”(一旦遇到死循环，浏览器就会直接卡掉)</p>
<p>4、把css放在body上，把js放在body下面<br>　　让其先加载css（注意:这里关于优化没有多大关系）</p>
<p>5、减少css表达式的使用</p>
<p>6、css选择器解析规则所示从右往左解析的。减少元素标签作为最后一个选择对象</p>
<p>7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>
<p>8、在js封装过程中，尽量做到低耦合高内聚，减少页面的冗余代码。</p>
<p>9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上</p>
<p>10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作</p>
<p>11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画<br>　　如果想使用每隔一段时间执行动画，应该避免使用setInterval，尽量使用setTimeout<br>　　代替setInterval定时器。因为setInterval定时器存在弊端:可能造成两个动画间隔时间<br>　　缩短</p>
<p>12、尽量减少使用递归，避免死递归。<br>　　解决:建议使用尾递归</p>
<p>13、基于script标签下载js文件时，可以使用defer或者async来异步加载</p>
<p>14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。</p>
<p>15、减少Flash的使用</p>
<p>三、存储</p>
<p>1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意:也有弊端）可以让一些不太会改变的静态资源做缓存。比如:一些图片，js，cs</p>
<p>2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储，<br>　　避免向后台请求数据或者说在离线状态下做一些数据展示。</p>
<p>四、其他优化</p>
<p>1、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）<br>　　注意:图层不要过多设置，否则不但效果没有达到反而更差了</p>
<p>2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢<br>　　那么，页面会在一段时间内处于阻塞状态。目的:为了解决请求数据不耽搁渲染，提高页面的<br>　　渲染效率。解决方法:需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示<br>　　延迟分批加载类似图片懒加载。减少第一次页面加载时候的http请求次数</p>
<p>3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）<br>　　解决方法:只需要将音视频的<code>preload=none</code>即可。<br>　　目的:为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源</p>
<h2 id="webSocket如何兼容低浏览器"><a href="#webSocket如何兼容低浏览器" class="headerlink" title="webSocket如何兼容低浏览器"></a>webSocket如何兼容低浏览器</h2><ul>
<li>基于长轮询的 XHR</li>
<li>Adobe Flash Socket</li>
<li>ActiveX HTMLFile (IE)</li>
<li>基于 multipart 编码发送 XHR<br>参考链接:<a href="https://www.cnblogs.com/pengc/p/8718380.html" target="_blank" rel="noopener">https://www.cnblogs.com/pengc/p/8718380.html</a></li>
</ul>
<h2 id="web开发中会话跟踪的方法"><a href="#web开发中会话跟踪的方法" class="headerlink" title="web开发中会话跟踪的方法"></a>web开发中会话跟踪的方法</h2><ol>
<li>隐藏表单域：<input type="hidden">非常适合步需要大量数据存储的会话应用。</li>
<li>URL 重写：URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。</li>
<li>Cookie：一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至在客户端计算机重启后它仍可以保留其值。</li>
<li>Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</li>
<li>IP地址</li>
</ol>
<h2 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h2><p>一台服务器要与HTTP1.1兼容，只要为资源实现GET和HEAD方法即可。</p>
<ul>
<li>GET是最常用的方法，通常用于请求服务器发送某个资源。</li>
<li>HEAD 与 GET 类似，但服务器在响应中值返回首部，不返回实体的主体部分。</li>
<li>PUT 让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用干这个主体替代它。</li>
<li>POST 起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li>
<li>TRACE 会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE 方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li>
<li>OPTIONS 方法请求 web 服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>
<li>DELETE 请求服务器删除请求 URL 指定的资源</li>
</ul>
<h2 id="HTTP状态码及其含义"><a href="#HTTP状态码及其含义" class="headerlink" title="HTTP状态码及其含义"></a>HTTP状态码及其含义</h2><table>
<thead>
<tr>
<th>状态码</th>
<th style="text-align:right">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td style="text-align:right">Information（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td style="text-align:right">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td style="text-align:right">Redirection（重定向状态码）</td>
<td style="text-align:center">需要进行附加的操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td style="text-align:right">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td style="text-align:right">Server Error（服务端错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<ul>
<li>204     服务器成功处理，但未返回内容。</li>
<li>304    Not Modified 未修改。    所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
<li>400    Bad Request    客户端请求的语法错误，服务器无法理解</li>
<li>403    Forbidden    服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li>404    Not Found    服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面<h2 id="什么是同源：协议相同-域名相同-端口相同"><a href="#什么是同源：协议相同-域名相同-端口相同" class="headerlink" title="什么是同源：协议相同 域名相同 端口相同"></a>什么是同源：协议相同 域名相同 端口相同</h2></li>
</ul>
<p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>如果非同源，共有三种行为受到限制<br>1.Cookie、LocalStorage 和 IndexDB 无法读取。<br>2.DOM 无法获得。<br>3.AJAX 请求不能发送。</p>
<hr>
<p>// 下面的还没有看<br>关于建站安全防护</p>
<p>要做好防XSS、CSRF、SQL注入攻击.DDOS攻击。</p>
<p>XSS概念:</p>
<p>译为跨站脚本攻击,具体是指攻击者在Web页面里插入恶意Script脚本，当用户浏览该网页时，Script代码会被执行，从而进行恶意攻击。<br>XSS预防:</p>
<p>关键cookie字段设置httpOnly<br>输入检查,特殊字符 &lt; &gt; / &amp;等,对其进行转义后存储<br>CSRF概念：</p>
<p>本质上讲，是黑客将一个http接口中需要传递的所有参数都预测出来，然后不管以什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD。<br>CSRF 预防：</p>
<p>使用验证码，更高级用图灵测试<br>SQL概念：</p>
<p>通常没有任何过滤，直接把参数存放到了SQL语句当中<br>SQL预防：</p>
<p>根本上防止SQL注入的方法，就是参数化查询或者做词法分析。<br>DDOS概念：</p>
<p>利用木桶原理，寻找利用系统应用的瓶颈；阻塞和耗尽；当前问题：用户的带宽小于攻击的规模，噪声访问带宽成为木桶的短板。<br>DDOS预防：用软硬件结合的方式来防御是最有效的<br>25.对前端工程化的理解</p>
<p>1.开发规范<br>2.模块化开发<br>3.组件化开发<br>4.组件仓库<br>5.性能优化<br>6.项目部署<br>7.开发流程<br>8.开发工具<br>26.AMD和CMD是什么？它们的区别有哪些？</p>
<p>AMD 和 CMD 是二种模块定义规范。现在都使用模块化编程，AMD，异步模块定义；CMD，通用模块定义。AMD依赖前置，CMD依赖就近。CMD的 API 职责单一，没有全局require，AMD的一个API可以多用。</p>
<p>27.MVC BFC</p>
<p>mvc是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。MVC对应Html，CSS，js。</p>
<p>BFC全称”Block Formatting Context”, 中文为“块级格式化上下文”。流体特性：块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；BFC元素特性表现原则就是，内部子元素不会影响外部的元素。</p>
<p>28.你如何对网站的文件和资源进行优化？</p>
<p>期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用（多个域名来提供缓存）其他。<br>29.如果网页内容需要支持多语言，你会怎么做？</p>
<p>1.应用字符集的选择，选择UTF-8编码<br>2.语言书写习惯&amp;导航结构<br>3.数据库驱动型网站<br>30.如果设计中使用了非标准的字体，你该如何去实现？</p>
<p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：<br>用图片代替<br>web fonts在线字库，如Google Webfonts，Typekit等等;<a href="http://www.chinaz.com/free/20…；" target="_blank" rel="noopener">http://www.chinaz.com/free/20…；</a><br>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)<br>31.如何自学一门新编程语言</p>
<p>(1)了解背景知识：历史、现状、特点、应用领域、发展趋势<br>(2)搭建开发环境，编写HelloWorld<br>(3)声明变量和常量<br>(4)数据类型<br>(5)运算符<br>(6)逻辑结构<br>(7)通用小程序<br>(8)函数和对象<br>(9)第三方库、组件、框架<br>(10)实用项目<br>32.什么是哈希表？</p>
<p>散列表（也叫哈希表），是根据关键码值直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>33.静态网页和动态网页区别：</p>
<p>静态: 网页内容任何人在任何时间访问都是不变的</p>
<p>动态: 网页内容不同人在不同时间访问可能是不同的</p>
<p>34.SQL语句的分类</p>
<p>DDL:数据定义语句 CREATE/DROP/ALTER…<br>DCL:数据控制语句 GRANT…<br>DML:操作操作语句 INSERT/UPDATE/DELETE<br>DQL:查询语句 SELECT<br>35.什么是弹性布局？</p>
<p>解决某元素中“子元素”的布局方式，为布局提供最大的灵活性。</p>
<p>设为 flex 布局以后，子元素的 float、clear 和vertical-align属性将失效!!!</p>
<p>display:flex; 属性align-self 定义子元素的位置。</p>
<p>36.编写响应式？</p>
<p>1.声明viewport元标签<br>2.使用流式布局<br>3.所有容器使用相对尺寸，不用绝对尺寸<br>4.（最重要原则）使用CSS3 Media Query技术<br>37.常见的浏览器兼容问题？</p>
<p>1.不同浏览器的标签默认的内.外补丁不同。*{margin:0;padding:0;}<br>2.图片默认有间距使用float属性为img布局<br>3.居中问题（而FF默认为左对齐）margin: 0 auto;<br>4.CSS 兼容前缀 -ms- IE、-moz- Firefox、-o- Opera、-webkit- Chrome、<br>5.使用CSS Hack 如： +:IE6,7的前缀、-:IE6的前缀<br>38.H5新特性：</p>
<p>(1)Canvas绘图<br>(2)SVG绘图<br>(3)地理定位<br>(4)Web Worker<br>web worker 是运行在后台的 JS，独立于其他脚本，不会影响页面的性能。<br>(5)Web Storage<br>1.Cookie技术 （ 兼容性好,数据不能超4kb,操作复杂）<br>2.（兼容性差,数据8MB,操作简单）sessionStorage<br>3.localStorage<br>(6)Web Socket<br>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。<br>39.C3新特性：</p>
<p>1.复杂的选择器<br>2.弹性布局<br>3.动画<br>40.什么是typescript</p>
<p>1.它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。<br>2.TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以不加改变的在TypeScript下工作。TypeScript是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。<br>41.三大框架的区别：</p>
<p>Angular带有比较强的排它性的<br>React主张是函数式编程的理念，侵入性没有Angular那么强，主要因为它是软性侵入。<br>Vue 渐进式的<br>42.spa应用</p>
<p>优点：用户体验好 、良好的前后端分离。</p>
<p>缺点：<br>1.不利于SEO。<br>2.初次加载耗时相对增多。<br>3.导航不可用，如果一定要导航需要自行实现前进、后退。<br>43.什么是模块化编程？</p>
<p>每个模块内部，module变量代表当前模块。</p>
<p>这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<p>44.性能优化？</p>
<p>1.使用 CDN<br>2.图片懒加载<br>3.使用外部 JavaScript 和 CSS<br>4.压缩 JavaScript 、 CSS 、字体、图片等<br>5.优化 CSS Sprite<br>6.减少 HTTP 请求数<br>7.减少 DNS 查询<br>8.减少 DOM 元素数量<br>9.减少 DOM 操作<br>10.把脚本放在页面底部<br>可以看看这篇文章 关于前端优化的一些方案<br>45.什么是HTTP协议：</p>
<p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。<br>HTTP1.1 和 2.0协议的区别：<br>HTTP1.1不支持 header 数据的压缩，而2.0支持</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/02/webTitle/" data-id="ck0rxd4ue001rygkcfo1291z2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/26/promise/" class="article-date">
  <time datetime="2019-08-26T02:44:24.000Z" itemprop="datePublished">2019-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/26/promise/">Promise</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-08-26 10:44:24</p>
<h1 id="理解【ES6】Promise"><a href="#理解【ES6】Promise" class="headerlink" title="理解【ES6】Promise"></a>理解【ES6】Promise</h1><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><p>Promise是异步编程的一种解决方案，比传统的异步解决方案【回调函数】和【事件】更合理、更强大。</p>
<ul>
<li>从语法上讲，Promise是一个对象，从它可以获取异步操作的信息。</li>
</ul>
<h2 id="代码书写比较"><a href="#代码书写比较" class="headerlink" title="代码书写比较"></a>代码书写比较</h2><p>首先封装一个支持Promise的ajax方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function request(url,data = &#123;&#125;)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url,</span><br><span class="line">            data,</span><br><span class="line">            success:function (data) &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;,</span><br><span class="line">            error:function (error) &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;。</span><br></pre></td></tr></table></figure></p>
<p>用 request 方法实现多个互相依赖的网络请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let url1 = &apos;http://xxx.xxx.1&apos;;</span><br><span class="line">let url2 = &apos;http://xxx.xxx.2&apos;;</span><br><span class="line">let url3 = &apos;http://xxx.xxx.3&apos;;</span><br><span class="line">request(url1)</span><br><span class="line">    .then((data)=&gt;&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">        return request(url2,data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then((data)=&gt;&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">        return request(url3,data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then((data)=&gt;&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((error)=&gt;&#123;</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Promise-的特性"><a href="#Promise-的特性" class="headerlink" title="Promise 的特性"></a>Promise 的特性</h2><h3 id="Promise-的状态、"><a href="#Promise-的状态、" class="headerlink" title="Promise 的状态、"></a>Promise 的状态、</h3><ul>
<li>pending (等待态)</li>
<li>fulfilled (完成态)</li>
<li>rejected (拒绝态)</li>
</ul>
<h3 id="终值与拒因"><a href="#终值与拒因" class="headerlink" title="终值与拒因"></a>终值与拒因</h3><ul>
<li>终值： 指的是promise被解决时传递给解决回掉的值</li>
<li>拒因：拒绝原因，指在 promise 被拒绝时传递给异常回调的拒绝原因</li>
</ul>
<h3 id="状态与状态关系，状态与终值和拒因的关系"><a href="#状态与状态关系，状态与终值和拒因的关系" class="headerlink" title="状态与状态关系，状态与终值和拒因的关系"></a>状态与状态关系，状态与终值和拒因的关系</h3><ul>
<li>pending可以迁移至fulfilled或rejected</li>
<li>fulfilled 不能迁移至其他状态，必须拥有一个不可变的终值</li>
<li>rejected 不能迁移至其他状态，必须拥有一个不可变的据因</li>
</ul>
<h2 id="Promise-的使用"><a href="#Promise-的使用" class="headerlink" title="Promise 的使用"></a>Promise 的使用</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>Promise 是一个构造函数，使用new操作符返回一个promise对象</p>
<p>构造函数接收一个 excutor函数作为参数</p>
<p>excutor函数有两个函数类型的参数resolve和reject</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">     // 在 excutor 函数中执行异步操作</span><br><span class="line">     // 当异步操作完成后，调用 resolve 函数或 reject 函数</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数在调用时，excutor函数会作为同步代码立即执行</li>
<li>我们通常在excutor函数中执行我们的异步操作</li>
<li>未调用resolve、reject函数时，promise对象的状态为pending</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&apos;p1&apos;);</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;);</span><br><span class="line">// p1 的状态一直为 pending</span><br></pre></td></tr></table></figure>
<ul>
<li>当调用resolve函数，resolve的参数为非promise对象，非thenable对象</li>
</ul>
<ol>
<li>resolve 函数的参数，作为 promise 对象的终值</li>
<li>promise 对象的状态变为 fulfilled</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&apos;p2&apos;);</span><br><span class="line">        resolve(&apos;我是p2的终值&apos;)</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;);</span><br><span class="line">// 代码执行，1000ms内，p2 的状态为 pending</span><br><span class="line">// 代码执行，1000ms后，p2 的状态为 fulfilled</span><br><span class="line">// 代码执行，1000ms后，p2 的终值为 &apos;我是p2的终值&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>当调用 resolve 函数, resolve 的参数为 promise 对象</li>
</ul>
<ol>
<li>promise 对象的状态、终值、拒因与传入的 promise 对象同步<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(&apos;error&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(p)</span><br><span class="line">&#125;)</span><br><span class="line">// p1 的状态为 rejected ，拒因为 error</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>当调用 resolve 函数, resolve 的参数为 thenable 对象</li>
</ul>
<ol>
<li>会对 thenable 对象进行展开操作，promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let thenable1 = &#123;</span><br><span class="line">    then:function(resolve,reject)&#123;</span><br><span class="line">        resolve(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let thenable2 = &#123;</span><br><span class="line">    then:function(resolve,reject)&#123;</span><br><span class="line">        reject(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let thenable3 = &#123;</span><br><span class="line">    then:function(resolve,reject)&#123;</span><br><span class="line">        throw new Error(3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let thenable4 = &#123;</span><br><span class="line">    then:function(fn1,fn2)&#123;</span><br><span class="line">        //不调用 fn1 fn2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(thenable1);</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(thenable2);</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(thenable3);</span><br><span class="line">&#125;)</span><br><span class="line">let p4 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(thenable4);</span><br><span class="line">&#125;)</span><br><span class="line">// p1 的状态为 fulfilled 终值为 1</span><br><span class="line">// p2 的状态为 rejected  终值为 2</span><br><span class="line">// p3 的状态为 rejected  拒因为 Error：3</span><br><span class="line">// p4 的状态为 pending</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>当调用reject函数，reject函数的参数，作为promise对象的拒因</li>
<li>promise对象的状态变为rejected</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(&apos;p3&apos;);</span><br><span class="line">        reject(&apos;我是p3的拒因&apos;)</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;);</span><br><span class="line">// 代码执行，1000ms内，p3 的状态为 pending</span><br><span class="line">// 代码执行，1000ms后，p3 的状态为 rejected</span><br><span class="line">// 代码执行，1000ms后，p3 的拒因为 &apos;我是p3的拒因&apos;</span><br></pre></td></tr></table></figure>
<h2 id="Promise对象上的方法"><a href="#Promise对象上的方法" class="headerlink" title="Promise对象上的方法"></a>Promise对象上的方法</h2><h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p>promise提供一个then方法，用于访问其终值和拒因。<br>promise的then 方法接受两个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>onFulfilled函数用于当promise状态变为fulfilled时，接收终值。</li>
<li>onRejected函数用于当promise状态变为rejected时，接收拒因<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        resolve(&apos;异步任务获取的数据&apos;)</span><br><span class="line">    &#125;,50)</span><br><span class="line">&#125;).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">// 异步任务获取的数据</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        reject(new Error(&apos;异步任务异常&apos;))</span><br><span class="line">    &#125;,50)</span><br><span class="line">&#125;).then(null,(error)=&gt;&#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line">// Error: 异步任务异常</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    throw new Error(&apos;抛出一个异常&apos;);</span><br><span class="line">&#125;).then(null,(error)=&gt;&#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;)</span><br><span class="line">// Error: 抛出一个异常</span><br></pre></td></tr></table></figure>
<h3 id="onFulfilled-和-onRejected-参数可选"><a href="#onFulfilled-和-onRejected-参数可选" class="headerlink" title="onFulfilled 和 onRejected 参数可选"></a>onFulfilled 和 onRejected 参数可选</h3><ul>
<li>如果 onFulfilled 不是函数，其必须被忽略</li>
<li>如果 onRejected 不是函数，其必须被忽略</li>
</ul>
<h4 id="onFulfilled-的特性"><a href="#onFulfilled-的特性" class="headerlink" title="onFulfilled 的特性"></a>onFulfilled 的特性</h4><p>如果onFulfilled是函数：</p>
<ul>
<li>当promise执行结束后其必须被调用，其第一个参数为promise的终值</li>
<li>当promise执行结束前其不可被调用</li>
<li>其调用次数不可超过1次<h4 id="onRejected-的特性"><a href="#onRejected-的特性" class="headerlink" title="onRejected 的特性"></a>onRejected 的特性</h4>如果onRejected是函数：</li>
<li>当promise执行结束后其必须被调用，其第一个参数为promise的拒因</li>
<li>当promise执行结束前其不可被调用</li>
<li><p>其调用次数不可超过1次</p>
<h4 id="onFulfilled-和-onRejected-的调用时机"><a href="#onFulfilled-和-onRejected-的调用时机" class="headerlink" title="onFulfilled 和 onRejected 的调用时机"></a>onFulfilled 和 onRejected 的调用时机</h4></li>
<li><p>当 promise 对象的状态变为 fulfilled 或 rejected 时调用</p>
</li>
<li>onFulfilled、onRejected 永远都是异步调用</li>
<li>onFulfilled、onRejected 在事件队列中作为微任务来处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(3);</span><br><span class="line">&#125;).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4)</span><br><span class="line">// print: 1 4 3 2</span><br></pre></td></tr></table></figure>
<h4 id="onFulfilled-和-onRejected-的调用要求"><a href="#onFulfilled-和-onRejected-的调用要求" class="headerlink" title="onFulfilled 和 onRejected 的调用要求"></a>onFulfilled 和 onRejected 的调用要求</h4><ul>
<li>onFulfilled 和 onRejected 必须被作为函数调用</li>
<li>非严格模式下，this 为全局对象</li>
<li>严格模式下，this 为 undefined<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">    new Promise((resolve)=&gt;&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function fn2()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    new Promise((resolve)=&gt;&#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn1(); // print: window</span><br><span class="line">fn2(); // print: undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="then方法的多次调用"><a href="#then方法的多次调用" class="headerlink" title="then方法的多次调用"></a>then方法的多次调用</h2><ul>
<li>then方法可以被同一个promise对象多次调用</li>
<li>then方法会返回一个新的promise对象</li>
<li>当promise成功执行时，所有onFulfilled需按照其注册顺序依次回调</li>
<li>当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve)=&gt;&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;);</span><br><span class="line">let p1 = p.then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;异步执行，第一个onFulfilled&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = p.then(()=&gt;&#123;</span><br><span class="line">    console.log(&apos;异步执行，第二个onFulfilled&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(p1.constructor === Promise);</span><br><span class="line">console.log(p === p1);</span><br><span class="line">console.log(p === p2);</span><br><span class="line">console.log(p1 === p2);</span><br><span class="line">// print: true</span><br><span class="line">// print: false</span><br><span class="line">// print: false</span><br><span class="line">// print: false</span><br><span class="line">// print: 异步执行，第一个onFulfilled</span><br><span class="line">// print: 异步执行，第二个onFulfilled</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="then方法的返回值"><a href="#then方法的返回值" class="headerlink" title="then方法的返回值"></a>then方法的返回值</h4><p>then方法返回一个promise对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>若onFulfilled 、onRejected 返回一个非promise<br>对象、非thenable对象的值x,则promise2的状态变为fulfilled，终值为x</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    throw new Error();</span><br><span class="line">&#125;);</span><br><span class="line">let p1 = p.then(null,(data)=&gt;&#123;</span><br><span class="line">    return &apos;我是p2的终值&apos;</span><br><span class="line">&#125;);</span><br><span class="line">p1.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;);</span><br><span class="line">// print: 我是p2的终值</span><br></pre></td></tr></table></figure>
</li>
<li><p>若 onFulfilled 、onRejected 返回一个 promise 对象的值 x ，promise2 的状态、终值、拒因与 x 同步</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(2)</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = new Promise((resolve)=&gt;&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">let p4 = p3.then(()=&gt;&#123;</span><br><span class="line">    return p1;</span><br><span class="line">&#125;)</span><br><span class="line">let p5 = p3.then(()=&gt;&#123;</span><br><span class="line">    return p2;</span><br><span class="line">&#125;)</span><br><span class="line">// p4 的状态为 fulfilled 终值为 1</span><br><span class="line">// p5 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>
<ul>
<li>若 onFulfilled 、onRejected 返回一个 thenable 对象 ，会对 thenable 对象进行展开操作，promise2 的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let thenable1 = &#123;</span><br><span class="line">    then:function(resolve,reject)&#123;</span><br><span class="line">        resolve(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let thenable2 = &#123;</span><br><span class="line">    then:function(resolve,reject)&#123;</span><br><span class="line">        reject(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = p1.then(()=&gt;&#123;</span><br><span class="line">    return thenable1;</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = p1.then(()=&gt;&#123;</span><br><span class="line">    return thenable2;</span><br><span class="line">&#125;)</span><br><span class="line">// p2 的状态为 fulfilled 终值为 1</span><br><span class="line">// p3 的状态为 rejected  拒因为 2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>若 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 的状态为 rejected，拒因为 e</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve();</span><br><span class="line">&#125;);</span><br><span class="line">let p1 = p.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&apos;error&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">// print:&amp;emsp;Error: error</span><br></pre></td></tr></table></figure>
</li>
<li><p>若 onFulfilled 不是函数且 promise1 成功执行， promise2 的状态为 fulfilled 终值为 promise1 的终值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&apos;我是p1的终值&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">let p1 = p.then(null,null);</span><br><span class="line">p1.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">// print:&amp;emsp;我是p1的终值</span><br></pre></td></tr></table></figure>
</li>
<li><p>若 onRejected 不是函数且 promise1 拒绝执行， promise2 的状态为 rejected 拒因为 promise1 的拒因</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(&apos;我是p1的拒因&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">let p1 = p.then(null,null);</span><br><span class="line">p1.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">// print:我是p1的拒因</span><br></pre></td></tr></table></figure>
</li>
<li><p>若 onFulfilled、onRejected 执行过程中抛出异常，则 promise2 的状态为 rejected 拒因为抛出的异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&apos;我是p的终值&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">let p1 = p.then((data)=&gt;&#123;</span><br><span class="line">    throw new Error(&apos;异常&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(null,(err)=&gt;&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">// print:Error: 异常</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="终值和拒因的穿透特性"><a href="#终值和拒因的穿透特性" class="headerlink" title="终值和拒因的穿透特性"></a>终值和拒因的穿透特性</h3><ul>
<li>如果 promise 的状态变为 fulfilled，then 方法没有注册 onFulfilled</li>
</ul>
<ol>
<li>then 方法返回的 promise 对象的状态变为 fulfilled</li>
<li>then 方法返回的 promise 对象的终值与原 promise 对象的终值相同</li>
</ol>
<ul>
<li>如果 promise 的状态变为 rejected，then 方法没有注册 onRejected</li>
</ul>
<ol>
<li>then 方法返回的 promise 对象的状态变为 rejected</li>
<li>then 方法返回的 promise 对象的拒因与原 promise 对象的拒因相同</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p3 = p1.then(null,null);</span><br><span class="line">let p4 = p2.then(null,null);</span><br><span class="line">// p3 的状态是 fulfilled 终值 1</span><br><span class="line">// p4 的状态是 rejected  拒因 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p5 = p3.then(null,null);</span><br><span class="line">p6 = p4.then(null,null);</span><br><span class="line">// p3 的状态是 fulfilled 终值 1</span><br><span class="line">// p4 的状态是 rejected  拒因 2</span><br></pre></td></tr></table></figure>
<ul>
<li>穿透特性主要用于异常处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let fn1 = function()&#123;&#125;</span><br><span class="line">let fn2 = function()&#123;&#125;</span><br><span class="line">let fn3 = function()&#123;&#125;</span><br><span class="line">let fn4 = function()&#123;&#125;</span><br><span class="line">let fn5 = function()&#123;&#125;</span><br><span class="line">let onError = function()&#123;&#125;;</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        reject()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(fn1)</span><br><span class="line">.then(fn2)</span><br><span class="line">.then(fn3)</span><br><span class="line">.then(fn4)</span><br><span class="line">.then(fn5)</span><br><span class="line">.then(null,onError)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>fn1、fn2、fn3、fn4、fn5 都可能发生错误，通过在最后的then函数注册的 onRejected 函数接收可能发生异常错误</p>
<h3 id="catch方法："><a href="#catch方法：" class="headerlink" title="catch方法："></a>catch方法：</h3><p>catch(fn) 方法实际上是 then(null,fn) 方法的别名，catch 方法的返回值以及 catch 方法中出现异常的情况与调用 then 方法相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).then(null,function(error)&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">// 等同于</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject()</span><br><span class="line">&#125;).catch(function(error)&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Promise-的静态方法"><a href="#Promise-的静态方法" class="headerlink" title="Promise 的静态方法"></a>Promise 的静态方法</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>Promise.resolve 方法用于将现有数据转换为 promise 对象</p>
<ul>
<li>若入参为 promise 对象</li>
</ul>
<p>返回的 promise 对象的状态、终值、拒因与 Promise.resolve 方法的入参同步</p>
<ul>
<li>若入参为 thenable 对象</li>
</ul>
<p>会对 thenable 对象进行展开操作，返回的 promise 对象的状态、终值、拒因取决于 thenable 对象的 then 方法调用结果</p>
<ul>
<li>若入参为非 promise 非 thenable 对象</li>
</ul>
<p>1.返回的 promise 对象的状态为 fulfilled<br>2.返回的 promise 对象的终值为 Promise.resolve 方法的入参</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let p = Promise.resolve(x)</span><br><span class="line">// 等价于</span><br><span class="line">let p = new Promise((resolve)=&gt;&#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><ul>
<li>Promise.reject 方法用于返回一个状态为 rejected ,拒因为方法入参的 promise 对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let p = Promise.reject(x)</span><br><span class="line">// 等价于</span><br><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><ul>
<li><p>Promise.all 方法用于将多个 promise 对象包装成一个新的 promise 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象<br>p 的状态由 p1、p2、p3 决定</p>
</li>
<li><p>当 p1、p2、p3 的状态都变成 fulfilled</p>
</li>
</ul>
<p>p 的状态为 fulfilled<br>此时 p1、p2、p3 的终值组成一个数组，这个数组作为 p 的终值</p>
<ul>
<li>当 p1、p2、p3 的状态有一个变成 rejected</li>
</ul>
<p>p 的状态变为 rejected<br>此时第一个状态变为 rejected 的 promise 对象的拒因作为 p 的拒因<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(1);</span><br><span class="line">let p2 = Promise.resolve(2);</span><br><span class="line">let p3 = 3;</span><br><span class="line"></span><br><span class="line">Promise.all([p1,p2,p3]).then((data)=&gt;&#123;</span><br><span class="line">    console.log(data); // print: [1,2,3]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(1);</span><br><span class="line">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        reject(&apos;p2 error&apos;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        reject(&apos;p3 error&apos;)</span><br><span class="line">    &#125;,500)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.all([p1,p2,p3]).catch((error)=&gt;&#123;</span><br><span class="line">    console.log(error); // print: p3 error</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><ul>
<li><p>Promise.race 方法同样用于将多个 promise 对象包装成一个新的 promise 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = Promise.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>p1、p2、p3 都是 promise 对象，如果不是，调用 Promise.resolve 方法转换为 promise 对象</p>
</li>
<li>p 的状态由 p1、p2、p3 中状态最先变为 fulfilled 或 rejected 的 promise 对象决定</li>
<li>p 的终值或拒因由最先变更状态的 promise 对象所决定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 = Promise.resolve(1);</span><br><span class="line">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        reject(&apos;p2 error&apos;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        reject(&apos;p3 error&apos;)</span><br><span class="line">    &#125;,500)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;).catch(error=&gt;&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;)</span><br><span class="line">// print: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        resolve(1)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        reject(&apos;p2 error&apos;)</span><br><span class="line">    &#125;,800)</span><br><span class="line">&#125;)</span><br><span class="line">let p3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        reject(&apos;p3 error&apos;)</span><br><span class="line">    &#125;,500)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([p1,p2,p3]).then(data=&gt;&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;).catch(error=&gt;&#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;)</span><br><span class="line">// print: p3 error</span><br></pre></td></tr></table></figure>
<h2 id="Promise-的错误捕获"><a href="#Promise-的错误捕获" class="headerlink" title="Promise 的错误捕获"></a>Promise 的错误捕获</h2><p>当 promise 的状态为 rejected 且为对 promise 对象使用 catch 方法，此时的异常信息会被 promise 对象吃掉 可以通过监听 unhandledRejection 事件，专门监听未捕获的reject错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// node 环境下</span><br><span class="line">process.on(&apos;unhandledRejection&apos;, error =&gt; &#123;</span><br><span class="line">    console.log(&apos;unhandledRejection&apos;, error);</span><br><span class="line">&#125;);</span><br><span class="line">// 浏览器下</span><br><span class="line">window.addEventListener(&apos;unhandledrejection&apos;,(e)=&gt;&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Promise-的问题"><a href="#Promise-的问题" class="headerlink" title="Promise 的问题"></a>Promise 的问题</h2><ul>
<li>无法取消Promise，若没有状态变更，也无法停止 promise 的等待</li>
<li>不设定 then 或 catch 方法，构造函数(excutor函数)错误，无法捕获</li>
<li>未完成状态时，无法得知是刚开始，还是即将完成</li>
</ul>
<p>参考链接：<a href="https://juejin.im/post/5d06e9c76fb9a07ee4636235" target="_blank" rel="noopener">https://juejin.im/post/5d06e9c76fb9a07ee4636235</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/26/promise/" data-id="ck0rxd4u5001nygkcv73a4g40" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS-thread" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/21/JS-thread/" class="article-date">
  <time datetime="2019-08-21T07:36:08.000Z" itemprop="datePublished">2019-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/21/JS-thread/">从多线程到Event Loop全面梳理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-08-21 15:36:08</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>几乎在每一本JS相关的书籍中，都会说JS是<code>单线程</code>的，JS是通过<code>事件队列(Event Loop)</code>的方式来实现异步回调的。 对很多初学JS的人来说，根本搞不清楚单线程的JS为什么拥有 <code>异步</code>的能力，所以，我试图从<code>进程</code>、<code>线程</code>的角度来解释这个问题。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddada3a3d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br>计算机的核心是<code>CPU</code>，它承担了所有的计算任务。<br>它就像一座工厂，时刻在运行。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb1e54c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br><code>进程</code>就好比工厂的车间，它代表CPU所能处理的单个任务。 <code>进程</code>之间相互独立，任一时刻，CPU总是运行一个<code>进程</code>，其他<code>进程</code>处于非运行状态。 CPU使用时间片轮转进度算法(这是个什么算法？？？？)来实现同时运行多个<code>进程</code>。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/20/16caca3ddb0197b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br>一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。<br><code>线程</code>就好比车间里的工人，一个<code>进程</code>可以包括多个<code>线程</code>，多个<code>线程</code>共享<code>进程</code>资源。</p>
<h2 id="CPU、进程、线程之间的关系"><a href="#CPU、进程、线程之间的关系" class="headerlink" title="CPU、进程、线程之间的关系"></a>CPU、进程、线程之间的关系</h2><p>从上文我们已经简单了解了CPU、进程、线程，简单汇总一下。</p>
<ul>
<li><code>进程</code>是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li><code>线程</code>是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>
<li>不同<code>进程</code>之间也可以通信，不过代价较大</li>
<li><code>单线程</code>与<code>多线程</code>，都是指在一个<code>进程</code>内的单和多<h2 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h2></li>
</ul>
<p>我们已经知道了<code>CPU</code>、<code>进程</code>、<code>线程</code>之间的关系，对于计算机来说，每一个应用程序都是一个<code>进程</code>，<br>而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过<code>子进程</code>来实现的。<br>对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。<br>而对于浏览器来说，浏览器就是<code>多进程</code>的，我在Chrome浏览器中打开了多个tab，然后打开windows控制管理器：<br><img src="https://user-gold-cdn.xitu.io/2019/8/21/16cb1f0a851c86b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br>如上图，我们可以看到一个Chrome浏览器启动了好多个进程。</p>
<p>总结一下：</p>
<ul>
<li>浏览器是多进程的</li>
<li>每一个Tab页，就是一个独立的进程<h2 id="浏览器包含了哪些进程"><a href="#浏览器包含了哪些进程" class="headerlink" title="浏览器包含了哪些进程"></a>浏览器包含了哪些进程</h2></li>
<li>主进程<blockquote>
<ul>
<li>协调控制其他子进程（创建、销毁）</li>
<li>浏览器界面显示，用户交互，前进、后退、收藏</li>
<li>将渲染进程得到的内存中的Bitmap，绘制到用户界面上</li>
<li>处理不可见操作，网络请求，文件访问等</li>
</ul>
</blockquote>
</li>
<li>第三方插件进程<blockquote>
<ul>
<li>每种类型的插件对应一个进程，仅当使用该插件时才创建</li>
</ul>
</blockquote>
</li>
<li>GPU进程<blockquote>
<ul>
<li>用于3D绘制等</li>
</ul>
</blockquote>
</li>
<li><code>渲染进程</code>，就是我们说的<code>浏览器内核</code><blockquote>
<ul>
<li>负责页面渲染，脚本执行，事件处理等</li>
<li>每个tab页一个渲染进程</li>
</ul>
</blockquote>
</li>
</ul>
<p>那么浏览器中包含了这么多的进程，那么对于普通的前端操作来说，最重要的是什么呢？</p>
<p>答案是<code>渲染进程</code>，也就是我们常说的<code>浏览器内核</code></p>
<h2 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h2><p>从前文我们得知，进程和线程是一对多的关系，也就是说一个进程包含了多条线程。<br>而对于<code>渲染进程</code>来说，它当然也是多线程的了，接下来我们来看一下渲染进程包含哪些线程。</p>
<ul>
<li>GUI渲染线程<blockquote>
<ul>
<li>负责渲染页面，布局和绘制</li>
<li>页面需要重绘和回流时，该线程就会执行</li>
<li>与js引擎线程互斥，防止渲染结果不可预期</li>
</ul>
</blockquote>
</li>
<li>JS引擎线程<blockquote>
<ul>
<li>负责处理解析和执行javascript脚本程序</li>
<li>只有一个JS引擎线程（单线程）</li>
<li>与GUI渲染线程互斥，防止渲染结果不可预期</li>
</ul>
</blockquote>
</li>
<li>事件触发线程<blockquote>
<ul>
<li>用来控制事件循环（鼠标点击、setTimeout、ajax等）</li>
<li>当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</li>
</ul>
</blockquote>
</li>
<li>定时触发器线程<blockquote>
<ul>
<li>setInterval与setTimeout所在的线程</li>
<li>定时任务并不是由JS引擎计时的，是由定时触发线程来计时的</li>
<li>计时完毕后，通知事件触发线程</li>
</ul>
</blockquote>
</li>
<li>异步http请求线程<blockquote>
<ul>
<li>浏览器有一个单独的线程用于处理AJAX请求</li>
<li>当请求完成时，若有回调函数，通知事件触发线程</li>
</ul>
</blockquote>
</li>
</ul>
<p>当我们了解了渲染进程包含的这些线程后，我们思考两个问题：</p>
<ol>
<li>为什么 javascript 是单线程的</li>
<li>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥<h2 id="为什么-javascript-是单线程的"><a href="#为什么-javascript-是单线程的" class="headerlink" title="为什么 javascript 是单线程的"></a>为什么 javascript 是单线程的</h2>首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。</li>
</ol>
<p>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</p>
<h2 id="为什么-GUI-渲染线程为什么与-JS-引擎线程互斥"><a href="#为什么-GUI-渲染线程为什么与-JS-引擎线程互斥" class="headerlink" title="为什么 GUI 渲染线程为什么与 JS 引擎线程互斥"></a>为什么 GUI 渲染线程为什么与 JS 引擎线程互斥</h2><p>这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，<br>那么渲染线程前后获得的元素就可能不一致了。<br>因此，为了防止渲染出现不可预期的结果，浏览器设定 <code>GUI渲染线程</code>和<code>JS引擎线程</code>为互斥关系，<br>当JS引擎线程执行时<code>GUI渲染线程</code>会被挂起，GUI更新则会被保存在一个队列中等待<code>JS引擎线程</code>空闲时立即被执行。</p>
<h2 id="从-Event-Loop-看-JS-的运行机制"><a href="#从-Event-Loop-看-JS-的运行机制" class="headerlink" title="从 Event Loop 看 JS 的运行机制"></a>从 Event Loop 看 JS 的运行机制</h2><p>到了这里，终于要进入我们的主题，什么是 Event Loop<br>先理解一些概念</p>
<ul>
<li>JS 分为同步任务和异步任务</li>
<li>同步任务都在JS引擎线程上执行，形成一个<code>执行栈</code></li>
<li>事件触发线程管理一个<code>任务队列</code>，异步任务触发条件达成，将回调事件放到<code>任务队列</code>中</li>
<li><code>执行栈</code>中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取<code>任务队列</code>，将可运行的异步任务回调事件添加到<code>执行栈</code>中，开始执行<br><img src="https://user-gold-cdn.xitu.io/2019/8/21/16cb1d70e5120bea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></li>
</ul>
<p>在前端开发中我们会通过<code>setTimeout/setInterval</code>来指定定时任务，会通过<code>XHR/fetch</code>发送网络请求， 接下来简述一下<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>到底做了什么事</p>
<p>我们知道，不管是<code>setTimeout/setInterval</code>和<code>XHR/fetch</code>代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。</p>
<p>当代码执行到<code>setTimeout/setInterval</code>时，实际上是JS引擎线程通知定时触发器线程，间隔一个时间后，会触发一个回调事件， 而<code>定时触发器线程</code>在接收到这个消息后，会在等待的时间后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>
<p>当代码执行到<code>XHR/fetch</code>时，实际上是<code>JS引擎线程</code>通知<code>异步http请求线程</code>，发送一个网络请求，并制定请求完成后的回调事件， 而<code>异步http请求线程</code>在接收到这个消息后，会在请求成功后，将回调事件放入到由<code>事件触发线程</code>所管理的<code>事件队列</code>中。</p>
<p>当我们的同步任务执行完，<code>JS引擎线程</code>会询问<code>事件触发线程</code>，在<code>事件队列</code>中是否有待执行的回调函数，如果有就会加入到执行栈中交给<code>JS引擎线程</code>执行<br><img src="https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7433f29c46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"><br>再用代码来解释一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let timerCallback = function() &#123;</span><br><span class="line">  console.log(&apos;wait one second&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">let httpCallback = function() &#123;</span><br><span class="line">  console.log(&apos;get server data success&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同步任务</span><br><span class="line">console.log(&apos;hello&apos;);</span><br><span class="line">// 同步任务</span><br><span class="line">// 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理</span><br><span class="line">// 1s 后事件触发线程将 timerCallback 加入到事件队列中</span><br><span class="line">setTimeout(timerCallback,1000);</span><br><span class="line">// 同步任务</span><br><span class="line">// 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理</span><br><span class="line">// 请求成功后事件触发线程将 httpCallback 加入到事件队列中</span><br><span class="line">$.get(&apos;www.xxxx.com&apos;,httpCallback);</span><br><span class="line">// 同步任务</span><br><span class="line">console.log(&apos;world&apos;);</span><br><span class="line">//...</span><br><span class="line">// 所有同步任务执行完后</span><br><span class="line">// 询问事件触发线程在事件事件队列中是否有需要执行的回调函数</span><br><span class="line">// 如果没有，一直询问，直到有为止</span><br><span class="line">// 如果有，将回调事件加入执行栈中，开始执行回调代码</span><br></pre></td></tr></table></figure></p>
<p>总结一下：</p>
<ul>
<li>JS引擎线程只执行执行栈中的事件</li>
<li>执行栈中的代码执行完毕，就会读取事件队列中的事件</li>
<li>事件队列中的回调事件，是由各自线程插入到事件队列中的</li>
<li>如此循环</li>
</ul>
<h2 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h2><p>当我们基本了解了什么是执行栈，什么是事件队列之后，我们深入了解一下事件循环中<code>宏任务</code>、<code>微任务</code></p>
<h4 id="什么是宏任务"><a href="#什么是宏任务" class="headerlink" title="什么是宏任务"></a>什么是宏任务</h4><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），<br>每一个宏任务会从头到尾执行完毕，不会执行其他。</p>
<p>我们前文提到过<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染。</p>
<blockquote>
<p>宏任务–&gt;渲染–&gt;宏任务–&gt;渲染–&gt;渲染．．．</p>
</blockquote>
<h6 id="主代码块，setTimeout，setInterval等，都属于宏任务"><a href="#主代码块，setTimeout，setInterval等，都属于宏任务" class="headerlink" title="主代码块，setTimeout，setInterval等，都属于宏任务"></a>主代码块，setTimeout，setInterval等，都属于宏任务</h6><p>第一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.body.style = &apos;background:black&apos;;</span><br><span class="line">document.body.style = &apos;background:red&apos;;</span><br><span class="line">document.body.style = &apos;background:blue&apos;;</span><br><span class="line">document.body.style = &apos;background:grey&apos;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-1cc3c2301dac4edc?imageMogr2/auto-orient/strip" alt="image"><br>我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次<code>宏任务</code>，所以全部执行完才触发<code>页面渲染</code>，渲染时<code>GUI线程</code>会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。</p>
<p>第二个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.body.style = &apos;background:blue&apos;;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    document.body.style = &apos;background:black&apos;</span><br><span class="line">&#125;,0)</span><br></pre></td></tr></table></figure></p>
<p>执行一下，再看效果<br><img src="https://upload-images.jianshu.io/upload_images/11846892-d1a432fac3b248c6?imageMogr2/auto-orient/strip" alt="image"><br>我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p>
<h2 id="什么是微任务"><a href="#什么是微任务" class="headerlink" title="什么是微任务"></a>什么是微任务</h2><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而<code>微任务</code>可以理解成在当前<code>宏任务</code>执行后立即执行的任务。<br>也就是说，当<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完。</p>
<h6 id="Promise，process-nextTick等，属于微任务。"><a href="#Promise，process-nextTick等，属于微任务。" class="headerlink" title="Promise，process.nextTick等，属于微任务。"></a>Promise，process.nextTick等，属于微任务。</h6><p>第一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.body.style = &apos;background:blue&apos;</span><br><span class="line">console.log(1);</span><br><span class="line">Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    document.body.style = &apos;background:black&apos;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(3);</span><br></pre></td></tr></table></figure></p>
<p>执行一下，再看效果：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-dc4ebf185e18b83d?imageMogr2/auto-orient/strip" alt="image"></p>
<p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出。<br>页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染<br>第二个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    Promise.resolve(3).then(data =&gt; console.log(data))</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">// print : 1 3 2</span><br></pre></td></tr></table></figure></p>
<p>上面代码共包含两个 <code>setTimeout</code> ，也就是说除主代码块外，共有两个<code>宏任务</code>，<br>其中第一个<code>宏任务</code>执行中，输出 1 ，并且创建了<code>微任务队列</code>，所以在下一个<code>宏任务队列</code>执行前，<br>先执行<code>微任务</code>，在<code>微任务</code>执行中，输出 3 ，<code>微任务</code>执行后，执行下一次<code>宏任务</code>，执行中输出 2</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>执行一个<code>宏任务</code>（栈中没有就从<code>事件队列</code>中获取）</li>
<li>执行过程中如果遇到<code>微任务</code>，就将它添加到<code>微任务</code>的任务队列中</li>
<li><code>宏任务</code>执行完毕后，立即执行当前微<code>任务队列</code>中的所有<code>微任务</code>（依次执行）</li>
<li>当前<code>宏任务</code>执行完毕，开始检查渲染，然后<code>GUI线程</code>接管渲染</li>
<li>渲染完毕后，<code>JS线程</code>继续接管，开始下一个<code>宏任务</code>（从事件队列中获取）</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/21/16cb1d7bb4bd9fd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<p>参考链接：<a href="https://juejin.im/post/5d5b4c2df265da03dd3d73e5" target="_blank" rel="noopener">https://juejin.im/post/5d5b4c2df265da03dd3d73e5</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/21/JS-thread/" data-id="ck0rxd4tq0017ygkct4mzlrpp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-request" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/19/request/" class="article-date">
  <time datetime="2019-08-19T06:05:42.000Z" itemprop="datePublished">2019-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/19/request/">关于前端请求的那些事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-08-19 14:05:42</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前端是一个快速发展的领域，而在前端的技术栈当中，前端请求又是最见的一个领域，通过请求接口数据，才能将一个静态的页面动态化。本文将以前端发展的时间轴来逐一分析前端请求的技术演变及其优劣。</p>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>XMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest,开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有的浏览器均支持获取XMLHttpRequest对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); //获取XMLHttpRequest对象</span><br></pre></td></tr></table></figure></p>
<p>由于浏览器的兼容性，各个浏览器对于创建XMLHttpRequest的方法不同，以下是兼容方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var xhr;</span><br><span class="line">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class="line">  xhr = new XMLHttpRequest();</span><br><span class="line">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class="line">  try &#123;</span><br><span class="line">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);  //IE5,6</span><br><span class="line">    &#125; catch (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用XMLHttpRequest发起一个get请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// get请求</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p>
<p>完整的post请求代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var xhr;</span><br><span class="line">if (window.XMLHttpRequest) &#123; // Mozilla, Safari...</span><br><span class="line">  xhr = new XMLHttpRequest();</span><br><span class="line">&#125; else if (window.ActiveXObject) &#123; // IE</span><br><span class="line">  try &#123;</span><br><span class="line">    xhr = new ActiveXObject(&apos;Msxml2.XMLHTTP&apos;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    &#125; catch (e) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (xhr) &#123;</span><br><span class="line">  xhr.onreadystatechange = onReadyStateChange;</span><br><span class="line">  xhr.open(&apos;POST&apos;, &apos;/api&apos;, true);</span><br><span class="line">  // 设置 Content-Type 为 application/x-www-form-urlencoded</span><br><span class="line">  // 以表单的形式传递数据</span><br><span class="line">  xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">  xhr.send(&apos;username=admin&amp;password=root&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// onreadystatechange 方法</span><br><span class="line">function onReadyStateChange() &#123;</span><br><span class="line">  // 该函数会被调用四次</span><br><span class="line">  if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123;</span><br><span class="line">    console.log(&apos;执行成功&apos;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;执行出错&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Jquery-Ajax"><a href="#Jquery-Ajax" class="headerlink" title="Jquery Ajax"></a>Jquery Ajax</h2><p>说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;   //标准写法</span><br><span class="line">   type: &apos;POST&apos;,</span><br><span class="line">   url: url,</span><br><span class="line">   data: data,</span><br><span class="line">   dataType: dataType,</span><br><span class="line">   success: function () &#123;&#125;,</span><br><span class="line">   error: function () &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">$.get(url,function()&#123;&#125;); //get请求</span><br><span class="line">$.post(url,body,function()&#123;&#125;); //post请求</span><br><span class="line">$.getJSON(url,function()&#123;&#125;);  //get请求从服务器加载Json编码</span><br></pre></td></tr></table></figure></p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>对原生XHR的封装</li>
<li>针对MVC的编程</li>
<li>完美的兼容性</li>
<li>支持jsonp<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>不符合MVVM</li>
<li>异步模型不够现代，不支持链式，代码可读性差</li>
<li>整个Jquery太大，引入成本过高</li>
</ul>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>fetch其实是一个新世界，脱离XHR，完全是基于Promise的异步处理机制，使用起来会比ajax更加简单。<br>使用fetch的代码会相比xhr来说更具有条理性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(function(response) &#123;</span><br><span class="line">  return response.json();</span><br><span class="line">&#125;).then(function(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  console.log(&quot;Oops, error&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在使用ES6的箭头函数后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(response =&gt; response.json())</span><br><span class="line">  .then(data =&gt; console.log(data))</span><br><span class="line">  .catch(e =&gt; console.log(&quot;Oops, error&quot;, e))</span><br></pre></td></tr></table></figure></p>
<p>优点：</p>
<ul>
<li>更加底层，提供的API丰富（request, response）</li>
<li>语法简单，脱离了XHR，基于ES新的Promise设计</li>
</ul>
<p>缺点：</p>
<ul>
<li>兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：<code>es6-promise</code>,<code>babel-polyfill</code>,<code>fetch-ie8</code>等</li>
<li>不支持jsonp，可以引入<code>fetch-jsonp</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装 npm install fetch-jsonp --save-dev</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用 </span><br><span class="line">fetchJsonp(url, &#123;</span><br><span class="line"> timeout: 3000, jsonpCallback: &apos;callback&apos; </span><br><span class="line">&#125;).then(function(response) &#123; </span><br><span class="line">  console.log(response.json()); </span><br><span class="line">&#125;).catch(function(e) &#123; </span><br><span class="line">  console.log(e) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>没有拦截器，需要额外再封装一层或者<code>fetch-interceptor</code></li>
<li>默认不带cookie，需要添加配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url,&#123;</span><br><span class="line">  credentials: &apos;include&apos;  </span><br><span class="line">  //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>没有abort，不支持timeout超时处理<br>可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。</li>
<li>无法获取progress状态<br>Fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取.<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2>axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。</li>
<li>支持node，创建http请求</li>
<li>支持Promise API</li>
<li>客户端防止CSRF：每个请求带一个cookie拿到的key</li>
<li>拦截请求和响应</li>
<li>可取消请求<br>兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。<h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//npm</span><br><span class="line">npm install axios</span><br><span class="line"></span><br><span class="line">//cdn</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="基本使用如下："><a href="#基本使用如下：" class="headerlink" title="基本使用如下："></a>基本使用如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    url: url,</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;console.log(res)&#125;)</span><br><span class="line">.catch(err =&gt; &#123;console.log(err)&#125;)</span><br><span class="line"></span><br><span class="line">// get请求</span><br><span class="line">axios.get(url)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// post请求</span><br><span class="line">axios.post（‘/user’, &#123;</span><br><span class="line">    name: &apos;Jerry&apos;,</span><br><span class="line">    lastName: &apos;Liang&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="如何选择（个人理解，仅供参考）"><a href="#如何选择（个人理解，仅供参考）" class="headerlink" title="如何选择（个人理解，仅供参考）"></a>如何选择（个人理解，仅供参考）<a href="https://qianduan.group/posts/5bebe26f9fd64d5a7458a932#-" target="_blank" rel="noopener"></a></h2><ol>
<li>首先可以肯定的是，如果你的代码依旧是基于Jquery，那毫无疑问，ajax就是你最好的选择。</li>
<li>如果你使用的是任意MVVM框架，建议无脑使用axios，fetch在实际项目使用中，需要各种的封装和异常处理，并非开箱即用，而axios可以做到直接替换$.ajax。</li>
<li>如果就是要使用fetch，那相信你也一定能封装成自己的一套最佳实践。</li>
</ol>
<p>参考：<a href="https://qianduan.group/posts/5bebe26f9fd64d5a7458a932" target="_blank" rel="noopener">https://qianduan.group/posts/5bebe26f9fd64d5a7458a932</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/19/request/" data-id="ck0rxd4t6000mygkcq5fyc8bp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-message-comp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/15/message-comp/" class="article-date">
  <time datetime="2019-08-15T08:05:21.000Z" itemprop="datePublished">2019-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/15/message-comp/">模拟element-ui写message组件思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-08-15 16:05:21</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时的开发过程中，我们总是先写好一个组件，然后在需要的页面中用 <code>import</code> 引入即可，但如果是下面这种类型的组件呢👇</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-a36600e65a733412?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>上面这种类型的浮层提示有一个很大的特点，就是使用频率特别高，几乎每个页面都会用到它，于是乎我们就要在每个页面中去引入该组件，并且在每个页面都得通过一个变量来控制它的显隐，这显然不是我们想要的🙅。。。那我们想要的是什么样呢🤔？用过一些 UI 框架的同学们应该知道有这样一种用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$message(&#123;</span><br><span class="line">    duration: 3000,</span><br><span class="line">    content: &apos;这是一条消息提示&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>没错，就是这么简单的一句话就万事大吉了（就是用 js 调用组件而已啦🧐）。那这种效果究竟是怎么实现的呢？今天就让我们来（手把手🤝 ）一探究竟吧！</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>不知道小伙伴们有没有用过 <code>Vue.extend()</code> 这个东东，反正我是很少碰过，印象不深，所以这里我们先来短暂了解一下 <code>Vue.extend()</code> 主要是用来干嘛的。先来个官方说明（不多的，坚持下）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-562ca3309f3120c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>没怎么看懂？😴没关系，不重要，你只要记住（加少许理解）以下用法即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 导入以往的普通组件</span><br><span class="line">import Main from &apos;./main.vue&apos;;</span><br><span class="line">// 用 Vue.extend 创建组件的模板（构造函数）</span><br><span class="line">let mainConstructor = Vue.extend(Main);</span><br><span class="line">// 实例化组件</span><br><span class="line">let instance = new mainConstructor();</span><br><span class="line">// 挂载到相应的元素上</span><br><span class="line">instance.$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure>
<p>不知道你看懂没有，上面的 <code>Vue.extend(Main)</code> 就是一个基于 main.vue 的组件模板（构造函数），<code>instance</code> 是实例化的组件，<code>$mount()</code> 是手动挂载的意思。其中 <code>Vue.extend()</code> 和 <code>$mount()</code> 就是我们通过 js 调用、渲染并挂载组件的精髓所在，相当于早前的 <code>createElement</code> 和 <code>appendChild</code>，有异曲同工之效。这个点需要我们好好熟悉一下，所以你可以先停下来屡屡思路🤔。<br>补充一下🤐：<code>$mount()</code> 里面如果没有参数，说明组件只是渲染了但还没有挂载到页面上，如果有正确的（元素）参数则直接挂载到元素下面。</p>
<h2 id="写一个-message-组件"><a href="#写一个-message-组件" class="headerlink" title="写一个 message 组件"></a>写一个 message 组件</h2><p>js 调用归调用，最原始的组件还是要有的，只是我们不通过 <code>import</code> 来引入到页面中而已。ok，我们就以最开始的那个 message图片来简单写一下这个 vue 组件（element-ui中的message 和 alert 也是一样的）。这里就直接上代码啦，毕竟它的结构简单到爆了，也不是本章节的重点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- message.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class="line">    &lt;p&gt;服务器错误，请稍后重试&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;EchojoyMessage&quot;,</span><br><span class="line">  </span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class="line">        this.$destroy(true);</span><br><span class="line">        this.$el.parentNode.removeChild(this.$el);</span><br><span class="line">      &#125;, 3000);</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.echojoy-message &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  color: #fff;</span><br><span class="line">  z-index: 9999;</span><br><span class="line">  background: transparent;</span><br><span class="line">  &gt; p &#123;</span><br><span class="line">    padding: 12px 22px;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">    background: rgba(17, 17, 17, 0.7);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>上面的内容想必大家应该都能看懂，所以这里就直接讲下面的重点了。</p>
<h2 id="写一个-message-js"><a href="#写一个-message-js" class="headerlink" title="写一个 message.js"></a>写一个 message.js</h2><p>我们在 message.vue 的同级目录下新建一个 message.js 文件。我们先瞟一眼文件内容（也不多，已经是个最简版了）👇：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// message.js</span><br><span class="line">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class="line">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const Toast = function() &#123;</span><br><span class="line">  instance = new ToastConstructor().$mount(); // 渲染组件</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class="line">let instance;</span><br><span class="line"></span><br><span class="line">const Message = function (options = &#123;&#125;) &#123;</span><br><span class="line">    instance = new messageConstructor().$mount(); // 渲染组件</span><br><span class="line">    document.body.appendChild(instance.$el); // 挂载到 body 下</span><br><span class="line">&#125;;</span><br><span class="line">export default Message;</span><br></pre></td></tr></table></figure>
<p>上面的代码暴露了一个 Message 函数。为什么要暴露一个函数呢？原因很简单：你想想，我们最终是不是要根据 <code>this.$Message ()</code> 来调用一个组件，说白了，通过 js 调用，本质就是调用一个 函数。也就是说 <code>this.$Message ()</code> 就是执行了上面代码中导出的 <code>export default Message</code>，也就是执行了 Message 函数（<code>const Message = function() {}</code>），所以当我们调用 <code>this.$Message()</code> 的时候其实就是执行了 <code>Message()</code> 函数。而 <code>Message()</code> 函数只做了一件事情：就是通过手动挂载的方式把组件挂载到 body 下面。<br>补充一下🤐：一般来说我们常见的是 <code>$mount(&quot;#app&quot;)</code>，也就是把组件挂载到 <code>#app</code> 下面，<code>&lt;router-view /&gt;</code> 也包含在 <code>#app</code> 中，但是我们这种 Message提示是放在 <code>body</code> 下面的，也就是说它不受 <code>#app</code> 和 <code>&lt;router-view /&gt;</code> 的管控，所以当我们切换页面（路由）的时候，这个 Message 组件是不会跟着立马消失的，这点要注意哦😯。<br>这里顺便给个组件的目录结构，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-2e4a12e3b5f5da91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message.png"></p>
<h2 id="开始调用"><a href="#开始调用" class="headerlink" title="开始调用"></a>开始调用</h2><p>调用方式很简单，首先我们在入口文件 main.js（和上面不是同一个😢） 里加上两行代码，这样我们就能在需要的地方直接用 js 调用它了，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import EchojoyMessage from &apos;./../packages/message/src/message.js&apos;</span><br><span class="line">Vue.prototype.$message = EchojoyMessage;</span><br></pre></td></tr></table></figure>
<p>然后在页面中测试一下，就像下面这样子：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-09a2f0e7cbe77528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ALAERT.png"></p>
<p>运行一下代码：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-a3c24b73cd995de6?imageMogr2/auto-orient/strip" alt="image"></p>
<figcaption></figcaption>

<p>嗯，挺好，小有成就的 feel 👏👏👏。</p>
<h2 id="支持可传参数"><a href="#支持可传参数" class="headerlink" title="支持可传参数"></a>支持可传参数</h2><p>别急，我们好像还漏了点什么🤔。。。对了，现在还不支持传参呢，直接调用 <code>this.$message()</code> 就只能显示————服务器错误，请稍后重试（这下全都是后端的锅了😊）。但我们可是个有追求的前端，不能局限于此，所以现在让我们来尝试增加下两个可配置参数，这里拿 <code>duration</code> 和 <code>content</code> 举个栗子🌰。<br>首先我们要修改 message.vue 组件里面的内容（其实没啥大变化），就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- message.vue 可配置版 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div class=&quot;echojoy-message&quot; &gt;</span><br><span class="line">    &lt;p &gt;</span><br><span class="line">      &#123;&#123;content&#125;&#125; </span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 主要就改了 data</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;EchojoyMessage&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      content: &quot;&quot;,</span><br><span class="line">      duration: 3000</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.$destroy(true);</span><br><span class="line">      this.$el.parentNode.removeChild(this.$el);</span><br><span class="line">    &#125;, this.duration);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码应该算是浅显易懂了，接下来我们看下 message.js 里面改了啥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// message.js</span><br><span class="line">import Vue from &quot;vue&quot;; // 引入 Vue 是因为要用到 Vue.extend() 这个方法</span><br><span class="line">import message from &quot;./message.vue&quot;; // 引入刚才的 toast 组件</span><br><span class="line"></span><br><span class="line">let messageConstructor = Vue.extend(message); // 这个在前面的前置知识内容里面有讲到</span><br><span class="line">let instance;</span><br><span class="line"></span><br><span class="line">const Message = function (options = &#123;&#125;) &#123;</span><br><span class="line">  instance = new messageConstructor(&#123;</span><br><span class="line">    data: options // 这里的 data 会传到 message.vue 组件中的 data 中，当然也可以写在 props 里</span><br><span class="line">  &#125;); // 渲染组件</span><br><span class="line">  document.body.appendChild(instance.$mount().$el); // 挂载到 body 下</span><br><span class="line">&#125;;</span><br><span class="line">export default Message;</span><br></pre></td></tr></table></figure>
<p>其实 message.js 也没多大变化，就是在函数里面加了个参数。要注意的是 <code>new messageConstructor({ data: options })</code> 中的 data 就是 message.vue 组件中的 data，不是随随便便取的字段名，传入的 <code>options</code> 会和组件中的 data 合并（Vue 的功劳）。<br>em。。。是的，就这么简单，现在让我们继续来调用一下它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show()&#123;</span><br><span class="line">      this.$message.success(&#123;</span><br><span class="line">        content: &quot;哈哈哈哈，消失的贼快&quot;,</span><br><span class="line">        duration: 0</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>运行一下就可以看到：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-738632ab3db8fc91?imageMogr2/auto-orient/strip" alt="image"></p>
<figcaption></figcaption>

<p>当然，这还没完，我们继续添加个小功能点🙄。。。</p>
<h2 id="支持-this-message-error"><a href="#支持-this-message-error" class="headerlink" title="支持 this.$message.error()"></a>支持 this.$message.error()</h2><p>这里我们打算支持 <code>this.$message.error()</code> 和 <code>this.$message.success()</code> 这两种方式，所以我们第一步还是要先去修改一下 message.vue 文件的内容（主要就是根据 <code>type</code> 值来修改组件的样式），就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--main.vue--&gt;</span><br><span class="line">&lt;div class=&quot;echojoy-message&quot; :class=&quot;type ? `echojoy-message--$&#123;type&#125;` : &apos;&apos;&quot;&gt;</span><br><span class="line">    &lt;p class=&quot;echojoy-message-content&quot;&gt;</span><br><span class="line">      &#123;&#123;content&#125;&#125; </span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  ...</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      type: &quot;&quot;,</span><br><span class="line">      content: &quot;&quot;,</span><br><span class="line">      duration: 3000</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.echojoy-message&#123;</span><br><span class="line">  ...</span><br><span class="line">  &amp;--error p &#123; background: rgba(255, 0, 0, 0.5); &#125;</span><br><span class="line">  &amp;--success p &#123; background: rgba(0, 255, 0, 0.5); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>其次，<code>this.$message.error()</code> 其实就等价于 <code>Message.error()</code>，所以我们现在的目的就是要给 Message函数扩充方法，也比较简单，就先看代码再解释吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// message.js</span><br><span class="line">const Message= function(options = &#123;&#125;) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br><span class="line">// 以下就是在 Message函数中拓展 [&quot;success&quot;, &quot;error&quot;] 这两个方法</span><br><span class="line"></span><br><span class="line">[&quot;success&quot;, &quot;error&quot;].forEach(type =&gt; &#123;</span><br><span class="line">  Message[type] = options =&gt; &#123;</span><br><span class="line">    options.type = type;</span><br><span class="line">    return Message(options);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default Message;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>Message.error()</code> 和 <code>Message.success()</code> 最终还是调用 <code>Message(options)</code> 这个函数，只不过在调用之前需要多做一步处理，就是将 <code>[&quot;success&quot;, &quot;error&quot;]</code> 作为一个 <code>type</code> 参数给合并进 <code>options</code> 里面再传递，仅此而已😬。<br>那就试试效果吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">      this.$message(&#123; content: &quot;这是正常的&quot; &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    showError() &#123;</span><br><span class="line">      this.$message.error(&#123; content: &quot;竟然失败了&quot; &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    showSuccess() &#123;</span><br><span class="line">      this.$message.success(&#123; content: &quot;居然成功了&quot; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-6435ed3c174a7160?imageMogr2/auto-orient/strip" alt="image"></p>
<h2 id="duration-lt-0-message一直存在"><a href="#duration-lt-0-message一直存在" class="headerlink" title="duration &lt;= 0,message一直存在"></a>duration &lt;= 0,message一直存在</h2><ul>
<li>传入参数非number类型<br>首先我们为了让组件可以在传入错误类型的duration是能正常使用，做了一个小小的兼容，判断变量类型是否为number，非number类型，控制台输出错误，并强行转化duration为数字1000.（处理办法相当粗暴了！！）</li>
<li>传入参数为number类型移除该组件实例和 DOM 节点<br><code>&gt;0</code><br>在duration的时间范围内，移除该组件实例和 DOM 节点<br><code>&lt;=0</code><br>不做任何处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    if (typeof this.duration !== &apos;number&apos; ) &#123;</span><br><span class="line">      console.error(&apos;the duration must be a number!&apos;)</span><br><span class="line">      this.duration = 1000</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.duration &gt; 0) &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        // 3s 后通过父级移除子元素的方式来移除该组件实例和 DOM 节点</span><br><span class="line">        this.$destroy(true);</span><br><span class="line">        this.$el.parentNode.removeChild(this.$el);</span><br><span class="line">      &#125;, this.duration);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="手动关闭message"><a href="#手动关闭message" class="headerlink" title="手动关闭message"></a>手动关闭message</h2><p>在dom结构上设置可以执行关闭的icon图标,添加事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;echojoy-icon-close echojoy-message-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p>
<p>在scripts中增加函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    close()&#123;</span><br><span class="line">      this.$destroy(true);</span><br><span class="line">      this.$el.parentNode.removeChild(this.$el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>再见吧！</p>
<p>参考 连接：<a href="https://juejin.im/post/5ca20e426fb9a05e42555d1d" target="_blank" rel="noopener">https://juejin.im/post/5ca20e426fb9a05e42555d1d</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/15/message-comp/" data-id="ck0rxd4tu001dygkcjtjb0etr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nodeBasics" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/14/nodeBasics/" class="article-date">
  <time datetime="2019-08-14T07:37:18.000Z" itemprop="datePublished">2019-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/14/nodeBasics/">node 基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-08-14 15:37:18</p>
<h1 id="有助于理解前端工具的-node-知识"><a href="#有助于理解前端工具的-node-知识" class="headerlink" title="有助于理解前端工具的 node 知识"></a>有助于理解前端工具的 node 知识</h1><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>平时写惯了业务代码之后，如果想要了解下 webpack 或者 vue-cli，好像是件很难上手的事情🙁 。拿 webpack 来说，我们可能会对配置熟悉点，但常常一段时间过后又忘了，感觉看起来不是很好懂。其实类似这种打包工具、构建工具我们最好应该先去学习一下 node 的一些基础知识，然后再回过头来看这些工具，就会有柳暗花明又一村的感觉，因为这些工具是用 node 写出来的🤯。<br>想想我们是不是时常看到过这种东西：<code>const path = require(&#39;path&#39;);</code>。<br>假设你学过前端框架但没学过 node，你看到这句话的时候就会一头雾水，好像知道它是弄路径的，但具体这是哪里来的，常用来做什么就不得而知了，我起初看的感觉就是这样🤨。<br>后来才知道这其实是 node 的内置模块，因为这些构建工具或打包工具是用 node 来执行的，只要我们有装 node，它里面的内置模块就能直接引用，不用另外安装。所以强烈建议大家要是想了解这类工具最好先学习一下 node，不然会总是懵逼的🧐。<br>言归正传，本篇就来简要讲述一下 node 的一些常用内置模块。</p>
<h2 id="node-初识"><a href="#node-初识" class="headerlink" title="node 初识"></a>node 初识</h2><h4 id="node-是什么"><a href="#node-是什么" class="headerlink" title="node 是什么"></a>node 是什么</h4><p>首先 node 不是一门后台语言而是一个环境，一个能够让 js 运行在服务器的环境，这个环境就好比是服务器上的浏览器（虽然不是很恰当），但正是因为有了它才使得 js 变成了一门后台语言。</p>
<h4 id="node-遵循的规范"><a href="#node-遵循的规范" class="headerlink" title="node 遵循的规范"></a>node 遵循的规范</h4><p>其次 node 遵循的是 CommonJs 规范，什么意思？其实就是规定了导入导出的方式😬，就向下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./module&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">&#125;</span><br><span class="line">exports.a = 1;</span><br></pre></td></tr></table></figure></p>
<p>这就是 node 的规范，用<code>require</code> 导入、用 <code>module.exports</code> 导出。那 node 为什么不支持 ESM（就是用 <code>import</code> 导入、用 <code>export</code> 导出）规范呢，因为它出现的比较早，仅此而已，然后一时半会儿还改不过来，以后应该就会支持了。另外，我们时常在 webpack 里看到 <code>require()</code> 字样却没有看见 <code>import()</code>就是因为 webpack 是要用 node 来执行的，而 node 目前只支持 <code>require()</code>。</p>
<p>这里顺带来一张各种规范图（这种东西容易忘，当作历史看看就行🙄），如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-9bba9115e27bcd20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16ad4be6bc803f68.png"></p>
<h2 id="require-寻找依赖"><a href="#require-寻找依赖" class="headerlink" title="require 寻找依赖"></a>require 寻找依赖</h2><p>require() 里面的参数有两种写法，一种带路径一种不带路径。就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./module&apos;); // 带相对路径</span><br><span class="line">require(&apos;/module&apos;); // 带绝对路径</span><br><span class="line">require(&apos;module&apos;); // 不带路径</span><br></pre></td></tr></table></figure></p>
<p>这种不带路径的 <code>require(&#39;module&#39;)</code>引入方式，可能是内置模块，也可能是第三方模块，内置模块优先查找，没有的话就是第三方模块了，它会先从当前目录的 node_modules 里面查找，没有的话就到父目录下的 node_modules 里面去找，如此向上追溯，直到根目录下的 node_modules 目录，要是还没有的话就会到全局里面去找，大概是这么一个搜索过程。</p>
<p>另外一种带路径的方式，就会沿着路径去找，如果没有找到则会尝试将当前目录作一个包来加载。此外，使用绝对路径的速度查找最快，当然了，node 也对路径查找做了缓存机制。</p>
<h2 id="node-模块包装"><a href="#node-模块包装" class="headerlink" title="node 模块包装"></a>node 模块包装</h2><p>node 在解析每个模块（js 文件）时，会对每个模块进行包装，就是在代码外面加一个闭包，并且向里传递五个参数，这样就保证了每个模块之间的独立，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">    // module: 表示当前模块</span><br><span class="line">    // __filename: 当前模块的带有完整绝对路径的文件名</span><br><span class="line">    // __dirname: 当前模块的完整绝对路径</span><br><span class="line">    module.exports = exports = this = &#123;&#125;;</span><br><span class="line">    // 我们的代码就在这里...</span><br><span class="line">    return module.exports;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>想想我们平时是不是常在 webpack 里面看到 __dirname 这种东西，我们既没有引入也没有声明它，为什么能够直接使用呢，就是因为这个原因😮。</p>
<h2 id="node-的应用场景"><a href="#node-的应用场景" class="headerlink" title="node 的应用场景"></a>node 的应用场景</h2><p>一般来说，node 主要应用于以下几个方面：</p>
<ul>
<li>自动化构建等工具</li>
<li>中间层</li>
<li>小项目</li>
</ul>
<p>第一点对于前端同学来说应该是重中之重了，什么工程化、自动构建工具就是用 node 写出来的，它是前端的一大分水岭之一，是块难啃的骨头，所以我们必须拿下，不然瓶颈很快就到了。如果你能熟练应用 node 的各种模块（系统模块 + 第三方模块），那么恭喜你，你又比别人牛逼了一截😎。</p>
<h2 id="node-的优点"><a href="#node-的优点" class="headerlink" title="node 的优点"></a>node 的优点</h2><ul>
<li>适合前端大大们</li>
<li>基于事件驱动和无阻塞的I/O（适合处理并发请求）</li>
<li>性能较好（别人做过性能分析）</li>
</ul>
<h2 id="node-内置模块"><a href="#node-内置模块" class="headerlink" title="node 内置模块"></a>node 内置模块</h2><p>ok，废话了这么多，咱们赶紧来看看一些常见的 node 基础模块吧。相信掌握这些对你学习 webpack 和 vue-cli 等工具是有很大帮助的✊ 。</p>
<h3 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h3><p>这是 node 最最基础的功能了，我们用 <code>node http.js</code> 运行一下下面的文件就能开启一个服务器，在浏览器中输入 <code>http://localhost:8888</code> 即可访问，http.js 具体内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// http.js</span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">http.createServer((req, res) =&gt; &#123; // 开启一个服务</span><br><span class="line">  console.log(&apos;请求来了&apos;); // 如果你打开 http://localhost:8888，控制台就会打印此消息</span><br><span class="line">  res.write(&apos;hello&apos;); // 返回给页面的值，也就是页面会显示 hello</span><br><span class="line">  res.end(); // 必须有结束的标识，否则页面会一直处于加载状态</span><br><span class="line">&#125;).listen(8888); // 端口号</span><br></pre></td></tr></table></figure></p>
<h3 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs 文件系统"></a>fs 文件系统</h3><p>由于 js 一开始是用来开发给浏览器用的，所以它的能力就局限于浏览器，不能直接对客户端的本地文件进行操作，这样做的目的是为了保证客户端的信息安全，当然了，通过一些手段也可以操作客户端内容（就像 <code>&lt;input type=&#39;file&#39;&gt;</code>），但是需要用户手动操作才行。<br>但是当 js 作为后台语言时，就可以直接对服务器上的资源文件进行 I/O 操作了。这也是 node 中尤为重要的模块之一（操作文件的能力），这在自动化构建和工程化中是很常用的。它的主要职责就是读写文件，或者移动复制删除等。fs 就好比对数据库进行增删改查一样，不同的是它操作的是文件。下面我们来具体看看代码用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 写入文件：fs.writeFile(path, fileData, cb);</span><br><span class="line">fs.writeFile(&apos;./text.txt&apos;, &apos;hello xr!&apos;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&apos;写入失败&apos;, err);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;写入成功&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 读取文件：fs.readFile(path, cb);</span><br><span class="line">fs.readFile(&apos;./text.txt&apos;, (err, fileData) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&apos;读取失败&apos;, err);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&apos;读取成功&apos;, fileData.toString()); // fileData 是二进制文件，非媒体文件可以用 toString 转换一下</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是 readFile 里面的 fileData 是原始的二进制文件🤨（em…就是计算机才看的懂的文件格式），对于非媒体类型（如纯文本）的文件可以用 <code>toString()</code> 转换一下，媒体类型的文件以后则会以流的方式进行读取，要是强行用 <code>toString()</code> 转换的话会丢失掉原始信息，所以不能乱转。二进制和 <code>toString</code> 的效果就像下面这样：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-c418ff2996cf5c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>另外，和 fs.readFile（异步） 和 fs.writeFile（异步）相对应的还有 fs.readFileSync（同步）和 fs.writeFileSync（同步），fs 的大多方法也都有同步异步两个版本，具体取决于业务选择，一般都用异步，不知道用啥的话也用异步。</p>
<h2 id="path-路径"><a href="#path-路径" class="headerlink" title="path 路径"></a>path 路径</h2><p>这个模块想必大家应该都并不陌生，🧐瞟过 webpack 的都应该看过这个东东。很显然，path 就是来处理路径相关东西的，我们直接看下面的常见用例就能够体会到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">let str = &apos;/root/a/b/index.html&apos;;</span><br><span class="line">console.log(path.dirname(str)); // 路径</span><br><span class="line">// /root/a/b</span><br><span class="line">console.log(path.extname(str)); // 后缀名</span><br><span class="line">// .html</span><br><span class="line">console.log(path.basename(str)); // 文件名</span><br><span class="line">// index.html</span><br><span class="line"></span><br><span class="line">// path.resolve() 路径解析，简单来说就是拼凑路径，最终返回一个绝对路径</span><br><span class="line">let pathOne = path.resolve(&apos;rooot/a/b&apos;, &apos;../c&apos;, &apos;d&apos;, &apos;..&apos;, &apos;e&apos;);</span><br><span class="line"></span><br><span class="line">// 一般用来打印绝对路径，就像下面这样，其中 __dirname 指的就是当前目录</span><br><span class="line">let pathTwo = path.resolve(__dirname, &apos;build&apos;); // 这个用法很常见，你应该在 webpack 中有见过</span><br><span class="line"></span><br><span class="line">console.log(pathOne, pathTwo, __dirname);</span><br><span class="line">// pathOne  =&gt;  /Users/lgq/Desktop/node/rooot/a/c/e</span><br><span class="line">// pathTwo  =&gt;  /Users/lgq/Desktop/node/build</span><br><span class="line">// __dirname  =&gt;  /Users/lgq/Desktop/node</span><br></pre></td></tr></table></figure></p>
<p>嗯，下次看到 path 这个东西就不会迷茫了。</p>
<h3 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h3><p>很显然这是个用来处理网址相关东西的，也是我们必须要掌握的，主要用来获取地址路径和参数的，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">let site = &apos;http://www.xr.com/a/b/index.html?a=1&amp;b=2&apos;;</span><br><span class="line">let &#123; pathname, query &#125; = url.parse(site, true); // url.parse() 解析网址，true 的意思是把参数解析成对象</span><br><span class="line"></span><br><span class="line">console.log(pathname, query);</span><br><span class="line">// /a/b/index.html  &#123; a: &apos;1&apos;, b: &apos;2&apos; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="querystring-查询字符串"><a href="#querystring-查询字符串" class="headerlink" title="querystring 查询字符串"></a>querystring 查询字符串</h3><p>这个主要是用来把形如这样的字符串 <code>a=1&amp;b=2&amp;c=3</code>（&amp;和=可以换成别的）解析成 <code>{ a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; }</code> 对象，反过来也可以把对象拼接成字符串，上面的 url 参数也可以用 querystring 来解析，具体演示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const querystring = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">let query = &apos;a=1&amp;b=2&amp;c=3&apos;; // 形如这样的字符串就能被解析</span><br><span class="line">let obj = querystring.parse(query);</span><br><span class="line">console.log(obj, obj.a); // &#123; a: &apos;1&apos;, b: &apos;2&apos;, c: &apos;3&apos; &#125;   &apos;1&apos;</span><br><span class="line"></span><br><span class="line">query = &apos;a=1&amp;b=2&amp;c=3&amp;a=3&apos;; // 如果参数重复，其所对应的值会变成数组</span><br><span class="line">obj = querystring.parse(query);</span><br><span class="line">console.log(obj); // &#123; a: [ &apos;1&apos;, &apos;3&apos; ], b: &apos;2&apos;, c: &apos;3&apos; &#125;</span><br><span class="line"></span><br><span class="line">// 相反的我们可以用 querystring.stringify() 把对象拼接成字符串</span><br><span class="line">query = querystring.stringify(obj);</span><br><span class="line">console.log(query); // a=1&amp;a=3&amp;b=2&amp;c=3</span><br></pre></td></tr></table></figure>
<h3 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert 断言"></a>assert 断言</h3><p>这个我们直接看下面代码就知道它的作用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// assert.js</span><br><span class="line">const assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">// assert(条件，错误消息)，条件这部分会返回一个布尔值</span><br><span class="line">assert(2 &lt; 1, &apos;断言失败&apos;);</span><br></pre></td></tr></table></figure>
<p><code>node assert.js</code> 运行一下代码就能看到如下结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11846892-6bd3e74df2f4db39?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>上图是断言失败的例子，如果断言正确的话，则不会有任何提示，程序会继续默默往下执行。所以断言的作用就是先判断条件是否正确（有点像 if），如果条件返回值为 <code>false</code> 则阻止程序运行，并抛出一个错误，如果返回值为 <code>true</code> 则继续执行，一般用于函数中间和参数判断。<br>另外，这里再介绍两种 equal 用法（assert 里面有好多种 equal，这里举例其中的两种）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// assert.js</span><br><span class="line">const assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">const obj1 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class="line">const obj2 = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class="line">const obj3 = &#123; a: &#123; b: &apos;1&apos; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">// assert.deepEqual(变量，预期值，错误信息)   变量 == 预期值</span><br><span class="line">// assert.deepStrictEqual(变量，预期值，错误信息)  变量 === 预期值</span><br><span class="line">// 同样也是错误的时候抛出信息，正确的时候继续默默执行</span><br><span class="line">assert.deepEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class="line">assert.deepEqual(obj1, obj3, &apos;不等哦&apos;); // true</span><br><span class="line">assert.deepStrictEqual(obj1, obj2, &apos;不等哦&apos;); // true</span><br><span class="line">assert.deepStrictEqual(obj1, obj3, &apos;不等哦&apos;); // false，这个会抛出错误信息</span><br></pre></td></tr></table></figure>
<h3 id="stream-流"><a href="#stream-流" class="headerlink" title="stream 流"></a>stream 流</h3><p>stream 又叫做流，大家或多或少应该有听过这个概念，那具体是什么意思呢？在这里，你可以把它当做是前面说过的 <code>fs.readFile</code> 和 <code>fs.writeFile</code> 的升级版。<br>我们要知道 <code>readFile</code> 和 <code>writeFile</code> 的工作流程 是先把整个文件读取到内存中，然后再一次写入，这种方式对于稍大的文件就不适用了，因为这样容易导致内存不足，所以更好的方式是什么呢？就是边读边写啦，业界常说成管道流，就像水流经过水管一样，进水多少，出水就多少，这个水管就是占用的资源（内存），就那么大，这我们样就能合理利用内存分配啦，而不是一口气吃成个胖子，有吃撑的风险（就是内存爆了🤐）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 读取流：fs.createReadStream();</span><br><span class="line">// 写入流：fs.createWriteStream();</span><br><span class="line">let rs = fs.createReadStream(&apos;a.txt&apos;); // 要读取的文件</span><br><span class="line">let ws = fs.createWriteStream(&apos;a2.txt&apos;); // 输出的文件</span><br><span class="line"></span><br><span class="line">rs.pipe(ws); // 用 pipe 将 rs 和 ws 衔接起来，将读取流的数据传到输出流（就是这么简单的一句话就能搞定）</span><br><span class="line"></span><br><span class="line">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;成功&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>流式操作，就是一直读取，它是个连续的过程，如果一边快一边慢，或者一边出错没衔接上也没关系，它会自动处理，不用我们自己去调整其中的误差，是个优秀的模块没错了👍。另外，我们没有直接使用 stream 模块，是因为 fs 模块引用了它并对其做了封装，所以用 fs 即可。</p>
<h3 id="zlib-压缩"><a href="#zlib-压缩" class="headerlink" title="zlib 压缩"></a>zlib 压缩</h3><p>这个用法简单，作用也明了，直接看下面的代码就能理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const zlib = require(&apos;zlib&apos;);</span><br><span class="line"></span><br><span class="line">let rs = fs.createReadStream(&apos;tree.jpg&apos;);</span><br><span class="line">let gz = zlib.createGzip();</span><br><span class="line">let ws = fs.createWriteStream(&apos;tree.jpg.gz&apos;);</span><br><span class="line"></span><br><span class="line">rs.pipe(gz).pipe(ws);  // 原始文件 =&gt; 压缩 =&gt; 写入</span><br><span class="line"></span><br><span class="line">rs.on(&apos;error&apos;, err =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line">ws.on(&apos;finish&apos;, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;成功&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ok👌，以上就是本章要讲的一些 node 知识（比较基础，大家凑合看看）。当然除此之外，还有 util、Buffer、Event、crypto 和 process 等其他内置模块，这里就不一一赘述了，希望大家能够多动手多敲两下代码多实践，毕竟纸上得来终觉浅嘛💪。如果你能用好 node 的各种模块，那么转后端也就拥有了无限可能性😋（其实前端的坑大的超乎你想像😭）。<br>参考作者：尤水就下<br>参考链接：<a href="https://juejin.im/post/5ccacfb96fb9a03201243cb9" target="_blank" rel="noopener">https://juejin.im/post/5ccacfb96fb9a03201243cb9</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/14/nodeBasics/" data-id="ck0rxd4tv001eygkcmbzyp7ij" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/">node</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-npmBuild" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/npmBuild/" class="article-date">
  <time datetime="2019-07-26T06:18:53.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/npmBuild/">npm 部署自己的组件库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>
<h1 id="基于-vue-cli-打造属于自己的-UI-库"><a href="#基于-vue-cli-打造属于自己的-UI-库" class="headerlink" title="基于 vue-cli 打造属于自己的 UI 库"></a>基于 vue-cli 打造属于自己的 UI 库</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h2 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h2><p>我们可能习惯了在一个 vue 里面引入组件的方式，所以先这里要巩固一下全局引入组件的方式。举个栗子🌰，一般我们的用法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Loading from &apos;../components/loading&apos;</span><br><span class="line">// 方法一：name 是组件的名字</span><br><span class="line">Vue.component(Loading.name, Loading)</span><br><span class="line">// 方法二：前提是 Loading 有提供 install 这个方法</span><br><span class="line">Vue.use(Loading);</span><br></pre></td></tr></table></figure></p>
<h1 id="基于vue-cli3打造组件库"><a href="#基于vue-cli3打造组件库" class="headerlink" title="基于vue-cli3打造组件库"></a>基于vue-cli3打造组件库</h1><h1 id="搭建目录"><a href="#搭建目录" class="headerlink" title="搭建目录"></a>搭建目录</h1><h4 id="快速创建项目"><a href="#快速创建项目" class="headerlink" title="快速创建项目"></a>快速创建项目</h4><ul>
<li>vue-cli3<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create projectName</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="修改目录结构"><a href="#修改目录结构" class="headerlink" title="修改目录结构"></a>修改目录结构</h3><ul>
<li>把 src 目录名字改成 examples，这是用于展示组件示例的</li>
<li>在根目录下新建一个 packages 文件夹，这是用来放组件的<br><img src="/images/1.png" alt="1ll.png"><br> 你可能会问为什么要建这样的目录结构，问得好，原因很简单，因为别人是这样做的，所以借鉴（模仿）罗。。。我们可以看到 Element 的源码也是这样的结构：<br>当我们水平不够的时候，模仿是一种强大的学习能力👏。</li>
</ul>
<h3 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h3><p>小改了一下目录之后，你会惊奇的发现项目运行不了了。没关系，这很正常，毕竟 src 都不见了，路径啥的肯定得报错。所以现在我们来解决这个问题。 在根目录下新建一个 vue.config.js 文件（新项目是没有这个文件的），并写入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // 修改 pages 入口</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: &apos;examples/main.js&apos;, // 入口</span><br><span class="line">      template: &apos;public/index.html&apos;, // 模板</span><br><span class="line">      filename: &apos;index.html&apos; // 输出文件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 扩展 webpack 配置</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    // @ 默认指向 src 目录，这里要改成 examples</span><br><span class="line">    // 另外也可以新增一个 ~ 指向 packages</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(&apos;@&apos;, path.resolve(&apos;examples&apos;))</span><br><span class="line">      .set(&apos;~&apos;, path.resolve(&apos;packages&apos;))</span><br><span class="line"></span><br><span class="line">    // 把 packages 和 examples 加入编译，因为新增的文件默认是不被 webpack 处理的</span><br><span class="line">    config.module</span><br><span class="line">      .rule(&apos;js&apos;)</span><br><span class="line">      .include.add(/packages/).end()</span><br><span class="line">      .include.add(/examples/).end()</span><br><span class="line">      .use(&apos;babel&apos;)</span><br><span class="line">      .loader(&apos;babel-loader&apos;)</span><br><span class="line">      .tap(options =&gt; &#123;</span><br><span class="line">        // 修改它的选项...</span><br><span class="line">        return options</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的注释应该都写的挺明了，主要就是修改别名、修改入口文件以及把新文件加入 webpack 编译这几个步骤。然后我们再运行一下程序就可以跑得通了。至于为什么这么配置、或者怎么配置，不了解的同学可以去 <a href="https://link.juejin.im/?target=https%3A%2F%2Fcli.vuejs.org%2Fzh%2Fconfig%2F%23%25E5%2585%25A8%25E5%25B1%2580-cli-%25E9%2585%258D%25E7%25BD%25AE" target="_blank" rel="noopener">Vue Cli</a> 官网看下，上面写的是清清楚楚、明明白白，然而我也只是懂那么一两个配置而已😭😭😭，还没学会 webpack 的套路，因为常常是用的时候看一眼，一阵子不用就又忘了，没办法🤷‍♀️脑子不行。</p>
<h2 id="编写组件"><a href="#编写组件" class="headerlink" title="编写组件"></a>编写组件</h2><p>一个组件库没有组件怎么行呢，所以我们要先写个 test 组件（你可以随便写，这不重要）。ok👌，我们先在 packages 目录下新建一个 test 文件夹，再在 test 文件夹下下面新建一个 src 文件夹，在 src 文件夹下面新建一个 test.vue 组件，大概长下面这样子👇：</p>
<p><img src="/images/2.png" alt="1ll.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--test.vue--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;echojoy-test&quot; @click=&quot;handleClick&quot;&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;EchojoyTest&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      this.num++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style &gt;</span><br><span class="line">.echojoy-test &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  line-height: 100px;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  font-size: 30px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  background: #24292e;</span><br><span class="line">  color: white;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>应该都能看懂吧，不过多解释。⚠️这里主要强调一点，就是 name 这个名字尤为重要，我就在这个坑里呆了挺久。首先它是必须要写的，为啥呢，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 <code>EchojoyTest</code>，到时候我们写的标签就长这样 <code>&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</code>，就像 Element 一样，name 是 <code>ElButton</code>，用的时候就是 <code>&lt;el-button&gt;&lt;/el-button&gt;</code>。</p>
<h2 id="暴露组件"><a href="#暴露组件" class="headerlink" title="暴露组件"></a>暴露组件</h2><p>让我们在 packages/test 下面新建一个 index.js 文件，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 对外提供对组件的引用，注意组件必须声明 name</span><br><span class="line">import EchojoyTest from &apos;./src/test&apos;</span><br><span class="line">// 为组件提供 install 安装方法，供按需引入</span><br><span class="line">EchojoyTest.install = Vue =&gt; &#123;</span><br><span class="line">  Vue.component(EchojoyTest.name, EchojoyTest)</span><br><span class="line">&#125;</span><br><span class="line">export default EchojoyTest</span><br></pre></td></tr></table></figure>
<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 <code>Vue.use()</code> 的需要，use 会默认调用 install 方法安装，仅此而已。接着我们在 packages 下面也新建一个 index.js 文件，注意和上面那个 index.js 区别开，上面那个是针对单个组件安装的，这个是针对所有组件全局安装的，先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import EchojoyTest from &apos;./test&apos;</span><br><span class="line">// 存储组件列表</span><br><span class="line">const components = [</span><br><span class="line">  EchojoyTest</span><br><span class="line">]</span><br><span class="line">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span><br><span class="line">const install = function (Vue) &#123;</span><br><span class="line">  // 判断是否安装</span><br><span class="line">  if (install.installed) return</span><br><span class="line">  install.installed = true</span><br><span class="line">  // 遍历注册全局组件</span><br><span class="line">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class="line">  // 下面这个写法也可以</span><br><span class="line">  // components.map(component =&gt; Vue.use(component))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断是否是直接引入文件</span><br><span class="line">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class="line">  install(window.Vue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span><br><span class="line">  install,</span><br><span class="line">  // 以下是具体的组件列表</span><br><span class="line">  ...components</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这步的主要作用就是统一导出所有组件及暴露 install 方法。之前的 index.js 只是安装单个组件，而现在这个 index.js 是循环安装所有组件，具体使用就看你是不是要按需引用了。这里给个目录结构方便大家观看：</p>
<p><img src="/images/3.png" alt="1ll.png"></p>
<p>因为这步挺重要的，所以建议好好停下来理解消化一下🤔。。。<br>当然你可能会问道，为什么这样建目录？还能什么原因，因为 Element 是这样（如下图），所以我们这样写，仅此而已。</p>
<h2 id="组件测试"><a href="#组件测试" class="headerlink" title="组件测试"></a>组件测试</h2><p>ok，组件写完了，接下来我们就在 examples 下面测试一下，看看能不能引用成功。 首先在 examples 下的 main.js 中引入刚刚写好的包，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import EchojoyUI from &apos;./../packages&apos;</span><br><span class="line">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure></p>
<p>然后把 examples/components下面的 HelloWorld里面的内容删了，写入自己标签组件，就像下面这样：</p>
<p><img src="/images/11.png" alt="1ll.png"></p>
<p>好了，最后让我们运行一下项目 <code>npm run  serve</code>，看看效果，嗯，还凑合吧。</p>
<h2 id="库模式打包"><a href="#库模式打包" class="headerlink" title="库模式打包"></a>库模式打包</h2><p>在 vue-cli3 中我们通过以下命令可以将一个单独的入口打包成一个库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// target: 默认为构建应用，改为 lib 即可启用构建库模式</span><br><span class="line">// name: 输出文件名</span><br><span class="line">// dest: 输出目录，默认为 dist，这里我们改为 lib</span><br><span class="line">// entry: 入口文件路径</span><br><span class="line">vue-cli-service build --target lib --name lib [entry]</span><br></pre></td></tr></table></figure>
<p>要注意的是在库模式中，打包出来的库中是不包含 Vue 的。 然后我们修改一下 package.json 文件，就像下面这样：</p>
<p><img src="/images/5.png" alt="1ll.png"></p>
<p>接着执行 <code>npm run lib</code> 就能生成库啦，看看左侧的目录是不是多了个 lib 文件夹，那个就是我们要发布的东西。<br><img src="/images/6.png" alt="1ll.png"></p>
<p>补充下，lib 目录下面的 js 之所以有好几种，是因为有两种规范（common 和 umd）、是否压缩（min）和映射（map）的区别，暂且知道有这么回事就行，不用深究。</p>
<h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><p>万事俱备，只欠发布。</p>
<ol>
<li>完善一下 README.md 文档，这个随便写两句就好</li>
<li>修改一下 package.json 文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &quot;name&quot;: &quot;echojoy-ui&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;description&quot;: &quot;基于 vue-cli3 的 UI 组件库&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;lib/xr-ui.umd.min.js&quot;,</span><br><span class="line">  &quot;keywords&quot;: &quot;echojoy-ui&quot;,</span><br><span class="line">  &quot;private&quot;: false,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在根目录下新建一个 .npmignore 文件，内容和 .gitignore 差不多：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 这是复制 .gitignore 里面的</span><br><span class="line">.DS_Store</span><br><span class="line">node_modules</span><br><span class="line">/dist</span><br><span class="line"></span><br><span class="line"># local env files</span><br><span class="line">.env.local</span><br><span class="line">.env.*.local</span><br><span class="line"></span><br><span class="line"># Log files</span><br><span class="line">npm-debug.log*</span><br><span class="line">yarn-debug.log*</span><br><span class="line">yarn-error.log*</span><br><span class="line"></span><br><span class="line"># Editor directories and files</span><br><span class="line">.idea</span><br><span class="line">.vscode</span><br><span class="line">*.suo</span><br><span class="line">*.ntvs*</span><br><span class="line">*.njsproj</span><br><span class="line">*.sln</span><br><span class="line">*.sw*</span><br><span class="line"></span><br><span class="line"># 以下是新增的</span><br><span class="line"># 要忽略目录和指定文件</span><br><span class="line">examples/</span><br><span class="line">packages/</span><br><span class="line">public/</span><br><span class="line">vue.config.js</span><br><span class="line">babel.config.js</span><br><span class="line">*.map</span><br><span class="line">*.html</span><br></pre></td></tr></table></figure>
<p>最后执行 <code>npm login</code> 登入 npm 账号，再执行 <code>npm publish</code> 发布即可，就这么简单的两步就可以，过一会在 npm 上就能搜到了。当然前提是你有个 npm 账号，没有的话去注册一个吧，很 easy 的，然后还要搜下你的 npm 包名是否有人用，有的话就换一个。</p>
<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>终于，历尽千辛万苦，我们可以引用自己写的库拉，想想就牛叉。别激动，让我们试验一下，用 <code>vue create echojoy-ui-use</code> 另起一个新项目，然后 <code>npm i echojoy-ui -S</code>，可以在 node_modules 里面看到我们的包大概长这样：<br><img src="/images/7.png" alt="1ll.png"></p>
<p>然后在 main.js 引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import EchojoyUI from &quot;echojoy-ui&quot;;</span><br><span class="line">import &quot;echojoy-ui/lib/echojoy-ui.css&quot;;</span><br><span class="line">Vue.use(EchojoyUI);</span><br></pre></td></tr></table></figure>
<p>这样我们就能在页面中引入组件啦，哈哈哈哈，贼开心，喜上眉梢。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;echojoy-test&gt;&lt;/echojoy-test&gt;</span><br></pre></td></tr></table></figure>
<h1 id="vue-cli3（vue-cli2）"><a href="#vue-cli3（vue-cli2）" class="headerlink" title="! vue-cli3（vue-cli2）"></a>! vue-cli3（vue-cli2）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack projectName</span><br></pre></td></tr></table></figure>
<p><img src="/images/8.png" alt="1ll.png"></p>
<h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p><code>npm run dev</code><br><img src="/images/9.png" alt="1ll.png"><br>浏览器输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080</span><br></pre></td></tr></table></figure></p>
<h4 id="编写组件-1"><a href="#编写组件-1" class="headerlink" title="编写组件"></a>编写组件</h4><p>在src的components新建组件limit：即文件夹<code>EchoLimit</code>-&gt;文件<code>index.vue</code> + 文件<code>index+css</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;echo-limit-container&quot; v-if=&quot;visible === false&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;echo-limit-container-inner&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;echo-limit-text&quot;&gt;</span><br><span class="line">        &#123;&#123;limitTip&#125;&#125;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    visible: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    limitTip: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &apos;没有权限！！&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  name: &quot;EchoLimit&quot; // 这个名字很重要，它就是未来的标签名&lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  @import &quot;./index&quot;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<p>⚠️这里主要强调一点，就是 name 这个名字尤为重要，你可以把它理解为 id，具有唯一标识组件的作用，将来我们可是要通过这个 name 来找到和判定这是什么组件，所以你写的所有组件应该是不重名的；其次这个 name 就是我们最终的标签名，比如这里我们的 name 是 EchoLimit，到时候我们写的标签就长这样 <echo-limit></echo-limit>，就像 Element 一样，name 是 ElButton，用的时候就是 <el-button></el-button>。</p>
<h4 id="暴露组件-1"><a href="#暴露组件-1" class="headerlink" title="暴露组件"></a>暴露组件</h4><ul>
<li>注册单个组件</li>
</ul>
<p>在 components 的 EchoLimit下面新建一个 index.js 文件，具体代码如下：<br>// 为组件提供 install 方法，供组件对外按需引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import EchoLimit from &quot;./EchoLimit/index.vue&quot;;</span><br><span class="line">EchoLimit.install = Vue =&gt; &#123;</span><br><span class="line">  Vue.component(EchoLimit.name, EchoLimit);</span><br><span class="line">&#125;;</span><br><span class="line">export default EchoLimit;</span><br></pre></td></tr></table></figure></p>
<p>这步的精髓就在于给组件扩展一个 install 方法，至于为什么要扩展这个方法，文章开头已经说到了，是因为 Vue.use() 的需要，use 会默认调用 install 方法安装。</p>
<ul>
<li>注册全局组件<br>让我们在 components 下面新建一个 index.js 文件，具体代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">import EchoLimit from &apos;./EchoLimit&apos;</span><br><span class="line">// 所有组件列表</span><br><span class="line">const components = [</span><br><span class="line">  EchoLimit</span><br><span class="line">]</span><br><span class="line">// 定义 install 方法，接收 Vue 作为参数</span><br><span class="line">const install = function (Vue) &#123;</span><br><span class="line">  // 判断是否安装，安装过就不继续往下执行</span><br><span class="line">  if (install.installed) return</span><br><span class="line">  install.installed = true</span><br><span class="line">  // 遍历注册所有组件</span><br><span class="line">  components.map(component =&gt; Vue.component(component.name, component))</span><br><span class="line">  // 下面这个写法也可以</span><br><span class="line">  // components.map(component =&gt; Vue.use(component))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检测到 Vue 才执行，毕竟我们是基于 Vue 的</span><br><span class="line">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class="line">  install(window.Vue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(components[0].name) // 控制台输出组件的name,方便引用组件</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  install,</span><br><span class="line">  // 所有组件，必须具有 install，才能使用 Vue.use()</span><br><span class="line">  ...components</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>目录结构方便大家观看：<br><img src="/images/4.png" alt="1ll.png"></p>
<h4 id="组件测试-1"><a href="#组件测试-1" class="headerlink" title="组件测试"></a>组件测试</h4><p>ok，组件写完了，接下来我们就在 HelloWorld.vue下面测试一下，看看能不能引用成功。 首先在 src下的 main.js 中引入刚刚写好的包，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import EchoUI from &apos;./components&apos;</span><br><span class="line">Vue.use(EchoUI)</span><br></pre></td></tr></table></figure>
<p>在 HelloWorld.vue中引入组件EchoLimit.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;EchoLimit&gt;&lt;/EchoLimit&gt;</span><br><span class="line">     &lt;echo-limit&gt;&lt;/echo-limit&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/echo-limit&gt;</span><br></pre></td></tr></table></figure></p>
<p>运行项目<code>npm run dev</code>,会发现成功了！！!<br><img src="/images/10.png" alt="1ll.png"></p>
<p>过程同上！！！！！！！！！</p>
<p>参考 连接：<a href="https://www.jianshu.com/p/41cc796488df" target="_blank" rel="noopener">https://www.jianshu.com/p/41cc796488df</a><br>参考 链接：<a href="https://juejin.im/post/5c95c61f6fb9a070c40acf65" target="_blank" rel="noopener">https://juejin.im/post/5c95c61f6fb9a070c40acf65</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/26/npmBuild/" data-id="ck0rxd4tw001gygkcnia1xh6z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/">npm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexoDeplayBug" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/hexoDeplayBug/" class="article-date">
  <time datetime="2019-07-24T07:28:39.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/hexoDeplayBug/">hexo deplay出错</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Author: Echo<br>Time: 2019-07-24 15:28:39</p>
<p>今天想在自己的另一个博客地址上更新一下博客，没想到hexo deplay没有反应，以下是解决过程：</p>
<h1 id="当部署失败的时候，请按照以下步骤进行："><a href="#当部署失败的时候，请按照以下步骤进行：" class="headerlink" title="当部署失败的时候，请按照以下步骤进行："></a>当部署失败的时候，请按照以下步骤进行：</h1><p>报错内容如下：<br><img src="https://upload-images.jianshu.io/upload_images/11846892-380d07b43c8f919a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="通过SSH-key来上传代码"><a href="#通过SSH-key来上传代码" class="headerlink" title="通过SSH key来上传代码"></a>通过SSH key来上传代码</h1><h6 id="1将SSH-key添加到github中"><a href="#1将SSH-key添加到github中" class="headerlink" title="1将SSH key添加到github中"></a>1将SSH key添加到github中</h6><p>① 打开本地文件：id_rsa.pub（文件路径可以在上一步SSH生成成功后看到路径，比如我的是c/Users/echo/.ssh/id_rsa.pub），可以将这个文件在编辑器中打开，然后全选复制。</p>
<p>② 登陆github，点击头像位置处 Settings ——&gt; SSH and GPG keys ——&gt; New SSH key，点击新建SSH key。</p>
<p>③ 将 ① 中复制的内容粘贴在key文本框里，title可以不用填（或者自己起一个名字也可以）</p>
<h6 id="2测试设置是否成功："><a href="#2测试设置是否成功：" class="headerlink" title="2测试设置是否成功："></a>2测试设置是否成功：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果出现如下情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You&apos;ve successfully authenticated, but GitHub does not </span><br><span class="line">provide shell access.</span><br></pre></td></tr></table></figure></p>
<p>将项目中如下位置文件做出更改<br><img src="https://upload-images.jianshu.io/upload_images/11846892-9dc350788418a979.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>不要使用https，而是改为SSH，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repository: https://github.com/username/username.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo：git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>一般这步基本就可以部署了！！！<br>如果部署还是失败，可以试试如下步骤（还是不行，就多试几遍。。。有点坑）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除.deploy_git</span><br><span class="line">$ hexo clean </span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p>
<p>本人的问题成功解决了，希望帮到大家哈哈哈哈哈开心！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/hexoDeplayBug/" data-id="ck0rxd4t3000hygkctjlyz4mh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blog-hexo/">blog-hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog-hexo/">blog-hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6-vue/">es6, vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/">web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端面试题/">前端面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/blog-hexo/" style="font-size: 15px;">blog-hexo</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/es6-vue/" style="font-size: 10px;">es6, vue</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/前端面试题/" style="font-size: 20px;">前端面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/20/express/">express： 实现本地代码+本地mock+环境接口数据</a>
          </li>
        
          <li>
            <a href="/2019/09/20/commitMessage/">Commit message 代码提交规范</a>
          </li>
        
          <li>
            <a href="/2019/09/20/ForwardReverseProxy/">正向代理&amp;反向代理</a>
          </li>
        
          <li>
            <a href="/2019/09/20/virtualDom/">虚拟dom</a>
          </li>
        
          <li>
            <a href="/2019/09/20/axios/">axios封装</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>