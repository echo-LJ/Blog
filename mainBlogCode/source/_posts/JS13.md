---
title: 「硬核JS」你真的了解垃圾回收机制吗
date: 2023-12-04 10:20:48
tags: JS
---

<meta name="referrer" content="no-referrer"/>

## 前言？

* 什么是垃圾回收机制？

* 垃圾是怎样产生的？

* 为什么要进行垃圾回收？

* 垃圾回收是怎样进行的？

* V8 引擎对垃圾回收进行了哪些优化？

### 一、GC是什么

`GC`即`Garbage Collection`,程序工作过程中会产生很多`垃圾`,这些垃圾是程序不用的内存或是之前用过了，以后不会再用的内存空间，而`GC`就是负责垃圾回收的，因为它工作在引擎内部，所以对于前端来说，`GC`是相对无感的，这一套引擎执行而对前端无感的操作被称为`垃圾回收机制`了。

* 自带`GC`的语言：`Java`、`Python`、`JavaScript`等.
* 无`GC`的语言：`C`、`C++` 等,程序员手动管理内存了，相对比较麻烦.


### 二、垃圾产生&为何回收
在写代码时创建一个基本类型、对象、函数都是需要占用内存的，我们不会关注内存分配，因为是引擎自动分配的内存空间。

但是，当我们不需要这些数据，会发生什么呢？JavaScript引擎是如何发现并清理他们的呢？

举个🌰：

引用数据是放在`堆内存`中的, 然后在`栈内存`中存放一个对堆内存中实际对象的引用地址，所以`JavaScript`操作引用数据类型操作的都是对象的引用而不是实际的对象。

```
let test = {
  name: "isboyjc"
};
test = [1,2,3,4,5]
```

将上面的变量test重新赋值一个新的数组，也就变成了该变量引用了一个数组，对之前对象的引用关系就没有了，如下图所示：

![img.png](https://upload-images.jianshu.io/upload_images/11846892-4e964cf22c08659c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


没有了引用关系，也就是无用对象（垃圾），所以就需要被清理（垃圾回收）。

程序运行需要内存，只要程序提出要求，操作系统或运行时就需要提供内存，那么对于持续运行的服务进程，必须要即时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

### 三、 垃圾回收策略

在`JavaScript`内存管理中有一个概念叫`可达性`： 以某种方式可访问或可使用的值，它们被保存在内存中，反之不可访问则需回收。

* 如何回收：发现不可达的对象(垃圾)并给予清理。

* `JavaScript垃圾回收机制：`定期找到不再使用的内存变量，并释放内存
* 为什么不能实时清理： 实时开销过大。

怎么找到不可达对象，并进行清理呢？本文简单介绍两种算法策略：


####  标记清除算法

**`策略`**

标记清除（Mark-Sweep）, `目前在JavaScript中算法是最常用的`,到目前为止的大多数浏览器的`JavaScipt`都在采用标记清除算法，只是各大浏览器厂商对此算法进行了优化加工，不同浏览器的`JavaScipt`引擎在垃圾回收的频率上有所差异。

此算法分为`标记`、`清除`两个部分，在活动对象上做标记，把没有被标记的对象进行清除。

* 如何给变量进行标记？有很多种办法： 比如变量进入到执行环境中，反转某一位来标记，或者可以维护进入环境变量和离开环境变量和羊两个列表，自由的把变量从一个表转入到另一个表中等等方法。

引擎在执行GC标记清除算法时，需要从出发点去遍历内存中所有的对象去打标记，而出发点有很多，我们称之为一组`根`对象，例如：浏览器环境中的`文档DOM对象`、`全局Window对象`等。

* 标记清除算法流程如下：

1、 垃圾收集器在运行时给内存中每一个对象添加一个标记，假设内存中的对象都是垃圾，全标记为0.
2、然后从根对象开始遍历，把不是垃圾的节点标记为1.
3、清除所有标记为0 的垃圾，并释放他们所占用的内存.
4、最后，把所有对象的标记修改为0, 用于下一轮垃圾回收

**`优点`**

标记清除法实现比较简单，使用一位二进制就可以标记。

**`缺点`**

清除垃圾对象之后，剩余的内存对象位置不变，会导致`空闲内存空间不是连续的`,会出现`内存碎片`，由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题。

![img2.png](https://upload-images.jianshu.io/upload_images/11846892-d63b4ce891c504b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


假设我们新建的对象内存大小为size,由于空闲内存时间断的、不连续的，则需要对内存空闲列表进行一次遍历，找出大于等于size的内存块才能进行分配。
![img3.png](https://upload-images.jianshu.io/upload_images/11846892-1805382920866472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如何找到合适的块进行分配呢？可以采取以下三种策略（猜想）

* `First-fit`: 找到大于等于size的空闲块，立即返回。
* `Best-fit`: 遍历整个空闲列表，找到大于等于size的最小分块。
* `Worst-fit`: 遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回。

这三种策略Worst-fit看似最合理，但会造成更多的小分块，形成内部碎片，所以不推荐，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择。

综上所属，标记清除算法或者说策略就有两个很明显的缺点

* `内存碎片化`： 空闲内存块不是连续的，容易出现更多的空闲内存块，还可能在分配内存更大的对象时找不到合适的内存块。
* `分配速度慢`：因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。

**`标记整理（Mark-Compact）算法`**  
可以解决标记清除算法的缺点：在于清除之后剩余的对象位置不变而导致的空闲内存不连续.

它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）

![截屏2023-12-04 下午2.07.56.png](https://upload-images.jianshu.io/upload_images/11846892-1b3043760305745d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

####  引用计数算法

**`策略`**

引用计数，实际是最早的一种垃圾回收算法，它把`对象是否不再需要`，简化定义为`对象有没有其他对象使用到它`，如果对象是零次引用，对象将被垃圾回收机制回收，目前该算法很少使用。

它的策略是跟踪记录每个变量值被使用的次数：

* 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
* 如果同一个值又被赋给另一个变量，那么引用数加 1
* 如果该变量的值被其他的值覆盖了，则引用次数减 1
* 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存
举个🌰：
```
let a = new Object() 	// 此对象的引用计数为 1（a引用）
let b = a 		// 此对象的引用计数是 2（a,b引用）
a = null  		// 此对象的引用计数为 1（b引用）
b = null 	 	// 此对象的引用计数为 0（无引用）
...			// GC 回收此对象
```
这种算法有一个`很严重问题`：即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子

```
function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}
```

如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，`假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放`

我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，`引用计数则不会释放，也就会造成大量无用内存占用`，这也是后来放弃引用计数，使用标记清除的原因之一.

**`优点`**

引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以`立即回收垃圾`.

**`缺点`**

引用计数它需要一个计数器，而此计数器需要占很大的位置，因为不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的。

---

### V8对GC的优化

#### 分代式垃圾回收

上面的垃圾标记清除算法，在每次垃圾回收时都要检查内存中的所有对象，对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点？

**`新老生代`**
V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为`新生代`和`老生代`两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收
* 新生代的对象: 为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量.
* 老生代的对象: 为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大.

V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）

![img5.png](https://upload-images.jianshu.io/upload_images/11846892-00a5a814220ba35f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**`新生代垃圾回收`**

新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收，在 `Scavenge算法` 的具体实现中，主要采用了一种复制式的方法即 `Cheney算法` .

Cheney算法将内存一分为二，分为使用区，空闲区

![img6.png](https://upload-images.jianshu.io/upload_images/11846892-182d30d32e60e8de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

新加入的对象会放在使用区，当内存快满的时候，进行一次垃圾清理操作。

* 开始垃圾回收时，新生代垃圾回收器会将使用区的内存对象进行标记，并将使用区的内存对象复制到空闲区并进行排序，
* 垃圾清理阶段，将非活动对象占用的内存清理掉，
* 最后进行角色互换，空闲区变成使用区，使用区变成空闲区。

有两种情况新生代对象变成老生代对象：
* 当一个对象经历多次复制后，它依然存活，则被认为是生命周期比较长的对象，随后移动到老生代中，用老生代垃圾回收器进行管理
* 如果复制一个对象到空闲区，空闲区空间内存占用好过了25%，那么这个对象直接被移动到老生代中。

设置25%为分界比列的原因： 当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配。

**`老生代垃圾回收采用标记整理算法`**

**`为什么要采用分代式？`**

分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率。

---

### 并行回收(Parallel)

`全停顿（Stop-The-World）：`JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 全停顿。

举个🌰：

一次 GC 需要 60ms ，那我们的应用逻辑就得暂停 60ms ，假如一次 GC 的时间过长，对用户来说就可能造成页面卡顿等问题。

为了解决这个问题，V8 引入了并行回收机制： 垃圾回收器在主线程执行的过程中，开启多个辅助线程，同时执行同样的回收工作。

![img6.png](https://upload-images.jianshu.io/upload_images/11846892-96ab155cadffeb1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收.

#### 增量标记与懒性清理

并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种`全停顿`式的垃圾回收方式,对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间.

所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记

**`增量`**将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 GC 标记（如下图）

![img55.png](https://upload-images.jianshu.io/upload_images/11846892-63144b4615004ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

🤔将一次完整的 GC 标记分次执行，那在每一小次 GC 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？V8 对这两个问题对应的解决方案分别是三色标记法与写屏障

#### 三色标记法(暂停与恢复)

三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑

* 白色指的是未被标记的对象
* 灰色指自身被标记，成员变量（该对象的引用对象）未被标记
* 黑色指自身和成员变量皆被标记

![img99.png](https://upload-images.jianshu.io/upload_images/11846892-5982a6b3752cb158.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


如上图所示，我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色
就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 C、E 将要等待回收）
采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以
三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 `全停顿` 的时间

#### 写屏障(增量中修改引用)

一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了，增量中修改引用，可能不太好理解，我们举个例子（如图）

![img555.png](https://upload-images.jianshu.io/upload_images/11846892-6b3271500fd2acf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

假如我们有 A、B、C 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 B 的指向由对象 C 改为了对象 D ，接着恢复执行下一次增量分段
这时其实对象 C 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 GC 是不会清理 C 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 GC 也会清理，这对我们程序运行并没有太大影响
我们再看新的对象 D 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 D 呢，这肯定是不对的

**V8 增量回收使用 写屏障 (Write-barrier) 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 GC 标记阶段可以正确标记，这个机制也被称作` 强三色不变性`**

那在我们上图的例子中，将对象 B 的指向由对象 C 改为对象 D 后，白色对象 D 会被强制改为灰色

#### 懒性清理

增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(Lazy Sweeping)
增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记


#### 增量标记与惰性清理的优缺？

增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：

首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量（吞吐量是指系统或组件在指定时间段内处理任务或事件的速率）


#### 并发回收(Concurrent)

前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？

**并发回收**它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）
![img666.png](https://upload-images.jianshu.io/upload_images/11846892-257ea2489a9a7858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 JavaScript  时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点.


### 再说V8中GC优化


V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，老生代垃圾回收器中这几种策略(并行回收、增量标记与惰性清理)都是融合使用的.

老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）
标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）
同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务之间执行.

## 总结

 V8 引擎为我们的垃圾回收所做的一些主要优化了，虽然引擎有优化，但并不是说我们就可以完全不用关心垃圾回收这块了，我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 `内存泄漏`


---
总结：大功告成✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️



参考链接:
* [「硬核JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214#heading-6)

