---
title: HTTP
date: 2023-08-25 10:07:53
tags: HTTP
---


<meta name="referrer" content="no-referrer"/>

### HTTP 的特点和缺点

**特点:** `无连接`、`无状态`、`灵活`、`简单快速`
* **无连接:** 每一次请求都要连接一次，请求结束就会断掉，不会保持连接。
* **无状态:** 每一次请求都是独立的，请求结束后不会记录连接的信息，减少了网络开销，这`是优点也是缺点`。
* **灵活:** 通过http协议中头部的`Content-type`标记，可以传输任意数据类型的数据对象（文本、图片、视频等），非常灵活。
* **简单快速:** 发送请求访问某个资源时，只需传送请求方法和URL就可以，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快。

**缺点:** `无状态`、`不安全`、`明文传输`、`对头阻塞`
* **无状态:** 请求不会记录任何连接信息，没有记忆，就无法区分多个请求的发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
* **不安全:** `明文传输`可能被窃听，不安全，缺少`身份认证`可能遭遇伪装，还有缺少`报文完整性验证`可能遭到篡改。
* **明文传输:** 报文（header部分）使用的是明文，直接将信息暴露给外界，`WIFI陷阱`就是复用明文传输的特点，诱导用户连上热点，疯狂抓去流量，从而获取用户敏感信息。
* **队头阻塞:** 开启长连接(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)

### HTTP 报文组成部分

`http报文`：由请求报文和响应报文组成.
`请求报文`：由请求行、请求头、空行、请求体四部分组成.
`响应报文`：由状态行、响应头、空行、响应体四部分组成.

* **请求行**：包含http方法，请求地址，http协议以及版本.
```
GET /index.html HTTP/1.1
```
* **请求头/响应头**: 包含了一系列的键值对，用于提供关于请求或响应的信息和配置,来告诉服务端我要哪些内容，要注意什么类型等,[请求头/响应头每一个字段详解](https://kb.cnblogs.com/page/92320/)。
* **空行**: 用来区分首部与实体，因为请求头都是键值对的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了.
* **请求体**：请求的参数.
* **状态行**: 包含协议版本号、状态码、状态信息。
```
HTTP/1.1 200 OK
```
### HTTP 请求方法(9种)

**`HTTP1.0`**： GET、POST、HEAD
**`HTTP1.1`**： PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT

|  方法   | 描述  |
|  ----  | ----  |
| GET  | 获取资源 |
| POST  | 传输资源，通常会造成服务器资源的修改。 |
| HEAD  | 获得报文首部（类似于GET方法，但不返回实际的资源内容）HEAD方法常用于检查资源的可用性和元数据，而不获取实际内容,客户端可以通过检查返回的响应头来判断资源是否存在、是否已更改等。 |
| PUT  | 更新资源 |
| PATCH  | 对PUT的补充，对已知资源部分更新 |
| DELETE  | 删除资源 |
| OPTIONS  | 列出该资源的服务器支持的请求方法，用来跨域请求 |
| TRACE  | 追踪请求/响应路径，用于测试或诊断,以便在请求/响应链中查看经过的中间节点和任何修改的内容(由于TRACE请求可能会将敏感信息泄露给中间节点和潜在的攻击者，因此在生产环境中通常不建议使用TRACE方法。) |
| CONNECT  | 将连接改为管道方式用于代理服务器(隧道代理下面有讲)(CONNECT方法用于请求与目标服务器建立一条隧道（Tunnel），通常用于将HTTP协议转换为HTTPS协议，或者用于代理服务器与目标服务器之间建立加密通信) |


* HEAD方法
```
HEAD /example.html HTTP/1.1
Host: www.example.com
// 响应结果
HTTP/1.1 200 OK
Date: Thu, 01 Jul 2021 12:00:00 GMT
Server: Apache/2.4.10
Content-Length: 1234
Content-Type: text/html; charset=utf-8
```
* OPTIONS方法
```
OPTIONS /example.html HTTP/1.1
Host: www.example.com
// 响应结果
HTTP/1.1 200 OK
Allow: GET, HEAD, POST, OPTIONS
Date: Thu, 01 Jul 2021 12:00:00 GMT
Server: Apache/2.4.10
Content-Length: 0
```

### GET 和 POST 的区别


* **数据传输方式**： `GET参数通过URL传递，POST放在Request body中`。
* **缓存机制**：`GET请求可以被浏览器缓存，可以利用浏览器的缓存机制来提高性能。POST请求默认是不被缓存的，每次提交都会重新获取最新的响应。`
* **安全性**:`GET请求的参数以明文形式出现在URL中，可以被浏览器缓存、历史记录和服务器日志等存储和记录， 而POST请求将参数封装在请求体中，并且不会显示在URL中，相对来说更安全，适用于传输敏感数据。`
* **浏览器回退机制**： `GET在浏览器回退时是无害的`（当用户点击浏览器的回退按钮时，浏览器会首先检查缓存，如果有缓存的GET响应，则直接从缓存中加载响应内容，不会再次向服务器发起请求，因此回退操作对服务器来说是无害的），`而POST会再次发起请求`（由于POST请求可能触发了服务器上的状态更改、数据提交等操作，浏览器在回退时通常不会从缓存中加载该请求的响应）。

* **请求长度限制**: GET请求对于URL的长度有限制，不同浏览器和服务器有不同的限制，一般在2KB至8KB之间。而POST请求没有明确的长度限制，可以传输大量数据。
* **编码方式不同** `GET请求只能进行URL编码`（encodeURIComponent函数），`而POST支持多种编码方式`。
* **参数的数据类型限制**：`对参数的数据类型，GET只接受ASCII字符`（对非ASCII字符的处理，需要进行URL编码），`而POST没有限制`。
* **网络层面的差异**： `GET产生一个TCP数据包，POST产生两个数据包(Firefox只发一次)。GET浏览器把 http header和data一起发出去，响应成功200，POST先发送header，响应100 continue， 再发送请求体数据，响应成功200`（先发送一个Expect: 100-continue的请求头，并等待服务器返回100 Continue响应，这样设计的目的是为了在处理大量数据或涉及长时间传输的情况下，让服务器能够提前进行处理确认，以提高效率。并非所有浏览器都返回响应！特别是在处理小量数据或简单的请求时，服务器可能会跳过这个阶段，直接接收请求的数据），


### 常见HTTP的状态码

* `1xx:` 指示信息——表示请求已接收，继续处理
* `2xx:` 成功——表示请求已被成功接收
* `3xx:` 重定向——表示要完成请求必须进行进一步操作
* `4xx:` 客户端错误——表示请求有语法错误或请求无法实现
* `5xx:` 服务端错误——表示服务器未能实现合法的请求

|  状态码   | 描述  | 附加  |
|  ----  | ----  | ----  |
| 200  | 请求成功 | ----  |
| 200  | 已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时 |----  |
| 301  | 永久重定向 |当服务器返回301状态码时，它会表示请求的资源已经被永久移动到了一个新的URL。客户端收到301响应后，应该更新自己的链接并使用新的URL重新发送请求。该响应还会包含一个Location头部字段，指示新的资源位置。｜
| 302  | 临时重定向 |客户端接收到这个响应后，会继续使用原始URL发送后续的请求。搜索引擎会将原始URL的权重保留，并在下一次请求时再次访问原始URL。使用302重定向时，浏览器通常不会缓存重定向结果。｜
| 304  | 请求资源未修改，可以使用缓存的资源，不用在服务器取 | 这通常用于缓存和优化网络性能，减少不必要的数据传输。`服务器在返回304响应时通常还会包含一个Last-Modified或ETag头部字段，用于与客户端浏览器的缓存信息进行比较。  |
| 400  | 请求有语法错误 | ----  |
| 401  | 没有权限访问 | ----  |
| 403  | 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时 | ----  |
| 404  | 请求资源不存在 | ----  |
| 500  | 服务器内部错误，无法完成请求 | ----  |
| 502  | Bad Gateway-错误的网关 | 这通常意味着代理服务器或网关服务器无法正确地将请求转发给目标服务器或上游服务器。1、上游服务器故障，2、网络连接问题， 3、配置错误｜
| 503  | 请求未完成，因服务器过载、宕机或维护等 | ----  |

### 什么是持久连接/长连接
`http1.0`协议采用的是"请求-应答"模式，当使用普通模式，每个请求/应答客户与服务器都要新建一个连接，完成之后立即断开连接(http协议为无连接的协议).
`http1.1`版本支持长连接，即`请求头`添加`Connection: Keep-Alive`，使用Keep-Alive模式(又称持久连接，连接复用)建立一个`TCP`连接后使客户端到服务端的连接持续有效，可以发送/接受多个`http`请求/响应，当出现对服务器的后续请求时，Keep-Alive功能避免了建立或者重新建立连接.

![截屏2023-08-28 下午2.22.46.png](https://upload-images.jianshu.io/upload_images/11846892-9a8c75166217ef5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图： 短连接极大的降低了传输效率
### 长连接优缺点

**`优点`**

* `减少CPU及内存的使用`： 因为不需要经常建立和关闭连接。
* `支持管道化`的请求及响应模式。
* `减少网络堵塞`： 减少了TCP请求。
* `减少后续请求响应时间-提高性能、`： 因为不需要等待建立TCP、握手、挥手、关闭TCP的过程。
* 发生错误时，可以在`不关闭连接的情况下进行错误提示`


**`缺点`**
* `资源占用` 长连接需要在服务器端保持连接的状态，这可能会占用服务器的内存和其他资源。在高流量情况下，可能需要增加服务器资源以处理大量的长连接请求。
* 长连接时间的长短，直接影响到服务器的并发数.
* 可能造成`队头堵塞`(下面有讲)，造成信息延迟.


### 如何避免长连接资源浪费？

* `服务端设置适当的超时时间`: 如Nginx，设置`keepalive_timeout`设置长连接超时时间，`keepalive_requests`设置长连接请求次数上限.确保连接在一段时间内没有活动时会被关闭。这样可以避免连接长时间处于闲置状态，释放服务器资源。
* `客户端请求头声明`：Connection: close，本次通信后就关闭连接.
* `系统内核参数设置：`
```
// 适用于大多数基于Linux的系统。
net.ipv4.tcp_keepalive_time = 60，连接闲置60秒后，服务端尝试向客户端发送侦测包，判断TCP连接状态，如果没有收到ack反馈就在
net.ipv4.tcp_keepalive_intvl = 10，就在10秒后再次尝试发送侦测包，直到收到ack反馈。
net.ipv4.tcp_keepalive_probes = 5，一共会尝试5次，要是都没有收到就关闭这个TCP连接了
```

* `某些使用短连接`
1、 临时请求
2、低并发请求
3、请求间隔较长
4、负载均衡环境



### 什么是管线化(管道化)

`http1.1`在使用`长连接`的情况下，建立一个连接通道后，连接上消息的传递类似于
> 请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3
`管理化连接`的消息就变成了类似这样
> 请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3

`管线化`是在同一个TCP连接里`发一个请求后不必等其回来就可以继续发请求出去`，这可以减少整体的响应时间，但是服务器还是`会按照请求的顺序响应请求`，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题`队头堵塞`(下面有讲解决方法).

**管线化的特点**

* 管线化机制通过持久连接完成，在`http1.1`版本才支持.
* 只有`GET`请求和`HEAD`请求才可以进行管线化，而POST有所限制.
* 初次创建连接时不应启动管线化机制，因为服务器不一定支持http1.1版本的协议
* 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序就是请求的顺序
* 要求`客户端`和`服务端`都支持管线化，但并不要求服务端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可
* 由于上面提到的服务端问题，开户管线化很`可能并不会带来大幅度的性能提升`，而且很多服务端和代理程序对管线化的支持并不好，因为浏览器(Chrome/Firefox)默认并未开启管线化支持.

### 如何解决HTTP对头阻塞的问题
1、`http1.0`协议采用的是`请求-应答`模式，报文必须是`一发一收`，这样就形成了`先进先出`的串行队列，没有优先级，只有入队的先后顺序，排在最前面的请求最先处理，导致如果队首的请求耗时过长，后面的请求只能处于阻塞状态，这就是著名的`队头阻塞`的问题。
2、在`HTTP/1.1` 的持久连接中，如果一个请求在队头等待响应时被阻塞，后续的请求也会被阻塞，导致效率低下。解决如下：
* **并发连接**
因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列中的任务阻塞了其他全部任务，现在浏览器标准中一个域名并发连接可以有6-8个（chrome6个/firefox8个）
* **域名分片**
多准备几个二级域名： a.baidu.com、b.baidu.com、c.baidu.com 当访问baidu.com时，可以让不同的资源从不同的二级域名中获取，二它们都指向同一台服务器，这样就能够并发不同的连接了。

* **HTTP/2** 使用 HTTP/2 协议，其主要特性是支持多路复用（multiplexing），可以在同一个连接上同时发送多个请求和接收多个响应。这样可以避免队头阻塞的问题，并提升了性能。HTTP/2 还支持头部压缩、服务器推送等特性，进一步提高了性能和效率。

* **使用异步加载技术**：可以通过使用异步加载的技术，如异步 JavaScript（AJAX），延迟加载等，将页面的关键资源提前加载，减少资源请求的数量，从而降低队头阻塞的影响。
### 说一下HTTP代理

常见的代理方式有两种:`普通代理（中间人代理）`、`隧道代理`。

#### 普通代理（中间人代理）

![截屏2023-08-29 下午2.03.55.png](https://upload-images.jianshu.io/upload_images/11846892-69d7298c35e8c8e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

它可以在中间可以帮我们过滤、缓存、负载均衡(多台服务器共用一台代理情况下)等一些处理！
⚠️：实际场景中客户端和服务器之间可能有多个代理服务器！

#### 隧道代理

**正向代理隧道:**有时候客户端需要通过`防火墙`或`代理服务器`连接到目标服务器，但被阻断了某些协议或端口。为了绕过限制，客户端和代理服务器可以建立一个加密的隧道连接，将原始通信封装在该连接中进行传输。这样可以使客户端在代理服务器的帮助下访问受限制的目标服务器。

客户端通过`CONNECT方法`请求隧道代理创建一个可以到任意目标服务器和端口号的TCP连接，创建成功之后隧道代理只做请求和响应数据的转发，中间它不会做任何处理.

![截屏2023-08-29 下午2.10.54.png](https://upload-images.jianshu.io/upload_images/11846892-58a38fdad9de139e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 为什么需要隧道代理呢？
隧道代理的主要作用是为了绕过网络限制和防火墙，以实现安全的通信和访问受限资源
* 越过防火墙限制: 某些网络环境中，由于防火墙或其他网络设备的配置，特定的协议或端口可能被禁止或限制。通过使用隧道代理，可以在防火墙之外建立加密的隧道连接，将原始通信封装在该连接中进行传输，从而绕过限制，实现对受限资源的访问。

例子： 我们都知道https服务是需要网站有证书的，而代理服务器显然没有，所以浏览器和代理之间无法创建TLS，所以就有了隧道代理，它把浏览器的数据原样透传，这样就实现了通过中间代理和服务端进行TLS握手，然后进行加密传输。

#### 使用代理服务器的好处

* **`突破访问限制和地理屏障：`** 可以绕过地理的限制(翻墙)，让用户访问受限的资源或服务。模拟其他地理位置，访问受限的资源。
* **`安全性更高：`** 隐藏客户端的真实IP地址,保护客户端的身份和隐私信息，防止被追踪和识别,也可以过滤恶意流量、防止攻击和入侵。
* **`负载均衡和高可用性: `** 代理服务器可以作为负载均衡器，将请求分发到多个后端服务器，实现负载均衡和高可用性。通过分散请求，可以平衡服务器负载，提供更好的性能和可伸缩性。
* **`缓存和加速: `** 代理服务器可以缓存服务器的响应，在后续的请求中直接返回缓存的响应，减少网络延迟和传输成本。通过缓存机制，代理服务器可以提供更快的响应速度，提高用户体验和网站性能。

### 代理常用的请求头
#### Via
Via 是代理服务器中常见的请求头之一。它用于标识请求经过的代理服务器链路。当代理服务器将请求转发给下一个代理服务器时，会在请求头中添加(代理服务器添加) Via 字段，并包含代理服务器的名称和版本信息。

```
Via: 1.1 proxy-server.example.com (Proxy Server v1.0)
```

**作用：**
1、跟踪请求路径
2、防止循环代理
#### X-Real-IP

一般记录真实发出请求的客户端的IP，还有X-Forwarded-Host和X-Forwarded-Proto分别记录真实发出请求的客户端的域名和协议名
#### X-Forwarded-For

记录客户端请求的来源IP，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源IP追加进去
```
X-Forwarded-For: client,proxy1,proxy2
```
⚠️：与服务器直连的代理服务器的IP不会被追加进去，该代理可能过TCP连接的Remote Address字段获取到与服务器直连的代理服务器IP

⚠️：添加 X-Forwarded-For 请求头是可选的，且可以被代理服务器修改或删除。不是所有的代理服务器都会添加或传递该请求头，因此无法保证每个代理服务器的 IP 地址都会在 X-Forwarded-For 中显示，因此可以伪造客户端IP.

#### 代理中客户端IP伪造问题以及如何预防？
在代理中，客户端IP伪造是一个常见的问题，因为代理服务器在转发请求时可能会修改或删除 X-Forwarded-For 请求头，从而篡改了客户端的真实IP地址。这可能导致诸如身份伪装、访问限制绕过和安全漏洞等问题。

**预防**

* 使用http1.1中的`Forwarded` 头字段是用于替代 `X-Forwarded-For` 头字段的标准化字段.
```
Forwarded: by=127.0.0.1; for=192.0.2.0; proto=https; host=example.com
```

* 在代理服务器和目标服务器中进行严格的安全认证和授权控制， 确保有经过验证的客户端才能访问受保护的资源。

* 在对外Nginx服务器上配置
```
// $remote_addr : 是 Nginx 变量，表示客户端 原始 IP 地址
location / {
  proxy_set_header X-Forwarded-For $remote_addr
}
```
⚠️： 如果多个代理服务转发，这个配置并不能强制要求其他代理服务器或攻击者不篡改或删除 X-Forwarded-For 请求头，因为请求头是可以被客户端或代理服务器篡改的。
* 从右到左遍历`X-Forwarded-For`的IP，排除已知代理服务器IP和内网IP，获取到第一个符合条件的IP可以提高准确性。

⚠️： 上述方法仍存在如下问题
1、代理服务器列表不完全：部分代理服务器不会添加到请求头上
2、动态IP地址： 某些代理服务器使用动态的IP地址。
3、内网IP篡改：攻击者可以在伪造的请求中使用公共的IP地址（云服务商提供的IP地址）来作为代理服务器。

### 正向代理和反向代理

#### 正向代理
工作在客户端的代理为正向代理。使用正向代理的时候，需要在客户端配置需要使用的代理服务器，正向代理对服务端透明。比如抓包工具Fiddler、Charles以及访问一些外网网站的代理工具都是正向代理
![截屏2023-08-29 下午2.59.43.png](https://upload-images.jianshu.io/upload_images/11846892-aa7bbed075f4ec78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 正向代理通常用于

1、缓存
2、屏蔽某些不健康的网站
3、通过代理访问原本无法访问的网站
4、上网认证，对用户访问进行授权

#### 反向代理
工作在服务端的代理称为反向代理。使用反向代理的时候，不需要在客户端进行设置，反向代理对客户端透明。如Nginx就是反向代理
![截屏2023-08-29 下午3.00.29.png](https://upload-images.jianshu.io/upload_images/11846892-fd7dd056121f2dec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 反向代理通常用于：负载均衡、服务端缓存、流量隔离、日志、金丝雀发布

![截屏2023-08-29 下午2.08.47.png](https://upload-images.jianshu.io/upload_images/11846892-a28b8c2c77831da4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 ---
总结：大功告成✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️

参考链接:
* [20分钟助你拿下HTTP和HTTPS，巩固你的HTTP知识体系](https://juejin.cn/post/6994629873985650696)
* [简单比较 http https http2](https://juejin.cn/post/6844903559952089102#heading-4)
* [为什么每次请求之前要发送一个OPTIONS请求](https://blog.csdn.net/luanxiyuan/article/details/100137496)


