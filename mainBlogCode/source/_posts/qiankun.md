---
title: 乾坤-微前端
date: 2023-09-04 15:16:16
tags: qiankun
---

<meta name="referrer" content="no-referrer"/>

## 微前端
* 微前端不是特指某一项技术，而是一种思想。是由2016年 [ThoughtWorks Technology Radar](https://www.thoughtworks.com/radar/techniques/micro-frontends) 中提出的，借鉴后端微服务的架构模式，将 Web 应用由单一的单体应用转变为多个小型前端应用，聚合为一的应用。
* 所以微前端不是指具体的库，不是指具体的框架，不是指具体的工具，而是一种理想与架构模式。
* 微前端的核心三大原则就是：**`独立运行`**、**`独立部署`**、**`独立开发`** 所以满足这些的最佳人选就是 “iframe”!!!

### 微前端能解决什么问题 ?

举例: 一个持续多年的应用，经历几年的业务的更新迭代，当项目发展到一定程度的时候就会遇到以下问题

* 业务模块之间不断的堆叠，交错引用，业务耦合如何治理？
* 老技术、老代码不敢动，新技术、新架构又想用？
* 万年技术债？既要跟随业务敏捷迭代，又要保证代码库向好发展，旧的框架类库如何平稳升级？
* 一个项目多个团队开发，你冲突我，我冲突你，如何解决并行开发的冲突？
* 代码库持续膨胀，难以维护的项目代码，是屎上雕花？还是从头再来？


有没有一种可以分解复杂度，提升协作效率，支持灵活扩展的架构模式？ **`微前端应运而生—— “更友好的iframe” `** 将一个巨无霸应用拆解为一个个独立的微应用应用，而用户又是无感知的！

![截屏2023-09-04 下午4.46.49.png](https://upload-images.jianshu.io/upload_images/11846892-b0ba1a37012f44d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 微前端核心原则：

* `技术栈无关`： 主应用不限制子应用接入的技术栈，每个应用的技术栈选型可以配合业务情景选择。
* `独立开发、独立部署`：既可以组合运行，也可以单独运行。
* `环境隔离`: 应用之间 JavaScript、CSS 隔离避免互相影响.
* `消息通信`：统一的通信方式，降低使用通信的成本.
* `依赖复用`：解决依赖、公共逻辑需要重复维护的问题.

这意味着我们可以循序渐进的进行巨石应用的拆解，去技术升级、去架构尝试、去业务拆解等等。以低成本、低风险的进行，`为项目带来更多可能性`.

### 我们的项目适不适合改造成微前端项目模式？

* 是否有明确的业务边界，业务是否高度集中。
* 业务是否高度耦合、项目是否足够庞大到需要拆分。
* 团队中存在多个技术栈并且无法统一，需要接入同一套主系统。
* 技术老旧，扩展困难，维护吃力不讨好。
* 开发协同、部署维护等工作，效率低下，一着不慎，满盘皆输。

## 微前端技术选型

|  技术方案   | 描述  |  技术栈   |  优点   | 缺点  |  单独构建 / 部署   | 构建速度  |  SPA 体验   | 项目侵入性  |  学习成本   | 通信难度  |  
|  ----  | ----  |  ----  | ----  |  ----  | ----  |  ----  | ----  |  ----  | ----  |  ----  |
| iframe  | 每个微应用独立开发部署，通过 iframe的方式将这些应用嵌入到父应用系统中 | 无限制 | 1. 技术栈无关，子应用独立构建部署 2. 实现简单，子应用之间自带沙箱，天然隔离，互不影响  | 体验差、路由无法记忆、页面适配困难、无法监控、依赖无法复用，兼容性等都具有局限性，资源开销巨大，通信困难 | 支持  | 正常 | 不支持  | 高 | 低  | 高 | 
| Nginx 路由转发  | 通过Nginx配置实现不同路径映射到不同应用 | 无限制  | 简单、快速、易配置 | 在切换应用时触发发页面刷新，通信不易  | 支持 | 正常  | 不支持 | 正常  | 低 | 高  |
| Npm 集成  | 将微应用抽离成包的方式，发布Npm中，由父应用依赖的方式使用，构建时候集成进项目中 |  无限制 | 1. 编译阶段的应用，在项目运行阶段无需加载，体验流畅 2.开发与接入成本低，容易理解  | 1. 影响主应用编译速度和打包后的体积 2. 不支持动态下发，npm包更新后，需要重新更新包，主应用需要重新发布部署 | 不支持  | 慢 | 支持  | 高 | 高  | 正常 |
| 通用中心路由基座式  | 微应用可以使用不同技术栈；微应用之间完全独立，互不依赖。统一由基座工程进行管理，按照DOM节点的注册、挂载、卸载来完成。 | 无限制  | 子应用独立构建，用户体验好，可控性强，适应快速迭代 | 学习与实现的成本比较高，需要额外处理依赖复用  | 支持 | 正常  | 支持 | 高  | 高 | 正常  |
| 特定中心路由基座式 | 微应用业务线之间使用相同技术栈；基座工程和微应用可以单独开发单独部署；微应用有能力复用基座工程的公共基建。 | 统一技术栈  | 子应用独立构建，用户体验好，可控性强，适应快速迭代 | 学习与实现的成本比较高，需要额外处理依赖复用  | 支持 | 正常  | 高 | 高  | 正常 |
| webpack5 模块联邦  | webpack5 模块联邦 去中心模式、脱离基座模式。每个应用是单独部署在各自的服务器，每个应用都可以引用其他应用，也能被其他应用所引用 | 统一技术栈  | 基于webpack5，无需引入新框架，学习成本低，像引入第三方库一样方便，各个应用的资源都可以相互共享应用间松耦合，各应用平行的关系 | 需要升级Webpack5技术栈必须保持一致改造旧项目难度大  | 支持 | 正常  | 低 | 低  |正常 | 

对于选择困难同学来说，可以参考以下纬度进行方案技术的选型

|  参考纬度   | 是否能支持未来的迭代  |
|  稳定性  | 该方案是否经历了社区的考验，有较多的成熟案例，同时保持较高的 活跃性  |
|  可拓展性  | 支持定制化开发，提供较高的可拓展能力，同时成本可以在接受范围内  |
|  可控性  | 发生问题后，能够在第一时间内进行问题排查，以最快的响应速度来处理问题，修复的方案是否会依赖于外部环境  |

**市面框架对比：**













---

总结：大功告成✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️


参考链接:
* [万字长文-落地微前端 qiankun 理论与实践指北](https://juejin.cn/post/7069566144750813197)
