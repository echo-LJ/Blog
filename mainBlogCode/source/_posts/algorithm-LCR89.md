---
title: algorithm-LCR89： 打家劫舍 III（动态规划）-中等
date: 2023-09-11 16:46:39
tags: 算法
---

<meta name="referrer" content="no-referrer"/>


## 题目描述： 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 


**示例1:**


```
输入：nums = [1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

```
**示例2:**


```
输入：nums = [1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

```

## 题解方法一： 动态规划

`简化一下这个问题:`设动态规划列表 dp ，dp[i] 代表前 i 个房子在满足条件下的能偷盗到的最高金额。

**`转移方程`**
* 有 n 个房子，前 n 间能偷盗到的最高金额是 dp[n] ，前 n−1 间能偷盗到的最高金额是 dp[n−1] ，此时向这些房子后加一间房，此房间价值为 num；
* **加一间房间后**： 由于不能抢相邻的房子，意味着抢第 n+1 间就不能抢第 n 间；那么前 n+1 间房能偷取到的最高金额 dp[n+1] 一定是以下两种情况的 较大值 ：
    - 不抢第 n+1 个房间，因此等于前 n 个房子的最高金额，即 dp[n+1]=dp[n]
    - 抢第 n+1 个房间，此时不能抢第 n 个房间；因此等于前 n−1 个房子的最高金额加上当前房间价值，即 dp[n+1]=dp[n−1]+num；

* 细心的我们发现： 难道在前 n 间的最高金额 dp[n] 情况下，第 n 间一定被偷了吗？假设没有被偷，那 n+1 间的最大值应该也可能是 dp[n+1]=dp[n]+num吧？其实这种假设的情况可以被省略，这是因为：

    - 假设第 n 间没有被偷，那么此时 dp[n]=dp[n−1] ，此时 dp[n+1]=dp[n]+num=dp[n−1]+num ，即两种情况可以 合并为一种情况 考虑；
    - 假设第 n 间被偷，那么此时 dp[n+1]=dp[n]+num 不可取 ，因为偷了第 n 间就不能偷第 n+1 间。
* 最终的转移方程： dp[n+1]=max(dp[n],dp[n−1]+num)
* 返回值：返回 dp 列表最后一个元素值，即所有房间的最大偷盗价值。
* 简化空间复杂度：我们发现 dp[n]只与 dp[n−1] 和 dp[n−2]有关系，因此我们可以设两个变量 cur和 pre 交替记录，将空间复杂度降到 O(1)。

**`代码实现如下：`** 
```

var rob = (nums) => {
    let cur = 0;
    let pre = 0;
    for (let num of nums) {
      [pre, cur] = [cur, Math.max(pre + num, cur)];
    }
    return cur;
  }

```


 ---
总结：大功告成✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️

参考链接:

* [algorithm-LCR89： 打家劫舍 III（动态规划）-中等](https://leetcode.cn/problems/Gu0c2T/description/)




