---
title: 网络缓存
date: 2023-08-30 13:39:00
tags: HTTP
---

<meta name="referrer" content="no-referrer"/>

## 前言
---

网络方面的缓存分为一下几种：`DNS缓存`、`HTTP缓存`、`CDN缓存`、`代理服务器缓存`、`反向代理缓存`、`数据库查询缓存`,其中`HTTP缓存`通常被称为`浏览器缓存`.

其次，浏览器的`本地存储`和`离线存储`，更快的提高首屏加载速度，让页面飞起。

### DNS缓存

**`DNS 缓存:`** 是指将 DNS 查询的结果存储在本地，以便将来相同的查询可以更快地获得解析结果。这提供了`更快的域名解析速度`。

当在浏览器中输入一段url, 通常将该`域名`解析成对应的`IP地址`,以便与对应的服务器建立连接。
**`域名解析过程`**：是通过向`DNS服务器发送查询的请求`, 以获取与该域名相关联的IP地址.

`DNS 缓存`允许在进行首次DNS 查询后将查询的结果存储在`本地的缓存`中。当再次执行相同的请求时，直接从本地缓存中取出已经解析的结果，无需再次发送DNS解析。**`优点：`** 大大减少域名的解析时间和延迟，提高网络的访问速度和效率。

`DNS 缓存`存在多个层级中，包括`操作系统的本地缓存`、`浏览器的缓存` 以及`ISP(互联网提供商)` 和 `DNS服务器的缓存`。 当多个设备或用户在同一个网络中请求相同的域名时，可以**共享DNS缓存，并避免重复的DNS查询**。

⚠️： DNS 缓存是有时效性的， 由于域名所关联的IP可能发生变化，缓存的DNS结果可能不准确，所以缓存的条目会在一段时间之后过期，需要重新发送查询请求。

#### DNS域名查找过程

* DNS域名查找的顺序： （下面两张图存在矛盾，需要再次确认，并修正）

![截屏2023-08-30 下午2.04.05.png](https://upload-images.jianshu.io/upload_images/11846892-3755c3c8688621e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


![截屏2023-08-30 下午2.06.44.png](https://upload-images.jianshu.io/upload_images/11846892-40e843d975f407c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在任意一步查找到结果，都会直接返回，整个过程客户端只发送一次请求。

如果都没有找到，就会走DNS服务器设置的转发器，如果没设置转发模式，则向`13根`发起解析请求，这里就是迭代查询，如图

>13根：
>全球共有13个根域服务器IP地址，不是13台服务器！
>因为借助任播技术，可以在全球设立这些IP的镜像站点，所以访问的不是唯一的那台主机.



![截屏2023-08-30 下午2.12.19.png](https://upload-images.jianshu.io/upload_images/11846892-17e831dec9d50d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图所示，整个过程会发送多次查询请求。

* 根域名服务器： 全球DNS系统的最高级别，负责存储顶级域名服务器的信息。
* 顶级域名服务器： 解析所查询域名的权威域名服务器。
* 权威域名服务器：负责管理特定域名的DNS服务器。

权威域名服务器收到请求后，会进行解析并返回给本地DNS服务器所查询域名对应的IP地址。

查询到结果把DNS解析的地址记录缓存在客户端，这样下次就不用在迭代查询了。

### HTTP缓存

HTTP缓存(浏览器缓存)是指浏览器在本地存储之前获取的网页或资源副本。当再次请求相同的资源时，浏览器可以从缓存中直接获取，而不需要向服务器重新发起请求。


**`HTTP缓存机制:`** 是基于资源的`URL`来进行缓存。

当客户端或中间代理服务器收到一个HTTP响应时，`服务器会标记该资源的缓存策略`。根据缓存策略的指示，客户端或中间代理服务器会判断是否缓存响应，并在以后的请求中使用缓存副本。

![截屏2023-08-30 下午2.20.00.png](https://upload-images.jianshu.io/upload_images/11846892-3ac12a3be985c73d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**常见的HTTP缓存策略有：**
#### 强制缓存

第一次请求时，服务器把资源的过期时间通过响应头中的Expires和Cache-Control两个字段告诉浏览器，之后再请求这个资源的话，会判断有没有过期，没有过期就直接拿来用，不向服务器发起请求，这就是强缓存

* `Expires`: 用来指定资源到期绝对时间，服务器响应时，添加在响应头中。
```
expires: Wed, 22 Nov 2021 08:41:00 GMT
```
⚠️： 客户端手动更改当前时间，则缓存策略可能失效。 举例：当前是8.1日，Expires 是8.2日，而用户手动更改客户端时间到8.3日，则缓存失效。

* `Cache-Control`: 指定资源过期时间秒，如下，表示在这个请求正确返回后的300秒内，资源可以使用，否则过期

```
cache-control:max-age=300
```

* 为什么指定缓存过期时间需要两个字段呢？ 有的浏览器不能识别`Cache-Control`,则使用Expires。

##### Expires 和 Cache-Control 的区别
* Expires 是`HTTP/1.0`中的，Cache-Control是`HTTP/1.1`中的。
* 两者同时存在Cache-Control优先级更高，Expires 是为了兼容。

##### Cache-Control请求头常见属性（表中的描述是随机定义的）
客户端对于服务器资源的`期望`缓存行为

|  字段(单位秒)   | 说明  |
|  ----  | ----  |
| max-age=300  | 拒绝接受长于300秒的资源，为0时表示获取最新资源 |
| max-stale=100  | 缓存过期之后的100秒内，依然拿来用 |
| min-fresh=50  | 缓存到期时间还剩余50秒开始，就不给拿了，不新鲜了 |
| no-cache | 协商缓存验证 |
| no-store  | 不使用缓存 |
| only-if-chached  | 只使用缓存，没有就报504错误 |
| no-transform  | 中间代理服务器不应该对响应进行内容转换或修改。Content-Encoding, Content-Range,Content-Type等HTTP头不能由代理修改。然并卵 |

##### Cache-Control响应头常见属性（表中的描述是随机定义的）
服务器用来`控制`客户端和中间代理服务器对于资源的缓存行为.

|  字段(单位秒)   | 说明  |
|  ----  | ----  |
| max-age=300  | 缓存有效期300秒 |
| s-maxage=500  | 有效期500秒，优先级高于max-age，适用于共享缓存(如CDN) |
| public  | 可以被任何终端缓存，包括代理服务器、CDN等 |
| private | 只能被用户的浏览器终端缓存(私有缓存) |
| no-store  | 不使用缓存 |
| no-cache  | 先和服务端确认资源是否发生变化，没有就使用 |
| no-transform  | 中间代理服务器不应该对响应进行内容转换或修改。Content-Encoding, Content-Range,Content-Type等HTTP头不能由代理修改。然并卵 |
| must-revalidate  | 客户端缓存过期了就向源服务器验证 |
| proxy-revalidate  | 代理缓存过期了就去源服务器重新获取 |

##### 强缓存的缺点
* 缓存过期之后，不管资源有没有变化，都会重新发起请求，重新获取资源

而我们希望的是在资源文件没有更新的情况下，即使过期了也不重新获取资源，继续使用旧资源

所以协商缓存它来了，在强缓存过期的情况下，再走协商缓存的流程，判断文件有没有更新.


####  协商缓存

第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，还会在响应头添加 `Last-Modified` 字段:告诉浏览器该资源的最后修改时间.

```
last-modified: Fri, 27 Oct 2021 08:35:57 GMT
```
然后浏览器再次请求的时候就把这个时间再通过另一个字段`If-Modified-Since`，发送给服务器
```
if-modified-since: Fri, 27 Oct 2021 08:35:57 GMT
```

服务器将两个时间进行对比：

* 没有更改： 返回304和空响应体
* 有更改： 返回200和新的资源

![截屏2023-08-30 下午2.43.55.png](https://upload-images.jianshu.io/upload_images/11846892-4f75ce11aeb359ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


所以说Last-Modified/If-Modified-Since它俩是成对的，是为了对比文件修改时间


#####  协商缓存的缺点

*  如果本地打开了缓存文件，即使没有对文件进行修改，但还是会造成Last-Modified被修改，服务器端不能命中缓存导致发送相同资源
* 因为Last-Modified只能以秒计时，如果在不可感知的时间内修改了文件，服务器端会认为还是命中了，无法返回正确的资源
* 如果资源有周期性变化，如资源修改后，在一个周期内又改回了原来的样子，我们认为这个周期前的缓存是可以使用的，但是Last-Modified不这样认为
##### ETag/If-None-Match

第一次请求资源时，服务器除了会在响应头上返回·Expires·、`Cache-Control`、`Last-Modified`，还在返回`Etag`字段，表示当前资源文件的一个唯一标识。这个标识符由服务器基于文件内容编码生成，能精准感知文件的变化，只要文件内容不同，ETag就会重新生成.

```
etag: W/"132489-1627839023000"
```
然后浏览器再次请求的时候就把这个文件标识 再通过另一个字段 If-None-Match，发送给服务器
```
if-none-match: W/"132489-1627839023000"
```

服务器将两个标示进行对比：

* 没有更改： 返回304和空响应体
* 有更改： 返回200和新的资源

##### Last-Modified 和 ETag 的区别

* Etag 感知文件精准度要高于 Last-Modified
* 同时使用时，服务器校验优先级 Etag/If-None-Match
* Last-Modified 性能上要优于 Etag，因为 Etag 生成过程中需要服务器付出额外开销，会影响服务器端的性能，所以它并不能完全替代 Last-Modified，只能作为补充和强化。


#### 强缓存与协商缓存的区别

* 优先查找强缓存，没有命中再查找协商缓存
* 强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，资源是否有更新，服务器肯定知道
* 目前项目大多数使用缓存方案：

1、协商缓存一般存储：HTML
2、强缓存一般存储：css, image, js，文件名带上 hash


#### 启发式缓存

就是响应中没有`Expires`，`Cache-Control：max-age`或`Cache-Control:s-maxage`，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算缓存有效期

通常会根据响应头中的`Date`字段(报文创建时间)减去`Last-Modified`值的10%作为缓存时间
```
max(0,（Date - Last-Modified)) % 10
```
#### 缓存实际使用策略

##### 对于频繁变动的资源:
使用`Cache-Control：no-cache`, 使浏览器每次都请求数据，然后配合`Etag` 或`Last-Modified`来验证资源是否有效，这样虽然不能节省请求数量，但能显著减少响应数据的大小。

##### 对于不常变化的资源：

可以给它们的Cache-Control配置一个很大的max-age=31536000(一年)，这样浏览器之后请求相同的URL会命中强缓存，而为了解决更新问题，就需要在文件名(或者路径)中添加hash，版本号等动态字符，之后更改动态字符，从而达到更改引用URL的目的，让之前的强缓存失效(其实并未立即失效，只是不再使用了而已)

### CDN缓存

**`内容分发网络（CDN）缓存`**是指将静态资源（如图片、CSS、JavaScript 文件等）分发到全球各地的缓存节点，以便用户从离其更近的节点获取资源，从而提供更快的响应速度和更好的性能。

##### CDN缓存策略

CDN会判断缓存数据是否过期，如果没有过期，则直接将缓存数据返回给客户端，从而加快了响应速度。如果CDN判断缓存过期，就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。

##### CDN缓存优点
CDN不仅解决了`跨运营商`和`跨地域访问`的问题，大大降低访问延时的同时，还起到了分流的作用，减轻了源服务器的负载.

* [了解更多CDN内容](https://juejin.cn/post/6985816725098856479)

### 代理服务器缓存：
代理服务器缓存是位于客户端和目标服务器之间的中间层，它可以缓存由客户端请求的资源。代理服务器可以减轻服务器负载，并提供更快的服务响应时间。

### 数据库查询缓存: 
数据库查询缓存是指数据库系统在执行查询操作后，将查询结果存储在内存中，以便在后续相同的查询请求中可以直接从缓存中获取结果，而不需要再次执行查询操作。

### 缓存存放位置，和读取的优先级
优先级就是按下面顺序
1. Service Worker

2. Memory Cache(内存)
就是将资源存储在内存中，下次访问直接从内存中读取。例如刷新页面时，很多数据都是来自于内存缓存。一般存储脚本、字体、图片。
优点是读取速度快；缺点由于一旦关闭Tab标签页，内存中的缓存也就释放了，所以容量和存储时效上差些
3. Disk Cache(硬盘)
就是将资源存储在硬盘中，下次访问时直接从硬盘中读取。它会根据请求头中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使是跨域站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次请求。
优点是缓存在硬盘中，容量大，并且存储时效性更长；缺点是读取速度慢些
4. Push Cache
这个是推送缓存，是HTTP/2中的内容，当上面三种缓存都没有命中时才会，被使用。它只会存在于Session中，一旦会话结束就会释放，所以缓存时间很短，而且Push Cache中的缓存只能被使用一次.

### 几种刷新和回车的区别

* 使用 Ctrl+F5 强制刷新页面时，会对本地缓存文件直接过期，然后跳过强缓存和协商缓存，直接请求服务器
* 点击刷新或 F5 刷新页面时，对本地缓存文件过期，然后带If-Modifed-Since和If-None-Match发起协商缓存验证新鲜度
* 浏览器输入URL回车，浏览器查找 Disk Cache，有则使用，没有则发送网络请求


####
---

总结：大功告成✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️


参考链接:
* [为什么第二次打开页面快？五步吃透前端缓存，让页面飞起](https://juejin.cn/post/6993358764481085453)
