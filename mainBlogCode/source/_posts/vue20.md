---
title: v-for和v-if
date: 2023-04-18 14:22:48
tags: Vue.js
---

<meta name="referrer" content="no-referrer"/>

### Vue  v-for 中 :key 到底有什么用？

-  key的作用是为了高效的更新虚拟DOM树，提高查找的效率，一次性定位到要修改的元素（Vue不直接操作真实的DOM树，通过虚拟DOM树就可以重新渲染修改的地方，影藏在背后的原理其实就是 diff 算法）。

-    **（key的必要性）** vue在patch过程中，key是一个必要条件去判断两个node节点是否是相同节点：渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，vue只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了`频繁更新元素`，造成了大量的dom更新操作，明显是不可取的,使得整个`patch过程比较低效，影响性能`。

-    **（实际使用方式）** 实际使用中在渲染一组列表时key必须设置，而且必须是唯一标识，应该避免使用数组索引作为key，这可能导致一些隐蔽的bug，如数据错位；vue中在使用相同标签元素过渡切换时，也会使用key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。

不使用可能会导致性能消耗、数据错位。

### v-for和v-if哪个优先级更高

-   实践中不应该把`v-for`和`v-if`放一起.
-   在Vue2中`v-for`的优先级是高于`v-if`，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表，这会比较浪费.

-   在Vue3中则完全相反，`v-if`的优先级高于`v-for`，所以`v-if`执行时，如果它调用的变量还不存在，就会导致异常.

**通常有两种情况下导致我们这样做:**

-  过滤列表中的项目: (比如 `v-for="user in users" v-if="user.isActive"`)。此时定义一个计算属性 (比如 `activeUsers`)，让其返回过滤后的列表即可（比如`users.filter(u=>u.isActive)`).
-   避免渲染本应该被隐藏的列表: (比如 `v-for="user in users" v-if="shouldShowUsers"`). 此时把 `v-if` 移动至容器元素上 (比如 `ul`、`ol`)或者外面包一层`template`即可.
-  文档中明确永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上，显然这是一个重要的注意事项.
-  源码里面关于代码生成的部分，能够清晰的看到是先处理`v-if`还是`v-for`，顺序上Vue2和Vue3正好相反，因此产生了一些症状的不同，但是不管怎样都是不能把它们写在一起的.

### 从vue3.x源码角度分析v-if 的优先级高于 v-for

在 Vue 3.x 中，v-if 比 v-for 优先级更高，这是因为 Vue 3.x 在编译时使用了更加高效的模板编译器和响应式系统，采用了完全静态的模板分析。

在处理指令时，编译器会将模板分析为一组`静态节点`和`动态节点`:

* 静态节点: 表示不会发生变化的部分,静态节点只会在编译时被处理一次。
* 动态节点: 表示需要响应式地更新的部分,而动态节点会被编译为`虚拟 DOM` 并随着响应式数据的变化而更新。

在处理 v-if 指令时，编译器会将其作为一个条件块（Condition Block）处理，并将其包含在同一个 Block 中。因此，无论 v-if 在模板中出现在何处，都可以在 Block 中动态显示或隐藏子节点。

而在处理 v-for 指令时，编译器会将其作为一个循环块（For Block）处理，并将其包含在同一个 Block 中。由于循环渲染的节点数量是动态的，并且需要响应式地更新，因此需要将循环块和条件块分开处理，防止条件渲染的节点数量对循环渲染结果产生影响。

因此，在 Vue 3.x 中，v-if 比 v-for 的优先级更高，这是为了防止动态渲染的节点数量对条件渲染产生影响，以保证处理结果的正确性。

### 从vue2.x源码角度分析v-for 的优先级高于 v-if

在 Vue 2.x 中，v-for 比 v-if 优先级更高，这是因为 Vue 2.x 采用了 `template-to-render-function` 的编译方式，先将模板编译成一个渲染函数，再通过渲染函数来生成虚拟 DOM。

在编译时，Vue 2.x 会处理指令和表达式，并将它们编译成真实的 JavaScript 代码。在处理 v-for 指令时，Vue 2.x 会生成一个函数，用于生成对应数量的子节点，并为每个子节点绑定对应的数据和事件等。这样可以实现对数据源的遍历和渲染。

而在处理 v-if 指令时，Vue 2.x 会根据表达式的值条件性地生成或跳过对应的子节点。这样可以实现根据条件动态地显示或隐藏子节点。

当同时存在 v-if 和 v-for 指令时，Vue 2.x 会先处理 v-for 指令，生成循环节点，然后对循环节点中的每个节点处理 v-if 指令，来动态地显示或隐藏子节点。如果将 v-if 放在 v-for 之前，会导致在条件渲染时很可能生成更多的中间节点，从而影响性能和渲染结果。

因此，在 Vue 2.x 中，v-for 的优先级高于 v-if，这是为了确保循环渲染的结果是准确的，并且避免不必要的中间节点生成.
### vue3.x中为什么更改了v-if和v-for的优先级

在 Vue 3.x 中更改了 v-if 和 v-for 的优先级，将 v-if 的优先级提高到了 v-for 之上，主要是为了优化响应式更新的性能和行为。

在 Vue 3.x 中，采用了全量响应式系统，具体体验可参考 Composition API（Composition API 可以帮助程序进一步细分代码组成部分，避免组件之间耦合，增加代码可读性，方便进行优化调整），并使用了更加高效的编译器和虚拟 DOM 实现，从而提高了渲染性能和更新响应式数据的速度。

在更新响应式数据时，Vue 3.x 采用了最小化更改的策略，即在更新虚拟 DOM 时，只对发生变化的部分进行更新，而不是重新生成整个 DOM 树。在这个过程中，如果 v-if 的优先级低于 v-for，则可能会导致不必要的中间节点被创建或销毁，从而影响更新的效率和精度。

因此，将 v-if 的优先级提高到 v-for 之上，可以确保在更新响应式数据时，只渲染和更新目标节点，避免不必要的性能损失，并提高更新响应式数据的准确性。

同时，在 Vue 3.x 中，提高 v-if 的优先级，也可以更加灵活地使用条件渲染技术，从而实现更加复杂的模板逻辑和交互效果。
## 结束语
---
总结：大功告成✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️✌️